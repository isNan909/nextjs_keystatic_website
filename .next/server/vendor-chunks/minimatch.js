"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minimatch";
exports.ids = ["vendor-chunks/minimatch"];
exports.modules = {

/***/ "(ssr)/./node_modules/minimatch/dist/mjs/assert-valid-pattern.js":
/*!*****************************************************************!*\
  !*** ./node_modules/minimatch/dist/mjs/assert-valid-pattern.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertValidPattern: () => (/* binding */ assertValidPattern)\n/* harmony export */ });\nconst MAX_PATTERN_LENGTH = 1024 * 64;\nconst assertValidPattern = (pattern)=>{\n    if (typeof pattern !== \"string\") {\n        throw new TypeError(\"invalid pattern\");\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError(\"pattern is too long\");\n    }\n}; //# sourceMappingURL=assert-valid-pattern.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvbWpzL2Fzc2VydC12YWxpZC1wYXR0ZXJuLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxxQkFBcUIsT0FBTztBQUMzQixNQUFNQyxxQkFBcUIsQ0FBQ0M7SUFDL0IsSUFBSSxPQUFPQSxZQUFZLFVBQVU7UUFDN0IsTUFBTSxJQUFJQyxVQUFVO0lBQ3hCO0lBQ0EsSUFBSUQsUUFBUUUsTUFBTSxHQUFHSixvQkFBb0I7UUFDckMsTUFBTSxJQUFJRyxVQUFVO0lBQ3hCO0FBQ0osRUFBRSxDQUNGLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL0BrZXlzdGF0aWMvdGVtcGxhdGVzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9tanMvYXNzZXJ0LXZhbGlkLXBhdHRlcm4uanM/ZWM2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBNQVhfUEFUVEVSTl9MRU5HVEggPSAxMDI0ICogNjQ7XG5leHBvcnQgY29uc3QgYXNzZXJ0VmFsaWRQYXR0ZXJuID0gKHBhdHRlcm4pID0+IHtcbiAgICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGF0dGVybicpO1xuICAgIH1cbiAgICBpZiAocGF0dGVybi5sZW5ndGggPiBNQVhfUEFUVEVSTl9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0dGVybiBpcyB0b28gbG9uZycpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQtdmFsaWQtcGF0dGVybi5qcy5tYXAiXSwibmFtZXMiOlsiTUFYX1BBVFRFUk5fTEVOR1RIIiwiYXNzZXJ0VmFsaWRQYXR0ZXJuIiwicGF0dGVybiIsIlR5cGVFcnJvciIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/dist/mjs/assert-valid-pattern.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/minimatch/dist/mjs/ast.js":
/*!************************************************!*\
  !*** ./node_modules/minimatch/dist/mjs/ast.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AST: () => (/* binding */ AST)\n/* harmony export */ });\n/* harmony import */ var _brace_expressions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./brace-expressions.js */ \"(ssr)/./node_modules/minimatch/dist/mjs/brace-expressions.js\");\n/* harmony import */ var _unescape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unescape.js */ \"(ssr)/./node_modules/minimatch/dist/mjs/unescape.js\");\n// parse a single path portion\n\n\nconst types = new Set([\n    \"!\",\n    \"?\",\n    \"+\",\n    \"*\",\n    \"@\"\n]);\nconst isExtglobType = (c)=>types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = \"(?!(?:^|/)\\\\.\\\\.?(?:$|/))\";\nconst startNoDot = \"(?!\\\\.)\";\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set([\n    \"[\",\n    \".\"\n]);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set([\n    \"..\",\n    \".\"\n]);\nconst reSpecials = new Set(\"().*{}+?[]^$\\\\!\");\nconst regExpEscape = (s)=>s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n// any single thing other than /\nconst qmark = \"[^/]\";\n// * => any number of characters\nconst star = qmark + \"*?\";\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + \"+?\";\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nclass AST {\n    #root;\n    #hasMagic;\n    #uflag;\n    #parts;\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt;\n    constructor(type, parent, options = {}){\n        this.#uflag = false;\n        this.#parts = [];\n        this.#filledNegs = false;\n        this.#emptyExt = false;\n        this.type = type;\n        // extglobs are inherently magical\n        if (type) this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === \"!\" && !this.#root.#filledNegs) this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */ if (this.#hasMagic !== undefined) return this.#hasMagic;\n        /* c8 ignore stop */ for (const p of this.#parts){\n            if (typeof p === \"string\") continue;\n            if (p.type || p.hasMagic) return this.#hasMagic = true;\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined) return this.#toString;\n        if (!this.type) {\n            return this.#toString = this.#parts.map((p)=>String(p)).join(\"\");\n        } else {\n            return this.#toString = this.type + \"(\" + this.#parts.map((p)=>String(p)).join(\"|\") + \")\";\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */ if (this !== this.#root) throw new Error(\"should only call on root\");\n        if (this.#filledNegs) return this;\n        /* c8 ignore stop */ // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while(n = this.#negs.pop()){\n            if (n.type !== \"!\") continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while(pp){\n                for(let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++){\n                    for (const part of n.#parts){\n                        /* c8 ignore start */ if (typeof part === \"string\") {\n                            throw new Error(\"string part in extglob AST??\");\n                        }\n                        /* c8 ignore stop */ part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts){\n            if (p === \"\") continue;\n            /* c8 ignore start */ if (typeof p !== \"string\" && !(p instanceof AST && p.#parent === this)) {\n                throw new Error(\"invalid part: \" + p);\n            }\n            /* c8 ignore stop */ this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null ? this.#parts.slice().map((p)=>typeof p === \"string\" ? p : p.toJSON()) : [\n            this.type,\n            ...this.#parts.map((p)=>p.toJSON())\n        ];\n        if (this.isStart() && !this.type) ret.unshift([]);\n        if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === \"!\")) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this) return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart()) return false;\n        if (this.#parentIndex === 0) return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for(let i = 0; i < this.#parentIndex; i++){\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === \"!\")) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this) return true;\n        if (this.#parent?.type === \"!\") return true;\n        if (!this.#parent?.isEnd()) return false;\n        if (!this.type) return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */ const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */ return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === \"string\") this.push(part);\n        else this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts){\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = \"\";\n            while(i < str.length){\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === \"\\\\\") {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === \"^\" || c === \"!\") {\n                            braceNeg = true;\n                        }\n                    } else if (c === \"]\" && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                } else if (c === \"[\") {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === \"(\") {\n                    ast.push(acc);\n                    acc = \"\";\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = \"\";\n        while(i < str.length){\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === \"\\\\\") {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === \"^\" || c === \"!\") {\n                        braceNeg = true;\n                    }\n                } else if (c === \"]\" && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            } else if (c === \"[\") {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === \"(\") {\n                part.push(acc);\n                acc = \"\";\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === \"|\") {\n                part.push(acc);\n                acc = \"\";\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === \")\") {\n                if (acc === \"\" && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = \"\";\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [\n            str.substring(pos - 1)\n        ];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */ if (this !== this.#root) return this.#root.toMMPattern();\n        /* c8 ignore stop */ const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? \"i\" : \"\") + (uflag ? \"u\" : \"\");\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob\n        });\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this) this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts.map((p)=>{\n                const [re, _, hasMagic, uflag] = typeof p === \"string\" ? AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            }).join(\"\");\n            let start = \"\";\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === \"string\") {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = // dots are allowed, and the pattern starts with [ or .\n                        dot && aps.has(src.charAt(0)) || // the pattern starts with \\., and then [ or .\n                        src.startsWith(\"\\\\.\") && aps.has(src.charAt(2)) || // the pattern starts with \\.\\., and then [ or .\n                        src.startsWith(\"\\\\.\\\\.\") && aps.has(src.charAt(4));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : \"\";\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = \"\";\n            if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === \"!\") {\n                end = \"(?:$|\\\\/)\";\n            }\n            const final = start + src + end;\n            return [\n                final,\n                (0,_unescape_js__WEBPACK_IMPORTED_MODULE_1__.unescape)(src),\n                this.#hasMagic = !!this.#hasMagic,\n                this.#uflag\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === \"*\" || this.type === \"+\";\n        // some kind of extglob\n        const start = this.type === \"!\" ? \"(?:(?!(?:\" : \"(?:\";\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== \"!\") {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [\n                s\n            ];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [\n                s,\n                (0,_unescape_js__WEBPACK_IMPORTED_MODULE_1__.unescape)(this.toString()),\n                false,\n                false\n            ];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? \"\" : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = \"\";\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = \"\";\n        if (this.type === \"!\" && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : \"\") + starNoEmpty;\n        } else {\n            const close = this.type === \"!\" ? \"))\" + (this.isStart() && !dot && !allowDot ? startNoDot : \"\") + star + \")\" : this.type === \"@\" ? \")\" : this.type === \"?\" ? \")?\" : this.type === \"+\" && bodyDotAllowed ? \")\" : this.type === \"*\" && bodyDotAllowed ? `)?` : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            (0,_unescape_js__WEBPACK_IMPORTED_MODULE_1__.unescape)(body),\n            this.#hasMagic = !!this.#hasMagic,\n            this.#uflag\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts.map((p)=>{\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */ if (typeof p === \"string\") {\n                throw new Error(\"string type in extglob ast??\");\n            }\n            /* c8 ignore stop */ // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        }).filter((p)=>!(this.isStart() && this.isEnd()) || !!p).join(\"|\");\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = \"\";\n        let uflag = false;\n        for(let i = 0; i < glob.length; i++){\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? \"\\\\\" : \"\") + c;\n                continue;\n            }\n            if (c === \"\\\\\") {\n                if (i === glob.length - 1) {\n                    re += \"\\\\\\\\\";\n                } else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === \"[\") {\n                const [src, needUflag, consumed, magic] = (0,_brace_expressions_js__WEBPACK_IMPORTED_MODULE_0__.parseClass)(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === \"*\") {\n                if (noEmpty && glob === \"*\") re += starNoEmpty;\n                else re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === \"?\") {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [\n            re,\n            (0,_unescape_js__WEBPACK_IMPORTED_MODULE_1__.unescape)(glob),\n            !!hasMagic,\n            uflag\n        ];\n    }\n} //# sourceMappingURL=ast.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvbWpzL2FzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSw4QkFBOEI7QUFDc0I7QUFDWDtBQUN6QyxNQUFNRSxRQUFRLElBQUlDLElBQUk7SUFBQztJQUFLO0lBQUs7SUFBSztJQUFLO0NBQUk7QUFDL0MsTUFBTUMsZ0JBQWdCLENBQUNDLElBQU1ILE1BQU1JLEdBQUcsQ0FBQ0Q7QUFDdkMsaUVBQWlFO0FBQ2pFLGdFQUFnRTtBQUNoRSwwQ0FBMEM7QUFDMUMsdUVBQXVFO0FBQ3ZFLE1BQU1FLG1CQUFtQjtBQUN6QixNQUFNQyxhQUFhO0FBQ25CLHVFQUF1RTtBQUN2RSxxRUFBcUU7QUFDckUscUVBQXFFO0FBQ3JFLE1BQU1DLGtCQUFrQixJQUFJTixJQUFJO0lBQUM7SUFBSztDQUFJO0FBQzFDLDBEQUEwRDtBQUMxRCxNQUFNTyxXQUFXLElBQUlQLElBQUk7SUFBQztJQUFNO0NBQUk7QUFDcEMsTUFBTVEsYUFBYSxJQUFJUixJQUFJO0FBQzNCLE1BQU1TLGVBQWUsQ0FBQ0MsSUFBTUEsRUFBRUMsT0FBTyxDQUFDLDRCQUE0QjtBQUNsRSxnQ0FBZ0M7QUFDaEMsTUFBTUMsUUFBUTtBQUNkLGdDQUFnQztBQUNoQyxNQUFNQyxPQUFPRCxRQUFRO0FBQ3JCLDBFQUEwRTtBQUMxRSxzQ0FBc0M7QUFDdEMsTUFBTUUsY0FBY0YsUUFBUTtBQUM1Qix5RUFBeUU7QUFDekUsMkRBQTJEO0FBQ3BELE1BQU1HO0lBRVQsQ0FBQ0MsSUFBSSxDQUFDO0lBQ04sQ0FBQ0MsUUFBUSxDQUFDO0lBQ1YsQ0FBQ0MsS0FBSyxDQUFTO0lBQ2YsQ0FBQ0MsS0FBSyxDQUFNO0lBQ1osQ0FBQ0MsTUFBTSxDQUFDO0lBQ1IsQ0FBQ0MsV0FBVyxDQUFDO0lBQ2IsQ0FBQ0MsSUFBSSxDQUFDO0lBQ04sQ0FBQ0MsVUFBVSxDQUFTO0lBQ3BCLENBQUNDLE9BQU8sQ0FBQztJQUNULENBQUNDLFFBQVEsQ0FBQztJQUNWLGtEQUFrRDtJ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QSxTQUFTc0Y7b0JBQ2pCL0QsS0FBS2dFLFdBQVc7b0JBQ2hCeEYsV0FBV0EsWUFBWXlGO29CQUN2QjtnQkFDSjtZQUNKO1lBQ0EsSUFBSXhHLE1BQU0sS0FBSztnQkFDWCxJQUFJb0YsV0FBV2pCLFNBQVMsS0FDcEJDLE1BQU14RDtxQkFFTndELE1BQU16RDtnQkFDVkksV0FBVztnQkFDWDtZQUNKO1lBQ0EsSUFBSWYsTUFBTSxLQUFLO2dCQUNYb0UsTUFBTTFEO2dCQUNOSyxXQUFXO2dCQUNYO1lBQ0o7WUFDQXFELE1BQU03RCxhQUFhUDtRQUN2QjtRQUNBLE9BQU87WUFBQ29FO1lBQUl4RSxzREFBUUEsQ0FBQ3VFO1lBQU8sQ0FBQyxDQUFDcEQ7WUFBVUM7U0FBTTtJQUNsRDtBQUNKLEVBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGtleXN0YXRpYy90ZW1wbGF0ZXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L21qcy9hc3QuanM/YzliMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBwYXJzZSBhIHNpbmdsZSBwYXRoIHBvcnRpb25cbmltcG9ydCB7IHBhcnNlQ2xhc3MgfSBmcm9tICcuL2JyYWNlLWV4cHJlc3Npb25zLmpzJztcbmltcG9ydCB7IHVuZXNjYXBlIH0gZnJvbSAnLi91bmVzY2FwZS5qcyc7XG5jb25zdCB0eXBlcyA9IG5ldyBTZXQoWychJywgJz8nLCAnKycsICcqJywgJ0AnXSk7XG5jb25zdCBpc0V4dGdsb2JUeXBlID0gKGMpID0+IHR5cGVzLmhhcyhjKTtcbi8vIFBhdHRlcm5zIHRoYXQgZ2V0IHByZXBlbmRlZCB0byBiaW5kIHRvIHRoZSBzdGFydCBvZiBlaXRoZXIgdGhlXG4vLyBlbnRpcmUgc3RyaW5nLCBvciBqdXN0IGEgc2luZ2xlIHBhdGggcG9ydGlvbiwgdG8gcHJldmVudCBkb3RzXG4vLyBhbmQvb3IgdHJhdmVyc2FsIHBhdHRlcm5zLCB3aGVuIG5lZWRlZC5cbi8vIEV4dHMgZG9uJ3QgbmVlZCB0aGUgXiBvciAvIGJpdCwgYmVjYXVzZSB0aGUgcm9vdCBiaW5kcyB0aGF0IGFscmVhZHkuXG5jb25zdCBzdGFydE5vVHJhdmVyc2FsID0gJyg/ISg/Ol58LylcXFxcLlxcXFwuPyg/OiR8LykpJztcbmNvbnN0IHN0YXJ0Tm9Eb3QgPSAnKD8hXFxcXC4pJztcbi8vIGNoYXJhY3RlcnMgdGhhdCBpbmRpY2F0ZSBhIHN0YXJ0IG9mIHBhdHRlcm4gbmVlZHMgdGhlIFwibm8gZG90c1wiIGJpdCxcbi8vIGJlY2F1c2UgYSBkb3QgKm1pZ2h0KiBiZSBtYXRjaGVkLiAoIGlzIG5vdCBpbiB0aGUgbGlzdCwgYmVjYXVzZSBpblxuLy8gdGhlIGNhc2Ugb2YgYSBjaGlsZCBleHRnbG9iLCBpdCB3aWxsIGhhbmRsZSB0aGUgcHJldmVudGlvbiBpdHNlbGYuXG5jb25zdCBhZGRQYXR0ZXJuU3RhcnQgPSBuZXcgU2V0KFsnWycsICcuJ10pO1xuLy8gY2FzZXMgd2hlcmUgdHJhdmVyc2FsIGlzIEEtT0ssIG5vIGRvdCBwcmV2ZW50aW9uIG5lZWRlZFxuY29uc3QganVzdERvdHMgPSBuZXcgU2V0KFsnLi4nLCAnLiddKTtcbmNvbnN0IHJlU3BlY2lhbHMgPSBuZXcgU2V0KCcoKS4qe30rP1tdXiRcXFxcIScpO1xuY29uc3QgcmVnRXhwRXNjYXBlID0gKHMpID0+IHMucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbi8vIGFueSBzaW5nbGUgdGhpbmcgb3RoZXIgdGhhbiAvXG5jb25zdCBxbWFyayA9ICdbXi9dJztcbi8vICogPT4gYW55IG51bWJlciBvZiBjaGFyYWN0ZXJzXG5jb25zdCBzdGFyID0gcW1hcmsgKyAnKj8nO1xuLy8gdXNlICsgd2hlbiB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0ICpzb21ldGhpbmcqIG1hdGNoZXMsIGJlY2F1c2UgdGhlICogaXNcbi8vIHRoZSBvbmx5IHRoaW5nIGluIHRoZSBwYXRoIHBvcnRpb24uXG5jb25zdCBzdGFyTm9FbXB0eSA9IHFtYXJrICsgJys/Jztcbi8vIHJlbW92ZSB0aGUgXFwgY2hhcnMgdGhhdCB3ZSBhZGRlZCBpZiB3ZSBlbmQgdXAgZG9pbmcgYSBub25tYWdpYyBjb21wYXJlXG4vLyBjb25zdCBkZXNsYXNoID0gKHM6IHN0cmluZykgPT4gcy5yZXBsYWNlKC9cXFxcKC4pL2csICckMScpXG5leHBvcnQgY2xhc3MgQVNUIHtcbiAgICB0eXBlO1xuICAgICNyb290O1xuICAgICNoYXNNYWdpYztcbiAgICAjdWZsYWcgPSBmYWxzZTtcbiAgICAjcGFydHMgPSBbXTtcbiAgICAjcGFyZW50O1xuICAgICNwYXJlbnRJbmRleDtcbiAgICAjbmVncztcbiAgICAjZmlsbGVkTmVncyA9IGZhbHNlO1xuICAgICNvcHRpb25zO1xuICAgICN0b1N0cmluZztcbiAgICAvLyBzZXQgdG8gdHJ1ZSBpZiBpdCdzIGFuIGV4dGdsb2Igd2l0aCBubyBjaGlsZHJlblxuICAgIC8vICh3aGljaCByZWFsbHkgbWVhbnMgb25lIGNoaWxkIG9mICcnKVxuICAgICNlbXB0eUV4dCA9IGZhbHNlO1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHBhcmVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIC8vIGV4dGdsb2JzIGFyZSBpbmhlcmVudGx5IG1hZ2ljYWxcbiAgICAgICAgaWYgKHR5cGUpXG4gICAgICAgICAgICB0aGlzLiNoYXNNYWdpYyA9IHRydWU7XG4gICAgICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy4jcm9vdCA9IHRoaXMuI3BhcmVudCA/IHRoaXMuI3BhcmVudC4jcm9vdCA6IHRoaXM7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSB0aGlzLiNyb290ID09PSB0aGlzID8gb3B0aW9ucyA6IHRoaXMuI3Jvb3QuI29wdGlvbnM7XG4gICAgICAgIHRoaXMuI25lZ3MgPSB0aGlzLiNyb290ID09PSB0aGlzID8gW10gOiB0aGlzLiNyb290LiNuZWdzO1xuICAgICAgICBpZiAodHlwZSA9PT0gJyEnICYmICF0aGlzLiNyb290LiNmaWxsZWROZWdzKVxuICAgICAgICAgICAgdGhpcy4jbmVncy5wdXNoKHRoaXMpO1xuICAgICAgICB0aGlzLiNwYXJlbnRJbmRleCA9IHRoaXMuI3BhcmVudCA/IHRoaXMuI3BhcmVudC4jcGFydHMubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgZ2V0IGhhc01hZ2ljKCkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMuI2hhc01hZ2ljICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jaGFzTWFnaWM7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLiNwYXJ0cykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChwLnR5cGUgfHwgcC5oYXNNYWdpYylcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuI2hhc01hZ2ljID0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90ZTogd2lsbCBiZSB1bmRlZmluZWQgdW50aWwgd2UgZ2VuZXJhdGUgdGhlIHJlZ2V4cCBzcmMgYW5kIGZpbmQgb3V0XG4gICAgICAgIHJldHVybiB0aGlzLiNoYXNNYWdpYztcbiAgICB9XG4gICAgLy8gcmVjb25zdHJ1Y3RzIHRoZSBwYXR0ZXJuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLiN0b1N0cmluZyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3RvU3RyaW5nO1xuICAgICAgICBpZiAoIXRoaXMudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiN0b1N0cmluZyA9IHRoaXMuI3BhcnRzLm1hcChwID0+IFN0cmluZyhwKSkuam9pbignJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiN0b1N0cmluZyA9XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlICsgJygnICsgdGhpcy4jcGFydHMubWFwKHAgPT4gU3RyaW5nKHApKS5qb2luKCd8JykgKyAnKScpO1xuICAgICAgICB9XG4gICAgfVxuICAgICNmaWxsTmVncygpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICh0aGlzICE9PSB0aGlzLiNyb290KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaG91bGQgb25seSBjYWxsIG9uIHJvb3QnKTtcbiAgICAgICAgaWYgKHRoaXMuI2ZpbGxlZE5lZ3MpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgLy8gY2FsbCB0b1N0cmluZygpIG9uY2UgdG8gZmlsbCB0aGlzIG91dFxuICAgICAgICB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuI2ZpbGxlZE5lZ3MgPSB0cnVlO1xuICAgICAgICBsZXQgbjtcbiAgICAgICAgd2hpbGUgKChuID0gdGhpcy4jbmVncy5wb3AoKSkpIHtcbiAgICAgICAgICAgIGlmIChuLnR5cGUgIT09ICchJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIHdhbGsgdXAgdGhlIHRyZWUsIGFwcGVuZGluZyBldmVydGhpbmcgdGhhdCBjb21lcyBBRlRFUiBwYXJlbnRJbmRleFxuICAgICAgICAgICAgbGV0IHAgPSBuO1xuICAgICAgICAgICAgbGV0IHBwID0gcC4jcGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKHBwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHAuI3BhcmVudEluZGV4ICsgMTsgIXBwLnR5cGUgJiYgaSA8IHBwLiNwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2Ygbi4jcGFydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIHBhcnQgaW4gZXh0Z2xvYiBBU1Q/PycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQuY29weUluKHBwLiNwYXJ0c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IHBwO1xuICAgICAgICAgICAgICAgIHBwID0gcC4jcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBwdXNoKC4uLnBhcnRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgaWYgKHAgPT09ICcnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnICYmICEocCBpbnN0YW5jZW9mIEFTVCAmJiBwLiNwYXJlbnQgPT09IHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBhcnQ6ICcgKyBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICB0aGlzLiNwYXJ0cy5wdXNoKHApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdGhpcy50eXBlID09PSBudWxsXG4gICAgICAgICAgICA/IHRoaXMuI3BhcnRzLnNsaWNlKCkubWFwKHAgPT4gKHR5cGVvZiBwID09PSAnc3RyaW5nJyA/IHAgOiBwLnRvSlNPTigpKSlcbiAgICAgICAgICAgIDogW3RoaXMudHlwZSwgLi4udGhpcy4jcGFydHMubWFwKHAgPT4gcC50b0pTT04oKSldO1xuICAgICAgICBpZiAodGhpcy5pc1N0YXJ0KCkgJiYgIXRoaXMudHlwZSlcbiAgICAgICAgICAgIHJldC51bnNoaWZ0KFtdKTtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmQoKSAmJlxuICAgICAgICAgICAgKHRoaXMgPT09IHRoaXMuI3Jvb3QgfHxcbiAgICAgICAgICAgICAgICAodGhpcy4jcm9vdC4jZmlsbGVkTmVncyAmJiB0aGlzLiNwYXJlbnQ/LnR5cGUgPT09ICchJykpKSB7XG4gICAgICAgICAgICByZXQucHVzaCh7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgaXNTdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3Jvb3QgPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gaWYgKHRoaXMudHlwZSkgcmV0dXJuICEhdGhpcy4jcGFyZW50Py5pc1N0YXJ0KClcbiAgICAgICAgaWYgKCF0aGlzLiNwYXJlbnQ/LmlzU3RhcnQoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuI3BhcmVudEluZGV4ID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIGlmIGV2ZXJ5dGhpbmcgQUhFQUQgb2YgdGhpcyBpcyBhIG5lZ2F0aW9uLCB0aGVuIGl0J3Mgc3RpbGwgdGhlIFwic3RhcnRcIlxuICAgICAgICBjb25zdCBwID0gdGhpcy4jcGFyZW50O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuI3BhcmVudEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBwID0gcC4jcGFydHNbaV07XG4gICAgICAgICAgICBpZiAoIShwcCBpbnN0YW5jZW9mIEFTVCAmJiBwcC50eXBlID09PSAnIScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpc0VuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3Jvb3QgPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuI3BhcmVudD8udHlwZSA9PT0gJyEnKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICghdGhpcy4jcGFyZW50Py5pc0VuZCgpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMudHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwYXJlbnQ/LmlzRW5kKCk7XG4gICAgICAgIC8vIGlmIG5vdCByb290LCBpdCdsbCBhbHdheXMgaGF2ZSBhIHBhcmVudFxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgY29uc3QgcGwgPSB0aGlzLiNwYXJlbnQgPyB0aGlzLiNwYXJlbnQuI3BhcnRzLmxlbmd0aCA6IDA7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHJldHVybiB0aGlzLiNwYXJlbnRJbmRleCA9PT0gcGwgLSAxO1xuICAgIH1cbiAgICBjb3B5SW4ocGFydCkge1xuICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhpcy5wdXNoKHBhcnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnB1c2gocGFydC5jbG9uZSh0aGlzKSk7XG4gICAgfVxuICAgIGNsb25lKHBhcmVudCkge1xuICAgICAgICBjb25zdCBjID0gbmV3IEFTVCh0aGlzLnR5cGUsIHBhcmVudCk7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLiNwYXJ0cykge1xuICAgICAgICAgICAgYy5jb3B5SW4ocCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIHN0YXRpYyAjcGFyc2VBU1Qoc3RyLCBhc3QsIHBvcywgb3B0KSB7XG4gICAgICAgIGxldCBlc2NhcGluZyA9IGZhbHNlO1xuICAgICAgICBsZXQgaW5CcmFjZSA9IGZhbHNlO1xuICAgICAgICBsZXQgYnJhY2VTdGFydCA9IC0xO1xuICAgICAgICBsZXQgYnJhY2VOZWcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFzdC50eXBlID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBvdXRzaWRlIG9mIGEgZXh0Z2xvYiwgYXBwZW5kIHVudGlsIHdlIGZpbmQgYSBzdGFydFxuICAgICAgICAgICAgbGV0IGkgPSBwb3M7XG4gICAgICAgICAgICBsZXQgYWNjID0gJyc7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJBdChpKyspO1xuICAgICAgICAgICAgICAgIC8vIHN0aWxsIGFjY3VtdWxhdGUgZXNjYXBlcyBhdCB0aGlzIHBvaW50LCBidXQgd2UgZG8gaWdub3JlXG4gICAgICAgICAgICAgICAgLy8gc3RhcnRzIHRoYXQgYXJlIGVzY2FwZWRcbiAgICAgICAgICAgICAgICBpZiAoZXNjYXBpbmcgfHwgYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwaW5nID0gIWVzY2FwaW5nO1xuICAgICAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbkJyYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBicmFjZVN0YXJ0ICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICdeJyB8fCBjID09PSAnIScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmFjZU5lZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ10nICYmICEoaSA9PT0gYnJhY2VTdGFydCArIDIgJiYgYnJhY2VOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkJyYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5CcmFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyYWNlU3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmFjZU5lZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghb3B0Lm5vZXh0ICYmIGlzRXh0Z2xvYlR5cGUoYykgJiYgc3RyLmNoYXJBdChpKSA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzdC5wdXNoKGFjYyk7XG4gICAgICAgICAgICAgICAgICAgIGFjYyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHQgPSBuZXcgQVNUKGMsIGFzdCk7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBBU1QuI3BhcnNlQVNUKHN0ciwgZXh0LCBpLCBvcHQpO1xuICAgICAgICAgICAgICAgICAgICBhc3QucHVzaChleHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3QucHVzaChhY2MpO1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc29tZSBraW5kIG9mIGV4dGdsb2IsIHBvcyBpcyBhdCB0aGUgKFxuICAgICAgICAvLyBmaW5kIHRoZSBuZXh0IHwgb3IgKVxuICAgICAgICBsZXQgaSA9IHBvcyArIDE7XG4gICAgICAgIGxldCBwYXJ0ID0gbmV3IEFTVChudWxsLCBhc3QpO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICBsZXQgYWNjID0gJyc7XG4gICAgICAgIHdoaWxlIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQXQoaSsrKTtcbiAgICAgICAgICAgIC8vIHN0aWxsIGFjY3VtdWxhdGUgZXNjYXBlcyBhdCB0aGlzIHBvaW50LCBidXQgd2UgZG8gaWdub3JlXG4gICAgICAgICAgICAvLyBzdGFydHMgdGhhdCBhcmUgZXNjYXBlZFxuICAgICAgICAgICAgaWYgKGVzY2FwaW5nIHx8IGMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGVzY2FwaW5nID0gIWVzY2FwaW5nO1xuICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluQnJhY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gYnJhY2VTdGFydCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICdeJyB8fCBjID09PSAnIScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyYWNlTmVnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnXScgJiYgIShpID09PSBicmFjZVN0YXJ0ICsgMiAmJiBicmFjZU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5CcmFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICdbJykge1xuICAgICAgICAgICAgICAgIGluQnJhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyYWNlU3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgIGJyYWNlTmVnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNFeHRnbG9iVHlwZShjKSAmJiBzdHIuY2hhckF0KGkpID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LnB1c2goYWNjKTtcbiAgICAgICAgICAgICAgICBhY2MgPSAnJztcbiAgICAgICAgICAgICAgICBjb25zdCBleHQgPSBuZXcgQVNUKGMsIHBhcnQpO1xuICAgICAgICAgICAgICAgIHBhcnQucHVzaChleHQpO1xuICAgICAgICAgICAgICAgIGkgPSBBU1QuI3BhcnNlQVNUKHN0ciwgZXh0LCBpLCBvcHQpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICd8Jykge1xuICAgICAgICAgICAgICAgIHBhcnQucHVzaChhY2MpO1xuICAgICAgICAgICAgICAgIGFjYyA9ICcnO1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgcGFydCA9IG5ldyBBU1QobnVsbCwgYXN0KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWNjID09PSAnJyAmJiBhc3QuI3BhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBhc3QuI2VtcHR5RXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFydC5wdXNoKGFjYyk7XG4gICAgICAgICAgICAgICAgYWNjID0gJyc7XG4gICAgICAgICAgICAgICAgYXN0LnB1c2goLi4ucGFydHMsIHBhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdW5maW5pc2hlZCBleHRnbG9iXG4gICAgICAgIC8vIGlmIHdlIGdvdCBoZXJlLCBpdCB3YXMgYSBtYWxmb3JtZWQgZXh0Z2xvYiEgbm90IGFuIGV4dGdsb2IsIGJ1dFxuICAgICAgICAvLyBtYXliZSBzb21ldGhpbmcgZWxzZSBpbiB0aGVyZS5cbiAgICAgICAgYXN0LnR5cGUgPSBudWxsO1xuICAgICAgICBhc3QuI2hhc01hZ2ljID0gdW5kZWZpbmVkO1xuICAgICAgICBhc3QuI3BhcnRzID0gW3N0ci5zdWJzdHJpbmcocG9zIC0gMSldO1xuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21HbG9iKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBhc3QgPSBuZXcgQVNUKG51bGwsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgICAgIEFTVC4jcGFyc2VBU1QocGF0dGVybiwgYXN0LCAwLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgLy8gcmV0dXJucyB0aGUgcmVndWxhciBleHByZXNzaW9uIGlmIHRoZXJlJ3MgbWFnaWMsIG9yIHRoZSB1bmVzY2FwZWRcbiAgICAvLyBzdHJpbmcgaWYgbm90LlxuICAgIHRvTU1QYXR0ZXJuKCkge1xuICAgICAgICAvLyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gcm9vdFxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMgIT09IHRoaXMuI3Jvb3QpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcm9vdC50b01NUGF0dGVybigpO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBjb25zdCBnbG9iID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBbcmUsIGJvZHksIGhhc01hZ2ljLCB1ZmxhZ10gPSB0aGlzLnRvUmVnRXhwU291cmNlKCk7XG4gICAgICAgIC8vIGlmIHdlJ3JlIGluIG5vY2FzZSBtb2RlLCBhbmQgbm90IG5vY2FzZU1hZ2ljT25seSwgdGhlbiB3ZSBkb1xuICAgICAgICAvLyBzdGlsbCBuZWVkIGEgcmVndWxhciBleHByZXNzaW9uIGlmIHdlIGhhdmUgdG8gY2FzZS1pbnNlbnNpdGl2ZWx5XG4gICAgICAgIC8vIG1hdGNoIGNhcGl0YWwvbG93ZXJjYXNlIGNoYXJhY3RlcnMuXG4gICAgICAgIGNvbnN0IGFueU1hZ2ljID0gaGFzTWFnaWMgfHxcbiAgICAgICAgICAgIHRoaXMuI2hhc01hZ2ljIHx8XG4gICAgICAgICAgICAodGhpcy4jb3B0aW9ucy5ub2Nhc2UgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy4jb3B0aW9ucy5ub2Nhc2VNYWdpY09ubHkgJiZcbiAgICAgICAgICAgICAgICBnbG9iLnRvVXBwZXJDYXNlKCkgIT09IGdsb2IudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICghYW55TWFnaWMpIHtcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsYWdzID0gKHRoaXMuI29wdGlvbnMubm9jYXNlID8gJ2knIDogJycpICsgKHVmbGFnID8gJ3UnIDogJycpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgUmVnRXhwKGBeJHtyZX0kYCwgZmxhZ3MpLCB7XG4gICAgICAgICAgICBfc3JjOiByZSxcbiAgICAgICAgICAgIF9nbG9iOiBnbG9iLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gcmV0dXJucyB0aGUgc3RyaW5nIG1hdGNoLCB0aGUgcmVnZXhwIHNvdXJjZSwgd2hldGhlciB0aGVyZSdzIG1hZ2ljXG4gICAgLy8gaW4gdGhlIHJlZ2V4cCAoc28gYSByZWd1bGFyIGV4cHJlc3Npb24gaXMgcmVxdWlyZWQpIGFuZCB3aGV0aGVyIG9yXG4gICAgLy8gbm90IHRoZSB1ZmxhZyBpcyBuZWVkZWQgZm9yIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gKGZvciBwb3NpeCBjbGFzc2VzKVxuICAgIC8vIFRPRE86IGluc3RlYWQgb2YgaW5qZWN0aW5nIHRoZSBzdGFydC9lbmQgYXQgdGhpcyBwb2ludCwganVzdCByZXR1cm5cbiAgICAvLyB0aGUgQk9EWSBvZiB0aGUgcmVnZXhwLCBhbG9uZyB3aXRoIHRoZSBzdGFydC9lbmQgcG9ydGlvbnMgc3VpdGFibGVcbiAgICAvLyBmb3IgYmluZGluZyB0aGUgc3RhcnQvZW5kIGluIGVpdGhlciBhIGpvaW5lZCBmdWxsLXBhdGggbWFrZVJlIGNvbnRleHRcbiAgICAvLyAod2hlcmUgd2UgYmluZCB0byAoXnwvKSwgb3IgYSBzdGFuZGFsb25lIG1hdGNoUGFydCBjb250ZXh0ICh3aGVyZVxuICAgIC8vIHdlIGJpbmQgdG8gXiwgYW5kIG5vdCAvKS4gIE90aGVyd2lzZSBzbGFzaGVzIGdldCBkdXBlZCFcbiAgICAvL1xuICAgIC8vIEluIHBhcnQtbWF0Y2hpbmcgbW9kZSwgdGhlIHN0YXJ0IGlzOlxuICAgIC8vIC0gaWYgbm90IGlzU3RhcnQ6IG5vdGhpbmdcbiAgICAvLyAtIGlmIHRyYXZlcnNhbCBwb3NzaWJsZSwgYnV0IG5vdCBhbGxvd2VkOiBeKD8hXFwuXFwuPyQpXG4gICAgLy8gLSBpZiBkb3RzIGFsbG93ZWQgb3Igbm90IHBvc3NpYmxlOiBeXG4gICAgLy8gLSBpZiBkb3RzIHBvc3NpYmxlIGFuZCBub3QgYWxsb3dlZDogXig/IVxcLilcbiAgICAvLyBlbmQgaXM6XG4gICAgLy8gLSBpZiBub3QgaXNFbmQoKTogbm90aGluZ1xuICAgIC8vIC0gZWxzZTogJFxuICAgIC8vXG4gICAgLy8gSW4gZnVsbC1wYXRoIG1hdGNoaW5nIG1vZGUsIHdlIHB1dCB0aGUgc2xhc2ggYXQgdGhlIFNUQVJUIG9mIHRoZVxuICAgIC8vIHBhdHRlcm4sIHNvIHN0YXJ0IGlzOlxuICAgIC8vIC0gaWYgZmlyc3QgcGF0dGVybjogc2FtZSBhcyBwYXJ0LW1hdGNoaW5nIG1vZGVcbiAgICAvLyAtIGlmIG5vdCBpc1N0YXJ0KCk6IG5vdGhpbmdcbiAgICAvLyAtIGlmIHRyYXZlcnNhbCBwb3NzaWJsZSwgYnV0IG5vdCBhbGxvd2VkOiAvKD8hXFwuXFwuPyg/OiR8LykpXG4gICAgLy8gLSBpZiBkb3RzIGFsbG93ZWQgb3Igbm90IHBvc3NpYmxlOiAvXG4gICAgLy8gLSBpZiBkb3RzIHBvc3NpYmxlIGFuZCBub3QgYWxsb3dlZDogLyg/IVxcLilcbiAgICAvLyBlbmQgaXM6XG4gICAgLy8gLSBpZiBsYXN0IHBhdHRlcm4sIHNhbWUgYXMgcGFydC1tYXRjaGluZyBtb2RlXG4gICAgLy8gLSBlbHNlIG5vdGhpbmdcbiAgICAvL1xuICAgIC8vIEFsd2F5cyBwdXQgdGhlICg/OiR8Lykgb24gbmVnYXRlZCB0YWlscywgdGhvdWdoLCBiZWNhdXNlIHRoYXQgaGFzIHRvIGJlXG4gICAgLy8gdGhlcmUgdG8gYmluZCB0aGUgZW5kIG9mIHRoZSBuZWdhdGVkIHBhdHRlcm4gcG9ydGlvbiwgYW5kIGl0J3MgZWFzaWVyIHRvXG4gICAgLy8ganVzdCBzdGljayBpdCBpbiBub3cgcmF0aGVyIHRoYW4gdHJ5IHRvIGluamVjdCBpdCBsYXRlciBpbiB0aGUgbWlkZGxlIG9mXG4gICAgLy8gdGhlIHBhdHRlcm4uXG4gICAgLy9cbiAgICAvLyBXZSBjYW4ganVzdCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIGVuZCwgYW5kIGxlYXZlIGl0IHVwIHRvIHRoZSBjYWxsZXJcbiAgICAvLyB0byBrbm93IHdoZXRoZXIgaXQncyBnb2luZyB0byBiZSB1c2VkIGpvaW5lZCBvciBpbiBwYXJ0cy5cbiAgICAvLyBBbmQsIGlmIHRoZSBzdGFydCBpcyBhZGp1c3RlZCBzbGlnaHRseSwgY2FuIGRvIHRoZSBzYW1lIHRoZXJlOlxuICAgIC8vIC0gaWYgbm90IGlzU3RhcnQ6IG5vdGhpbmdcbiAgICAvLyAtIGlmIHRyYXZlcnNhbCBwb3NzaWJsZSwgYnV0IG5vdCBhbGxvd2VkOiAoPzovfF4pKD8hXFwuXFwuPyQpXG4gICAgLy8gLSBpZiBkb3RzIGFsbG93ZWQgb3Igbm90IHBvc3NpYmxlOiAoPzovfF4pXG4gICAgLy8gLSBpZiBkb3RzIHBvc3NpYmxlIGFuZCBub3QgYWxsb3dlZDogKD86L3xeKSg/IVxcLilcbiAgICAvL1xuICAgIC8vIEJ1dCBpdCdzIGJldHRlciB0byBoYXZlIGEgc2ltcGxlciBiaW5kaW5nIHdpdGhvdXQgYSBjb25kaXRpb25hbCwgZm9yXG4gICAgLy8gcGVyZm9ybWFuY2UsIHNvIHByb2JhYmx5IGJldHRlciB0byByZXR1cm4gYm90aCBzdGFydCBvcHRpb25zLlxuICAgIC8vXG4gICAgLy8gVGhlbiB0aGUgY2FsbGVyIGp1c3QgaWdub3JlcyB0aGUgZW5kIGlmIGl0J3Mgbm90IHRoZSBmaXJzdCBwYXR0ZXJuLFxuICAgIC8vIGFuZCB0aGUgc3RhcnQgYWx3YXlzIGdldHMgYXBwbGllZC5cbiAgICAvL1xuICAgIC8vIEJ1dCB0aGF0J3MgYWx3YXlzIGdvaW5nIHRvIGJlICQgaWYgaXQncyB0aGUgZW5kaW5nIHBhdHRlcm4sIG9yIG5vdGhpbmcsXG4gICAgLy8gc28gdGhlIGNhbGxlciBjYW4ganVzdCBhdHRhY2ggJCBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuIHdoZW4gYnVpbGRpbmcuXG4gICAgLy9cbiAgICAvLyBTbyB0aGUgdG9kbyBpczpcbiAgICAvLyAtIGJldHRlciBkZXRlY3Qgd2hhdCBraW5kIG9mIHN0YXJ0IGlzIG5lZWRlZFxuICAgIC8vIC0gcmV0dXJuIGJvdGggZmxhdm9ycyBvZiBzdGFydGluZyBwYXR0ZXJuXG4gICAgLy8gLSBhdHRhY2ggJCBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuIHdoZW4gY3JlYXRpbmcgdGhlIGFjdHVhbCBSZWdFeHBcbiAgICAvL1xuICAgIC8vIEFoLCBidXQgd2FpdCwgbm8sIHRoYXQgYWxsIG9ubHkgYXBwbGllcyB0byB0aGUgcm9vdCB3aGVuIHRoZSBmaXJzdCBwYXR0ZXJuXG4gICAgLy8gaXMgbm90IGFuIGV4dGdsb2IuIElmIHRoZSBmaXJzdCBwYXR0ZXJuIElTIGFuIGV4dGdsb2IsIHRoZW4gd2UgbmVlZCBhbGxcbiAgICAvLyB0aGF0IGRvdCBwcmV2ZW50aW9uIGJpeiB0byBsaXZlIGluIHRoZSBleHRnbG9iIHBvcnRpb25zLCBiZWNhdXNlIGVnXG4gICAgLy8gKygqfC54KikgY2FuIG1hdGNoIC54eSBidXQgbm90IC55eC5cbiAgICAvL1xuICAgIC8vIFNvLCByZXR1cm4gdGhlIHR3byBmbGF2b3JzIGlmIGl0J3MgI3Jvb3QgYW5kIHRoZSBmaXJzdCBjaGlsZCBpcyBub3QgYW5cbiAgICAvLyBBU1QsIG90aGVyd2lzZSBsZWF2ZSBpdCB0byB0aGUgY2hpbGQgQVNUIHRvIGhhbmRsZSBpdCwgYW5kIHRoZXJlLFxuICAgIC8vIHVzZSB0aGUgKD86XnwvKSBzdHlsZSBvZiBzdGFydCBiaW5kaW5nLlxuICAgIC8vXG4gICAgLy8gRXZlbiBzaW1wbGlmaWVkIGZ1cnRoZXI6XG4gICAgLy8gLSBTaW5jZSB0aGUgc3RhcnQgZm9yIGEgam9pbiBpcyBlZyAvKD8hXFwuKSBhbmQgdGhlIHN0YXJ0IGZvciBhIHBhcnRcbiAgICAvLyBpcyBeKD8hXFwuKSwgd2UgY2FuIGp1c3QgcHJlcGVuZCAoPyFcXC4pIHRvIHRoZSBwYXR0ZXJuIChlaXRoZXIgcm9vdFxuICAgIC8vIG9yIHN0YXJ0IG9yIHdoYXRldmVyKSBhbmQgcHJlcGVuZCBeIG9yIC8gYXQgdGhlIFJlZ2V4cCBjb25zdHJ1Y3Rpb24uXG4gICAgdG9SZWdFeHBTb3VyY2UoYWxsb3dEb3QpIHtcbiAgICAgICAgY29uc3QgZG90ID0gYWxsb3dEb3QgPz8gISF0aGlzLiNvcHRpb25zLmRvdDtcbiAgICAgICAgaWYgKHRoaXMuI3Jvb3QgPT09IHRoaXMpXG4gICAgICAgICAgICB0aGlzLiNmaWxsTmVncygpO1xuICAgICAgICBpZiAoIXRoaXMudHlwZSkge1xuICAgICAgICAgICAgY29uc3Qgbm9FbXB0eSA9IHRoaXMuaXNTdGFydCgpICYmIHRoaXMuaXNFbmQoKTtcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9IHRoaXMuI3BhcnRzXG4gICAgICAgICAgICAgICAgLm1hcChwID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbcmUsIF8sIGhhc01hZ2ljLCB1ZmxhZ10gPSB0eXBlb2YgcCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyBBU1QuI3BhcnNlR2xvYihwLCB0aGlzLiNoYXNNYWdpYywgbm9FbXB0eSlcbiAgICAgICAgICAgICAgICAgICAgOiBwLnRvUmVnRXhwU291cmNlKGFsbG93RG90KTtcbiAgICAgICAgICAgICAgICB0aGlzLiNoYXNNYWdpYyA9IHRoaXMuI2hhc01hZ2ljIHx8IGhhc01hZ2ljO1xuICAgICAgICAgICAgICAgIHRoaXMuI3VmbGFnID0gdGhpcy4jdWZsYWcgfHwgdWZsYWc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhcnQoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy4jcGFydHNbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHN0cmluZyB0aGF0IHdpbGwgbWF0Y2ggdGhlIHN0YXJ0IG9mIHRoZSBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHByb3RlY3QgYWdhaW5zdCBkb3RzIGFuZCBzdWNoLlxuICAgICAgICAgICAgICAgICAgICAvLyAnLicgYW5kICcuLicgY2Fubm90IG1hdGNoIHVubGVzcyB0aGUgcGF0dGVybiBpcyB0aGF0IGV4YWN0bHksXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgaXQgc3RhcnRzIHdpdGggLiBvciBkb3Q6dHJ1ZSBpcyBzZXQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvdFRyYXZBbGxvd2VkID0gdGhpcy4jcGFydHMubGVuZ3RoID09PSAxICYmIGp1c3REb3RzLmhhcyh0aGlzLiNwYXJ0c1swXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZG90VHJhdkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFwcyA9IGFkZFBhdHRlcm5TdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgYSBwb3NzaWJpbGl0eSBvZiBtYXRjaGluZyAuIG9yIC4uLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByZXZlbnQgdGhhdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZWROb1RyYXYgPSBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvdHMgYXJlIGFsbG93ZWQsIGFuZCB0aGUgcGF0dGVybiBzdGFydHMgd2l0aCBbIG9yIC5cbiAgICAgICAgICAgICAgICAgICAgICAgIChkb3QgJiYgYXBzLmhhcyhzcmMuY2hhckF0KDApKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGF0dGVybiBzdGFydHMgd2l0aCBcXC4sIGFuZCB0aGVuIFsgb3IgLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzcmMuc3RhcnRzV2l0aCgnXFxcXC4nKSAmJiBhcHMuaGFzKHNyYy5jaGFyQXQoMikpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXR0ZXJuIHN0YXJ0cyB3aXRoIFxcLlxcLiwgYW5kIHRoZW4gWyBvciAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNyYy5zdGFydHNXaXRoKCdcXFxcLlxcXFwuJykgJiYgYXBzLmhhcyhzcmMuY2hhckF0KDQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIHByZXZlbnQgZG90cyBpZiBpdCBjYW4ndCBtYXRjaCBhIGRvdCwgb3IgaWYgYVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3ViLXBhdHRlcm4gd2lsbCBiZSBwcmV2ZW50aW5nIGl0IGFueXdheS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZWROb0RvdCA9ICFkb3QgJiYgIWFsbG93RG90ICYmIGFwcy5oYXMoc3JjLmNoYXJBdCgwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG5lZWROb1RyYXYgPyBzdGFydE5vVHJhdmVyc2FsIDogbmVlZE5vRG90ID8gc3RhcnROb0RvdCA6ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXBwZW5kIHRoZSBcImVuZCBvZiBwYXRoIHBvcnRpb25cIiBwYXR0ZXJuIHRvIG5lZ2F0aW9uIHRhaWxzXG4gICAgICAgICAgICBsZXQgZW5kID0gJyc7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0VuZCgpICYmXG4gICAgICAgICAgICAgICAgdGhpcy4jcm9vdC4jZmlsbGVkTmVncyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuI3BhcmVudD8udHlwZSA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gJyg/OiR8XFxcXC8pJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpbmFsID0gc3RhcnQgKyBzcmMgKyBlbmQ7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGZpbmFsLFxuICAgICAgICAgICAgICAgIHVuZXNjYXBlKHNyYyksXG4gICAgICAgICAgICAgICAgKHRoaXMuI2hhc01hZ2ljID0gISF0aGlzLiNoYXNNYWdpYyksXG4gICAgICAgICAgICAgICAgdGhpcy4jdWZsYWcsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBib2R5ICp0d2ljZSogaWYgaXQncyBhIHJlcGVhdCBwYXR0ZXJuXG4gICAgICAgIC8vIGF0IHRoZSBzdGFydCwgb25jZSBpbiBub2RvdCBtb2RlLCB0aGVuIGFnYWluIGluIGRvdCBtb2RlLCBzbyBhXG4gICAgICAgIC8vIHBhdHRlcm4gbGlrZSAqKD8pIGNhbiBtYXRjaCAneC55J1xuICAgICAgICBjb25zdCByZXBlYXRlZCA9IHRoaXMudHlwZSA9PT0gJyonIHx8IHRoaXMudHlwZSA9PT0gJysnO1xuICAgICAgICAvLyBzb21lIGtpbmQgb2YgZXh0Z2xvYlxuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMudHlwZSA9PT0gJyEnID8gJyg/Oig/ISg/OicgOiAnKD86JztcbiAgICAgICAgbGV0IGJvZHkgPSB0aGlzLiNwYXJ0c1RvUmVnRXhwKGRvdCk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhcnQoKSAmJiB0aGlzLmlzRW5kKCkgJiYgIWJvZHkgJiYgdGhpcy50eXBlICE9PSAnIScpIHtcbiAgICAgICAgICAgIC8vIGludmFsaWQgZXh0Z2xvYiwgaGFzIHRvIGF0IGxlYXN0IGJlICpzb21ldGhpbmcqIHByZXNlbnQsIGlmIGl0J3NcbiAgICAgICAgICAgIC8vIHRoZSBlbnRpcmUgcGF0aCBwb3J0aW9uLlxuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuI3BhcnRzID0gW3NdO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuI2hhc01hZ2ljID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIFtzLCB1bmVzY2FwZSh0aGlzLnRvU3RyaW5nKCkpLCBmYWxzZSwgZmFsc2VdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFhYWCBhYnN0cmFjdCBvdXQgdGhpcyBtYXAgbWV0aG9kXG4gICAgICAgIGxldCBib2R5RG90QWxsb3dlZCA9ICFyZXBlYXRlZCB8fCBhbGxvd0RvdCB8fCBkb3QgfHwgIXN0YXJ0Tm9Eb3RcbiAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgIDogdGhpcy4jcGFydHNUb1JlZ0V4cCh0cnVlKTtcbiAgICAgICAgaWYgKGJvZHlEb3RBbGxvd2VkID09PSBib2R5KSB7XG4gICAgICAgICAgICBib2R5RG90QWxsb3dlZCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5RG90QWxsb3dlZCkge1xuICAgICAgICAgICAgYm9keSA9IGAoPzoke2JvZHl9KSg/OiR7Ym9keURvdEFsbG93ZWR9KSo/YDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbiBlbXB0eSAhKCkgaXMgZXhhY3RseSBlcXVpdmFsZW50IHRvIGEgc3Rhck5vRW1wdHlcbiAgICAgICAgbGV0IGZpbmFsID0gJyc7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICchJyAmJiB0aGlzLiNlbXB0eUV4dCkge1xuICAgICAgICAgICAgZmluYWwgPSAodGhpcy5pc1N0YXJ0KCkgJiYgIWRvdCA/IHN0YXJ0Tm9Eb3QgOiAnJykgKyBzdGFyTm9FbXB0eTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlID0gdGhpcy50eXBlID09PSAnISdcbiAgICAgICAgICAgICAgICA/IC8vICEoKSBtdXN0IG1hdGNoIHNvbWV0aGluZyxidXQgISh4KSBjYW4gbWF0Y2ggJydcbiAgICAgICAgICAgICAgICAgICAgJykpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5pc1N0YXJ0KCkgJiYgIWRvdCAmJiAhYWxsb3dEb3QgPyBzdGFydE5vRG90IDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgOiB0aGlzLnR5cGUgPT09ICdAJ1xuICAgICAgICAgICAgICAgICAgICA/ICcpJ1xuICAgICAgICAgICAgICAgICAgICA6IHRoaXMudHlwZSA9PT0gJz8nXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICcpPydcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy50eXBlID09PSAnKycgJiYgYm9keURvdEFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICcpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy50eXBlID09PSAnKicgJiYgYm9keURvdEFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgKT9gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYCkke3RoaXMudHlwZX1gO1xuICAgICAgICAgICAgZmluYWwgPSBzdGFydCArIGJvZHkgKyBjbG9zZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZmluYWwsXG4gICAgICAgICAgICB1bmVzY2FwZShib2R5KSxcbiAgICAgICAgICAgICh0aGlzLiNoYXNNYWdpYyA9ICEhdGhpcy4jaGFzTWFnaWMpLFxuICAgICAgICAgICAgdGhpcy4jdWZsYWcsXG4gICAgICAgIF07XG4gICAgfVxuICAgICNwYXJ0c1RvUmVnRXhwKGRvdCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcGFydHNcbiAgICAgICAgICAgIC5tYXAocCA9PiB7XG4gICAgICAgICAgICAvLyBleHRnbG9iIEFTVHMgc2hvdWxkIG9ubHkgY29udGFpbiBwYXJlbnQgQVNUc1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgdHlwZSBpbiBleHRnbG9iIGFzdD8/Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgLy8gY2FuIGlnbm9yZSBoYXNNYWdpYywgYmVjYXVzZSBleHRnbG9icyBhcmUgYWxyZWFkeSBhbHdheXMgbWFnaWNcbiAgICAgICAgICAgIGNvbnN0IFtyZSwgXywgX2hhc01hZ2ljLCB1ZmxhZ10gPSBwLnRvUmVnRXhwU291cmNlKGRvdCk7XG4gICAgICAgICAgICB0aGlzLiN1ZmxhZyA9IHRoaXMuI3VmbGFnIHx8IHVmbGFnO1xuICAgICAgICAgICAgcmV0dXJuIHJlO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihwID0+ICEodGhpcy5pc1N0YXJ0KCkgJiYgdGhpcy5pc0VuZCgpKSB8fCAhIXApXG4gICAgICAgICAgICAuam9pbignfCcpO1xuICAgIH1cbiAgICBzdGF0aWMgI3BhcnNlR2xvYihnbG9iLCBoYXNNYWdpYywgbm9FbXB0eSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBlc2NhcGluZyA9IGZhbHNlO1xuICAgICAgICBsZXQgcmUgPSAnJztcbiAgICAgICAgbGV0IHVmbGFnID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2xvYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYyA9IGdsb2IuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGVzY2FwaW5nKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZSArPSAocmVTcGVjaWFscy5oYXMoYykgPyAnXFxcXCcgOiAnJykgKyBjO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBnbG9iLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmUgKz0gJ1xcXFxcXFxcJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3NyYywgbmVlZFVmbGFnLCBjb25zdW1lZCwgbWFnaWNdID0gcGFyc2VDbGFzcyhnbG9iLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3VtZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmUgKz0gc3JjO1xuICAgICAgICAgICAgICAgICAgICB1ZmxhZyA9IHVmbGFnIHx8IG5lZWRVZmxhZztcbiAgICAgICAgICAgICAgICAgICAgaSArPSBjb25zdW1lZCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGhhc01hZ2ljID0gaGFzTWFnaWMgfHwgbWFnaWM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9FbXB0eSAmJiBnbG9iID09PSAnKicpXG4gICAgICAgICAgICAgICAgICAgIHJlICs9IHN0YXJOb0VtcHR5O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmUgKz0gc3RhcjtcbiAgICAgICAgICAgICAgICBoYXNNYWdpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgcmUgKz0gcW1hcms7XG4gICAgICAgICAgICAgICAgaGFzTWFnaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmUgKz0gcmVnRXhwRXNjYXBlKGMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcmUsIHVuZXNjYXBlKGdsb2IpLCAhIWhhc01hZ2ljLCB1ZmxhZ107XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN0LmpzLm1hcCJdLCJuYW1lcyI6WyJwYXJzZUNsYXNzIiwidW5lc2NhcGUiLCJ0eXBlcyIsIlNldCIsImlzRXh0Z2xvYlR5cGUiLCJjIiwiaGFzIiwic3RhcnROb1RyYXZlcnNhbCIsInN0YXJ0Tm9Eb3QiLCJhZGRQYXR0ZXJuU3RhcnQiLCJqdXN0RG90cyIsInJlU3BlY2lhbHMiLCJyZWdFeHBFc2NhcGUiLCJzIiwicmVwbGFjZSIsInFtYXJrIiwic3RhciIsInN0YXJOb0VtcHR5IiwiQVNUIiwicm9vdCIsImhhc01hZ2ljIiwidWZsYWciLCJwYXJ0cyIsInBhcmVudCIsInBhcmVudEluZGV4IiwibmVncyIsImZpbGxlZE5lZ3MiLCJvcHRpb25zIiwidG9TdHJpbmciLCJlbXB0eUV4dCIsImNvbnN0cnVjdG9yIiwidHlwZSIsInB1c2giLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJwIiwibWFwIiwiU3RyaW5nIiwiam9pbiIsImZpbGxOZWdzIiwiRXJyb3IiLCJuIiwicG9wIiwicHAiLCJpIiwicGFydCIsImNvcHlJbiIsInRvSlNPTiIsInJldCIsInNsaWNlIiwiaXNTdGFydCIsInVuc2hpZnQiLCJpc0VuZCIsInBsIiwiY2xvbmUiLCJwYXJzZUFTVCIsInN0ciIsImFzdCIsInBvcyIsIm9wdCIsImVzY2FwaW5nIiwiaW5CcmFjZSIsImJyYWNlU3RhcnQiLCJicmFjZU5lZyIsImFjYyIsImNoYXJBdCIsIm5vZXh0IiwiZXh0Iiwic3Vic3RyaW5nIiwiZnJvbUdsb2IiLCJwYXR0ZXJuIiwidG9NTVBhdHRlcm4iLCJnbG9iIiwicmUiLCJib2R5IiwidG9SZWdFeHBTb3VyY2UiLCJhbnlNYWdpYyIsIm5vY2FzZSIsIm5vY2FzZU1hZ2ljT25seSIsInRvVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJmbGFncyIsIk9iamVjdCIsImFzc2lnbiIsIlJlZ0V4cCIsIl9zcmMiLCJfZ2xvYiIsImFsbG93RG90IiwiZG90Iiwibm9FbXB0eSIsInNyYyIsIl8iLCJwYXJzZUdsb2IiLCJzdGFydCIsImRvdFRyYXZBbGxvd2VkIiwiYXBzIiwibmVlZE5vVHJhdiIsInN0YXJ0c1dpdGgiLCJuZWVkTm9Eb3QiLCJlbmQiLCJmaW5hbCIsInJlcGVhdGVkIiwicGFydHNUb1JlZ0V4cCIsImJvZHlEb3RBbGxvd2VkIiwiY2xvc2UiLCJfaGFzTWFnaWMiLCJmaWx0ZXIiLCJuZWVkVWZsYWciLCJjb25zdW1lZCIsIm1hZ2ljIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/dist/mjs/ast.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/minimatch/dist/mjs/brace-expressions.js":
/*!**************************************************************!*\
  !*** ./node_modules/minimatch/dist/mjs/brace-expressions.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseClass: () => (/* binding */ parseClass)\n/* harmony export */ });\n// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    \"[:alnum:]\": [\n        \"\\\\p{L}\\\\p{Nl}\\\\p{Nd}\",\n        true\n    ],\n    \"[:alpha:]\": [\n        \"\\\\p{L}\\\\p{Nl}\",\n        true\n    ],\n    \"[:ascii:]\": [\n        \"\\\\x\" + \"00-\\\\x\" + \"7f\",\n        false\n    ],\n    \"[:blank:]\": [\n        \"\\\\p{Zs}\\\\t\",\n        true\n    ],\n    \"[:cntrl:]\": [\n        \"\\\\p{Cc}\",\n        true\n    ],\n    \"[:digit:]\": [\n        \"\\\\p{Nd}\",\n        true\n    ],\n    \"[:graph:]\": [\n        \"\\\\p{Z}\\\\p{C}\",\n        true,\n        true\n    ],\n    \"[:lower:]\": [\n        \"\\\\p{Ll}\",\n        true\n    ],\n    \"[:print:]\": [\n        \"\\\\p{C}\",\n        true\n    ],\n    \"[:punct:]\": [\n        \"\\\\p{P}\",\n        true\n    ],\n    \"[:space:]\": [\n        \"\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f\",\n        true\n    ],\n    \"[:upper:]\": [\n        \"\\\\p{Lu}\",\n        true\n    ],\n    \"[:word:]\": [\n        \"\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}\",\n        true\n    ],\n    \"[:xdigit:]\": [\n        \"A-Fa-f0-9\",\n        false\n    ]\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s)=>s.replace(/[[\\]\\\\-]/g, \"\\\\$&\");\n// escape all regexp magic characters\nconst regexpEscape = (s)=>s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges)=>ranges.join(\"\");\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nconst parseClass = (glob, position)=>{\n    const pos = position;\n    /* c8 ignore start */ if (glob.charAt(pos) !== \"[\") {\n        throw new Error(\"not in a brace expression\");\n    }\n    /* c8 ignore stop */ const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = \"\";\n    WHILE: while(i < glob.length){\n        const c = glob.charAt(i);\n        if ((c === \"!\" || c === \"^\") && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === \"]\" && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === \"\\\\\") {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n        // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === \"[\" && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)){\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return [\n                            \"$.\",\n                            false,\n                            glob.length - pos,\n                            true\n                        ];\n                    }\n                    i += cls.length;\n                    if (neg) negs.push(unip);\n                    else ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + \"-\" + braceEscape(c));\n            } else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = \"\";\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith(\"-]\", i + 1)) {\n            ranges.push(braceEscape(c + \"-\"));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith(\"-\", i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return [\n            \"\",\n            false,\n            0,\n            false\n        ];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return [\n            \"$.\",\n            false,\n            glob.length - pos,\n            true\n        ];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 && ranges.length === 1 && /^\\\\?.$/.test(ranges[0]) && !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [\n            regexpEscape(r),\n            false,\n            endPos - pos,\n            false\n        ];\n    }\n    const sranges = \"[\" + (negate ? \"^\" : \"\") + rangesToString(ranges) + \"]\";\n    const snegs = \"[\" + (negate ? \"\" : \"^\") + rangesToString(negs) + \"]\";\n    const comb = ranges.length && negs.length ? \"(\" + sranges + \"|\" + snegs + \")\" : ranges.length ? sranges : snegs;\n    return [\n        comb,\n        uflag,\n        endPos - pos,\n        true\n    ];\n}; //# sourceMappingURL=brace-expressions.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvbWpzL2JyYWNlLWV4cHJlc3Npb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSx3RUFBd0U7QUFDeEUsd0NBQXdDO0FBQ3hDLDhEQUE4RDtBQUM5RCxNQUFNQSxlQUFlO0lBQ2pCLGFBQWE7UUFBQztRQUF3QjtLQUFLO0lBQzNDLGFBQWE7UUFBQztRQUFpQjtLQUFLO0lBQ3BDLGFBQWE7UUFBQyxRQUFRLFdBQVc7UUFBTTtLQUFNO0lBQzdDLGFBQWE7UUFBQztRQUFjO0tBQUs7SUFDakMsYUFBYTtRQUFDO1FBQVc7S0FBSztJQUM5QixhQUFhO1FBQUM7UUFBVztLQUFLO0lBQzlCLGFBQWE7UUFBQztRQUFnQjtRQUFNO0tBQUs7SUFDekMsYUFBYTtRQUFDO1FBQVc7S0FBSztJQUM5QixhQUFhO1FBQUM7UUFBVTtLQUFLO0lBQzdCLGFBQWE7UUFBQztRQUFVO0tBQUs7SUFDN0IsYUFBYTtRQUFDO1FBQXlCO0tBQUs7SUFDNUMsYUFBYTtRQUFDO1FBQVc7S0FBSztJQUM5QixZQUFZO1FBQUM7UUFBK0I7S0FBSztJQUNqRCxjQUFjO1FBQUM7UUFBYTtLQUFNO0FBQ3RDO0FBQ0EsK0RBQStEO0FBQy9ELG1CQUFtQjtBQUNuQixNQUFNQyxjQUFjLENBQUNDLElBQU1BLEVBQUVDLE9BQU8sQ0FBQyxhQUFhO0FBQ2xELHFDQUFxQztBQUNyQyxNQUFNQyxlQUFlLENBQUNGLElBQU1BLEVBQUVDLE9BQU8sQ0FBQyw0QkFBNEI7QUFDbEUsNERBQTREO0FBQzVELE1BQU1FLGlCQUFpQixDQUFDQyxTQUFXQSxPQUFPQyxJQUFJLENBQUM7QUFDL0MsK0RBQStEO0FBQy9ELGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUseUNBQXlDO0FBQ3pDLGlFQUFpRTtBQUNqRSw2QkFBNkI7QUFDdEIsTUFBTUMsYUFBYSxDQUFDQyxNQUFNQztJQUM3QixNQUFNQyxNQUFNRDtJQUNaLG1CQUFtQixHQUNuQixJQUFJRCxLQUFLRyxN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U0FBU1UsSUFBSSxDQUFDM0IsTUFBTSxDQUFDLEVBQUUsS0FDdkIsQ0FBQ2EsUUFBUTtRQUNULE1BQU1lLElBQUk1QixNQUFNLENBQUMsRUFBRSxDQUFDaUIsTUFBTSxLQUFLLElBQUlqQixNQUFNLENBQUMsRUFBRSxDQUFDNkIsS0FBSyxDQUFDLENBQUMsS0FBSzdCLE1BQU0sQ0FBQyxFQUFFO1FBQ2xFLE9BQU87WUFBQ0YsYUFBYThCO1lBQUk7WUFBT2QsU0FBU1Q7WUFBSztTQUFNO0lBQ3hEO0lBQ0EsTUFBTXlCLFVBQVUsTUFBT2pCLENBQUFBLFNBQVMsTUFBTSxFQUFDLElBQUtkLGVBQWVDLFVBQVU7SUFDckUsTUFBTStCLFFBQVEsTUFBT2xCLENBQUFBLFNBQVMsS0FBSyxHQUFFLElBQUtkLGVBQWVTLFFBQVE7SUFDakUsTUFBTXdCLE9BQU9oQyxPQUFPaUIsTUFBTSxJQUFJVCxLQUFLUyxNQUFNLEdBQ25DLE1BQU1hLFVBQVUsTUFBTUMsUUFBUSxNQUM5Qi9CLE9BQU9pQixNQUFNLEdBQ1RhLFVBQ0FDO0lBQ1YsT0FBTztRQUFDQztRQUFNckI7UUFBT0csU0FBU1Q7UUFBSztLQUFLO0FBQzVDLEVBQUUsQ0FDRiw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Aa2V5c3RhdGljL3RlbXBsYXRlcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvbWpzL2JyYWNlLWV4cHJlc3Npb25zLmpzPzU5ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHJhbnNsYXRlIHRoZSB2YXJpb3VzIHBvc2l4IGNoYXJhY3RlciBjbGFzc2VzIGludG8gdW5pY29kZSBwcm9wZXJ0aWVzXG4vLyB0aGlzIHdvcmtzIGFjcm9zcyBhbGwgdW5pY29kZSBsb2NhbGVzXG4vLyB7IDxwb3NpeCBjbGFzcz46IFs8dHJhbnNsYXRpb24+LCAvdSBmbGFnIHJlcXVpcmVkLCBuZWdhdGVkXVxuY29uc3QgcG9zaXhDbGFzc2VzID0ge1xuICAgICdbOmFsbnVtOl0nOiBbJ1xcXFxwe0x9XFxcXHB7Tmx9XFxcXHB7TmR9JywgdHJ1ZV0sXG4gICAgJ1s6YWxwaGE6XSc6IFsnXFxcXHB7TH1cXFxccHtObH0nLCB0cnVlXSxcbiAgICAnWzphc2NpaTpdJzogWydcXFxceCcgKyAnMDAtXFxcXHgnICsgJzdmJywgZmFsc2VdLFxuICAgICdbOmJsYW5rOl0nOiBbJ1xcXFxwe1pzfVxcXFx0JywgdHJ1ZV0sXG4gICAgJ1s6Y250cmw6XSc6IFsnXFxcXHB7Q2N9JywgdHJ1ZV0sXG4gICAgJ1s6ZGlnaXQ6XSc6IFsnXFxcXHB7TmR9JywgdHJ1ZV0sXG4gICAgJ1s6Z3JhcGg6XSc6IFsnXFxcXHB7Wn1cXFxccHtDfScsIHRydWUsIHRydWVdLFxuICAgICdbOmxvd2VyOl0nOiBbJ1xcXFxwe0xsfScsIHRydWVdLFxuICAgICdbOnByaW50Ol0nOiBbJ1xcXFxwe0N9JywgdHJ1ZV0sXG4gICAgJ1s6cHVuY3Q6XSc6IFsnXFxcXHB7UH0nLCB0cnVlXSxcbiAgICAnWzpzcGFjZTpdJzogWydcXFxccHtafVxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGYnLCB0cnVlXSxcbiAgICAnWzp1cHBlcjpdJzogWydcXFxccHtMdX0nLCB0cnVlXSxcbiAgICAnWzp3b3JkOl0nOiBbJ1xcXFxwe0x9XFxcXHB7Tmx9XFxcXHB7TmR9XFxcXHB7UGN9JywgdHJ1ZV0sXG4gICAgJ1s6eGRpZ2l0Ol0nOiBbJ0EtRmEtZjAtOScsIGZhbHNlXSxcbn07XG4vLyBvbmx5IG5lZWQgdG8gZXNjYXBlIGEgZmV3IHRoaW5ncyBpbnNpZGUgb2YgYnJhY2UgZXhwcmVzc2lvbnNcbi8vIGVzY2FwZXM6IFsgXFwgXSAtXG5jb25zdCBicmFjZUVzY2FwZSA9IChzKSA9PiBzLnJlcGxhY2UoL1tbXFxdXFxcXC1dL2csICdcXFxcJCYnKTtcbi8vIGVzY2FwZSBhbGwgcmVnZXhwIG1hZ2ljIGNoYXJhY3RlcnNcbmNvbnN0IHJlZ2V4cEVzY2FwZSA9IChzKSA9PiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4vLyBldmVyeXRoaW5nIGhhcyBhbHJlYWR5IGJlZW4gZXNjYXBlZCwgd2UganVzdCBoYXZlIHRvIGpvaW5cbmNvbnN0IHJhbmdlc1RvU3RyaW5nID0gKHJhbmdlcykgPT4gcmFuZ2VzLmpvaW4oJycpO1xuLy8gdGFrZXMgYSBnbG9iIHN0cmluZyBhdCBhIHBvc2l4IGJyYWNlIGV4cHJlc3Npb24sIGFuZCByZXR1cm5zXG4vLyBhbiBlcXVpdmFsZW50IHJlZ3VsYXIgZXhwcmVzc2lvbiBzb3VyY2UsIGFuZCBib29sZWFuIGluZGljYXRpbmdcbi8vIHdoZXRoZXIgdGhlIC91IGZsYWcgbmVlZHMgdG8gYmUgYXBwbGllZCwgYW5kIHRoZSBudW1iZXIgb2YgY2hhcnNcbi8vIGNvbnN1bWVkIHRvIHBhcnNlIHRoZSBjaGFyYWN0ZXIgY2xhc3MuXG4vLyBUaGlzIGFsc28gcmVtb3ZlcyBvdXQgb2Ygb3JkZXIgcmFuZ2VzLCBhbmQgcmV0dXJucyAoJC4pIGlmIHRoZVxuLy8gZW50aXJlIGNsYXNzIGp1c3Qgbm8gZ29vZC5cbmV4cG9ydCBjb25zdCBwYXJzZUNsYXNzID0gKGdsb2IsIHBvc2l0aW9uKSA9PiB7XG4gICAgY29uc3QgcG9zID0gcG9zaXRpb247XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKGdsb2IuY2hhckF0KHBvcykgIT09ICdbJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbiBhIGJyYWNlIGV4cHJlc3Npb24nKTtcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICBjb25zdCBuZWdzID0gW107XG4gICAgbGV0IGkgPSBwb3MgKyAxO1xuICAgIGxldCBzYXdTdGFydCA9IGZhbHNlO1xuICAgIGxldCB1ZmxhZyA9IGZhbHNlO1xuICAgIGxldCBlc2NhcGluZyA9IGZhbHNlO1xuICAgIGxldCBuZWdhdGUgPSBmYWxzZTtcbiAgICBsZXQgZW5kUG9zID0gcG9zO1xuICAgIGxldCByYW5nZVN0YXJ0ID0gJyc7XG4gICAgV0hJTEU6IHdoaWxlIChpIDwgZ2xvYi5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYyA9IGdsb2IuY2hhckF0KGkpO1xuICAgICAgICBpZiAoKGMgPT09ICchJyB8fCBjID09PSAnXicpICYmIGkgPT09IHBvcyArIDEpIHtcbiAgICAgICAgICAgIG5lZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gJ10nICYmIHNhd1N0YXJ0ICYmICFlc2NhcGluZykge1xuICAgICAgICAgICAgZW5kUG9zID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzYXdTdGFydCA9IHRydWU7XG4gICAgICAgIGlmIChjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGlmICghZXNjYXBpbmcpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNjYXBlZCBcXCBjaGFyLCBmYWxsIHRocm91Z2ggYW5kIHRyZWF0IGxpa2Ugbm9ybWFsIGNoYXJcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gJ1snICYmICFlc2NhcGluZykge1xuICAgICAgICAgICAgLy8gZWl0aGVyIGEgcG9zaXggY2xhc3MsIGEgY29sbGF0aW9uIGVxdWl2YWxlbnQsIG9yIGp1c3QgYSBbXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtjbHMsIFt1bmlwLCB1LCBuZWddXSBvZiBPYmplY3QuZW50cmllcyhwb3NpeENsYXNzZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdsb2Iuc3RhcnRzV2l0aChjbHMsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGludmFsaWQsIFthLVtdIGlzIGZpbmUsIGJ1dCBub3QgW2EtWzphbHBoYV1dXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyckLicsIGZhbHNlLCBnbG9iLmxlbmd0aCAtIHBvcywgdHJ1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaSArPSBjbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVnKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmVncy5wdXNoKHVuaXApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh1bmlwKTtcbiAgICAgICAgICAgICAgICAgICAgdWZsYWcgPSB1ZmxhZyB8fCB1O1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBXSElMRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IGl0J3MganVzdCBhIG5vcm1hbCBjaGFyYWN0ZXIsIGVmZmVjdGl2ZWx5XG4gICAgICAgIGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChyYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAvLyB0aHJvdyB0aGlzIHJhbmdlIGF3YXkgaWYgaXQncyBub3QgdmFsaWQsIGJ1dCBvdGhlcnNcbiAgICAgICAgICAgIC8vIGNhbiBzdGlsbCBtYXRjaC5cbiAgICAgICAgICAgIGlmIChjID4gcmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKHJhbmdlU3RhcnQpICsgJy0nICsgYnJhY2VFc2NhcGUoYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gcmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKGMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSAnJztcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdyBtaWdodCBiZSB0aGUgc3RhcnQgb2YgYSByYW5nZS5cbiAgICAgICAgLy8gY2FuIGJlIGVpdGhlciBjLWQgb3IgYy1dIG9yIGM8bW9yZS4uLj5dIG9yIGNdIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgaWYgKGdsb2Iuc3RhcnRzV2l0aCgnLV0nLCBpICsgMSkpIHtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKGMgKyAnLScpKTtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnbG9iLnN0YXJ0c1dpdGgoJy0nLCBpICsgMSkpIHtcbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSBjO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90IHRoZSBzdGFydCBvZiBhIHJhbmdlLCBqdXN0IGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICByYW5nZXMucHVzaChicmFjZUVzY2FwZShjKSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgaWYgKGVuZFBvcyA8IGkpIHtcbiAgICAgICAgLy8gZGlkbid0IHNlZSB0aGUgZW5kIG9mIHRoZSBjbGFzcywgbm90IGEgdmFsaWQgY2xhc3MsXG4gICAgICAgIC8vIGJ1dCBtaWdodCBzdGlsbCBiZSB2YWxpZCBhcyBhIGxpdGVyYWwgbWF0Y2guXG4gICAgICAgIHJldHVybiBbJycsIGZhbHNlLCAwLCBmYWxzZV07XG4gICAgfVxuICAgIC8vIGlmIHdlIGdvdCBubyByYW5nZXMgYW5kIG5vIG5lZ2F0ZXMsIHRoZW4gd2UgaGF2ZSBhIHJhbmdlIHRoYXRcbiAgICAvLyBjYW5ub3QgcG9zc2libHkgbWF0Y2ggYW55dGhpbmcsIGFuZCB0aGF0IHBvaXNvbnMgdGhlIHdob2xlIGdsb2JcbiAgICBpZiAoIXJhbmdlcy5sZW5ndGggJiYgIW5lZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbJyQuJywgZmFsc2UsIGdsb2IubGVuZ3RoIC0gcG9zLCB0cnVlXTtcbiAgICB9XG4gICAgLy8gaWYgd2UgZ290IG9uZSBwb3NpdGl2ZSByYW5nZSwgYW5kIGl0J3MgYSBzaW5nbGUgY2hhcmFjdGVyLCB0aGVuIHRoYXQnc1xuICAgIC8vIG5vdCBhY3R1YWxseSBhIG1hZ2ljIHBhdHRlcm4sIGl0J3MganVzdCB0aGF0IG9uZSBsaXRlcmFsIGNoYXJhY3Rlci5cbiAgICAvLyB3ZSBzaG91bGQgbm90IHRyZWF0IHRoYXQgYXMgXCJtYWdpY1wiLCB3ZSBzaG91bGQganVzdCByZXR1cm4gdGhlIGxpdGVyYWxcbiAgICAvLyBjaGFyYWN0ZXIuIFtfXSBpcyBhIHBlcmZlY3RseSB2YWxpZCB3YXkgdG8gZXNjYXBlIGdsb2IgbWFnaWMgY2hhcnMuXG4gICAgaWYgKG5lZ3MubGVuZ3RoID09PSAwICYmXG4gICAgICAgIHJhbmdlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgL15cXFxcPy4kLy50ZXN0KHJhbmdlc1swXSkgJiZcbiAgICAgICAgIW5lZ2F0ZSkge1xuICAgICAgICBjb25zdCByID0gcmFuZ2VzWzBdLmxlbmd0aCA9PT0gMiA/IHJhbmdlc1swXS5zbGljZSgtMSkgOiByYW5nZXNbMF07XG4gICAgICAgIHJldHVybiBbcmVnZXhwRXNjYXBlKHIpLCBmYWxzZSwgZW5kUG9zIC0gcG9zLCBmYWxzZV07XG4gICAgfVxuICAgIGNvbnN0IHNyYW5nZXMgPSAnWycgKyAobmVnYXRlID8gJ14nIDogJycpICsgcmFuZ2VzVG9TdHJpbmcocmFuZ2VzKSArICddJztcbiAgICBjb25zdCBzbmVncyA9ICdbJyArIChuZWdhdGUgPyAnJyA6ICdeJykgKyByYW5nZXNUb1N0cmluZyhuZWdzKSArICddJztcbiAgICBjb25zdCBjb21iID0gcmFuZ2VzLmxlbmd0aCAmJiBuZWdzLmxlbmd0aFxuICAgICAgICA/ICcoJyArIHNyYW5nZXMgKyAnfCcgKyBzbmVncyArICcpJ1xuICAgICAgICA6IHJhbmdlcy5sZW5ndGhcbiAgICAgICAgICAgID8gc3Jhbmdlc1xuICAgICAgICAgICAgOiBzbmVncztcbiAgICByZXR1cm4gW2NvbWIsIHVmbGFnLCBlbmRQb3MgLSBwb3MsIHRydWVdO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyYWNlLWV4cHJlc3Npb25zLmpzLm1hcCJdLCJuYW1lcyI6WyJwb3NpeENsYXNzZXMiLCJicmFjZUVzY2FwZSIsInMiLCJyZXBsYWNlIiwicmVnZXhwRXNjYXBlIiwicmFuZ2VzVG9TdHJpbmciLCJyYW5nZXMiLCJqb2luIiwicGFyc2VDbGFzcyIsImdsb2IiLCJwb3NpdGlvbiIsInBvcyIsImNoYXJBdCIsIkVycm9yIiwibmVncyIsImkiLCJzYXdTdGFydCIsInVmbGFnIiwiZXNjYXBpbmciLCJuZWdhdGUiLCJlbmRQb3MiLCJyYW5nZVN0YXJ0IiwiV0hJTEUiLCJsZW5ndGgiLCJjIiwiY2xzIiwidW5pcCIsInUiLCJuZWciLCJPYmplY3QiLCJlbnRyaWVzIiwic3RhcnRzV2l0aCIsInB1c2giLCJ0ZXN0IiwiciIsInNsaWNlIiwic3JhbmdlcyIsInNuZWdzIiwiY29tYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/dist/mjs/brace-expressions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/minimatch/dist/mjs/escape.js":
/*!***************************************************!*\
  !*** ./node_modules/minimatch/dist/mjs/escape.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   escape: () => (/* binding */ escape)\n/* harmony export */ });\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */ const escape = (s, { windowsPathsNoEscape = false } = {})=>{\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape ? s.replace(/[?*()[\\]]/g, \"[$&]\") : s.replace(/[?*()[\\]\\\\]/g, \"\\\\$&\");\n}; //# sourceMappingURL=escape.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvbWpzL2VzY2FwZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Ozs7O0NBUUMsR0FDTSxNQUFNQSxTQUFTLENBQUNDLEdBQUcsRUFBRUMsdUJBQXVCLEtBQUssRUFBRyxHQUFHLENBQUMsQ0FBQztJQUM1RCx3REFBd0Q7SUFDeEQsNERBQTREO0lBQzVELHNEQUFzRDtJQUN0RCxPQUFPQSx1QkFDREQsRUFBRUUsT0FBTyxDQUFDLGNBQWMsVUFDeEJGLEVBQUVFLE9BQU8sQ0FBQyxnQkFBZ0I7QUFDcEMsRUFBRSxDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BrZXlzdGF0aWMvdGVtcGxhdGVzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9tanMvZXNjYXBlLmpzPzU2NGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFc2NhcGUgYWxsIG1hZ2ljIGNoYXJhY3RlcnMgaW4gYSBnbG9iIHBhdHRlcm4uXG4gKlxuICogSWYgdGhlIHtAbGluayB3aW5kb3dzUGF0aHNOb0VzY2FwZSB8IEdsb2JPcHRpb25zLndpbmRvd3NQYXRoc05vRXNjYXBlfVxuICogb3B0aW9uIGlzIHVzZWQsIHRoZW4gY2hhcmFjdGVycyBhcmUgZXNjYXBlZCBieSB3cmFwcGluZyBpbiBgW11gLCBiZWNhdXNlXG4gKiBhIG1hZ2ljIGNoYXJhY3RlciB3cmFwcGVkIGluIGEgY2hhcmFjdGVyIGNsYXNzIGNhbiBvbmx5IGJlIHNhdGlzZmllZCBieVxuICogdGhhdCBleGFjdCBjaGFyYWN0ZXIuICBJbiB0aGlzIG1vZGUsIGBcXGAgaXMgX25vdF8gZXNjYXBlZCwgYmVjYXVzZSBpdCBpc1xuICogbm90IGludGVycHJldGVkIGFzIGEgbWFnaWMgY2hhcmFjdGVyLCBidXQgaW5zdGVhZCBhcyBhIHBhdGggc2VwYXJhdG9yLlxuICovXG5leHBvcnQgY29uc3QgZXNjYXBlID0gKHMsIHsgd2luZG93c1BhdGhzTm9Fc2NhcGUgPSBmYWxzZSwgfSA9IHt9KSA9PiB7XG4gICAgLy8gZG9uJ3QgbmVlZCB0byBlc2NhcGUgK0AhIGJlY2F1c2Ugd2UgZXNjYXBlIHRoZSBwYXJlbnNcbiAgICAvLyB0aGF0IG1ha2UgdGhvc2UgbWFnaWMsIGFuZCBlc2NhcGluZyAhIGFzIFshXSBpc24ndCB2YWxpZCxcbiAgICAvLyBiZWNhdXNlIFshXV0gaXMgYSB2YWxpZCBnbG9iIGNsYXNzIG1lYW5pbmcgbm90ICddJy5cbiAgICByZXR1cm4gd2luZG93c1BhdGhzTm9Fc2NhcGVcbiAgICAgICAgPyBzLnJlcGxhY2UoL1s/KigpW1xcXV0vZywgJ1skJl0nKVxuICAgICAgICA6IHMucmVwbGFjZSgvWz8qKClbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzY2FwZS5qcy5tYXAiXSwibmFtZXMiOlsiZXNjYXBlIiwicyIsIndpbmRvd3NQYXRoc05vRXNjYXBlIiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/dist/mjs/escape.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/minimatch/dist/mjs/index.js":
/*!**************************************************!*\
  !*** ./node_modules/minimatch/dist/mjs/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AST: () => (/* reexport safe */ _ast_js__WEBPACK_IMPORTED_MODULE_2__.AST),\n/* harmony export */   GLOBSTAR: () => (/* binding */ GLOBSTAR),\n/* harmony export */   Minimatch: () => (/* binding */ Minimatch),\n/* harmony export */   braceExpand: () => (/* binding */ braceExpand),\n/* harmony export */   defaults: () => (/* binding */ defaults),\n/* harmony export */   escape: () => (/* reexport safe */ _escape_js__WEBPACK_IMPORTED_MODULE_3__.escape),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   makeRe: () => (/* binding */ makeRe),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   minimatch: () => (/* binding */ minimatch),\n/* harmony export */   sep: () => (/* binding */ sep),\n/* harmony export */   unescape: () => (/* reexport safe */ _unescape_js__WEBPACK_IMPORTED_MODULE_4__.unescape)\n/* harmony export */ });\n/* harmony import */ var brace_expansion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! brace-expansion */ \"(ssr)/./node_modules/brace-expansion/index.js\");\n/* harmony import */ var _assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assert-valid-pattern.js */ \"(ssr)/./node_modules/minimatch/dist/mjs/assert-valid-pattern.js\");\n/* harmony import */ var _ast_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ast.js */ \"(ssr)/./node_modules/minimatch/dist/mjs/ast.js\");\n/* harmony import */ var _escape_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./escape.js */ \"(ssr)/./node_modules/minimatch/dist/mjs/escape.js\");\n/* harmony import */ var _unescape_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./unescape.js */ \"(ssr)/./node_modules/minimatch/dist/mjs/unescape.js\");\n\n\n\n\n\nconst minimatch = (p, pattern, options = {})=>{\n    (0,_assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__.assertValidPattern)(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === \"#\") {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext)=>(f)=>!f.startsWith(\".\") && f.endsWith(ext);\nconst starDotExtTestDot = (ext)=>(f)=>f.endsWith(ext);\nconst starDotExtTestNocase = (ext)=>{\n    ext = ext.toLowerCase();\n    return (f)=>!f.startsWith(\".\") && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext)=>{\n    ext = ext.toLowerCase();\n    return (f)=>f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f)=>!f.startsWith(\".\") && f.includes(\".\");\nconst starDotStarTestDot = (f)=>f !== \".\" && f !== \"..\" && f.includes(\".\");\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f)=>f !== \".\" && f !== \"..\" && f.startsWith(\".\");\nconst starRE = /^\\*+$/;\nconst starTest = (f)=>f.length !== 0 && !f.startsWith(\".\");\nconst starTestDot = (f)=>f.length !== 0 && f !== \".\" && f !== \"..\";\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = \"\"])=>{\n    const noext = qmarksTestNoExt([\n        $0\n    ]);\n    if (!ext) return noext;\n    ext = ext.toLowerCase();\n    return (f)=>noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = \"\"])=>{\n    const noext = qmarksTestNoExtDot([\n        $0\n    ]);\n    if (!ext) return noext;\n    ext = ext.toLowerCase();\n    return (f)=>noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = \"\"])=>{\n    const noext = qmarksTestNoExtDot([\n        $0\n    ]);\n    return !ext ? noext : (f)=>noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = \"\"])=>{\n    const noext = qmarksTestNoExt([\n        $0\n    ]);\n    return !ext ? noext : (f)=>noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0])=>{\n    const len = $0.length;\n    return (f)=>f.length === len && !f.startsWith(\".\");\n};\nconst qmarksTestNoExtDot = ([$0])=>{\n    const len = $0.length;\n    return (f)=>f.length === len && f !== \".\" && f !== \"..\";\n};\n/* c8 ignore start */ const defaultPlatform = typeof process === \"object\" && process ? typeof process.env === \"object\" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : \"posix\";\nconst path = {\n    win32: {\n        sep: \"\\\\\"\n    },\n    posix: {\n        sep: \"/\"\n    }\n};\n/* c8 ignore stop */ const sep = defaultPlatform === \"win32\" ? path.win32.sep : path.posix.sep;\nminimatch.sep = sep;\nconst GLOBSTAR = Symbol(\"globstar **\");\nminimatch.GLOBSTAR = GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = \"[^/]\";\n// * => any number of characters\nconst star = qmark + \"*?\";\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = \"(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?\";\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = \"(?:(?!(?:\\\\/|^)\\\\.).)*?\";\nconst filter = (pattern, options = {})=>(p)=>minimatch(p, pattern, options);\nminimatch.filter = filter;\nconst ext = (a, b = {})=>Object.assign({}, a, b);\nconst defaults = (def)=>{\n    if (!def || typeof def !== \"object\" || !Object.keys(def).length) {\n        return minimatch;\n    }\n    const orig = minimatch;\n    const m = (p, pattern, options = {})=>orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}){\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */ constructor(type, parent, options = {}){\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */ static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {})=>orig.unescape(s, ext(def, options)),\n        escape: (s, options = {})=>orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {})=>orig.filter(pattern, ext(def, options)),\n        defaults: (options)=>orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {})=>orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {})=>orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {})=>orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: GLOBSTAR\n    });\n};\nminimatch.defaults = defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = (pattern, options = {})=>{\n    (0,_assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__.assertValidPattern)(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [\n            pattern\n        ];\n    }\n    return brace_expansion__WEBPACK_IMPORTED_MODULE_0__(pattern);\n};\nminimatch.braceExpand = braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = (pattern, options = {})=>new Minimatch(pattern, options).makeRe();\nminimatch.makeRe = makeRe;\nconst match = (list, pattern, options = {})=>{\n    const mm = new Minimatch(pattern, options);\n    list = list.filter((f)=>mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nminimatch.match = match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s)=>s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\nclass Minimatch {\n    constructor(pattern, options = {}){\n        (0,_assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__.assertValidPattern)(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === \"win32\";\n        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, \"/\");\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot = options.windowsNoMagicRoot !== undefined ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set){\n            for (const part of pattern){\n                if (typeof part !== \"string\") return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) {}\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === \"#\") {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [\n            ...new Set(this.braceExpand())\n        ];\n        if (options.debug) {\n            this.debug = (...args)=>console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map((s)=>this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __)=>{\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === \"\" && s[1] === \"\" && (s[2] === \"?\" || !globMagic.test(s[2])) && !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [\n                        ...s.slice(0, 4),\n                        ...s.slice(4).map((ss)=>this.parse(ss))\n                    ];\n                } else if (isDrive) {\n                    return [\n                        s[0],\n                        ...s.slice(1).map((ss)=>this.parse(ss))\n                    ];\n                }\n            }\n            return s.map((ss)=>this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter((s)=>s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for(let i = 0; i < this.set.length; i++){\n                const p = this.set[i];\n                if (p[0] === \"\" && p[1] === \"\" && this.globParts[i][2] === \"?\" && typeof p[3] === \"string\" && /^[a-z]:$/i.test(p[3])) {\n                    p[2] = \"?\";\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for(let i = 0; i < globParts.length; i++){\n                for(let j = 0; j < globParts[i].length; j++){\n                    if (globParts[i][j] === \"**\") {\n                        globParts[i][j] = \"*\";\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        } else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        } else {\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map((parts)=>{\n            let gs = -1;\n            while(-1 !== (gs = parts.indexOf(\"**\", gs + 1))){\n                let i = gs;\n                while(parts[i + 1] === \"**\"){\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map((parts)=>{\n            parts = parts.reduce((set, part)=>{\n                const prev = set[set.length - 1];\n                if (part === \"**\" && prev === \"**\") {\n                    return set;\n                }\n                if (part === \"..\") {\n                    if (prev && prev !== \"..\" && prev !== \".\" && prev !== \"**\") {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [\n                \"\"\n            ] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for(let i = 1; i < parts.length - 1; i++){\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === \"\" && parts[0] === \"\") continue;\n                    if (p === \".\" || p === \"\") {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === \".\" && parts.length === 2 && (parts[1] === \".\" || parts[1] === \"\")) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while(-1 !== (dd = parts.indexOf(\"..\", dd + 1))){\n                const p = parts[dd - 1];\n                if (p && p !== \".\" && p !== \"..\" && p !== \"**\") {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        }while (didSomething);\n        return parts.length === 0 ? [\n            \"\"\n        ] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts){\n                let gs = -1;\n                while(-1 !== (gs = parts.indexOf(\"**\", gs + 1))){\n                    let gss = gs;\n                    while(parts[gss + 1] === \"**\"){\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== \"..\") continue;\n                    if (!p || p === \".\" || p === \"..\" || !p2 || p2 === \".\" || p2 === \"..\") {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = \"**\";\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for(let i = 1; i < parts.length - 1; i++){\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === \"\" && parts[0] === \"\") continue;\n                        if (p === \".\" || p === \"\") {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === \".\" && parts.length === 2 && (parts[1] === \".\" || parts[1] === \"\")) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while(-1 !== (dd = parts.indexOf(\"..\", dd + 1))){\n                    const p = parts[dd - 1];\n                    if (p && p !== \".\" && p !== \"..\" && p !== \"**\") {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === \"**\";\n                        const splin = needDot ? [\n                            \".\"\n                        ] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0) parts.push(\"\");\n                        dd -= 2;\n                    }\n                }\n            }\n        }while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for(let i = 0; i < globParts.length - 1; i++){\n            for(let j = i + 1; j < globParts.length; j++){\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (!matched) continue;\n                globParts[i] = matched;\n                globParts[j] = [];\n            }\n        }\n        return globParts.filter((gs)=>gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = \"\";\n        while(ai < a.length && bi < b.length){\n            if (a[ai] === b[bi]) {\n                result.push(which === \"b\" ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            } else if (emptyGSMatch && a[ai] === \"**\" && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            } else if (emptyGSMatch && b[bi] === \"**\" && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            } else if (a[ai] === \"*\" && b[bi] && (this.options.dot || !b[bi].startsWith(\".\")) && b[bi] !== \"**\") {\n                if (which === \"b\") return false;\n                which = \"a\";\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            } else if (b[bi] === \"*\" && a[ai] && (this.options.dot || !a[ai].startsWith(\".\")) && a[ai] !== \"**\") {\n                if (which === \"a\") return false;\n                which = \"b\";\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            } else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate) return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for(let i = 0; i < pattern.length && pattern.charAt(i) === \"!\"; i++){\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset) this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === \"string\" && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive && file[0] === \"\" && file[1] === \"\" && file[2] === \"?\" && /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === \"string\" && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive && pattern[0] === \"\" && pattern[1] === \"\" && pattern[2] === \"?\" && typeof pattern[3] === \"string\" && /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === \"number\" && typeof pdi === \"number\") {\n                const [fd, pd] = [\n                    file[fdi],\n                    pattern[pdi]\n                ];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    } else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug(\"matchOne\", this, {\n            file,\n            pattern\n        });\n        this.debug(\"matchOne\", file.length, pattern.length);\n        for(var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++){\n            this.debug(\"matchOne loop\");\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */ if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */ if (p === GLOBSTAR) {\n                this.debug(\"GLOBSTAR\", [\n                    pattern,\n                    p,\n                    f\n                ]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug(\"** at the end\");\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for(; fi < fl; fi++){\n                        if (file[fi] === \".\" || file[fi] === \"..\" || !options.dot && file[fi].charAt(0) === \".\") return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while(fr < fl){\n                    var swallowee = file[fr];\n                    this.debug(\"\\nglobstar while\", file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug(\"globstar found match!\", fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    } else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === \".\" || swallowee === \"..\" || !options.dot && swallowee.charAt(0) === \".\") {\n                            this.debug(\"dot detected!\", file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug(\"globstar swallow a segment, and continue\");\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */ if (partial) {\n                    // ran out of file\n                    this.debug(\"\\n>>> no match, partial?\", file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */ return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === \"string\") {\n                hit = f === p;\n                this.debug(\"string match\", p, f, hit);\n            } else {\n                hit = p.test(f);\n                this.debug(\"pattern match\", p, f, hit);\n            }\n            if (!hit) return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        } else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        } else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === \"\";\n        /* c8 ignore start */ } else {\n            // should be unreachable.\n            throw new Error(\"wtf?\");\n        }\n    /* c8 ignore stop */ }\n    braceExpand() {\n        return braceExpand(this.pattern, this.options);\n    }\n    parse(pattern) {\n        (0,_assert_valid_pattern_js__WEBPACK_IMPORTED_MODULE_1__.assertValidPattern)(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === \"**\") return GLOBSTAR;\n        if (pattern === \"\") return \"\";\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if (m = pattern.match(starRE)) {\n            fastTest = options.dot ? starTestDot : starTest;\n        } else if (m = pattern.match(starDotExtRE)) {\n            fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);\n        } else if (m = pattern.match(qmarksRE)) {\n            fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);\n        } else if (m = pattern.match(starDotStarRE)) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        } else if (m = pattern.match(dotStarRE)) {\n            fastTest = dotStarTest;\n        }\n        const re = _ast_js__WEBPACK_IMPORTED_MODULE_2__.AST.fromGlob(pattern, this.options).toMMPattern();\n        return fastTest ? Object.assign(re, {\n            test: fastTest\n        }) : re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false) return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n        const flags = new Set(options.nocase ? [\n            \"i\"\n        ] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set.map((pattern)=>{\n            const pp = pattern.map((p)=>{\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(\"\"))flags.add(f);\n                }\n                return typeof p === \"string\" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src;\n            });\n            pp.forEach((p, i)=>{\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== GLOBSTAR || prev === GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== GLOBSTAR) {\n                        pp[i + 1] = \"(?:\\\\/|\" + twoStar + \"\\\\/)?\" + next;\n                    } else {\n                        pp[i] = twoStar;\n                    }\n                } else if (next === undefined) {\n                    pp[i - 1] = prev + \"(?:\\\\/|\" + twoStar + \")?\";\n                } else if (next !== GLOBSTAR) {\n                    pp[i - 1] = prev + \"(?:\\\\/|\\\\/\" + twoStar + \"\\\\/)\" + next;\n                    pp[i + 1] = GLOBSTAR;\n                }\n            });\n            return pp.filter((p)=>p !== GLOBSTAR).join(\"/\");\n        }).join(\"|\");\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? [\n            \"(?:\",\n            \")\"\n        ] : [\n            \"\",\n            \"\"\n        ];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = \"^\" + open + re + close + \"$\";\n        // can match anything, as long as it's not this.\n        if (this.negate) re = \"^(?!\" + re + \").+$\";\n        try {\n            this.regexp = new RegExp(re, [\n                ...flags\n            ].join(\"\"));\n        /* c8 ignore start */ } catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */ return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split(\"/\");\n        } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return [\n                \"\",\n                ...p.split(/\\/+/)\n            ];\n        } else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug(\"match\", f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === \"\";\n        }\n        if (f === \"/\" && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split(\"\\\\\").join(\"/\");\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, \"split\", ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, \"set\", set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for(let i = ff.length - 2; !filename && i >= 0; i--){\n                filename = ff[i];\n            }\n        }\n        for(let i = 0; i < set.length; i++){\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [\n                    filename\n                ];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return minimatch.defaults(def).Minimatch;\n    }\n}\n/* c8 ignore start */ \n\n\n/* c8 ignore stop */ minimatch.AST = _ast_js__WEBPACK_IMPORTED_MODULE_2__.AST;\nminimatch.Minimatch = Minimatch;\nminimatch.escape = _escape_js__WEBPACK_IMPORTED_MODULE_3__.escape;\nminimatch.unescape = _unescape_js__WEBPACK_IMPORTED_MODULE_4__.unescape; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvbWpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQzBCO0FBQ2hDO0FBQ007QUFDSTtBQUNsQyxNQUFNSyxZQUFZLENBQUNDLEdBQUdDLFNBQVNDLFVBQVUsQ0FBQyxDQUFDO0lBQzlDUCw0RUFBa0JBLENBQUNNO0lBQ25CLG9DQUFvQztJQUNwQyxJQUFJLENBQUNDLFFBQVFDLFNBQVMsSUFBSUYsUUFBUUcsTUFBTSxDQUFDLE9BQU8sS0FBSztRQUNqRCxPQUFPO0lBQ1g7SUFDQSxPQUFPLElBQUlDLFVBQVVKLFNBQVNDLFNBQVNJLEtBQUssQ0FBQ047QUFDakQsRUFBRTtBQUNGLHdEQUF3RDtBQUN4RCxNQUFNTyxlQUFlO0FBQ3JCLE1BQU1DLGlCQUFpQixDQUFDQyxNQUFRLENBQUNDLElBQU0sQ0FBQ0EsRUFBRUMsVUFBVSxDQUFDLFFBQVFELEVBQUVFLFFBQVEsQ0FBQ0g7QUFDeEUsTUFBTUksb0JBQW9CLENBQUNKLE1BQVEsQ0FBQ0MsSUFBTUEsRUFBRUUsUUFBUSxDQUFDSDtBQUNyRCxNQUFNSyx1QkFBdUIsQ0FBQ0w7SUFDMUJBLE1BQU1BLElBQUlNLFdBQVc7SUFDckIsT0FBTyxDQUFDTCxJQUFNLENBQUNBLEVBQUVDLFVBQVUsQ0FBQyxRQUFRRCxFQUFFSyxXQUFXLEdBQUdILFFBQVEsQ0FBQ0g7QUFDakU7QUFDQSxNQUFNTywwQkFBMEIsQ0FBQ1A7SUFDN0JBLE1BQU1BLElBQUlNLFdBQVc7SUFDckIsT0FBTyxDQUFDTCxJQUFNQSxFQUFFSyxXQUFXLEdBQUdILFFBQVEsQ0FBQ0g7QUFDM0M7QUFDQSxNQUFNUSxnQkFBZ0I7QUFDdEIsTUFBTUMsa0JBQWtCLENBQUNSLElBQU0sQ0FBQ0EsRUFBRUMsVUFBVSxDQUFDLFFBQVFELEVBQUVTLFFBQVEsQ0FBQztBQUNoRSxNQUFNQyxxQkFBcUIsQ0FBQ1YsSUFBTUEsTUFBTSxPQUFPQSxNQUFNLFFB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Q2pCLE9BQU8zRCxVQUFVMEQsUUFBUSxDQUFDQyxLQUFLckQsU0FBUztJQUM1QztBQUNKO0FBQ0EsbUJBQW1CLEdBQ1k7QUFDTTtBQUNJO0FBQ3pDLGtCQUFrQixHQUNsQk4sVUFBVUgsR0FBRyxHQUFHQSx3Q0FBR0E7QUFDbkJHLFVBQVVNLFNBQVMsR0FBR0E7QUFDdEJOLFVBQVVGLE1BQU0sR0FBR0EsOENBQU1BO0FBQ3pCRSxVQUFVRCxRQUFRLEdBQUdBLGtEQUFRQSxFQUM3QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Aa2V5c3RhdGljL3RlbXBsYXRlcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvbWpzL2luZGV4LmpzP2MzNjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGV4cGFuZCBmcm9tICdicmFjZS1leHBhbnNpb24nO1xuaW1wb3J0IHsgYXNzZXJ0VmFsaWRQYXR0ZXJuIH0gZnJvbSAnLi9hc3NlcnQtdmFsaWQtcGF0dGVybi5qcyc7XG5pbXBvcnQgeyBBU1QgfSBmcm9tICcuL2FzdC5qcyc7XG5pbXBvcnQgeyBlc2NhcGUgfSBmcm9tICcuL2VzY2FwZS5qcyc7XG5pbXBvcnQgeyB1bmVzY2FwZSB9IGZyb20gJy4vdW5lc2NhcGUuanMnO1xuZXhwb3J0IGNvbnN0IG1pbmltYXRjaCA9IChwLCBwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBhc3NlcnRWYWxpZFBhdHRlcm4ocGF0dGVybik7XG4gICAgLy8gc2hvcnRjdXQ6IGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gICAgaWYgKCFvcHRpb25zLm5vY29tbWVudCAmJiBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucykubWF0Y2gocCk7XG59O1xuLy8gT3B0aW1pemVkIGNoZWNraW5nIGZvciB0aGUgbW9zdCBjb21tb24gZ2xvYiBwYXR0ZXJucy5cbmNvbnN0IHN0YXJEb3RFeHRSRSA9IC9eXFwqKyhbXitAIT9cXCpcXFtcXChdKikkLztcbmNvbnN0IHN0YXJEb3RFeHRUZXN0ID0gKGV4dCkgPT4gKGYpID0+ICFmLnN0YXJ0c1dpdGgoJy4nKSAmJiBmLmVuZHNXaXRoKGV4dCk7XG5jb25zdCBzdGFyRG90RXh0VGVzdERvdCA9IChleHQpID0+IChmKSA9PiBmLmVuZHNXaXRoKGV4dCk7XG5jb25zdCBzdGFyRG90RXh0VGVzdE5vY2FzZSA9IChleHQpID0+IHtcbiAgICBleHQgPSBleHQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gKGYpID0+ICFmLnN0YXJ0c1dpdGgoJy4nKSAmJiBmLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBzdGFyRG90RXh0VGVzdE5vY2FzZURvdCA9IChleHQpID0+IHtcbiAgICBleHQgPSBleHQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gKGYpID0+IGYudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHN0YXJEb3RTdGFyUkUgPSAvXlxcKitcXC5cXCorJC87XG5jb25zdCBzdGFyRG90U3RhclRlc3QgPSAoZikgPT4gIWYuc3RhcnRzV2l0aCgnLicpICYmIGYuaW5jbHVkZXMoJy4nKTtcbmNvbnN0IHN0YXJEb3RTdGFyVGVzdERvdCA9IChmKSA9PiBmICE9PSAnLicgJiYgZiAhPT0gJy4uJyAmJiBmLmluY2x1ZGVzKCcuJyk7XG5jb25zdCBkb3RTdGFyUkUgPSAvXlxcLlxcKiskLztcbmNvbnN0IGRvdFN0YXJUZXN0ID0gKGYpID0+IGYgIT09ICcuJyAmJiBmICE9PSAnLi4nICYmIGYuc3RhcnRzV2l0aCgnLicpO1xuY29uc3Qgc3RhclJFID0gL15cXCorJC87XG5jb25zdCBzdGFyVGVzdCA9IChmKSA9PiBmLmxlbmd0aCAhPT0gMCAmJiAhZi5zdGFydHNXaXRoKCcuJyk7XG5jb25zdCBzdGFyVGVzdERvdCA9IChmKSA9PiBmLmxlbmd0aCAhPT0gMCAmJiBmICE9PSAnLicgJiYgZiAhPT0gJy4uJztcbmNvbnN0IHFtYXJrc1JFID0gL15cXD8rKFteK0AhP1xcKlxcW1xcKF0qKT8kLztcbmNvbnN0IHFtYXJrc1Rlc3ROb2Nhc2UgPSAoWyQwLCBleHQgPSAnJ10pID0+IHtcbiAgICBjb25zdCBub2V4dCA9IHFtYXJrc1Rlc3ROb0V4dChbJDBdKTtcbiAgICBpZiAoIWV4dClcbiAgICAgICAgcmV0dXJuIG5vZXh0O1xuICAgIGV4dCA9IGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAoZikgPT4gbm9leHQoZikgJiYgZi50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3QgcW1hcmtzVGVzdE5vY2FzZURvdCA9IChbJDAsIGV4dCA9ICcnXSkgPT4ge1xuICAgIGNvbnN0IG5vZXh0ID0gcW1hcmtzVGVzdE5vRXh0RG90KFskMF0pO1xuICAgIGlmICghZXh0KVxuICAgICAgICByZXR1cm4gbm9leHQ7XG4gICAgZXh0ID0gZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChmKSA9PiBub2V4dChmKSAmJiBmLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBxbWFya3NUZXN0RG90ID0gKFskMCwgZXh0ID0gJyddKSA9PiB7XG4gICAgY29uc3Qgbm9leHQgPSBxbWFya3NUZXN0Tm9FeHREb3QoWyQwXSk7XG4gICAgcmV0dXJuICFleHQgPyBub2V4dCA6IChmKSA9PiBub2V4dChmKSAmJiBmLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3QgcW1hcmtzVGVzdCA9IChbJDAsIGV4dCA9ICcnXSkgPT4ge1xuICAgIGNvbnN0IG5vZXh0ID0gcW1hcmtzVGVzdE5vRXh0KFskMF0pO1xuICAgIHJldHVybiAhZXh0ID8gbm9leHQgOiAoZikgPT4gbm9leHQoZikgJiYgZi5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHFtYXJrc1Rlc3ROb0V4dCA9IChbJDBdKSA9PiB7XG4gICAgY29uc3QgbGVuID0gJDAubGVuZ3RoO1xuICAgIHJldHVybiAoZikgPT4gZi5sZW5ndGggPT09IGxlbiAmJiAhZi5zdGFydHNXaXRoKCcuJyk7XG59O1xuY29uc3QgcW1hcmtzVGVzdE5vRXh0RG90ID0gKFskMF0pID0+IHtcbiAgICBjb25zdCBsZW4gPSAkMC5sZW5ndGg7XG4gICAgcmV0dXJuIChmKSA9PiBmLmxlbmd0aCA9PT0gbGVuICYmIGYgIT09ICcuJyAmJiBmICE9PSAnLi4nO1xufTtcbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgZGVmYXVsdFBsYXRmb3JtID0gKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzXG4gICAgPyAodHlwZW9mIHByb2Nlc3MuZW52ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBwcm9jZXNzLmVudiAmJlxuICAgICAgICBwcm9jZXNzLmVudi5fX01JTklNQVRDSF9URVNUSU5HX1BMQVRGT1JNX18pIHx8XG4gICAgICAgIHByb2Nlc3MucGxhdGZvcm1cbiAgICA6ICdwb3NpeCcpO1xuY29uc3QgcGF0aCA9IHtcbiAgICB3aW4zMjogeyBzZXA6ICdcXFxcJyB9LFxuICAgIHBvc2l4OiB7IHNlcDogJy8nIH0sXG59O1xuLyogYzggaWdub3JlIHN0b3AgKi9cbmV4cG9ydCBjb25zdCBzZXAgPSBkZWZhdWx0UGxhdGZvcm0gPT09ICd3aW4zMicgPyBwYXRoLndpbjMyLnNlcCA6IHBhdGgucG9zaXguc2VwO1xubWluaW1hdGNoLnNlcCA9IHNlcDtcbmV4cG9ydCBjb25zdCBHTE9CU1RBUiA9IFN5bWJvbCgnZ2xvYnN0YXIgKionKTtcbm1pbmltYXRjaC5HTE9CU1RBUiA9IEdMT0JTVEFSO1xuLy8gYW55IHNpbmdsZSB0aGluZyBvdGhlciB0aGFuIC9cbi8vIGRvbid0IG5lZWQgdG8gZXNjYXBlIC8gd2hlbiB1c2luZyBuZXcgUmVnRXhwKClcbmNvbnN0IHFtYXJrID0gJ1teL10nO1xuLy8gKiA9PiBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbmNvbnN0IHN0YXIgPSBxbWFyayArICcqPyc7XG4vLyAqKiB3aGVuIGRvdHMgYXJlIGFsbG93ZWQuICBBbnl0aGluZyBnb2VzLCBleGNlcHQgLi4gYW5kIC5cbi8vIG5vdCAoXiBvciAvIGZvbGxvd2VkIGJ5IG9uZSBvciB0d28gZG90cyBmb2xsb3dlZCBieSAkIG9yIC8pLFxuLy8gZm9sbG93ZWQgYnkgYW55dGhpbmcsIGFueSBudW1iZXIgb2YgdGltZXMuXG5jb25zdCB0d29TdGFyRG90ID0gJyg/Oig/ISg/OlxcXFwvfF4pKD86XFxcXC57MSwyfSkoJHxcXFxcLykpLikqPyc7XG4vLyBub3QgYSBeIG9yIC8gZm9sbG93ZWQgYnkgYSBkb3QsXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbmNvbnN0IHR3b1N0YXJOb0RvdCA9ICcoPzooPyEoPzpcXFxcL3xeKVxcXFwuKS4pKj8nO1xuZXhwb3J0IGNvbnN0IGZpbHRlciA9IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IChwKSA9PiBtaW5pbWF0Y2gocCwgcGF0dGVybiwgb3B0aW9ucyk7XG5taW5pbWF0Y2guZmlsdGVyID0gZmlsdGVyO1xuY29uc3QgZXh0ID0gKGEsIGIgPSB7fSkgPT4gT2JqZWN0LmFzc2lnbih7fSwgYSwgYik7XG5leHBvcnQgY29uc3QgZGVmYXVsdHMgPSAoZGVmKSA9PiB7XG4gICAgaWYgKCFkZWYgfHwgdHlwZW9mIGRlZiAhPT0gJ29iamVjdCcgfHwgIU9iamVjdC5rZXlzKGRlZikubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBtaW5pbWF0Y2g7XG4gICAgfVxuICAgIGNvbnN0IG9yaWcgPSBtaW5pbWF0Y2g7XG4gICAgY29uc3QgbSA9IChwLCBwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG9yaWcocCwgcGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG0sIHtcbiAgICAgICAgTWluaW1hdGNoOiBjbGFzcyBNaW5pbWF0Y2ggZXh0ZW5kcyBvcmlnLk1pbmltYXRjaCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgICAgICBzdXBlcihwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0aWMgZGVmYXVsdHMob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnLmRlZmF1bHRzKGV4dChkZWYsIG9wdGlvbnMpKS5NaW5pbWF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIEFTVDogY2xhc3MgQVNUIGV4dGVuZHMgb3JpZy5BU1Qge1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlLCBwYXJlbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgICAgIHN1cGVyKHR5cGUsIHBhcmVudCwgZXh0KGRlZiwgb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIHN0YXRpYyBmcm9tR2xvYihwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZy5BU1QuZnJvbUdsb2IocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bmVzY2FwZTogKHMsIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy51bmVzY2FwZShzLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIGVzY2FwZTogKHMsIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5lc2NhcGUocywgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBmaWx0ZXI6IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG9yaWcuZmlsdGVyKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgZGVmYXVsdHM6IChvcHRpb25zKSA9PiBvcmlnLmRlZmF1bHRzKGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgbWFrZVJlOiAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLm1ha2VSZShwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIGJyYWNlRXhwYW5kOiAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLmJyYWNlRXhwYW5kKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgbWF0Y2g6IChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG9yaWcubWF0Y2gobGlzdCwgcGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBzZXA6IG9yaWcuc2VwLFxuICAgICAgICBHTE9CU1RBUjogR0xPQlNUQVIsXG4gICAgfSk7XG59O1xubWluaW1hdGNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4vLyBCcmFjZSBleHBhbnNpb246XG4vLyBhe2IsY31kIC0+IGFiZCBhY2Rcbi8vIGF7Yix9YyAtPiBhYmMgYWNcbi8vIGF7MC4uM31kIC0+IGEwZCBhMWQgYTJkIGEzZFxuLy8gYXtiLGN7ZCxlfWZ9ZyAtPiBhYmcgYWNkZmcgYWNlZmdcbi8vIGF7YixjfWR7ZSxmfWcgLT4gYWJkZWcgYWNkZWcgYWJkZWcgYWJkZmdcbi8vXG4vLyBJbnZhbGlkIHNldHMgYXJlIG5vdCBleHBhbmRlZC5cbi8vIGF7Mi4ufWIgLT4gYXsyLi59YlxuLy8gYXtifWMgLT4gYXtifWNcbmV4cG9ydCBjb25zdCBicmFjZUV4cGFuZCA9IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBhc3NlcnRWYWxpZFBhdHRlcm4ocGF0dGVybik7XG4gICAgLy8gVGhhbmtzIHRvIFlldGluZyBMaSA8aHR0cHM6Ly9naXRodWIuY29tL3lldGluZ2xpPiBmb3JcbiAgICAvLyBpbXByb3ZpbmcgdGhpcyByZWdleHAgdG8gYXZvaWQgYSBSZURPUyB2dWxuZXJhYmlsaXR5LlxuICAgIGlmIChvcHRpb25zLm5vYnJhY2UgfHwgIS9cXHsoPzooPyFcXHspLikqXFx9Ly50ZXN0KHBhdHRlcm4pKSB7XG4gICAgICAgIC8vIHNob3J0Y3V0LiBubyBuZWVkIHRvIGV4cGFuZC5cbiAgICAgICAgcmV0dXJuIFtwYXR0ZXJuXTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGFuZChwYXR0ZXJuKTtcbn07XG5taW5pbWF0Y2guYnJhY2VFeHBhbmQgPSBicmFjZUV4cGFuZDtcbi8vIHBhcnNlIGEgY29tcG9uZW50IG9mIHRoZSBleHBhbmRlZCBzZXQuXG4vLyBBdCB0aGlzIHBvaW50LCBubyBwYXR0ZXJuIG1heSBjb250YWluIFwiL1wiIGluIGl0XG4vLyBzbyB3ZSdyZSBnb2luZyB0byByZXR1cm4gYSAyZCBhcnJheSwgd2hlcmUgZWFjaCBlbnRyeSBpcyB0aGUgZnVsbFxuLy8gcGF0dGVybiwgc3BsaXQgb24gJy8nLCBhbmQgdGhlbiB0dXJuZWQgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbi8vIEEgcmVnZXhwIGlzIG1hZGUgYXQgdGhlIGVuZCB3aGljaCBqb2lucyBlYWNoIGFycmF5IHdpdGggYW5cbi8vIGVzY2FwZWQgLywgYW5kIGFub3RoZXIgZnVsbCBvbmUgd2hpY2ggam9pbnMgZWFjaCByZWdleHAgd2l0aCB8LlxuLy9cbi8vIEZvbGxvd2luZyB0aGUgbGVhZCBvZiBCYXNoIDQuMSwgbm90ZSB0aGF0IFwiKipcIiBvbmx5IGhhcyBzcGVjaWFsIG1lYW5pbmdcbi8vIHdoZW4gaXQgaXMgdGhlICpvbmx5KiB0aGluZyBpbiBhIHBhdGggcG9ydGlvbi4gIE90aGVyd2lzZSwgYW55IHNlcmllc1xuLy8gb2YgKiBpcyBlcXVpdmFsZW50IHRvIGEgc2luZ2xlICouICBHbG9ic3RhciBiZWhhdmlvciBpcyBlbmFibGVkIGJ5XG4vLyBkZWZhdWx0LCBhbmQgY2FuIGJlIGRpc2FibGVkIGJ5IHNldHRpbmcgb3B0aW9ucy5ub2dsb2JzdGFyLlxuZXhwb3J0IGNvbnN0IG1ha2VSZSA9IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucykubWFrZVJlKCk7XG5taW5pbWF0Y2gubWFrZVJlID0gbWFrZVJlO1xuZXhwb3J0IGNvbnN0IG1hdGNoID0gKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG1tID0gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKTtcbiAgICBsaXN0ID0gbGlzdC5maWx0ZXIoZiA9PiBtbS5tYXRjaChmKSk7XG4gICAgaWYgKG1tLm9wdGlvbnMubm9udWxsICYmICFsaXN0Lmxlbmd0aCkge1xuICAgICAgICBsaXN0LnB1c2gocGF0dGVybik7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufTtcbm1pbmltYXRjaC5tYXRjaCA9IG1hdGNoO1xuLy8gcmVwbGFjZSBzdHVmZiBsaWtlIFxcKiB3aXRoICpcbmNvbnN0IGdsb2JNYWdpYyA9IC9bPypdfFsrQCFdXFwoLio/XFwpfFxcW3xcXF0vO1xuY29uc3QgcmVnRXhwRXNjYXBlID0gKHMpID0+IHMucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbmV4cG9ydCBjbGFzcyBNaW5pbWF0Y2gge1xuICAgIG9wdGlvbnM7XG4gICAgc2V0O1xuICAgIHBhdHRlcm47XG4gICAgd2luZG93c1BhdGhzTm9Fc2NhcGU7XG4gICAgbm9uZWdhdGU7XG4gICAgbmVnYXRlO1xuICAgIGNvbW1lbnQ7XG4gICAgZW1wdHk7XG4gICAgcHJlc2VydmVNdWx0aXBsZVNsYXNoZXM7XG4gICAgcGFydGlhbDtcbiAgICBnbG9iU2V0O1xuICAgIGdsb2JQYXJ0cztcbiAgICBub2Nhc2U7XG4gICAgaXNXaW5kb3dzO1xuICAgIHBsYXRmb3JtO1xuICAgIHdpbmRvd3NOb01hZ2ljUm9vdDtcbiAgICByZWdleHA7XG4gICAgY29uc3RydWN0b3IocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBvcHRpb25zLnBsYXRmb3JtIHx8IGRlZmF1bHRQbGF0Zm9ybTtcbiAgICAgICAgdGhpcy5pc1dpbmRvd3MgPSB0aGlzLnBsYXRmb3JtID09PSAnd2luMzInO1xuICAgICAgICB0aGlzLndpbmRvd3NQYXRoc05vRXNjYXBlID1cbiAgICAgICAgICAgICEhb3B0aW9ucy53aW5kb3dzUGF0aHNOb0VzY2FwZSB8fCBvcHRpb25zLmFsbG93V2luZG93c0VzY2FwZSA9PT0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLndpbmRvd3NQYXRoc05vRXNjYXBlKSB7XG4gICAgICAgICAgICB0aGlzLnBhdHRlcm4gPSB0aGlzLnBhdHRlcm4ucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlc2VydmVNdWx0aXBsZVNsYXNoZXMgPSAhIW9wdGlvbnMucHJlc2VydmVNdWx0aXBsZVNsYXNoZXM7XG4gICAgICAgIHRoaXMucmVnZXhwID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZWdhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub25lZ2F0ZSA9ICEhb3B0aW9ucy5ub25lZ2F0ZTtcbiAgICAgICAgdGhpcy5jb21tZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJ0aWFsID0gISFvcHRpb25zLnBhcnRpYWw7XG4gICAgICAgIHRoaXMubm9jYXNlID0gISF0aGlzLm9wdGlvbnMubm9jYXNlO1xuICAgICAgICB0aGlzLndpbmRvd3NOb01hZ2ljUm9vdCA9XG4gICAgICAgICAgICBvcHRpb25zLndpbmRvd3NOb01hZ2ljUm9vdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLndpbmRvd3NOb01hZ2ljUm9vdFxuICAgICAgICAgICAgICAgIDogISEodGhpcy5pc1dpbmRvd3MgJiYgdGhpcy5ub2Nhc2UpO1xuICAgICAgICB0aGlzLmdsb2JTZXQgPSBbXTtcbiAgICAgICAgdGhpcy5nbG9iUGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5zZXQgPSBbXTtcbiAgICAgICAgLy8gbWFrZSB0aGUgc2V0IG9mIHJlZ2V4cHMgZXRjLlxuICAgICAgICB0aGlzLm1ha2UoKTtcbiAgICB9XG4gICAgaGFzTWFnaWMoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWFnaWNhbEJyYWNlcyAmJiB0aGlzLnNldC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgdGhpcy5zZXQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkZWJ1ZyguLi5fKSB7IH1cbiAgICBtYWtlKCkge1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvLyBlbXB0eSBwYXR0ZXJucyBhbmQgY29tbWVudHMgbWF0Y2ggbm90aGluZy5cbiAgICAgICAgaWYgKCFvcHRpb25zLm5vY29tbWVudCAmJiBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGF0dGVybikge1xuICAgICAgICAgICAgdGhpcy5lbXB0eSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RlcCAxOiBmaWd1cmUgb3V0IG5lZ2F0aW9uLCBldGMuXG4gICAgICAgIHRoaXMucGFyc2VOZWdhdGUoKTtcbiAgICAgICAgLy8gc3RlcCAyOiBleHBhbmQgYnJhY2VzXG4gICAgICAgIHRoaXMuZ2xvYlNldCA9IFsuLi5uZXcgU2V0KHRoaXMuYnJhY2VFeHBhbmQoKSldO1xuICAgICAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyA9ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCB0aGlzLmdsb2JTZXQpO1xuICAgICAgICAvLyBzdGVwIDM6IG5vdyB3ZSBoYXZlIGEgc2V0LCBzbyB0dXJuIGVhY2ggb25lIGludG8gYSBzZXJpZXMgb2ZcbiAgICAgICAgLy8gcGF0aC1wb3J0aW9uIG1hdGNoaW5nIHBhdHRlcm5zLlxuICAgICAgICAvLyBUaGVzZSB3aWxsIGJlIHJlZ2V4cHMsIGV4Y2VwdCBpbiB0aGUgY2FzZSBvZiBcIioqXCIsIHdoaWNoIGlzXG4gICAgICAgIC8vIHNldCB0byB0aGUgR0xPQlNUQVIgb2JqZWN0IGZvciBnbG9ic3RhciBiZWhhdmlvcixcbiAgICAgICAgLy8gYW5kIHdpbGwgbm90IGNvbnRhaW4gYW55IC8gY2hhcmFjdGVyc1xuICAgICAgICAvL1xuICAgICAgICAvLyBGaXJzdCwgd2UgcHJlcHJvY2VzcyB0byBtYWtlIHRoZSBnbG9iIHBhdHRlcm4gc2V0cyBhIGJpdCBzaW1wbGVyXG4gICAgICAgIC8vIGFuZCBkZWR1cGVkLiAgVGhlcmUgYXJlIHNvbWUgcGVyZi1raWxsaW5nIHBhdHRlcm5zIHRoYXQgY2FuIGNhdXNlXG4gICAgICAgIC8vIHByb2JsZW1zIHdpdGggYSBnbG9iIHdhbGssIGJ1dCB3ZSBjYW4gc2ltcGxpZnkgdGhlbSBkb3duIGEgYml0LlxuICAgICAgICBjb25zdCByYXdHbG9iUGFydHMgPSB0aGlzLmdsb2JTZXQubWFwKHMgPT4gdGhpcy5zbGFzaFNwbGl0KHMpKTtcbiAgICAgICAgdGhpcy5nbG9iUGFydHMgPSB0aGlzLnByZXByb2Nlc3MocmF3R2xvYlBhcnRzKTtcbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHRoaXMuZ2xvYlBhcnRzKTtcbiAgICAgICAgLy8gZ2xvYiAtLT4gcmVnZXhwc1xuICAgICAgICBsZXQgc2V0ID0gdGhpcy5nbG9iUGFydHMubWFwKChzLCBfLCBfXykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNXaW5kb3dzICYmIHRoaXMud2luZG93c05vTWFnaWNSb290KSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXQncyBhIGRyaXZlIG9yIHVuYyBwYXRoLlxuICAgICAgICAgICAgICAgIGNvbnN0IGlzVU5DID0gc1swXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgc1sxXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNbMl0gPT09ICc/JyB8fCAhZ2xvYk1hZ2ljLnRlc3Qoc1syXSkpICYmXG4gICAgICAgICAgICAgICAgICAgICFnbG9iTWFnaWMudGVzdChzWzNdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0RyaXZlID0gL15bYS16XTovaS50ZXN0KHNbMF0pO1xuICAgICAgICAgICAgICAgIGlmIChpc1VOQykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWy4uLnMuc2xpY2UoMCwgNCksIC4uLnMuc2xpY2UoNCkubWFwKHNzID0+IHRoaXMucGFyc2Uoc3MpKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRHJpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzWzBdLCAuLi5zLnNsaWNlKDEpLm1hcChzcyA9PiB0aGlzLnBhcnNlKHNzKSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzLm1hcChzcyA9PiB0aGlzLnBhcnNlKHNzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KTtcbiAgICAgICAgLy8gZmlsdGVyIG91dCBldmVyeXRoaW5nIHRoYXQgZGlkbid0IGNvbXBpbGUgcHJvcGVybHkuXG4gICAgICAgIHRoaXMuc2V0ID0gc2V0LmZpbHRlcihzID0+IHMuaW5kZXhPZihmYWxzZSkgPT09IC0xKTtcbiAgICAgICAgLy8gZG8gbm90IHRyZWF0IHRoZSA/IGluIFVOQyBwYXRocyBhcyBtYWdpY1xuICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gdGhpcy5zZXRbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBbMF0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgIHBbMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2xvYlBhcnRzW2ldWzJdID09PSAnPycgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBbM10gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgIC9eW2Etel06JC9pLnRlc3QocFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcFsyXSA9ICc/JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHRoaXMuc2V0KTtcbiAgICB9XG4gICAgLy8gdmFyaW91cyB0cmFuc2Zvcm1zIHRvIGVxdWl2YWxlbnQgcGF0dGVybiBzZXRzIHRoYXQgYXJlXG4gICAgLy8gZmFzdGVyIHRvIHByb2Nlc3MgaW4gYSBmaWxlc3lzdGVtIHdhbGsuICBUaGUgZ29hbCBpcyB0b1xuICAgIC8vIGVsaW1pbmF0ZSB3aGF0IHdlIGNhbiwgYW5kIHB1c2ggYWxsICoqIHBhdHRlcm5zIGFzIGZhclxuICAgIC8vIHRvIHRoZSByaWdodCBhcyBwb3NzaWJsZSwgZXZlbiBpZiBpdCBpbmNyZWFzZXMgdGhlIG51bWJlclxuICAgIC8vIG9mIHBhdHRlcm5zIHRoYXQgd2UgaGF2ZSB0byBwcm9jZXNzLlxuICAgIHByZXByb2Nlc3MoZ2xvYlBhcnRzKSB7XG4gICAgICAgIC8vIGlmIHdlJ3JlIG5vdCBpbiBnbG9ic3RhciBtb2RlLCB0aGVuIHR1cm4gYWxsICoqIGludG8gKlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vZ2xvYnN0YXIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2xvYlBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBnbG9iUGFydHNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdsb2JQYXJ0c1tpXVtqXSA9PT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYlBhcnRzW2ldW2pdID0gJyonO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgb3B0aW1pemF0aW9uTGV2ZWwgPSAxIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpbWl6YXRpb25MZXZlbCA+PSAyKSB7XG4gICAgICAgICAgICAvLyBhZ2dyZXNzaXZlIG9wdGltaXphdGlvbiBmb3IgdGhlIHB1cnBvc2Ugb2YgZnMgd2Fsa2luZ1xuICAgICAgICAgICAgZ2xvYlBhcnRzID0gdGhpcy5maXJzdFBoYXNlUHJlUHJvY2VzcyhnbG9iUGFydHMpO1xuICAgICAgICAgICAgZ2xvYlBhcnRzID0gdGhpcy5zZWNvbmRQaGFzZVByZVByb2Nlc3MoZ2xvYlBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpbWl6YXRpb25MZXZlbCA+PSAxKSB7XG4gICAgICAgICAgICAvLyBqdXN0IGJhc2ljIG9wdGltaXphdGlvbnMgdG8gcmVtb3ZlIHNvbWUgLi4gcGFydHNcbiAgICAgICAgICAgIGdsb2JQYXJ0cyA9IHRoaXMubGV2ZWxPbmVPcHRpbWl6ZShnbG9iUGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2xvYlBhcnRzID0gdGhpcy5hZGphc2NlbnRHbG9ic3Rhck9wdGltaXplKGdsb2JQYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cztcbiAgICB9XG4gICAgLy8ganVzdCBnZXQgcmlkIG9mIGFkamFzY2VudCAqKiBwb3J0aW9uc1xuICAgIGFkamFzY2VudEdsb2JzdGFyT3B0aW1pemUoZ2xvYlBhcnRzKSB7XG4gICAgICAgIHJldHVybiBnbG9iUGFydHMubWFwKHBhcnRzID0+IHtcbiAgICAgICAgICAgIGxldCBncyA9IC0xO1xuICAgICAgICAgICAgd2hpbGUgKC0xICE9PSAoZ3MgPSBwYXJ0cy5pbmRleE9mKCcqKicsIGdzICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSBncztcbiAgICAgICAgICAgICAgICB3aGlsZSAocGFydHNbaSArIDFdID09PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IGdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShncywgaSAtIGdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBnZXQgcmlkIG9mIGFkamFzY2VudCAqKiBhbmQgcmVzb2x2ZSAuLiBwb3J0aW9uc1xuICAgIGxldmVsT25lT3B0aW1pemUoZ2xvYlBhcnRzKSB7XG4gICAgICAgIHJldHVybiBnbG9iUGFydHMubWFwKHBhcnRzID0+IHtcbiAgICAgICAgICAgIHBhcnRzID0gcGFydHMucmVkdWNlKChzZXQsIHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gc2V0W3NldC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAocGFydCA9PT0gJyoqJyAmJiBwcmV2ID09PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2ICYmIHByZXYgIT09ICcuLicgJiYgcHJldiAhPT0gJy4nICYmIHByZXYgIT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldC5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0LnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPT09IDAgPyBbJyddIDogcGFydHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXZlbFR3b0ZpbGVPcHRpbWl6ZShwYXJ0cykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFydHMpKSB7XG4gICAgICAgICAgICBwYXJ0cyA9IHRoaXMuc2xhc2hTcGxpdChwYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpZFNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBkaWRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIDxwcmU+LzxlPi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJlc2VydmVNdWx0aXBsZVNsYXNoZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHNxdWVlemUgb3V0IFVOQyBwYXR0ZXJuc1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiBwID09PSAnJyAmJiBwYXJ0c1swXSA9PT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgPT09ICcuJyB8fCBwID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFydHNbMF0gPT09ICcuJyAmJlxuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICAgICAgKHBhcnRzWzFdID09PSAnLicgfHwgcGFydHNbMV0gPT09ICcnKSkge1xuICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA8cHJlPi88cD4vLi4vPHJlc3Q+IC0+IDxwcmU+LzxyZXN0PlxuICAgICAgICAgICAgbGV0IGRkID0gMDtcbiAgICAgICAgICAgIHdoaWxlICgtMSAhPT0gKGRkID0gcGFydHMuaW5kZXhPZignLi4nLCBkZCArIDEpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tkZCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChwICYmIHAgIT09ICcuJyAmJiBwICE9PSAnLi4nICYmIHAgIT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGRkIC0gMSwgMik7XG4gICAgICAgICAgICAgICAgICAgIGRkIC09IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChkaWRTb21ldGhpbmcpO1xuICAgICAgICByZXR1cm4gcGFydHMubGVuZ3RoID09PSAwID8gWycnXSA6IHBhcnRzO1xuICAgIH1cbiAgICAvLyBGaXJzdCBwaGFzZTogc2luZ2xlLXBhdHRlcm4gcHJvY2Vzc2luZ1xuICAgIC8vIDxwcmU+IGlzIDEgb3IgbW9yZSBwb3J0aW9uc1xuICAgIC8vIDxyZXN0PiBpcyAxIG9yIG1vcmUgcG9ydGlvbnNcbiAgICAvLyA8cD4gaXMgYW55IHBvcnRpb24gb3RoZXIgdGhhbiAuLCAuLiwgJycsIG9yICoqXG4gICAgLy8gPGU+IGlzIC4gb3IgJydcbiAgICAvL1xuICAgIC8vICoqLy4uIGlzICpicnV0YWwqIGZvciBmaWxlc3lzdGVtIHdhbGtpbmcgcGVyZm9ybWFuY2UsIGJlY2F1c2VcbiAgICAvLyBpdCBlZmZlY3RpdmVseSByZXNldHMgdGhlIHJlY3Vyc2l2ZSB3YWxrIGVhY2ggdGltZSBpdCBvY2N1cnMsXG4gICAgLy8gYW5kICoqIGNhbm5vdCBiZSByZWR1Y2VkIG91dCBieSBhIC4uIHBhdHRlcm4gcGFydCBsaWtlIGEgcmVnZXhwXG4gICAgLy8gb3IgbW9zdCBzdHJpbmdzIChvdGhlciB0aGFuIC4uLCAuLCBhbmQgJycpIGNhbiBiZS5cbiAgICAvL1xuICAgIC8vIDxwcmU+LyoqLy4uLzxwPi88cD4vPHJlc3Q+IC0+IHs8cHJlPi8uLi88cD4vPHA+LzxyZXN0Piw8cHJlPi8qKi88cD4vPHA+LzxyZXN0Pn1cbiAgICAvLyA8cHJlPi88ZT4vPHJlc3Q+IC0+IDxwcmU+LzxyZXN0PlxuICAgIC8vIDxwcmU+LzxwPi8uLi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgLy8gKiovKiovPHJlc3Q+IC0+ICoqLzxyZXN0PlxuICAgIC8vXG4gICAgLy8gKiovKi88cmVzdD4gLT4gKi8qKi88cmVzdD4gPD09IG5vdCB2YWxpZCBiZWNhdXNlICoqIGRvZXNuJ3QgZm9sbG93XG4gICAgLy8gdGhpcyBXT1VMRCBiZSBhbGxvd2VkIGlmICoqIGRpZCBmb2xsb3cgc3ltbGlua3MsIG9yICogZGlkbid0XG4gICAgZmlyc3RQaGFzZVByZVByb2Nlc3MoZ2xvYlBhcnRzKSB7XG4gICAgICAgIGxldCBkaWRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyA8cHJlPi8qKi8uLi88cD4vPHA+LzxyZXN0PiAtPiB7PHByZT4vLi4vPHA+LzxwPi88cmVzdD4sPHByZT4vKiovPHA+LzxwPi88cmVzdD59XG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0cyBvZiBnbG9iUGFydHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZ3MgPSAtMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoLTEgIT09IChncyA9IHBhcnRzLmluZGV4T2YoJyoqJywgZ3MgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGdzcyA9IGdzO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocGFydHNbZ3NzICsgMV0gPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxwcmU+LyoqLyoqLzxyZXN0PiAtPiA8cHJlPi8qKi88cmVzdD5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdzcysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVnLCBpZiBncyBpcyAyIGFuZCBnc3MgaXMgNCwgdGhhdCBtZWFucyB3ZSBoYXZlIDMgKipcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFydHMsIGFuZCBjYW4gcmVtb3ZlIDIgb2YgdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdzcyA+IGdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZ3MgKyAxLCBnc3MgLSBncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwYXJ0c1tncyArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGFydHNbZ3MgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcDIgPSBwYXJ0c1tncyArIDNdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gJy4uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPT09ICcuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIXAyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwMiA9PT0gJy4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwMiA9PT0gJy4uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWRpdCBwYXJ0cyBpbiBwbGFjZSwgYW5kIHB1c2ggdGhlIG5ldyBvbmVcbiAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGdzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBwYXJ0cy5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJbZ3NdID0gJyoqJztcbiAgICAgICAgICAgICAgICAgICAgZ2xvYlBhcnRzLnB1c2gob3RoZXIpO1xuICAgICAgICAgICAgICAgICAgICBncy0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyA8cHJlPi88ZT4vPHJlc3Q+IC0+IDxwcmU+LzxyZXN0PlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc3F1ZWV6ZSBvdXQgVU5DIHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiBwID09PSAnJyAmJiBwYXJ0c1swXSA9PT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocCA9PT0gJy4nIHx8IHAgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0c1swXSA9PT0gJy4nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChwYXJ0c1sxXSA9PT0gJy4nIHx8IHBhcnRzWzFdID09PSAnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyA8cHJlPi88cD4vLi4vPHJlc3Q+IC0+IDxwcmU+LzxyZXN0PlxuICAgICAgICAgICAgICAgIGxldCBkZCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKC0xICE9PSAoZGQgPSBwYXJ0cy5pbmRleE9mKCcuLicsIGRkICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tkZCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCAmJiBwICE9PSAnLicgJiYgcCAhPT0gJy4uJyAmJiBwICE9PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVlZERvdCA9IGRkID09PSAxICYmIHBhcnRzW2RkICsgMV0gPT09ICcqKic7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGxpbiA9IG5lZWREb3QgPyBbJy4nXSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGRkIC0gMSwgMiwgLi4uc3BsaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRkIC09IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGRpZFNvbWV0aGluZyk7XG4gICAgICAgIHJldHVybiBnbG9iUGFydHM7XG4gICAgfVxuICAgIC8vIHNlY29uZCBwaGFzZTogbXVsdGktcGF0dGVybiBkZWR1cGVzXG4gICAgLy8gezxwcmU+LyovPHJlc3Q+LDxwcmU+LzxwPi88cmVzdD59IC0+IDxwcmU+LyovPHJlc3Q+XG4gICAgLy8gezxwcmU+LzxyZXN0Piw8cHJlPi88cmVzdD59IC0+IDxwcmU+LzxyZXN0PlxuICAgIC8vIHs8cHJlPi8qKi88cmVzdD4sPHByZT4vPHJlc3Q+fSAtPiA8cHJlPi8qKi88cmVzdD5cbiAgICAvL1xuICAgIC8vIHs8cHJlPi8qKi88cmVzdD4sPHByZT4vKiovPHA+LzxyZXN0Pn0gLT4gPHByZT4vKiovPHJlc3Q+XG4gICAgLy8gXi0tIG5vdCB2YWxpZCBiZWNhdXNlICoqIGRvZW5zJ3QgZm9sbG93IHN5bWxpbmtzXG4gICAgc2Vjb25kUGhhc2VQcmVQcm9jZXNzKGdsb2JQYXJ0cykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdsb2JQYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGdsb2JQYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZWQgPSB0aGlzLnBhcnRzTWF0Y2goZ2xvYlBhcnRzW2ldLCBnbG9iUGFydHNbal0sICF0aGlzLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGdsb2JQYXJ0c1tpXSA9IG1hdGNoZWQ7XG4gICAgICAgICAgICAgICAgZ2xvYlBhcnRzW2pdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cy5maWx0ZXIoZ3MgPT4gZ3MubGVuZ3RoKTtcbiAgICB9XG4gICAgcGFydHNNYXRjaChhLCBiLCBlbXB0eUdTTWF0Y2ggPSBmYWxzZSkge1xuICAgICAgICBsZXQgYWkgPSAwO1xuICAgICAgICBsZXQgYmkgPSAwO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCB3aGljaCA9ICcnO1xuICAgICAgICB3aGlsZSAoYWkgPCBhLmxlbmd0aCAmJiBiaSA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoYVthaV0gPT09IGJbYmldKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2god2hpY2ggPT09ICdiJyA/IGJbYmldIDogYVthaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICAgICAgYmkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVtcHR5R1NNYXRjaCAmJiBhW2FpXSA9PT0gJyoqJyAmJiBiW2JpXSA9PT0gYVthaSArIDFdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYVthaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbXB0eUdTTWF0Y2ggJiYgYltiaV0gPT09ICcqKicgJiYgYVthaV0gPT09IGJbYmkgKyAxXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJbYmldKTtcbiAgICAgICAgICAgICAgICBiaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYVthaV0gPT09ICcqJyAmJlxuICAgICAgICAgICAgICAgIGJbYmldICYmXG4gICAgICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5kb3QgfHwgIWJbYmldLnN0YXJ0c1dpdGgoJy4nKSkgJiZcbiAgICAgICAgICAgICAgICBiW2JpXSAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgIGlmICh3aGljaCA9PT0gJ2InKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpY2ggPSAnYSc7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYVthaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICAgICAgYmkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJbYmldID09PSAnKicgJiZcbiAgICAgICAgICAgICAgICBhW2FpXSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLm9wdGlvbnMuZG90IHx8ICFhW2FpXS5zdGFydHNXaXRoKCcuJykpICYmXG4gICAgICAgICAgICAgICAgYVthaV0gIT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICBpZiAod2hpY2ggPT09ICdhJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHdoaWNoID0gJ2InO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJbYmldKTtcbiAgICAgICAgICAgICAgICBhaSsrO1xuICAgICAgICAgICAgICAgIGJpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgZmFsbCBvdXQgb2YgdGhlIGxvb3AsIGl0IG1lYW5zIHRoZXkgdHdvIGFyZSBpZGVudGljYWxcbiAgICAgICAgLy8gYXMgbG9uZyBhcyB0aGVpciBsZW5ndGhzIG1hdGNoXG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgcmVzdWx0O1xuICAgIH1cbiAgICBwYXJzZU5lZ2F0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9uZWdhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLnBhdHRlcm47XG4gICAgICAgIGxldCBuZWdhdGUgPSBmYWxzZTtcbiAgICAgICAgbGV0IG5lZ2F0ZU9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGggJiYgcGF0dGVybi5jaGFyQXQoaSkgPT09ICchJzsgaSsrKSB7XG4gICAgICAgICAgICBuZWdhdGUgPSAhbmVnYXRlO1xuICAgICAgICAgICAgbmVnYXRlT2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZ2F0ZU9mZnNldClcbiAgICAgICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm4uc2xpY2UobmVnYXRlT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5uZWdhdGUgPSBuZWdhdGU7XG4gICAgfVxuICAgIC8vIHNldCBwYXJ0aWFsIHRvIHRydWUgdG8gdGVzdCBpZiwgZm9yIGV4YW1wbGUsXG4gICAgLy8gXCIvYS9iXCIgbWF0Y2hlcyB0aGUgc3RhcnQgb2YgXCIvKi9iLyovZFwiXG4gICAgLy8gUGFydGlhbCBtZWFucywgaWYgeW91IHJ1biBvdXQgb2YgZmlsZSBiZWZvcmUgeW91IHJ1blxuICAgIC8vIG91dCBvZiBwYXR0ZXJuLCB0aGVuIHRoYXQncyBmaW5lLCBhcyBsb25nIGFzIGFsbFxuICAgIC8vIHRoZSBwYXJ0cyBtYXRjaC5cbiAgICBtYXRjaE9uZShmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLy8gVU5DIHBhdGhzIGxpa2UgLy8/L1g6Ly4uLiBjYW4gbWF0Y2ggWDovLi4uIGFuZCB2aWNlIHZlcnNhXG4gICAgICAgIC8vIERyaXZlIGxldHRlcnMgaW4gYWJzb2x1dGUgZHJpdmUgb3IgdW5jIHBhdGhzIGFyZSBhbHdheXMgY29tcGFyZWRcbiAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVEcml2ZSA9IHR5cGVvZiBmaWxlWzBdID09PSAnc3RyaW5nJyAmJiAvXlthLXpdOiQvaS50ZXN0KGZpbGVbMF0pO1xuICAgICAgICAgICAgY29uc3QgZmlsZVVOQyA9ICFmaWxlRHJpdmUgJiZcbiAgICAgICAgICAgICAgICBmaWxlWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgIGZpbGVbMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgZmlsZVsyXSA9PT0gJz8nICYmXG4gICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChmaWxlWzNdKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5Ecml2ZSA9IHR5cGVvZiBwYXR0ZXJuWzBdID09PSAnc3RyaW5nJyAmJiAvXlthLXpdOiQvaS50ZXN0KHBhdHRlcm5bMF0pO1xuICAgICAgICAgICAgY29uc3QgcGF0dGVyblVOQyA9ICFwYXR0ZXJuRHJpdmUgJiZcbiAgICAgICAgICAgICAgICBwYXR0ZXJuWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgIHBhdHRlcm5bMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgcGF0dGVyblsyXSA9PT0gJz8nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHBhdHRlcm5bM10gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChwYXR0ZXJuWzNdKTtcbiAgICAgICAgICAgIGNvbnN0IGZkaSA9IGZpbGVVTkMgPyAzIDogZmlsZURyaXZlID8gMCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHBkaSA9IHBhdHRlcm5VTkMgPyAzIDogcGF0dGVybkRyaXZlID8gMCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmRpID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgcGRpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtmZCwgcGRdID0gW2ZpbGVbZmRpXSwgcGF0dGVybltwZGldXTtcbiAgICAgICAgICAgICAgICBpZiAoZmQudG9Mb3dlckNhc2UoKSA9PT0gcGQudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuW3BkaV0gPSBmZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBkaSA+IGZkaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UocGRpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmZGkgPiBwZGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgPSBmaWxlLnNsaWNlKGZkaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzb2x2ZSBhbmQgcmVkdWNlIC4gYW5kIC4uIHBvcnRpb25zIGluIHRoZSBmaWxlIGFzIHdlbGwuXG4gICAgICAgIC8vIGRvbnQnIG5lZWQgdG8gZG8gdGhlIHNlY29uZCBwaGFzZSwgYmVjYXVzZSBpdCdzIG9ubHkgb25lIHN0cmluZ1tdXG4gICAgICAgIGNvbnN0IHsgb3B0aW1pemF0aW9uTGV2ZWwgPSAxIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpbWl6YXRpb25MZXZlbCA+PSAyKSB7XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5sZXZlbFR3b0ZpbGVPcHRpbWl6ZShmaWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKCdtYXRjaE9uZScsIHRoaXMsIHsgZmlsZSwgcGF0dGVybiB9KTtcbiAgICAgICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLCBmaWxlLmxlbmd0aCwgcGF0dGVybi5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBmaSA9IDAsIHBpID0gMCwgZmwgPSBmaWxlLmxlbmd0aCwgcGwgPSBwYXR0ZXJuLmxlbmd0aDsgZmkgPCBmbCAmJiBwaSA8IHBsOyBmaSsrLCBwaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdtYXRjaE9uZSBsb29wJyk7XG4gICAgICAgICAgICB2YXIgcCA9IHBhdHRlcm5bcGldO1xuICAgICAgICAgICAgdmFyIGYgPSBmaWxlW2ZpXTtcbiAgICAgICAgICAgIHRoaXMuZGVidWcocGF0dGVybiwgcCwgZik7XG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgaW1wb3NzaWJsZS5cbiAgICAgICAgICAgIC8vIHNvbWUgaW52YWxpZCByZWdleHAgc3R1ZmYgaW4gdGhlIHNldC5cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIGlmIChwID09PSBHTE9CU1RBUikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ0dMT0JTVEFSJywgW3BhdHRlcm4sIHAsIGZdKTtcbiAgICAgICAgICAgICAgICAvLyBcIioqXCJcbiAgICAgICAgICAgICAgICAvLyBhLyoqL2IvKiovYyB3b3VsZCBtYXRjaCB0aGUgZm9sbG93aW5nOlxuICAgICAgICAgICAgICAgIC8vIGEvYi94L3kvei9jXG4gICAgICAgICAgICAgICAgLy8gYS94L3kvei9iL2NcbiAgICAgICAgICAgICAgICAvLyBhL2IveC9iL3gvY1xuICAgICAgICAgICAgICAgIC8vIGEvYi9jXG4gICAgICAgICAgICAgICAgLy8gVG8gZG8gdGhpcywgdGFrZSB0aGUgcmVzdCBvZiB0aGUgcGF0dGVybiBhZnRlclxuICAgICAgICAgICAgICAgIC8vIHRoZSAqKiwgYW5kIHNlZSBpZiBpdCB3b3VsZCBtYXRjaCB0aGUgZmlsZSByZW1haW5kZXIuXG4gICAgICAgICAgICAgICAgLy8gSWYgc28sIHJldHVybiBzdWNjZXNzLlxuICAgICAgICAgICAgICAgIC8vIElmIG5vdCwgdGhlICoqIFwic3dhbGxvd3NcIiBhIHNlZ21lbnQsIGFuZCB0cnkgYWdhaW4uXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyByZWN1cnNpdmVseSBhd2Z1bC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGEvKiovYi8qKi9jIG1hdGNoaW5nIGEvYi94L3kvei9jXG4gICAgICAgICAgICAgICAgLy8gLSBhIG1hdGNoZXMgYVxuICAgICAgICAgICAgICAgIC8vIC0gZG91Ymxlc3RhclxuICAgICAgICAgICAgICAgIC8vICAgLSBtYXRjaE9uZShiL3gveS96L2MsIGIvKiovYylcbiAgICAgICAgICAgICAgICAvLyAgICAgLSBiIG1hdGNoZXMgYlxuICAgICAgICAgICAgICAgIC8vICAgICAtIGRvdWJsZXN0YXJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKHgveS96L2MsIGMpIC0+IG5vXG4gICAgICAgICAgICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh5L3ovYywgYykgLT4gbm9cbiAgICAgICAgICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKHovYywgYykgLT4gbm9cbiAgICAgICAgICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKGMsIGMpIHllcywgaGl0XG4gICAgICAgICAgICAgICAgdmFyIGZyID0gZmk7XG4gICAgICAgICAgICAgICAgdmFyIHByID0gcGkgKyAxO1xuICAgICAgICAgICAgICAgIGlmIChwciA9PT0gcGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnKiogYXQgdGhlIGVuZCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBhICoqIGF0IHRoZSBlbmQgd2lsbCBqdXN0IHN3YWxsb3cgdGhlIHJlc3QuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgLy8gaG93ZXZlciwgaXQgd2lsbCBub3Qgc3dhbGxvdyAvLngsIHVubGVzc1xuICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25zLmRvdCBpcyBzZXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIC4gYW5kIC4uIGFyZSAqbmV2ZXIqIG1hdGNoZWQgYnkgKiosIGZvciBleHBsb3NpdmVseVxuICAgICAgICAgICAgICAgICAgICAvLyBleHBvbmVudGlhbCByZWFzb25zLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZmkgPCBmbDsgZmkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVbZmldID09PSAnLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlW2ZpXSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghb3B0aW9ucy5kb3QgJiYgZmlsZVtmaV0uY2hhckF0KDApID09PSAnLicpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb2ssIGxldCdzIHNlZSBpZiB3ZSBjYW4gc3dhbGxvdyB3aGF0ZXZlciB3ZSBjYW4uXG4gICAgICAgICAgICAgICAgd2hpbGUgKGZyIDwgZmwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN3YWxsb3dlZSA9IGZpbGVbZnJdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdcXG5nbG9ic3RhciB3aGlsZScsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwciwgc3dhbGxvd2VlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gWFhYIHJlbW92ZSB0aGlzIHNsaWNlLiAgSnVzdCBwYXNzIHRoZSBzdGFydCBpbmRleC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hPbmUoZmlsZS5zbGljZShmciksIHBhdHRlcm4uc2xpY2UocHIpLCBwYXJ0aWFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgZm91bmQgbWF0Y2ghJywgZnIsIGZsLCBzd2FsbG93ZWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuJ3Qgc3dhbGxvdyBcIi5cIiBvciBcIi4uXCIgZXZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiBvbmx5IHN3YWxsb3cgXCIuZm9vXCIgd2hlbiBleHBsaWNpdGx5IGFza2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN3YWxsb3dlZSA9PT0gJy4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dhbGxvd2VlID09PSAnLi4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBzd2FsbG93ZWUuY2hhckF0KDApID09PSAnLicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZG90IGRldGVjdGVkIScsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAqKiBzd2FsbG93cyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ2dsb2JzdGFyIHN3YWxsb3cgYSBzZWdtZW50LCBhbmQgY29udGludWUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbm8gbWF0Y2ggd2FzIGZvdW5kLlxuICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIGluIHBhcnRpYWwgbW9kZSwgd2UgY2FuJ3Qgc2F5IHRoaXMgaXMgbmVjZXNzYXJpbHkgb3Zlci5cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICBpZiAocGFydGlhbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByYW4gb3V0IG9mIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnXFxuPj4+IG5vIG1hdGNoLCBwYXJ0aWFsPycsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmciA9PT0gZmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc29tZXRoaW5nIG90aGVyIHRoYW4gKipcbiAgICAgICAgICAgIC8vIG5vbi1tYWdpYyBwYXR0ZXJucyBqdXN0IGhhdmUgdG8gbWF0Y2ggZXhhY3RseVxuICAgICAgICAgICAgLy8gcGF0dGVybnMgd2l0aCBtYWdpYyBoYXZlIGJlZW4gdHVybmVkIGludG8gcmVnZXhwcy5cbiAgICAgICAgICAgIGxldCBoaXQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaGl0ID0gZiA9PT0gcDtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdzdHJpbmcgbWF0Y2gnLCBwLCBmLCBoaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGl0ID0gcC50ZXN0KGYpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ3BhdHRlcm4gbWF0Y2gnLCBwLCBmLCBoaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IGVuZGluZyBpbiAvIG1lYW5zIHRoYXQgd2UnbGwgZ2V0IGEgZmluYWwgXCJcIlxuICAgICAgICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLiAgVGhpcyBjYW4gb25seSBtYXRjaCBhXG4gICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgXCJcIiBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlLlxuICAgICAgICAvLyBJZiB0aGUgZmlsZSBlbmRzIGluIC8sIHRoZW4gaXQgY2FuIG9ubHkgbWF0Y2ggYVxuICAgICAgICAvLyBhIHBhdHRlcm4gdGhhdCBlbmRzIGluIC8sIHVubGVzcyB0aGUgcGF0dGVybiBqdXN0XG4gICAgICAgIC8vIGRvZXNuJ3QgaGF2ZSBhbnkgbW9yZSBmb3IgaXQuIEJ1dCwgYS9iLyBzaG91bGQgKm5vdCpcbiAgICAgICAgLy8gbWF0Y2ggXCJhL2IvKlwiLCBldmVuIHRob3VnaCBcIlwiIG1hdGNoZXMgYWdhaW5zdCB0aGVcbiAgICAgICAgLy8gW14vXSo/IHBhdHRlcm4sIGV4Y2VwdCBpbiBwYXJ0aWFsIG1vZGUsIHdoZXJlIGl0IG1pZ2h0XG4gICAgICAgIC8vIHNpbXBseSBub3QgYmUgcmVhY2hlZCB5ZXQuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGEvYi8gc2hvdWxkIHN0aWxsIHNhdGlzZnkgYS8qXG4gICAgICAgIC8vIG5vdyBlaXRoZXIgd2UgZmVsbCBvZmYgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiwgb3Igd2UncmUgZG9uZS5cbiAgICAgICAgaWYgKGZpID09PSBmbCAmJiBwaSA9PT0gcGwpIHtcbiAgICAgICAgICAgIC8vIHJhbiBvdXQgb2YgcGF0dGVybiBhbmQgZmlsZW5hbWUgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgICAgIC8vIGFuIGV4YWN0IGhpdCFcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpID09PSBmbCkge1xuICAgICAgICAgICAgLy8gcmFuIG91dCBvZiBmaWxlLCBidXQgc3RpbGwgaGFkIHBhdHRlcm4gbGVmdC5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgb2sgaWYgd2UncmUgZG9pbmcgdGhlIG1hdGNoIGFzIHBhcnQgb2ZcbiAgICAgICAgICAgIC8vIGEgZ2xvYiBmcyB0cmF2ZXJzYWwuXG4gICAgICAgICAgICByZXR1cm4gcGFydGlhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwaSA9PT0gcGwpIHtcbiAgICAgICAgICAgIC8vIHJhbiBvdXQgb2YgcGF0dGVybiwgc3RpbGwgaGF2ZSBmaWxlIGxlZnQuXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG9ubHkgYWNjZXB0YWJsZSBpZiB3ZSdyZSBvbiB0aGUgdmVyeSBsYXN0XG4gICAgICAgICAgICAvLyBlbXB0eSBzZWdtZW50IG9mIGEgZmlsZSB3aXRoIGEgdHJhaWxpbmcgc2xhc2guXG4gICAgICAgICAgICAvLyBhLyogc2hvdWxkIG1hdGNoIGEvYi9cbiAgICAgICAgICAgIHJldHVybiBmaSA9PT0gZmwgLSAxICYmIGZpbGVbZmldID09PSAnJztcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHVucmVhY2hhYmxlLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3dGY/Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICB9XG4gICAgYnJhY2VFeHBhbmQoKSB7XG4gICAgICAgIHJldHVybiBicmFjZUV4cGFuZCh0aGlzLnBhdHRlcm4sIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIHBhcnNlKHBhdHRlcm4pIHtcbiAgICAgICAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvLyBzaG9ydGN1dHNcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09ICcqKicpXG4gICAgICAgICAgICByZXR1cm4gR0xPQlNUQVI7XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSAnJylcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgLy8gZmFyIGFuZCBhd2F5LCB0aGUgbW9zdCBjb21tb24gZ2xvYiBwYXR0ZXJuIHBhcnRzIGFyZVxuICAgICAgICAvLyAqLCAqLiosIGFuZCAqLjxleHQ+ICBBZGQgYSBmYXN0IGNoZWNrIG1ldGhvZCBmb3IgdGhvc2UuXG4gICAgICAgIGxldCBtO1xuICAgICAgICBsZXQgZmFzdFRlc3QgPSBudWxsO1xuICAgICAgICBpZiAoKG0gPSBwYXR0ZXJuLm1hdGNoKHN0YXJSRSkpKSB7XG4gICAgICAgICAgICBmYXN0VGVzdCA9IG9wdGlvbnMuZG90ID8gc3RhclRlc3REb3QgOiBzdGFyVGVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobSA9IHBhdHRlcm4ubWF0Y2goc3RhckRvdEV4dFJFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gKG9wdGlvbnMubm9jYXNlXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgICAgICA/IHN0YXJEb3RFeHRUZXN0Tm9jYXNlRG90XG4gICAgICAgICAgICAgICAgICAgIDogc3RhckRvdEV4dFRlc3ROb2Nhc2VcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgICAgID8gc3RhckRvdEV4dFRlc3REb3RcbiAgICAgICAgICAgICAgICAgICAgOiBzdGFyRG90RXh0VGVzdCkobVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBwYXR0ZXJuLm1hdGNoKHFtYXJrc1JFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gKG9wdGlvbnMubm9jYXNlXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgICAgICA/IHFtYXJrc1Rlc3ROb2Nhc2VEb3RcbiAgICAgICAgICAgICAgICAgICAgOiBxbWFya3NUZXN0Tm9jYXNlXG4gICAgICAgICAgICAgICAgOiBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgICAgICA/IHFtYXJrc1Rlc3REb3RcbiAgICAgICAgICAgICAgICAgICAgOiBxbWFya3NUZXN0KShtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobSA9IHBhdHRlcm4ubWF0Y2goc3RhckRvdFN0YXJSRSkpKSB7XG4gICAgICAgICAgICBmYXN0VGVzdCA9IG9wdGlvbnMuZG90ID8gc3RhckRvdFN0YXJUZXN0RG90IDogc3RhckRvdFN0YXJUZXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtID0gcGF0dGVybi5tYXRjaChkb3RTdGFyUkUpKSkge1xuICAgICAgICAgICAgZmFzdFRlc3QgPSBkb3RTdGFyVGVzdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZSA9IEFTVC5mcm9tR2xvYihwYXR0ZXJuLCB0aGlzLm9wdGlvbnMpLnRvTU1QYXR0ZXJuKCk7XG4gICAgICAgIHJldHVybiBmYXN0VGVzdCA/IE9iamVjdC5hc3NpZ24ocmUsIHsgdGVzdDogZmFzdFRlc3QgfSkgOiByZTtcbiAgICB9XG4gICAgbWFrZVJlKCkge1xuICAgICAgICBpZiAodGhpcy5yZWdleHAgfHwgdGhpcy5yZWdleHAgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwO1xuICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCB0aGlzLnNldCBpcyBhIDJkIGFycmF5IG9mIHBhcnRpYWxcbiAgICAgICAgLy8gcGF0dGVybiBzdHJpbmdzLCBvciBcIioqXCIuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEl0J3MgYmV0dGVyIHRvIHVzZSAubWF0Y2goKS4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkbid0XG4gICAgICAgIC8vIGJlIHVzZWQsIHJlYWxseSwgYnV0IGl0J3MgcHJldHR5IGNvbnZlbmllbnQgc29tZXRpbWVzLFxuICAgICAgICAvLyB3aGVuIHlvdSBqdXN0IHdhbnQgdG8gd29yayB3aXRoIGEgcmVnZXguXG4gICAgICAgIGNvbnN0IHNldCA9IHRoaXMuc2V0O1xuICAgICAgICBpZiAoIXNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVnZXhwID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdleHA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgdHdvU3RhciA9IG9wdGlvbnMubm9nbG9ic3RhclxuICAgICAgICAgICAgPyBzdGFyXG4gICAgICAgICAgICA6IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgPyB0d29TdGFyRG90XG4gICAgICAgICAgICAgICAgOiB0d29TdGFyTm9Eb3Q7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gbmV3IFNldChvcHRpb25zLm5vY2FzZSA/IFsnaSddIDogW10pO1xuICAgICAgICAvLyByZWdleHBpZnkgbm9uLWdsb2JzdGFyIHBhdHRlcm5zXG4gICAgICAgIC8vIGlmICoqIGlzIG9ubHkgaXRlbSwgdGhlbiB3ZSBqdXN0IGRvIG9uZSB0d29TdGFyXG4gICAgICAgIC8vIGlmICoqIGlzIGZpcnN0LCBhbmQgdGhlcmUgYXJlIG1vcmUsIHByZXBlbmQgKFxcL3x0d29TdGFyXFwvKT8gdG8gbmV4dFxuICAgICAgICAvLyBpZiAqKiBpcyBsYXN0LCBhcHBlbmQgKFxcL3R3b1N0YXJ8KSB0byBwcmV2aW91c1xuICAgICAgICAvLyBpZiAqKiBpcyBpbiB0aGUgbWlkZGxlLCBhcHBlbmQgKFxcL3xcXC90d29TdGFyXFwvKSB0byBwcmV2aW91c1xuICAgICAgICAvLyB0aGVuIGZpbHRlciBvdXQgR0xPQlNUQVIgc3ltYm9sc1xuICAgICAgICBsZXQgcmUgPSBzZXRcbiAgICAgICAgICAgIC5tYXAocGF0dGVybiA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcCA9IHBhdHRlcm4ubWFwKHAgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZiBvZiBwLmZsYWdzLnNwbGl0KCcnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzLmFkZChmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBwID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHJlZ0V4cEVzY2FwZShwKVxuICAgICAgICAgICAgICAgICAgICA6IHAgPT09IEdMT0JTVEFSXG4gICAgICAgICAgICAgICAgICAgICAgICA/IEdMT0JTVEFSXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHAuX3NyYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHAuZm9yRWFjaCgocCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBwcFtpICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IHBwW2kgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAocCAhPT0gR0xPQlNUQVIgfHwgcHJldiA9PT0gR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgbmV4dCAhPT0gR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBwW2kgKyAxXSA9ICcoPzpcXFxcL3wnICsgdHdvU3RhciArICdcXFxcLyk/JyArIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcFtpXSA9IHR3b1N0YXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBwW2kgLSAxXSA9IHByZXYgKyAnKD86XFxcXC98JyArIHR3b1N0YXIgKyAnKT8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ICE9PSBHTE9CU1RBUikge1xuICAgICAgICAgICAgICAgICAgICBwcFtpIC0gMV0gPSBwcmV2ICsgJyg/OlxcXFwvfFxcXFwvJyArIHR3b1N0YXIgKyAnXFxcXC8pJyArIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHBwW2kgKyAxXSA9IEdMT0JTVEFSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBwLmZpbHRlcihwID0+IHAgIT09IEdMT0JTVEFSKS5qb2luKCcvJyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignfCcpO1xuICAgICAgICAvLyBuZWVkIHRvIHdyYXAgaW4gcGFyZW5zIGlmIHdlIGhhZCBtb3JlIHRoYW4gb25lIHRoaW5nIHdpdGggfCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIG9ubHkgdGhlIGZpcnN0IHdpbGwgYmUgYW5jaG9yZWQgdG8gXiBhbmQgdGhlIGxhc3QgdG8gJFxuICAgICAgICBjb25zdCBbb3BlbiwgY2xvc2VdID0gc2V0Lmxlbmd0aCA+IDEgPyBbJyg/OicsICcpJ10gOiBbJycsICcnXTtcbiAgICAgICAgLy8gbXVzdCBtYXRjaCBlbnRpcmUgcGF0dGVyblxuICAgICAgICAvLyBlbmRpbmcgaW4gYSAqIG9yICoqIHdpbGwgbWFrZSBpdCBsZXNzIHN0cmljdC5cbiAgICAgICAgcmUgPSAnXicgKyBvcGVuICsgcmUgKyBjbG9zZSArICckJztcbiAgICAgICAgLy8gY2FuIG1hdGNoIGFueXRoaW5nLCBhcyBsb25nIGFzIGl0J3Mgbm90IHRoaXMuXG4gICAgICAgIGlmICh0aGlzLm5lZ2F0ZSlcbiAgICAgICAgICAgIHJlID0gJ14oPyEnICsgcmUgKyAnKS4rJCc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2V4cCA9IG5ldyBSZWdFeHAocmUsIFsuLi5mbGFnc10uam9pbignJykpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgaW1wb3NzaWJsZVxuICAgICAgICAgICAgdGhpcy5yZWdleHAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdleHA7XG4gICAgfVxuICAgIHNsYXNoU3BsaXQocCkge1xuICAgICAgICAvLyBpZiBwIHN0YXJ0cyB3aXRoIC8vIG9uIHdpbmRvd3MsIHdlIHByZXNlcnZlIHRoYXRcbiAgICAgICAgLy8gc28gdGhhdCBVTkMgcGF0aHMgYXJlbid0IGJyb2tlbi4gIE90aGVyd2lzZSwgYW55IG51bWJlciBvZlxuICAgICAgICAvLyAvIGNoYXJhY3RlcnMgYXJlIGNvYWxlc2NlZCBpbnRvIG9uZSwgdW5sZXNzXG4gICAgICAgIC8vIHByZXNlcnZlTXVsdGlwbGVTbGFzaGVzIGlzIHNldCB0byB0cnVlLlxuICAgICAgICBpZiAodGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIHAuc3BsaXQoJy8nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzV2luZG93cyAmJiAvXlxcL1xcL1teXFwvXSsvLnRlc3QocCkpIHtcbiAgICAgICAgICAgIC8vIGFkZCBhbiBleHRyYSAnJyBmb3IgdGhlIG9uZSB3ZSBsb3NlXG4gICAgICAgICAgICByZXR1cm4gWycnLCAuLi5wLnNwbGl0KC9cXC8rLyldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHAuc3BsaXQoL1xcLysvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaChmLCBwYXJ0aWFsID0gdGhpcy5wYXJ0aWFsKSB7XG4gICAgICAgIHRoaXMuZGVidWcoJ21hdGNoJywgZiwgdGhpcy5wYXR0ZXJuKTtcbiAgICAgICAgLy8gc2hvcnQtY2lyY3VpdCBpbiB0aGUgY2FzZSBvZiBidXN0ZWQgdGhpbmdzLlxuICAgICAgICAvLyBjb21tZW50cywgZXRjLlxuICAgICAgICBpZiAodGhpcy5jb21tZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmID09PSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZiA9PT0gJy8nICYmIHBhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8vIHdpbmRvd3M6IG5lZWQgdG8gdXNlIC8sIG5vdCBcXFxuICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MpIHtcbiAgICAgICAgICAgIGYgPSBmLnNwbGl0KCdcXFxcJykuam9pbignLycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyZWF0IHRoZSB0ZXN0IHBhdGggYXMgYSBzZXQgb2YgcGF0aHBhcnRzLlxuICAgICAgICBjb25zdCBmZiA9IHRoaXMuc2xhc2hTcGxpdChmKTtcbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzcGxpdCcsIGZmKTtcbiAgICAgICAgLy8ganVzdCBPTkUgb2YgdGhlIHBhdHRlcm4gc2V0cyBpbiB0aGlzLnNldCBuZWVkcyB0byBtYXRjaFxuICAgICAgICAvLyBpbiBvcmRlciBmb3IgaXQgdG8gYmUgdmFsaWQuICBJZiBuZWdhdGluZywgdGhlbiBqdXN0IG9uZVxuICAgICAgICAvLyBtYXRjaCBtZWFucyB0aGF0IHdlIGhhdmUgZmFpbGVkLlxuICAgICAgICAvLyBFaXRoZXIgd2F5LCByZXR1cm4gb24gdGhlIGZpcnN0IGhpdC5cbiAgICAgICAgY29uc3Qgc2V0ID0gdGhpcy5zZXQ7XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCAnc2V0Jywgc2V0KTtcbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZW5hbWUgb2YgdGhlIHBhdGggYnkgbG9va2luZyBmb3IgdGhlIGxhc3Qgbm9uLWVtcHR5IHNlZ21lbnRcbiAgICAgICAgbGV0IGZpbGVuYW1lID0gZmZbZmYubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmZi5sZW5ndGggLSAyOyAhZmlsZW5hbWUgJiYgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IGZmW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gc2V0W2ldO1xuICAgICAgICAgICAgbGV0IGZpbGUgPSBmZjtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGZpbGUgPSBbZmlsZW5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGl0ID0gdGhpcy5tYXRjaE9uZShmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKTtcbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMubmVnYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGhpdHMuICB0aGlzIGlzIHN1Y2Nlc3MgaWYgaXQncyBhIG5lZ2F0aXZlXG4gICAgICAgIC8vIHBhdHRlcm4sIGZhaWx1cmUgb3RoZXJ3aXNlLlxuICAgICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdHMoZGVmKSB7XG4gICAgICAgIHJldHVybiBtaW5pbWF0Y2guZGVmYXVsdHMoZGVmKS5NaW5pbWF0Y2g7XG4gICAgfVxufVxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5leHBvcnQgeyBBU1QgfSBmcm9tICcuL2FzdC5qcyc7XG5leHBvcnQgeyBlc2NhcGUgfSBmcm9tICcuL2VzY2FwZS5qcyc7XG5leHBvcnQgeyB1bmVzY2FwZSB9IGZyb20gJy4vdW5lc2NhcGUuanMnO1xuLyogYzggaWdub3JlIHN0b3AgKi9cbm1pbmltYXRjaC5BU1QgPSBBU1Q7XG5taW5pbWF0Y2guTWluaW1hdGNoID0gTWluaW1hdGNoO1xubWluaW1hdGNoLmVzY2FwZSA9IGVzY2FwZTtcbm1pbmltYXRjaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbImV4cGFuZCIsImFzc2VydFZhbGlkUGF0dGVybiIsIkFTVCIsImVzY2FwZSIsInVuZXNjYXBlIiwibWluaW1hdGNoIiwicCIsInBhdHRlcm4iLCJvcHRpb25zIiwibm9jb21tZW50IiwiY2hhckF0IiwiTWluaW1hdGNoIiwibWF0Y2giLCJzdGFyRG90RXh0UkUiLCJzdGFyRG90RXh0VGVzdCIsImV4dCIsImYiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJzdGFyRG90RXh0VGVzdERvdCIsInN0YXJEb3RFeHRUZXN0Tm9jYXNlIiwidG9Mb3dlckNhc2UiLCJzdGFyRG90RXh0VGVzdE5vY2FzZURvdCIsInN0YXJEb3RTdGFyUkUiLCJzdGFyRG90U3RhclRlc3QiLCJpbmNsdWRlcyIsInN0YXJEb3RTdGFyVGVzdERvdCIsImRvdFN0YXJSRSIsImRvdFN0YXJUZXN0Iiwic3RhclJFIiwic3RhclRlc3QiLCJsZW5ndGgiLCJzdGFyVGVzdERvdCIsInFtYXJrc1JFIiwicW1hcmtzVGVzdE5vY2FzZSIsIiQwIiwibm9leHQiLCJxbWFya3NUZXN0Tm9FeHQiLCJxbWFya3NUZXN0Tm9jYXNlRG90IiwicW1hcmtzVGVzdE5vRXh0RG90IiwicW1hcmtzVGVzdERvdCIsInFtYXJrc1Rlc3QiLCJsZW4iLCJkZWZhdWx0UGxhdGZvcm0iLCJwcm9jZXNzIiwiZW52IiwiX19NSU5JTUFUQ0hfVEVTVElOR19QTEFURk9STV9fIiwicGxhdGZvcm0iLCJwYXRoIiwid2luMzIiLCJzZXAiLCJwb3NpeCIsIkdMT0JTVEFSIiwiU3ltYm9sIiwicW1hcmsiLCJzdGFyIiwidHdvU3RhckRvdCIsInR3b1N0YXJOb0RvdCIsImZpbHRlciIsImEiLCJiIiwiT2JqZWN0IiwiYXNzaWduIiwiZGVmYXVsdHMiLCJkZWYiLCJrZXlzIiwib3JpZyIsIm0iLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJwYXJlbnQiLCJmcm9tR2xvYiIsInMiLCJtYWtlUmUiLCJicmFjZUV4cGFuZCIsImxpc3QiLCJub2JyYWNlIiwidGVzdCIsIm1tIiwibm9udWxsIiwicHVzaCIsImdsb2JNYWdpYyIsInJlZ0V4cEVzY2FwZSIsInJlcGxhY2UiLCJpc1dpbmRvd3MiLCJ3aW5kb3dzUGF0aHNOb0VzY2FwZSIsImFsbG93V2luZG93c0VzY2FwZSIsInByZXNlcnZlTXVsdGlwbGVTbGFzaGVzIiwicmVnZXhwIiwibmVnYXRlIiwibm9uZWdhdGUiLCJjb21tZW50IiwiZW1wdHkiLCJwYXJ0aWFsIiwibm9jYXNlIiwid2luZG93c05vTWFnaWNSb290IiwidW5kZWZpbmVkIiwiZ2xvYlNldCIsImdsb2JQYXJ0cyIsInNldCIsIm1ha2UiLCJoYXNNYWdpYyIsIm1hZ2ljYWxCcmFjZXMiLCJwYXJ0IiwiZGVidWciLCJfIiwicGFyc2VOZWdhdGUiLCJTZXQiLCJhcmdzIiwiY29uc29sZSIsImVycm9yIiwicmF3R2xvYlBhcnRzIiwibWFwIiwic2xhc2hTcGxpdCIsInByZXByb2Nlc3MiLCJfXyIsImlzVU5DIiwiaXNEcml2ZSIsInNsaWNlIiwic3MiLCJwYXJzZSIsImluZGV4T2YiLCJpIiwibm9nbG9ic3RhciIsImoiLCJvcHRpbWl6YXRpb25MZXZlbCIsImZpcnN0UGhhc2VQcmVQcm9jZXNzIiwic2Vjb25kUGhhc2VQcmVQcm9jZXNzIiwibGV2ZWxPbmVPcHRpbWl6ZSIsImFkamFzY2VudEdsb2JzdGFyT3B0aW1pemUiLCJwYXJ0cyIsImdzIiwic3BsaWNlIiwicmVkdWNlIiwicHJldiIsInBvcCIsImxldmVsVHdvRmlsZU9wdGltaXplIiwiQXJyYXkiLCJpc0FycmF5IiwiZGlkU29tZXRoaW5nIiwiZGQiLCJnc3MiLCJuZXh0IiwicDIiLCJvdGhlciIsIm5lZWREb3QiLCJzcGxpbiIsIm1hdGNoZWQiLCJwYXJ0c01hdGNoIiwiZW1wdHlHU01hdGNoIiwiYWkiLCJiaSIsInJlc3VsdCIsIndoaWNoIiwiZG90IiwibmVnYXRlT2Zmc2V0IiwibWF0Y2hPbmUiLCJmaWxlIiwiZmlsZURyaXZlIiwiZmlsZVVOQyIsInBhdHRlcm5Ecml2ZSIsInBhdHRlcm5VTkMiLCJmZGkiLCJwZGkiLCJmZCIsInBkIiwiZmkiLCJwaSIsImZsIiwicGwiLCJmciIsInByIiwic3dhbGxvd2VlIiwiaGl0IiwiRXJyb3IiLCJmYXN0VGVzdCIsInJlIiwidG9NTVBhdHRlcm4iLCJ0d29TdGFyIiwiZmxhZ3MiLCJwcCIsIlJlZ0V4cCIsInNwbGl0IiwiYWRkIiwiX3NyYyIsImZvckVhY2giLCJqb2luIiwib3BlbiIsImNsb3NlIiwiZXgiLCJmZiIsImZpbGVuYW1lIiwibWF0Y2hCYXNlIiwiZmxpcE5lZ2F0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/dist/mjs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/minimatch/dist/mjs/unescape.js":
/*!*****************************************************!*\
  !*** ./node_modules/minimatch/dist/mjs/unescape.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unescape: () => (/* binding */ unescape)\n/* harmony export */ });\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */ const unescape = (s, { windowsPathsNoEscape = false } = {})=>{\n    return windowsPathsNoEscape ? s.replace(/\\[([^\\/\\\\])\\]/g, \"$1\") : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, \"$1$2\").replace(/\\\\([^\\/])/g, \"$1\");\n}; //# sourceMappingURL=unescape.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvbWpzL3VuZXNjYXBlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sTUFBTUEsV0FBVyxDQUFDQyxHQUFHLEVBQUVDLHVCQUF1QixLQUFLLEVBQUcsR0FBRyxDQUFDLENBQUM7SUFDOUQsT0FBT0EsdUJBQ0RELEVBQUVFLE9BQU8sQ0FBQyxrQkFBa0IsUUFDNUJGLEVBQUVFLE9BQU8sQ0FBQyw2QkFBNkIsUUFBUUEsT0FBTyxDQUFDLGNBQWM7QUFDL0UsRUFBRSxDQUNGLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BrZXlzdGF0aWMvdGVtcGxhdGVzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9tanMvdW5lc2NhcGUuanM/ZGE4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVuLWVzY2FwZSBhIHN0cmluZyB0aGF0IGhhcyBiZWVuIGVzY2FwZWQgd2l0aCB7QGxpbmsgZXNjYXBlfS5cbiAqXG4gKiBJZiB0aGUge0BsaW5rIHdpbmRvd3NQYXRoc05vRXNjYXBlfSBvcHRpb24gaXMgdXNlZCwgdGhlbiBzcXVhcmUtYnJhY2VcbiAqIGVzY2FwZXMgYXJlIHJlbW92ZWQsIGJ1dCBub3QgYmFja3NsYXNoIGVzY2FwZXMuICBGb3IgZXhhbXBsZSwgaXQgd2lsbCB0dXJuXG4gKiB0aGUgc3RyaW5nIGAnWypdJ2AgaW50byBgKmAsIGJ1dCBpdCB3aWxsIG5vdCB0dXJuIGAnXFxcXConYCBpbnRvIGAnKidgLFxuICogYmVjdWFzZSBgXFxgIGlzIGEgcGF0aCBzZXBhcmF0b3IgaW4gYHdpbmRvd3NQYXRoc05vRXNjYXBlYCBtb2RlLlxuICpcbiAqIFdoZW4gYHdpbmRvd3NQYXRoc05vRXNjYXBlYCBpcyBub3Qgc2V0LCB0aGVuIGJvdGggYnJhY2UgZXNjYXBlcyBhbmRcbiAqIGJhY2tzbGFzaCBlc2NhcGVzIGFyZSByZW1vdmVkLlxuICpcbiAqIFNsYXNoZXMgKGFuZCBiYWNrc2xhc2hlcyBpbiBgd2luZG93c1BhdGhzTm9Fc2NhcGVgIG1vZGUpIGNhbm5vdCBiZSBlc2NhcGVkXG4gKiBvciB1bmVzY2FwZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB1bmVzY2FwZSA9IChzLCB7IHdpbmRvd3NQYXRoc05vRXNjYXBlID0gZmFsc2UsIH0gPSB7fSkgPT4ge1xuICAgIHJldHVybiB3aW5kb3dzUGF0aHNOb0VzY2FwZVxuICAgICAgICA/IHMucmVwbGFjZSgvXFxbKFteXFwvXFxcXF0pXFxdL2csICckMScpXG4gICAgICAgIDogcy5yZXBsYWNlKC8oKD8hXFxcXCkufF4pXFxbKFteXFwvXFxcXF0pXFxdL2csICckMSQyJykucmVwbGFjZSgvXFxcXChbXlxcL10pL2csICckMScpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuZXNjYXBlLmpzLm1hcCJdLCJuYW1lcyI6WyJ1bmVzY2FwZSIsInMiLCJ3aW5kb3dzUGF0aHNOb0VzY2FwZSIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/dist/mjs/unescape.js\n");

/***/ })

};
;