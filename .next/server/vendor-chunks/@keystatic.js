"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@keystatic";
exports.ids = ["vendor-chunks/@keystatic"];
exports.modules = {

/***/ "(rsc)/./node_modules/@keystatic/core/dist/api-bcef1679.node.react-server.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@keystatic/core/dist/api-bcef1679.node.react-server.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ component)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-04c3e71f.node.react-server.js */ \"(rsc)/./node_modules/@keystatic/core/dist/index-04c3e71f.node.react-server.js\");\n/* harmony import */ var emery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! emery */ \"(rsc)/./node_modules/emery/dist/emery.esm.js\");\n/* harmony import */ var decimal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.mjs\");\n/* harmony import */ var _sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sindresorhus/slugify */ \"(rsc)/./node_modules/@sindresorhus/slugify/index.js\");\n/* harmony import */ var _braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @braintree/sanitize-url */ \"(rsc)/./node_modules/@braintree/sanitize-url/dist/index.js\");\n\n\n\n\n\n\n// this is written like this rather than ArrayField<ComponentSchema> to avoid TypeScript erroring about circularity\nfunction component(options) {\n    return options;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3QvYXBpLWJjZWYxNjc5Lm5vZGUucmVhY3Qtc2VydmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMkI7QUFDb0I7QUFDaEM7QUFDSztBQUNXO0FBQ0U7QUFFakMsbUhBQW1IO0FBQ25ILFNBQVNBLFVBQVVDLE9BQU87SUFDeEIsT0FBT0E7QUFDVDtBQUUwQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BrZXlzdGF0aWMvdGVtcGxhdGVzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9Aa2V5c3RhdGljL2NvcmUvZGlzdC9hcGktYmNlZjE2Nzkubm9kZS5yZWFjdC1zZXJ2ZXIuanM/NTNjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCAnLi9pbmRleC0wNGMzZTcxZi5ub2RlLnJlYWN0LXNlcnZlci5qcyc7XG5pbXBvcnQgJ2VtZXJ5JztcbmltcG9ydCAnZGVjaW1hbC5qcyc7XG5pbXBvcnQgJ0BzaW5kcmVzb3JodXMvc2x1Z2lmeSc7XG5pbXBvcnQgJ0BicmFpbnRyZWUvc2FuaXRpemUtdXJsJztcblxuLy8gdGhpcyBpcyB3cml0dGVuIGxpa2UgdGhpcyByYXRoZXIgdGhhbiBBcnJheUZpZWxkPENvbXBvbmVudFNjaGVtYT4gdG8gYXZvaWQgVHlwZVNjcmlwdCBlcnJvcmluZyBhYm91dCBjaXJjdWxhcml0eVxuZnVuY3Rpb24gY29tcG9uZW50KG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmV4cG9ydCB7IGNvbXBvbmVudCBhcyBjIH07XG4iXSwibmFtZXMiOlsiY29tcG9uZW50Iiwib3B0aW9ucyIsImMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@keystatic/core/dist/api-bcef1679.node.react-server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@keystatic/core/dist/error-formatting-ec352252.node.react-server.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@keystatic/core/dist/error-formatting-ec352252.node.react-server.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   P: () => (/* binding */ PropValidationError),\n/* harmony export */   f: () => (/* binding */ formatFormDataError),\n/* harmony export */   l: () => (/* binding */ loadDataFile),\n/* harmony export */   p: () => (/* binding */ parseProps),\n/* harmony export */   t: () => (/* binding */ toFormattedFormDataError),\n/* harmony export */   v: () => (/* binding */ validateArrayLength)\n/* harmony export */ });\n/* harmony import */ var emery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! emery */ \"(rsc)/./node_modules/emery/dist/emery.esm.js\");\n/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-yaml */ \"(rsc)/./node_modules/js-yaml/dist/js-yaml.mjs\");\n/* harmony import */ var _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-04c3e71f.node.react-server.js */ \"(rsc)/./node_modules/@keystatic/core/dist/index-04c3e71f.node.react-server.js\");\n\n\n\nfunction validateArrayLength(schema, val, path) {\n    var _schema$validation, _schema$validation2;\n    if (((_schema$validation = schema.validation) === null || _schema$validation === void 0 || (_schema$validation = _schema$validation.length) === null || _schema$validation === void 0 ? void 0 : _schema$validation.min) !== undefined && val.length < schema.validation.length.min) {\n        return new PropValidationError(new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(`Must have at least ${schema.validation.length.min} element${schema.validation.length.min === 1 ? \"\" : \"s\"}`), path, schema);\n    }\n    if (((_schema$validation2 = schema.validation) === null || _schema$validation2 === void 0 || (_schema$validation2 = _schema$validation2.length) === null || _schema$validation2 === void 0 ? void 0 : _schema$validation2.max) !== undefined && val.length > schema.validation.length.max) {\n        return new PropValidationError(new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(`Must have at most ${schema.validation.length.max} element${schema.validation.length.max === 1 ? \"\" : \"s\"}}`), path, schema);\n    }\n}\nclass PropValidationError extends Error {\n    constructor(cause, path, schema){\n        super(`field error at ${path.join(\".\")}`, {\n            cause\n        });\n        this.path = path;\n        this.schema = schema;\n        this.cause = cause;\n    }\n}\nfunction toFormFieldStoredValue(val) {\n    if (val === null) {\n        return undefined;\n    }\n    return val;\n}\nconst isArray = Array.isArray;\nfunction parseProps(schema, _value, path, pathWithArrayFieldSlugs, parseFormField, /** This should be true for the reader and false elsewhere */ validateArrayFieldLength) {\n    let value = toFormFieldStoredValue(_value);\n    if (schema.kind === \"form\") {\n        try {\n            return parseFormField(schema, value, path, pathWithArrayFieldSlugs);\n        } catch (err) {\n            throw new PropValidationError(err, path, schema);\n        }\n    }\n    if (schema.kind === \"child\") {\n        return null;\n    }\n    if (schema.kind === \"conditional\") {\n        if (value === undefined) {\n            return (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.D)(schema);\n        }\n        try {\n            if (typeof value !== \"object\" || value === null || isArray(value)) {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be an object\");\n            }\n            for (const key of Object.keys(value)){\n                if (key !== \"discriminant\" && key !== \"value\") {\n                    throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(`Must only contain keys \"discriminant\" and \"value\", not \"${key}\"`);\n                }\n            }\n        } catch (err) {\n            throw new PropValidationError(err, path, schema);\n        }\n        const parsedDiscriminant = parseProps(schema.discriminant, value.discriminant, path.concat(\"discriminant\"), pathWithArrayFieldSlugs.concat(\"discriminant\"), parseFormField, validateArrayFieldLength);\n        return {\n            discriminant: parsedDiscriminant,\n            value: parseProps(schema.values[parsedDiscriminant], value.value, path.concat(\"value\"), pathWithArrayFieldSlugs.concat(\"value\"), parseFormField, validateArrayFieldLength)\n        };\n    }\n    if (schema.kind === \"object\") {\n        if (value === undefined) {\n            value = {};\n        }\n        try {\n            if (typeof value !== \"object\" || value === null || isArray(value)) {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be an object\");\n            }\n            const allowedKeysSet = new Set(Object.keys(schema.fields));\n            for (const key of Object.keys(value)){\n                if (!allowedKeysSet.has(key)) {\n                    throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(`Key on object value \"${key}\" is not allowed`);\n                }\n            }\n        } catch (err) {\n            throw new PropValidationError(err, path, schema);\n        }\n        const val = {};\n        const errors = [];\n        for (const key of Object.keys(schema.fields)){\n            let individualVal = value[key];\n            try {\n                const propVal = parseProps(schema.fields[key], individualVal, path.concat(key), pathWithArrayFieldSlugs.concat(key), parseFormField, validateArrayFieldLength);\n                val[key] = propVal;\n            } catch (err) {\n                errors.push(err);\n            }\n        }\n        if (errors.length) {\n            throw new AggregateError(errors);\n        }\n        return val;\n    }\n    if (schema.kind === \"array\") {\n        if (value === undefined) {\n            return [];\n        }\n        try {\n            if (!isArray(value)) {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be an array\");\n            }\n        } catch (err) {\n            throw new PropValidationError(err, path, schema);\n        }\n        const errors = [];\n        try {\n            if (validateArrayFieldLength) {\n                const error = validateArrayLength(schema, value, path);\n                if (error !== undefined) {\n                    errors.push(error);\n                }\n            }\n            return value.map((innerVal, i)=>{\n                try {\n                    let slug = i.toString();\n                    if (schema.slugField && typeof innerVal === \"object\" && innerVal !== null && !isArray(innerVal)) {\n                        if (schema.element.kind !== \"object\") {\n                            throw new Error(\"slugField on array fields requires the an object field element\");\n                        }\n                        const slugField = schema.element.fields[schema.slugField];\n                        if (!slugField) {\n                            throw new Error(`slugField \"${schema.slugField}\" does not exist on object field`);\n                        }\n                        if (slugField.kind !== \"form\") {\n                            throw new Error(`slugField \"${schema.slugField}\" is not a form field`);\n                        }\n                        if (slugField.formKind !== \"slug\") {\n                            throw new Error(`slugField \"${schema.slugField}\" is not a slug field`);\n                        }\n                        let parsedSlugFieldValue;\n                        try {\n                            parsedSlugFieldValue = slugField.parse(toFormFieldStoredValue(innerVal[schema.slugField]), undefined);\n                        } catch (err) {\n                            throw new AggregateError([\n                                err\n                            ]);\n                        }\n                        slug = slugField.serializeWithSlug(parsedSlugFieldValue).slug;\n                    }\n                    return parseProps(schema.element, innerVal, path.concat(i), pathWithArrayFieldSlugs.concat(slug), parseFormField, validateArrayFieldLength);\n                } catch (err) {\n                    errors.push(err);\n                }\n            });\n        } finally{\n            if (errors.length) {\n                throw new AggregateError(errors);\n            }\n        }\n    }\n    (0,emery__WEBPACK_IMPORTED_MODULE_0__.assertNever)(schema);\n}\nconst textDecoder = new TextDecoder();\nconst textEncoder = new TextEncoder();\nfunction splitFrontmatter(data) {\n    const str = textDecoder.decode(data);\n    const match = str.match(/^---(?:\\r?\\n([^]*?))?\\r?\\n---\\r?\\n?/);\n    if (match) {\n        var _match$;\n        const encoded = textEncoder.encode(match[0]);\n        return {\n            frontmatter: (_match$ = match[1]) !== null && _match$ !== void 0 ? _match$ : \"\",\n            content: data.slice(encoded.byteLength)\n        };\n    }\n    return null;\n}\nfunction loadDataFile(data, formatInfo) {\n    const parse = formatInfo.data === \"json\" ? JSON.parse : js_yaml__WEBPACK_IMPORTED_MODULE_1__.load;\n    if (!formatInfo.contentField) {\n        const dataFile = textDecoder.decode(data);\n        return {\n            loaded: parse(dataFile)\n        };\n    }\n    const res = splitFrontmatter(data);\n    (0,emery__WEBPACK_IMPORTED_MODULE_0__.assert)(res !== null, \"frontmatter not found\");\n    return {\n        loaded: parse(res.frontmatter),\n        extraFakeFile: {\n            path: `${formatInfo.contentField.key}${formatInfo.contentField.config.contentExtension}`,\n            contents: res.content\n        }\n    };\n}\nfunction flattenErrors(error) {\n    if (error instanceof AggregateError) {\n        return error.errors.flatMap(flattenErrors);\n    }\n    return [\n        error\n    ];\n}\nfunction formatFormDataError(error) {\n    const flatErrors = flattenErrors(error);\n    return flatErrors.map((error)=>{\n        if (error instanceof PropValidationError) {\n            const path = error.path.join(\".\");\n            return `${path}: ${error.cause instanceof _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad ? error.cause.message : `Unexpected error: ${error.cause}`}`;\n        }\n        return `Unexpected error: ${error}`;\n    }).join(\"\\n\");\n}\nfunction toFormattedFormDataError(error) {\n    const formatted = formatFormDataError(error);\n    return new Error(`Field validation failed:\\n` + formatted);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3QvZXJyb3ItZm9ybWF0dGluZy1lYzM1MjI1Mi5ub2RlLnJlYWN0LXNlcnZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBNEM7QUFDYjtBQUN5RTtBQUV4RyxTQUFTTyxvQkFBb0JDLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxJQUFJO0lBQzVDLElBQUlDLG9CQUFvQkM7SUFDeEIsSUFBSSxDQUFDLENBQUNELHFCQUFxQkgsT0FBT0ssVUFBVSxNQUFNLFFBQVFGLHVCQUF1QixLQUFLLEtBQUssQ0FBQ0EscUJBQXFCQSxtQkFBbUJHLE1BQU0sTUFBTSxRQUFRSCx1QkFBdUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsbUJBQW1CSSxHQUFHLE1BQU1DLGFBQWFQLElBQUlLLE1BQU0sR0FBR04sT0FBT0ssVUFBVSxDQUFDQyxNQUFNLENBQUNDLEdBQUcsRUFBRTtRQUNuUixPQUFPLElBQUlFLG9CQUFvQixJQUFJYixvRUFBY0EsQ0FBQyxDQUFDLG1CQUFtQixFQUFFSSxPQUFPSyxVQUFVLENBQUNDLE1BQU0sQ0FBQ0MsR0FBRyxDQUFDLFFBQVEsRUFBRVAsT0FBT0ssVUFBVSxDQUFDQyxNQUFNLENBQUNDLEdBQUcsS0FBSyxJQUFJLEtBQUssSUFBSSxDQUFDLEdBQUdMLE1BQU1GO0lBQ3pLO0lBQ0EsSUFBSSxDQUFDLENBQUNJLHNCQUFzQkosT0FBT0ssVUFBVSxNQUFNLFFBQVFELHdCQUF3QixLQUFLLEtBQUssQ0FBQ0Esc0JBQXNCQSxvQkFBb0JFLE1BQU0sTUFBTSxRQUFRRix3QkFBd0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsb0JBQW9CTSxHQUFHLE1BQU1GLGFBQWFQLElBQUlLLE1BQU0sR0FBR04sT0FBT0ssVUFBVSxDQUFDQyxNQUFNLENBQUNJLEdBQUcsRUFBRTtRQUN6UixPQUFPLElBQUlELG9CQUFvQixJQUFJYixvRUFBY0EsQ0FBQyxDQUFDLGtCQUFrQixFQUFFSSxPQUFPSyxV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SUFDckIsT0FBTztRQUNMRCxRQUFRdkIsTUFBTXdCLElBQUlWLFdBQVc7UUFDN0JXLGVBQWU7WUFDYjNFLE1BQU0sQ0FBQyxFQUFFcUUsV0FBV0UsWUFBWSxDQUFDL0MsR0FBRyxDQUFDLEVBQUU2QyxXQUFXRSxZQUFZLENBQUNLLE1BQU0sQ0FBQ0MsZ0JBQWdCLENBQUMsQ0FBQztZQUN4RkMsVUFBVUosSUFBSVQsT0FBTztRQUN2QjtJQUNGO0FBQ0Y7QUFFQSxTQUFTYyxjQUFjdkMsS0FBSztJQUMxQixJQUFJQSxpQkFBaUJELGdCQUFnQjtRQUNuQyxPQUFPQyxNQUFNTCxNQUFNLENBQUM2QyxPQUFPLENBQUNEO0lBQzlCO0lBQ0EsT0FBTztRQUFDdkM7S0FBTTtBQUNoQjtBQUNBLFNBQVN5QyxvQkFBb0J6QyxLQUFLO0lBQ2hDLE1BQU0wQyxhQUFhSCxjQUFjdkM7SUFDakMsT0FBTzBDLFdBQVd6QyxHQUFHLENBQUNELENBQUFBO1FBQ3BCLElBQUlBLGlCQUFpQmpDLHFCQUFxQjtZQUN4QyxNQUFNUCxPQUFPd0MsTUFBTXhDLElBQUksQ0FBQ1ksSUFBSSxDQUFDO1lBQzdCLE9BQU8sQ0FBQyxFQUFFWixLQUFLLEVBQUUsRUFBRXdDLE1BQU03QixLQUFLLFlBQVlqQixvRUFBY0EsR0FBRzhDLE1BQU03QixLQUFLLENBQUN3RSxPQUFPLEdBQUcsQ0FBQyxrQkFBa0IsRUFBRTNDLE1BQU03QixLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkg7UUFDQSxPQUFPLENBQUMsa0JBQWtCLEVBQUU2QixNQUFNLENBQUM7SUFDckMsR0FBRzVCLElBQUksQ0FBQztBQUNWO0FBQ0EsU0FBU3dFLHlCQUF5QjVDLEtBQUs7SUFDckMsTUFBTTZDLFlBQVlKLG9CQUFvQnpDO0lBQ3RDLE9BQU8sSUFBSS9CLE1BQU0sQ0FBQywwQkFBMEIsQ0FBQyxHQUFHNEU7QUFDbEQ7QUFFMkoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Aa2V5c3RhdGljL3RlbXBsYXRlcy1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3QvZXJyb3ItZm9ybWF0dGluZy1lYzM1MjI1Mi5ub2RlLnJlYWN0LXNlcnZlci5qcz9lODIzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydE5ldmVyLCBhc3NlcnQgfSBmcm9tICdlbWVyeSc7XG5pbXBvcnQgeyBsb2FkIH0gZnJvbSAnanMteWFtbCc7XG5pbXBvcnQgeyBhZCBhcyBGaWVsZERhdGFFcnJvciwgRCBhcyBnZXRJbml0aWFsUHJvcHNWYWx1ZSB9IGZyb20gJy4vaW5kZXgtMDRjM2U3MWYubm9kZS5yZWFjdC1zZXJ2ZXIuanMnO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUFycmF5TGVuZ3RoKHNjaGVtYSwgdmFsLCBwYXRoKSB7XG4gIHZhciBfc2NoZW1hJHZhbGlkYXRpb24sIF9zY2hlbWEkdmFsaWRhdGlvbjI7XG4gIGlmICgoKF9zY2hlbWEkdmFsaWRhdGlvbiA9IHNjaGVtYS52YWxpZGF0aW9uKSA9PT0gbnVsbCB8fCBfc2NoZW1hJHZhbGlkYXRpb24gPT09IHZvaWQgMCB8fCAoX3NjaGVtYSR2YWxpZGF0aW9uID0gX3NjaGVtYSR2YWxpZGF0aW9uLmxlbmd0aCkgPT09IG51bGwgfHwgX3NjaGVtYSR2YWxpZGF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc2NoZW1hJHZhbGlkYXRpb24ubWluKSAhPT0gdW5kZWZpbmVkICYmIHZhbC5sZW5ndGggPCBzY2hlbWEudmFsaWRhdGlvbi5sZW5ndGgubWluKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9wVmFsaWRhdGlvbkVycm9yKG5ldyBGaWVsZERhdGFFcnJvcihgTXVzdCBoYXZlIGF0IGxlYXN0ICR7c2NoZW1hLnZhbGlkYXRpb24ubGVuZ3RoLm1pbn0gZWxlbWVudCR7c2NoZW1hLnZhbGlkYXRpb24ubGVuZ3RoLm1pbiA9PT0gMSA/ICcnIDogJ3MnfWApLCBwYXRoLCBzY2hlbWEpO1xuICB9XG4gIGlmICgoKF9zY2hlbWEkdmFsaWRhdGlvbjIgPSBzY2hlbWEudmFsaWRhdGlvbikgPT09IG51bGwgfHwgX3NjaGVtYSR2YWxpZGF0aW9uMiA9PT0gdm9pZCAwIHx8IChfc2NoZW1hJHZhbGlkYXRpb24yID0gX3NjaGVtYSR2YWxpZGF0aW9uMi5sZW5ndGgpID09PSBudWxsIHx8IF9zY2hlbWEkdmFsaWRhdGlvbjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zY2hlbWEkdmFsaWRhdGlvbjIubWF4KSAhPT0gdW5kZWZpbmVkICYmIHZhbC5sZW5ndGggPiBzY2hlbWEudmFsaWRhdGlvbi5sZW5ndGgubWF4KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9wVmFsaWRhdGlvbkVycm9yKG5ldyBGaWVsZERhdGFFcnJvcihgTXVzdCBoYXZlIGF0IG1vc3QgJHtzY2hlbWEudmFsaWRhdGlvbi5sZW5ndGgubWF4fSBlbGVtZW50JHtzY2hlbWEudmFsaWRhdGlvbi5sZW5ndGgubWF4ID09PSAxID8gJycgOiAncyd9fWApLCBwYXRoLCBzY2hlbWEpO1xuICB9XG59XG5cbmNsYXNzIFByb3BWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBwYXRoLCBzY2hlbWEpIHtcbiAgICBzdXBlcihgZmllbGQgZXJyb3IgYXQgJHtwYXRoLmpvaW4oJy4nKX1gLCB7XG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICB9XG59XG5mdW5jdGlvbiB0b0Zvcm1GaWVsZFN0b3JlZFZhbHVlKHZhbCkge1xuICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5mdW5jdGlvbiBwYXJzZVByb3BzKHNjaGVtYSwgX3ZhbHVlLCBwYXRoLCBwYXRoV2l0aEFycmF5RmllbGRTbHVncywgcGFyc2VGb3JtRmllbGQsIC8qKiBUaGlzIHNob3VsZCBiZSB0cnVlIGZvciB0aGUgcmVhZGVyIGFuZCBmYWxzZSBlbHNld2hlcmUgKi9cbnZhbGlkYXRlQXJyYXlGaWVsZExlbmd0aCkge1xuICBsZXQgdmFsdWUgPSB0b0Zvcm1GaWVsZFN0b3JlZFZhbHVlKF92YWx1ZSk7XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ2Zvcm0nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBwYXJzZUZvcm1GaWVsZChzY2hlbWEsIHZhbHVlLCBwYXRoLCBwYXRoV2l0aEFycmF5RmllbGRTbHVncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgUHJvcFZhbGlkYXRpb25FcnJvcihlcnIsIHBhdGgsIHNjaGVtYSk7XG4gICAgfVxuICB9XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ2NoaWxkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ2NvbmRpdGlvbmFsJykge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZ2V0SW5pdGlhbFByb3BzVmFsdWUoc2NoZW1hKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsIHx8IGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcignTXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlKSkge1xuICAgICAgICBpZiAoa2V5ICE9PSAnZGlzY3JpbWluYW50JyAmJiBrZXkgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoYE11c3Qgb25seSBjb250YWluIGtleXMgXCJkaXNjcmltaW5hbnRcIiBhbmQgXCJ2YWx1ZVwiLCBub3QgXCIke2tleX1cImApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgUHJvcFZhbGlkYXRpb25FcnJvcihlcnIsIHBhdGgsIHNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZERpc2NyaW1pbmFudCA9IHBhcnNlUHJvcHMoc2NoZW1hLmRpc2NyaW1pbmFudCwgdmFsdWUuZGlzY3JpbWluYW50LCBwYXRoLmNvbmNhdCgnZGlzY3JpbWluYW50JyksIHBhdGhXaXRoQXJyYXlGaWVsZFNsdWdzLmNvbmNhdCgnZGlzY3JpbWluYW50JyksIHBhcnNlRm9ybUZpZWxkLCB2YWxpZGF0ZUFycmF5RmllbGRMZW5ndGgpO1xuICAgIHJldHVybiB7XG4gICAgICBkaXNjcmltaW5hbnQ6IHBhcnNlZERpc2NyaW1pbmFudCxcbiAgICAgIHZhbHVlOiBwYXJzZVByb3BzKHNjaGVtYS52YWx1ZXNbcGFyc2VkRGlzY3JpbWluYW50XSwgdmFsdWUudmFsdWUsIHBhdGguY29uY2F0KCd2YWx1ZScpLCBwYXRoV2l0aEFycmF5RmllbGRTbHVncy5jb25jYXQoJ3ZhbHVlJyksIHBhcnNlRm9ybUZpZWxkLCB2YWxpZGF0ZUFycmF5RmllbGRMZW5ndGgpXG4gICAgfTtcbiAgfVxuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0ge307XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCB8fCBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ011c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgICBjb25zdCBhbGxvd2VkS2V5c1NldCA9IG5ldyBTZXQoT2JqZWN0LmtleXMoc2NoZW1hLmZpZWxkcykpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsdWUpKSB7XG4gICAgICAgIGlmICghYWxsb3dlZEtleXNTZXQuaGFzKGtleSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoYEtleSBvbiBvYmplY3QgdmFsdWUgXCIke2tleX1cIiBpcyBub3QgYWxsb3dlZGApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgUHJvcFZhbGlkYXRpb25FcnJvcihlcnIsIHBhdGgsIHNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IHZhbCA9IHt9O1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYS5maWVsZHMpKSB7XG4gICAgICBsZXQgaW5kaXZpZHVhbFZhbCA9IHZhbHVlW2tleV07XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwcm9wVmFsID0gcGFyc2VQcm9wcyhzY2hlbWEuZmllbGRzW2tleV0sIGluZGl2aWR1YWxWYWwsIHBhdGguY29uY2F0KGtleSksIHBhdGhXaXRoQXJyYXlGaWVsZFNsdWdzLmNvbmNhdChrZXkpLCBwYXJzZUZvcm1GaWVsZCwgdmFsaWRhdGVBcnJheUZpZWxkTGVuZ3RoKTtcbiAgICAgICAgdmFsW2tleV0gPSBwcm9wVmFsO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgQWdncmVnYXRlRXJyb3IoZXJyb3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdhcnJheScpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKCFpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ011c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBQcm9wVmFsaWRhdGlvbkVycm9yKGVyciwgcGF0aCwgc2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGlmICh2YWxpZGF0ZUFycmF5RmllbGRMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB2YWxpZGF0ZUFycmF5TGVuZ3RoKHNjaGVtYSwgdmFsdWUsIHBhdGgpO1xuICAgICAgICBpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlLm1hcCgoaW5uZXJWYWwsIGkpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgc2x1ZyA9IGkudG9TdHJpbmcoKTtcbiAgICAgICAgICBpZiAoc2NoZW1hLnNsdWdGaWVsZCAmJiB0eXBlb2YgaW5uZXJWYWwgPT09ICdvYmplY3QnICYmIGlubmVyVmFsICE9PSBudWxsICYmICFpc0FycmF5KGlubmVyVmFsKSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5lbGVtZW50LmtpbmQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2x1Z0ZpZWxkIG9uIGFycmF5IGZpZWxkcyByZXF1aXJlcyB0aGUgYW4gb2JqZWN0IGZpZWxkIGVsZW1lbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNsdWdGaWVsZCA9IHNjaGVtYS5lbGVtZW50LmZpZWxkc1tzY2hlbWEuc2x1Z0ZpZWxkXTtcbiAgICAgICAgICAgIGlmICghc2x1Z0ZpZWxkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2x1Z0ZpZWxkIFwiJHtzY2hlbWEuc2x1Z0ZpZWxkfVwiIGRvZXMgbm90IGV4aXN0IG9uIG9iamVjdCBmaWVsZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNsdWdGaWVsZC5raW5kICE9PSAnZm9ybScpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzbHVnRmllbGQgXCIke3NjaGVtYS5zbHVnRmllbGR9XCIgaXMgbm90IGEgZm9ybSBmaWVsZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNsdWdGaWVsZC5mb3JtS2luZCAhPT0gJ3NsdWcnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2x1Z0ZpZWxkIFwiJHtzY2hlbWEuc2x1Z0ZpZWxkfVwiIGlzIG5vdCBhIHNsdWcgZmllbGRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXJzZWRTbHVnRmllbGRWYWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBhcnNlZFNsdWdGaWVsZFZhbHVlID0gc2x1Z0ZpZWxkLnBhcnNlKHRvRm9ybUZpZWxkU3RvcmVkVmFsdWUoaW5uZXJWYWxbc2NoZW1hLnNsdWdGaWVsZF0pLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBBZ2dyZWdhdGVFcnJvcihbZXJyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzbHVnID0gc2x1Z0ZpZWxkLnNlcmlhbGl6ZVdpdGhTbHVnKHBhcnNlZFNsdWdGaWVsZFZhbHVlKS5zbHVnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGFyc2VQcm9wcyhzY2hlbWEuZWxlbWVudCwgaW5uZXJWYWwsIHBhdGguY29uY2F0KGkpLCBwYXRoV2l0aEFycmF5RmllbGRTbHVncy5jb25jYXQoc2x1ZyksIHBhcnNlRm9ybUZpZWxkLCB2YWxpZGF0ZUFycmF5RmllbGRMZW5ndGgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFnZ3JlZ2F0ZUVycm9yKGVycm9ycyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzc2VydE5ldmVyKHNjaGVtYSk7XG59XG5cbmNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5jb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuZnVuY3Rpb24gc3BsaXRGcm9udG1hdHRlcihkYXRhKSB7XG4gIGNvbnN0IHN0ciA9IHRleHREZWNvZGVyLmRlY29kZShkYXRhKTtcbiAgY29uc3QgbWF0Y2ggPSBzdHIubWF0Y2goL14tLS0oPzpcXHI/XFxuKFteXSo/KSk/XFxyP1xcbi0tLVxccj9cXG4/Lyk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciBfbWF0Y2gkO1xuICAgIGNvbnN0IGVuY29kZWQgPSB0ZXh0RW5jb2Rlci5lbmNvZGUobWF0Y2hbMF0pO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9udG1hdHRlcjogKF9tYXRjaCQgPSBtYXRjaFsxXSkgIT09IG51bGwgJiYgX21hdGNoJCAhPT0gdm9pZCAwID8gX21hdGNoJCA6ICcnLFxuICAgICAgY29udGVudDogZGF0YS5zbGljZShlbmNvZGVkLmJ5dGVMZW5ndGgpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGxvYWREYXRhRmlsZShkYXRhLCBmb3JtYXRJbmZvKSB7XG4gIGNvbnN0IHBhcnNlID0gZm9ybWF0SW5mby5kYXRhID09PSAnanNvbicgPyBKU09OLnBhcnNlIDogbG9hZDtcbiAgaWYgKCFmb3JtYXRJbmZvLmNvbnRlbnRGaWVsZCkge1xuICAgIGNvbnN0IGRhdGFGaWxlID0gdGV4dERlY29kZXIuZGVjb2RlKGRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBsb2FkZWQ6IHBhcnNlKGRhdGFGaWxlKVxuICAgIH07XG4gIH1cbiAgY29uc3QgcmVzID0gc3BsaXRGcm9udG1hdHRlcihkYXRhKTtcbiAgYXNzZXJ0KHJlcyAhPT0gbnVsbCwgJ2Zyb250bWF0dGVyIG5vdCBmb3VuZCcpO1xuICByZXR1cm4ge1xuICAgIGxvYWRlZDogcGFyc2UocmVzLmZyb250bWF0dGVyKSxcbiAgICBleHRyYUZha2VGaWxlOiB7XG4gICAgICBwYXRoOiBgJHtmb3JtYXRJbmZvLmNvbnRlbnRGaWVsZC5rZXl9JHtmb3JtYXRJbmZvLmNvbnRlbnRGaWVsZC5jb25maWcuY29udGVudEV4dGVuc2lvbn1gLFxuICAgICAgY29udGVudHM6IHJlcy5jb250ZW50XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuRXJyb3JzKGVycm9yKSB7XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEFnZ3JlZ2F0ZUVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLmVycm9ycy5mbGF0TWFwKGZsYXR0ZW5FcnJvcnMpO1xuICB9XG4gIHJldHVybiBbZXJyb3JdO1xufVxuZnVuY3Rpb24gZm9ybWF0Rm9ybURhdGFFcnJvcihlcnJvcikge1xuICBjb25zdCBmbGF0RXJyb3JzID0gZmxhdHRlbkVycm9ycyhlcnJvcik7XG4gIHJldHVybiBmbGF0RXJyb3JzLm1hcChlcnJvciA9PiB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUHJvcFZhbGlkYXRpb25FcnJvcikge1xuICAgICAgY29uc3QgcGF0aCA9IGVycm9yLnBhdGguam9pbignLicpO1xuICAgICAgcmV0dXJuIGAke3BhdGh9OiAke2Vycm9yLmNhdXNlIGluc3RhbmNlb2YgRmllbGREYXRhRXJyb3IgPyBlcnJvci5jYXVzZS5tZXNzYWdlIDogYFVuZXhwZWN0ZWQgZXJyb3I6ICR7ZXJyb3IuY2F1c2V9YH1gO1xuICAgIH1cbiAgICByZXR1cm4gYFVuZXhwZWN0ZWQgZXJyb3I6ICR7ZXJyb3J9YDtcbiAgfSkuam9pbignXFxuJyk7XG59XG5mdW5jdGlvbiB0b0Zvcm1hdHRlZEZvcm1EYXRhRXJyb3IoZXJyb3IpIHtcbiAgY29uc3QgZm9ybWF0dGVkID0gZm9ybWF0Rm9ybURhdGFFcnJvcihlcnJvcik7XG4gIHJldHVybiBuZXcgRXJyb3IoYEZpZWxkIHZhbGlkYXRpb24gZmFpbGVkOlxcbmAgKyBmb3JtYXR0ZWQpO1xufVxuXG5leHBvcnQgeyBQcm9wVmFsaWRhdGlvbkVycm9yIGFzIFAsIGZvcm1hdEZvcm1EYXRhRXJyb3IgYXMgZiwgbG9hZERhdGFGaWxlIGFzIGwsIHBhcnNlUHJvcHMgYXMgcCwgdG9Gb3JtYXR0ZWRGb3JtRGF0YUVycm9yIGFzIHQsIHZhbGlkYXRlQXJyYXlMZW5ndGggYXMgdiB9O1xuIl0sIm5hbWVzIjpbImFzc2VydE5ldmVyIiwiYXNzZXJ0IiwibG9hZCIsImFkIiwiRmllbGREYXRhRXJyb3IiLCJEIiwiZ2V0SW5pdGlhbFByb3BzVmFsdWUiLCJ2YWxpZGF0ZUFycmF5TGVuZ3RoIiwic2NoZW1hIiwidmFsIiwicGF0aCIsIl9zY2hlbWEkdmFsaWRhdGlvbiIsIl9zY2hlbWEkdmFsaWRhdGlvbjIiLCJ2YWxpZGF0aW9uIiwibGVuZ3RoIiwibWluIiwidW5kZWZpbmVkIiwiUHJvcFZhbGlkYXRpb25FcnJvciIsIm1heCIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjYXVzZSIsImpvaW4iLCJ0b0Zvcm1GaWVsZFN0b3JlZFZhbHVlIiwiaXNBcnJheSIsIkFycmF5IiwicGFyc2VQcm9wcyIsIl92YWx1ZSIsInBhdGhXaXRoQXJyYXlGaWVsZFNsdWdzIiwicGFyc2VGb3JtRmllbGQiLCJ2YWxpZGF0ZUFycmF5RmllbGRMZW5ndGgiLCJ2YWx1ZSIsImtpbmQiLCJlcnIiLCJrZXkiLCJPYmplY3QiLCJrZXlzIiwicGFyc2VkRGlzY3JpbWluYW50IiwiZGlzY3JpbWluYW50IiwiY29uY2F0IiwidmFsdWVzIiwiYWxsb3dlZEtleXNTZXQiLCJTZXQiLCJmaWVsZHMiLCJoYXMiLCJlcnJvcnMiLCJpbmRpdmlkdWFsVmFsIiwicHJvcFZhbCIsInB1c2giLCJBZ2dyZWdhdGVFcnJvciIsImVycm9yIiwibWFwIiwiaW5uZXJWYWwiLCJpIiwic2x1ZyIsInRvU3RyaW5nIiwic2x1Z0ZpZWxkIiwiZWxlbWVudCIsImZvcm1LaW5kIiwicGFyc2VkU2x1Z0ZpZWxkVmFsdWUiLCJwYXJzZSIsInNlcmlhbGl6ZVdpdGhTbHVnIiwidGV4dERlY29kZXIiLCJUZXh0RGVjb2RlciIsInRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJzcGxpdEZyb250bWF0dGVyIiwiZGF0YSIsInN0ciIsImRlY29kZSIsIm1hdGNoIiwiX21hdGNoJCIsImVuY29kZWQiLCJlbmNvZGUiLCJmcm9udG1hdHRlciIsImNvbnRlbnQiLCJzbGljZSIsImJ5dGVMZW5ndGgiLCJsb2FkRGF0YUZpbGUiLCJmb3JtYXRJbmZvIiwiSlNPTiIsImNvbnRlbnRGaWVsZCIsImRhdGFGaWxlIiwibG9hZGVkIiwicmVzIiwiZXh0cmFGYWtlRmlsZSIsImNvbmZpZyIsImNvbnRlbnRFeHRlbnNpb24iLCJjb250ZW50cyIsImZsYXR0ZW5FcnJvcnMiLCJmbGF0TWFwIiwiZm9ybWF0Rm9ybURhdGFFcnJvciIsImZsYXRFcnJvcnMiLCJtZXNzYWdlIiwidG9Gb3JtYXR0ZWRGb3JtRGF0YUVycm9yIiwiZm9ybWF0dGVkIiwiUCIsImYiLCJsIiwicCIsInQiLCJ2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@keystatic/core/dist/error-formatting-ec352252.node.react-server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@keystatic/core/dist/generic-0a163b6b.node.react-server.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@keystatic/core/dist/generic-0a163b6b.node.react-server.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_6___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ cache),\n/* harmony export */   c: () => (/* binding */ collectionReader),\n/* harmony export */   s: () => (/* binding */ singletonReader)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-04c3e71f.node.react-server.js */ \"(rsc)/./node_modules/@keystatic/core/dist/index-04c3e71f.node.react-server.js\");\n/* harmony import */ var decimal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.mjs\");\n/* harmony import */ var _sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sindresorhus/slugify */ \"(rsc)/./node_modules/@sindresorhus/slugify/index.js\");\n/* harmony import */ var _braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @braintree/sanitize-url */ \"(rsc)/./node_modules/@braintree/sanitize-url/dist/index.js\");\n/* harmony import */ var _error_formatting_ec352252_node_react_server_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./error-formatting-ec352252.node.react-server.js */ \"(rsc)/./node_modules/@keystatic/core/dist/error-formatting-ec352252.node.react-server.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n\n\n\n\n\n\n\nfunction cache$1(func) {\n    return func;\n}\n// we conditionally using it since it's not actually in stable react releases yet\n// (though it should be unnecessary since this file is only imported in react-server environments anyway)\n// it's a function because some tools try to be smart with accessing things on namespace imports\n// and error at build time if you try to read an export that doesn't exist on a namespace object\nfunction getCache(react) {\n    var _react$cache;\n    return (_react$cache = react.cache) !== null && _react$cache !== void 0 ? _react$cache : cache$1;\n}\nconst cache = getCache(/*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_6___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_6___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_6__, 2))));\nasync function getAllEntries(parent, fsReader) {\n    return (await Promise.all((await fsReader.readdir(parent)).map(async (dirent)=>{\n        const name = `${parent}${dirent.name}`;\n        const entry = {\n            entry: dirent,\n            name\n        };\n        if (dirent.kind === \"directory\") {\n            return [\n                entry,\n                ...await getAllEntries(`${name}/`, fsReader)\n            ];\n        }\n        return entry;\n    }))).flat();\n}\nconst listCollection = cache(async function listCollection(collectionPath, glob, formatInfo, extension, fsReader) {\n    const entries = glob === \"*\" ? (await fsReader.readdir(collectionPath)).map((entry)=>({\n            entry,\n            name: entry.name\n        })) : (await getAllEntries(`${collectionPath}/`, fsReader)).map((x)=>({\n            entry: x.entry,\n            name: x.name.slice(collectionPath.length + 1)\n        }));\n    return (await Promise.all(entries.map(async (x)=>{\n        if (formatInfo.dataLocation === \"index\") {\n            if (x.entry.kind !== \"directory\") return [];\n            if (!await fsReader.fileExists((0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_1__.m)(`${collectionPath}/${x.name}`, formatInfo))) {\n                return [];\n            }\n            return [\n                x.name\n            ];\n        } else {\n            if (x.entry.kind !== \"file\" || !x.name.endsWith(extension)) {\n                return [];\n            }\n            return [\n                x.name.slice(0, -extension.length)\n            ];\n        }\n    }))).flat();\n});\nfunction collectionReader(collection, config, fsReader) {\n    const formatInfo = (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_1__.w)(config, collection);\n    const collectionPath = (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_1__.v)(config, collection);\n    const collectionConfig = config.collections[collection];\n    const schema = (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_1__.o)(collectionConfig.schema);\n    const glob = (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_1__.y)(config, collection);\n    const extension = (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_1__.aa)(formatInfo);\n    const read = (slug, ...args)=>{\n        var _args$;\n        return readItem(schema, formatInfo, (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_1__.x)(config, collection, slug), (_args$ = args[0]) === null || _args$ === void 0 ? void 0 : _args$.resolveLinkedFiles, `\"${slug}\" in collection \"${collection}\"`, fsReader, slug, collectionConfig.slugField, glob);\n    };\n    const list = ()=>listCollection(collectionPath, glob, formatInfo, extension, fsReader);\n    return {\n        read,\n        readOrThrow: async (...args)=>{\n            const entry = await read(...args);\n            if (entry === null) {\n                throw new Error(`Entry \"${args[0]}\" not found in collection \"${collection}\"`);\n            }\n            return entry;\n        },\n        // TODO: this could drop the fs.stat call that list does for each item\n        // since we just immediately read it\n        all: async (...args)=>{\n            const slugs = await list();\n            return (await Promise.all(slugs.map(async (slug)=>{\n                const entry = await read(slug, args[0]);\n                if (entry === null) return [];\n                return [\n                    {\n                        slug,\n                        entry\n                    }\n                ];\n            }))).flat();\n        },\n        list\n    };\n}\nconst readItem = cache(async function readItem(rootSchema, formatInfo, itemDir, resolveLinkedFiles, debugReference, fsReader, ...slugInfo) {\n    const dataFile = await fsReader.readFile((0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_1__.m)(itemDir, formatInfo));\n    if (dataFile === null) return null;\n    const { loaded, extraFakeFile } = (0,_error_formatting_ec352252_node_react_server_js__WEBPACK_IMPORTED_MODULE_5__.l)(dataFile, formatInfo);\n    const contentFieldPathsToEagerlyResolve = resolveLinkedFiles ? [] : undefined;\n    let validated;\n    try {\n        validated = (0,_error_formatting_ec352252_node_react_server_js__WEBPACK_IMPORTED_MODULE_5__.p)(rootSchema, loaded, [], [], (schema, value, path, pathWithArrayFieldSlugs)=>{\n            if (schema.formKind === \"asset\") {\n                return schema.reader.parse(value);\n            }\n            if (schema.formKind === \"content\") {\n                contentFieldPathsToEagerlyResolve === null || contentFieldPathsToEagerlyResolve === void 0 || contentFieldPathsToEagerlyResolve.push(path);\n                return async ()=>{\n                    let content;\n                    const filename = pathWithArrayFieldSlugs.join(\"/\") + schema.contentExtension;\n                    if (filename === (extraFakeFile === null || extraFakeFile === void 0 ? void 0 : extraFakeFile.path)) {\n                        content = extraFakeFile.contents;\n                    } else {\n                        var _await$fsReader$readF;\n                        content = (_await$fsReader$readF = await fsReader.readFile(`${itemDir}/${filename}`)) !== null && _await$fsReader$readF !== void 0 ? _await$fsReader$readF : undefined;\n                    }\n                    return schema.reader.parse(value, {\n                        content\n                    });\n                };\n            }\n            if (path.length === 1 && slugInfo[0] !== undefined) {\n                const [slug, slugField, glob] = slugInfo;\n                if (path[0] === slugField) {\n                    if (schema.formKind !== \"slug\") {\n                        throw new Error(`Slug field ${slugInfo[1]} is not a slug field`);\n                    }\n                    return schema.reader.parseWithSlug(value, {\n                        slug,\n                        glob\n                    });\n                }\n            }\n            return schema.reader.parse(value);\n        }, true);\n        if (contentFieldPathsToEagerlyResolve !== null && contentFieldPathsToEagerlyResolve !== void 0 && contentFieldPathsToEagerlyResolve.length) {\n            await Promise.all(contentFieldPathsToEagerlyResolve.map(async (path)=>{\n                const parentValue = (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_1__.R)(validated, path.slice(0, -1));\n                const keyOnParent = path[path.length - 1];\n                const originalValue = parentValue[keyOnParent];\n                parentValue[keyOnParent] = await originalValue();\n            }));\n        }\n    } catch (err) {\n        const formatted = (0,_error_formatting_ec352252_node_react_server_js__WEBPACK_IMPORTED_MODULE_5__.f)(err);\n        throw new Error(`Invalid data for ${debugReference}:\\n${formatted}`);\n    }\n    return validated;\n});\nfunction singletonReader(singleton, config, fsReader) {\n    const formatInfo = (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_1__.ab)(config, singleton);\n    const singletonPath = (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_1__.c)(config, singleton);\n    const schema = (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_1__.o)(config.singletons[singleton].schema);\n    const read = (...args)=>{\n        var _args$2;\n        return readItem(schema, formatInfo, singletonPath, (_args$2 = args[0]) === null || _args$2 === void 0 ? void 0 : _args$2.resolveLinkedFiles, `singleton \"${singleton}\"`, fsReader, undefined);\n    };\n    return {\n        read,\n        readOrThrow: async (...opts)=>{\n            const entry = await read(...opts);\n            if (entry === null) {\n                throw new Error(`Singleton \"${singleton}\" not found`);\n            }\n            return entry;\n        }\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3QvZ2VuZXJpYy0wYTE2M2I2Yi5ub2RlLnJlYWN0LXNlcnZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEyQjtBQUN1UjtBQUM5UjtBQUNXO0FBQ0U7QUFDK0Y7QUFDakc7QUFFL0IsU0FBUzJCLFFBQVFDLElBQUk7SUFDbkIsT0FBT0E7QUFDVDtBQUVBLGlGQUFpRjtBQUNqRix5R0FBeUc7QUFDekcsZ0dBQWdHO0FBQ2hHLGdHQUFnRztBQUNoRyxTQUFTQyxTQUFTQyxLQUFLO0lBQ3JCLElBQUlDO0lBQ0osT0FBTyxDQUFDQSxlQUFlRCxNQUFNRSxLQUFLLE1BQU0sUUFBUUQsaUJBQWlCLEtBQUssSUFBSUEsZUFBZUo7QUFDM0Y7QUFDQSxNQUFNSyxRQUFRSCxTQUFTSCx5TEFBS0E7QUFFNUIsZUFBZU8sY0FBY0MsTUFBTSxFQUFFQyxRQUFRO0lBQzNDLE9BQU8sQ0FBQyxNQUFNQyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxNQUFNRixTQUFTRyxPQUFPLENBQUNKLE9BQU0sRUFBR0ssR0FBRyxDQUFDLE9BQU1DO1FBQ25FLE1BQU1DLE9BQU8sQ0FBQyxFQUFFUCxPQUFPLEVBQUVNLE9BQU9DLElBQUksQ0FBQyxDQUFDO1FBQ3RDLE1BQU1DLFFBQVE7WUFDWkEsT0FBT0Y7WUFDUEM7UUFDRjtRQUNBLElBQUlELE9BQU9HLElBQUksS0FBSyxhQUFhO1lBQy9CLE9BQU87Z0JBQUNEO21CQUFXLE1BQU1ULGNBQWMsQ0FBQyxFQUFFUSxLQUFLLENBQUMsQ0FBQyxFQUFFTjthQUFXO1FBQ2hFO1FBQ0EsT0FBT087SUFDVCxHQUFFLEVBQUdFLElBQUk7QUFDWDtBQUNBLE1BQU1DLGlCQUFpQmIsTUFBTSxlQUFlYSxlQUFlQyxjQUFjLEVBQUVDLElBQUksRUFBRUMsVUFBVSxFQUFFQyxTQUFTLEVBQUVkLFFBQVE7SUFDOUcsTUFBTWUsVUFBVUgsU0FBUyxNQUFNLENBQUMsTUFBTVosU0FB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QGtleXN0YXRpYy9jb3JlL2Rpc3QvZ2VuZXJpYy0wYTE2M2I2Yi5ub2RlLnJlYWN0LXNlcnZlci5qcz9jZDFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgbSBhcyBnZXRFbnRyeURhdGFGaWxlcGF0aCwgUiBhcyBnZXRWYWx1ZUF0UHJvcFBhdGgsIHcgYXMgZ2V0Q29sbGVjdGlvbkZvcm1hdCwgdiBhcyBnZXRDb2xsZWN0aW9uUGF0aCwgbyBhcyBvYmplY3QsIHkgYXMgZ2V0U2x1Z0dsb2JGb3JDb2xsZWN0aW9uLCBhYSBhcyBnZXREYXRhRmlsZUV4dGVuc2lvbiwgYWIgYXMgZ2V0U2luZ2xldG9uRm9ybWF0LCBjIGFzIGdldFNpbmdsZXRvblBhdGgsIHggYXMgZ2V0Q29sbGVjdGlvbkl0ZW1QYXRoIH0gZnJvbSAnLi9pbmRleC0wNGMzZTcxZi5ub2RlLnJlYWN0LXNlcnZlci5qcyc7XG5pbXBvcnQgJ2RlY2ltYWwuanMnO1xuaW1wb3J0ICdAc2luZHJlc29yaHVzL3NsdWdpZnknO1xuaW1wb3J0ICdAYnJhaW50cmVlL3Nhbml0aXplLXVybCc7XG5pbXBvcnQgeyBsIGFzIGxvYWREYXRhRmlsZSwgcCBhcyBwYXJzZVByb3BzLCBmIGFzIGZvcm1hdEZvcm1EYXRhRXJyb3IgfSBmcm9tICcuL2Vycm9yLWZvcm1hdHRpbmctZWMzNTIyNTIubm9kZS5yZWFjdC1zZXJ2ZXIuanMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiBjYWNoZSQxKGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmM7XG59XG5cbi8vIHdlIGNvbmRpdGlvbmFsbHkgdXNpbmcgaXQgc2luY2UgaXQncyBub3QgYWN0dWFsbHkgaW4gc3RhYmxlIHJlYWN0IHJlbGVhc2VzIHlldFxuLy8gKHRob3VnaCBpdCBzaG91bGQgYmUgdW5uZWNlc3Nhcnkgc2luY2UgdGhpcyBmaWxlIGlzIG9ubHkgaW1wb3J0ZWQgaW4gcmVhY3Qtc2VydmVyIGVudmlyb25tZW50cyBhbnl3YXkpXG4vLyBpdCdzIGEgZnVuY3Rpb24gYmVjYXVzZSBzb21lIHRvb2xzIHRyeSB0byBiZSBzbWFydCB3aXRoIGFjY2Vzc2luZyB0aGluZ3Mgb24gbmFtZXNwYWNlIGltcG9ydHNcbi8vIGFuZCBlcnJvciBhdCBidWlsZCB0aW1lIGlmIHlvdSB0cnkgdG8gcmVhZCBhbiBleHBvcnQgdGhhdCBkb2Vzbid0IGV4aXN0IG9uIGEgbmFtZXNwYWNlIG9iamVjdFxuZnVuY3Rpb24gZ2V0Q2FjaGUocmVhY3QpIHtcbiAgdmFyIF9yZWFjdCRjYWNoZTtcbiAgcmV0dXJuIChfcmVhY3QkY2FjaGUgPSByZWFjdC5jYWNoZSkgIT09IG51bGwgJiYgX3JlYWN0JGNhY2hlICE9PSB2b2lkIDAgPyBfcmVhY3QkY2FjaGUgOiBjYWNoZSQxO1xufVxuY29uc3QgY2FjaGUgPSBnZXRDYWNoZShSZWFjdCk7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEFsbEVudHJpZXMocGFyZW50LCBmc1JlYWRlcikge1xuICByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKChhd2FpdCBmc1JlYWRlci5yZWFkZGlyKHBhcmVudCkpLm1hcChhc3luYyBkaXJlbnQgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSBgJHtwYXJlbnR9JHtkaXJlbnQubmFtZX1gO1xuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgZW50cnk6IGRpcmVudCxcbiAgICAgIG5hbWVcbiAgICB9O1xuICAgIGlmIChkaXJlbnQua2luZCA9PT0gJ2RpcmVjdG9yeScpIHtcbiAgICAgIHJldHVybiBbZW50cnksIC4uLihhd2FpdCBnZXRBbGxFbnRyaWVzKGAke25hbWV9L2AsIGZzUmVhZGVyKSldO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnk7XG4gIH0pKSkuZmxhdCgpO1xufVxuY29uc3QgbGlzdENvbGxlY3Rpb24gPSBjYWNoZShhc3luYyBmdW5jdGlvbiBsaXN0Q29sbGVjdGlvbihjb2xsZWN0aW9uUGF0aCwgZ2xvYiwgZm9ybWF0SW5mbywgZXh0ZW5zaW9uLCBmc1JlYWRlcikge1xuICBjb25zdCBlbnRyaWVzID0gZ2xvYiA9PT0gJyonID8gKGF3YWl0IGZzUmVhZGVyLnJlYWRkaXIoY29sbGVjdGlvblBhdGgpKS5tYXAoZW50cnkgPT4gKHtcbiAgICBlbnRyeSxcbiAgICBuYW1lOiBlbnRyeS5uYW1lXG4gIH0pKSA6IChhd2FpdCBnZXRBbGxFbnRyaWVzKGAke2NvbGxlY3Rpb25QYXRofS9gLCBmc1JlYWRlcikpLm1hcCh4ID0+ICh7XG4gICAgZW50cnk6IHguZW50cnksXG4gICAgbmFtZTogeC5uYW1lLnNsaWNlKGNvbGxlY3Rpb25QYXRoLmxlbmd0aCArIDEpXG4gIH0pKTtcbiAgcmV0dXJuIChhd2FpdCBQcm9taXNlLmFsbChlbnRyaWVzLm1hcChhc3luYyB4ID0+IHtcbiAgICBpZiAoZm9ybWF0SW5mby5kYXRhTG9jYXRpb24gPT09ICdpbmRleCcpIHtcbiAgICAgIGlmICh4LmVudHJ5LmtpbmQgIT09ICdkaXJlY3RvcnknKSByZXR1cm4gW107XG4gICAgICBpZiAoIShhd2FpdCBmc1JlYWRlci5maWxlRXhpc3RzKGdldEVudHJ5RGF0YUZpbGVwYXRoKGAke2NvbGxlY3Rpb25QYXRofS8ke3gubmFtZX1gLCBmb3JtYXRJbmZvKSkpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbeC5uYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHguZW50cnkua2luZCAhPT0gJ2ZpbGUnIHx8ICF4Lm5hbWUuZW5kc1dpdGgoZXh0ZW5zaW9uKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gW3gubmFtZS5zbGljZSgwLCAtZXh0ZW5zaW9uLmxlbmd0aCldO1xuICAgIH1cbiAgfSkpKS5mbGF0KCk7XG59KTtcbmZ1bmN0aW9uIGNvbGxlY3Rpb25SZWFkZXIoY29sbGVjdGlvbiwgY29uZmlnLCBmc1JlYWRlcikge1xuICBjb25zdCBmb3JtYXRJbmZvID0gZ2V0Q29sbGVjdGlvbkZvcm1hdChjb25maWcsIGNvbGxlY3Rpb24pO1xuICBjb25zdCBjb2xsZWN0aW9uUGF0aCA9IGdldENvbGxlY3Rpb25QYXRoKGNvbmZpZywgY29sbGVjdGlvbik7XG4gIGNvbnN0IGNvbGxlY3Rpb25Db25maWcgPSBjb25maWcuY29sbGVjdGlvbnNbY29sbGVjdGlvbl07XG4gIGNvbnN0IHNjaGVtYSA9IG9iamVjdChjb2xsZWN0aW9uQ29uZmlnLnNjaGVtYSk7XG4gIGNvbnN0IGdsb2IgPSBnZXRTbHVnR2xvYkZvckNvbGxlY3Rpb24oY29uZmlnLCBjb2xsZWN0aW9uKTtcbiAgY29uc3QgZXh0ZW5zaW9uID0gZ2V0RGF0YUZpbGVFeHRlbnNpb24oZm9ybWF0SW5mbyk7XG4gIGNvbnN0IHJlYWQgPSAoc2x1ZywgLi4uYXJncykgPT4ge1xuICAgIHZhciBfYXJncyQ7XG4gICAgcmV0dXJuIHJlYWRJdGVtKHNjaGVtYSwgZm9ybWF0SW5mbywgZ2V0Q29sbGVjdGlvbkl0ZW1QYXRoKGNvbmZpZywgY29sbGVjdGlvbiwgc2x1ZyksIChfYXJncyQgPSBhcmdzWzBdKSA9PT0gbnVsbCB8fCBfYXJncyQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hcmdzJC5yZXNvbHZlTGlua2VkRmlsZXMsIGBcIiR7c2x1Z31cIiBpbiBjb2xsZWN0aW9uIFwiJHtjb2xsZWN0aW9ufVwiYCwgZnNSZWFkZXIsIHNsdWcsIGNvbGxlY3Rpb25Db25maWcuc2x1Z0ZpZWxkLCBnbG9iKTtcbiAgfTtcbiAgY29uc3QgbGlzdCA9ICgpID0+IGxpc3RDb2xsZWN0aW9uKGNvbGxlY3Rpb25QYXRoLCBnbG9iLCBmb3JtYXRJbmZvLCBleHRlbnNpb24sIGZzUmVhZGVyKTtcbiAgcmV0dXJuIHtcbiAgICByZWFkLFxuICAgIHJlYWRPclRocm93OiBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCByZWFkKC4uLmFyZ3MpO1xuICAgICAgaWYgKGVudHJ5ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRW50cnkgXCIke2FyZ3NbMF19XCIgbm90IGZvdW5kIGluIGNvbGxlY3Rpb24gXCIke2NvbGxlY3Rpb259XCJgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9LFxuICAgIC8vIFRPRE86IHRoaXMgY291bGQgZHJvcCB0aGUgZnMuc3RhdCBjYWxsIHRoYXQgbGlzdCBkb2VzIGZvciBlYWNoIGl0ZW1cbiAgICAvLyBzaW5jZSB3ZSBqdXN0IGltbWVkaWF0ZWx5IHJlYWQgaXRcbiAgICBhbGw6IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBzbHVncyA9IGF3YWl0IGxpc3QoKTtcbiAgICAgIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoc2x1Z3MubWFwKGFzeW5jIHNsdWcgPT4ge1xuICAgICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IHJlYWQoc2x1ZywgYXJnc1swXSk7XG4gICAgICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICBzbHVnLFxuICAgICAgICAgIGVudHJ5XG4gICAgICAgIH1dO1xuICAgICAgfSkpKS5mbGF0KCk7XG4gICAgfSxcbiAgICBsaXN0XG4gIH07XG59XG5jb25zdCByZWFkSXRlbSA9IGNhY2hlKGFzeW5jIGZ1bmN0aW9uIHJlYWRJdGVtKHJvb3RTY2hlbWEsIGZvcm1hdEluZm8sIGl0ZW1EaXIsIHJlc29sdmVMaW5rZWRGaWxlcywgZGVidWdSZWZlcmVuY2UsIGZzUmVhZGVyLCAuLi5zbHVnSW5mbykge1xuICBjb25zdCBkYXRhRmlsZSA9IGF3YWl0IGZzUmVhZGVyLnJlYWRGaWxlKGdldEVudHJ5RGF0YUZpbGVwYXRoKGl0ZW1EaXIsIGZvcm1hdEluZm8pKTtcbiAgaWYgKGRhdGFGaWxlID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgY29uc3Qge1xuICAgIGxvYWRlZCxcbiAgICBleHRyYUZha2VGaWxlXG4gIH0gPSBsb2FkRGF0YUZpbGUoZGF0YUZpbGUsIGZvcm1hdEluZm8pO1xuICBjb25zdCBjb250ZW50RmllbGRQYXRoc1RvRWFnZXJseVJlc29sdmUgPSByZXNvbHZlTGlua2VkRmlsZXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgbGV0IHZhbGlkYXRlZDtcbiAgdHJ5IHtcbiAgICB2YWxpZGF0ZWQgPSBwYXJzZVByb3BzKHJvb3RTY2hlbWEsIGxvYWRlZCwgW10sIFtdLCAoc2NoZW1hLCB2YWx1ZSwgcGF0aCwgcGF0aFdpdGhBcnJheUZpZWxkU2x1Z3MpID0+IHtcbiAgICAgIGlmIChzY2hlbWEuZm9ybUtpbmQgPT09ICdhc3NldCcpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5yZWFkZXIucGFyc2UodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHNjaGVtYS5mb3JtS2luZCA9PT0gJ2NvbnRlbnQnKSB7XG4gICAgICAgIGNvbnRlbnRGaWVsZFBhdGhzVG9FYWdlcmx5UmVzb2x2ZSA9PT0gbnVsbCB8fCBjb250ZW50RmllbGRQYXRoc1RvRWFnZXJseVJlc29sdmUgPT09IHZvaWQgMCB8fCBjb250ZW50RmllbGRQYXRoc1RvRWFnZXJseVJlc29sdmUucHVzaChwYXRoKTtcbiAgICAgICAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICAgICAgICBsZXQgY29udGVudDtcbiAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGhXaXRoQXJyYXlGaWVsZFNsdWdzLmpvaW4oJy8nKSArIHNjaGVtYS5jb250ZW50RXh0ZW5zaW9uO1xuICAgICAgICAgIGlmIChmaWxlbmFtZSA9PT0gKGV4dHJhRmFrZUZpbGUgPT09IG51bGwgfHwgZXh0cmFGYWtlRmlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXh0cmFGYWtlRmlsZS5wYXRoKSkge1xuICAgICAgICAgICAgY29udGVudCA9IGV4dHJhRmFrZUZpbGUuY29udGVudHM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfYXdhaXQkZnNSZWFkZXIkcmVhZEY7XG4gICAgICAgICAgICBjb250ZW50ID0gKF9hd2FpdCRmc1JlYWRlciRyZWFkRiA9IGF3YWl0IGZzUmVhZGVyLnJlYWRGaWxlKGAke2l0ZW1EaXJ9LyR7ZmlsZW5hbWV9YCkpICE9PSBudWxsICYmIF9hd2FpdCRmc1JlYWRlciRyZWFkRiAhPT0gdm9pZCAwID8gX2F3YWl0JGZzUmVhZGVyJHJlYWRGIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2NoZW1hLnJlYWRlci5wYXJzZSh2YWx1ZSwge1xuICAgICAgICAgICAgY29udGVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxICYmIHNsdWdJbmZvWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgW3NsdWcsIHNsdWdGaWVsZCwgZ2xvYl0gPSBzbHVnSW5mbztcbiAgICAgICAgaWYgKHBhdGhbMF0gPT09IHNsdWdGaWVsZCkge1xuICAgICAgICAgIGlmIChzY2hlbWEuZm9ybUtpbmQgIT09ICdzbHVnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTbHVnIGZpZWxkICR7c2x1Z0luZm9bMV19IGlzIG5vdCBhIHNsdWcgZmllbGRgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNjaGVtYS5yZWFkZXIucGFyc2VXaXRoU2x1Zyh2YWx1ZSwge1xuICAgICAgICAgICAgc2x1ZyxcbiAgICAgICAgICAgIGdsb2JcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYS5yZWFkZXIucGFyc2UodmFsdWUpO1xuICAgIH0sIHRydWUpO1xuICAgIGlmIChjb250ZW50RmllbGRQYXRoc1RvRWFnZXJseVJlc29sdmUgIT09IG51bGwgJiYgY29udGVudEZpZWxkUGF0aHNUb0VhZ2VybHlSZXNvbHZlICE9PSB2b2lkIDAgJiYgY29udGVudEZpZWxkUGF0aHNUb0VhZ2VybHlSZXNvbHZlLmxlbmd0aCkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY29udGVudEZpZWxkUGF0aHNUb0VhZ2VybHlSZXNvbHZlLm1hcChhc3luYyBwYXRoID0+IHtcbiAgICAgICAgY29uc3QgcGFyZW50VmFsdWUgPSBnZXRWYWx1ZUF0UHJvcFBhdGgodmFsaWRhdGVkLCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgICAgIGNvbnN0IGtleU9uUGFyZW50ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBvcmlnaW5hbFZhbHVlID0gcGFyZW50VmFsdWVba2V5T25QYXJlbnRdO1xuICAgICAgICBwYXJlbnRWYWx1ZVtrZXlPblBhcmVudF0gPSBhd2FpdCBvcmlnaW5hbFZhbHVlKCk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXRGb3JtRGF0YUVycm9yKGVycik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgZm9yICR7ZGVidWdSZWZlcmVuY2V9OlxcbiR7Zm9ybWF0dGVkfWApO1xuICB9XG4gIHJldHVybiB2YWxpZGF0ZWQ7XG59KTtcbmZ1bmN0aW9uIHNpbmdsZXRvblJlYWRlcihzaW5nbGV0b24sIGNvbmZpZywgZnNSZWFkZXIpIHtcbiAgY29uc3QgZm9ybWF0SW5mbyA9IGdldFNpbmdsZXRvbkZvcm1hdChjb25maWcsIHNpbmdsZXRvbik7XG4gIGNvbnN0IHNpbmdsZXRvblBhdGggPSBnZXRTaW5nbGV0b25QYXRoKGNvbmZpZywgc2luZ2xldG9uKTtcbiAgY29uc3Qgc2NoZW1hID0gb2JqZWN0KGNvbmZpZy5zaW5nbGV0b25zW3NpbmdsZXRvbl0uc2NoZW1hKTtcbiAgY29uc3QgcmVhZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgdmFyIF9hcmdzJDI7XG4gICAgcmV0dXJuIHJlYWRJdGVtKHNjaGVtYSwgZm9ybWF0SW5mbywgc2luZ2xldG9uUGF0aCwgKF9hcmdzJDIgPSBhcmdzWzBdKSA9PT0gbnVsbCB8fCBfYXJncyQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYXJncyQyLnJlc29sdmVMaW5rZWRGaWxlcywgYHNpbmdsZXRvbiBcIiR7c2luZ2xldG9ufVwiYCwgZnNSZWFkZXIsIHVuZGVmaW5lZCk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgcmVhZCxcbiAgICByZWFkT3JUaHJvdzogYXN5bmMgKC4uLm9wdHMpID0+IHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gYXdhaXQgcmVhZCguLi5vcHRzKTtcbiAgICAgIGlmIChlbnRyeSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpbmdsZXRvbiBcIiR7c2luZ2xldG9ufVwiIG5vdCBmb3VuZGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IHsgY2FjaGUgYXMgYSwgY29sbGVjdGlvblJlYWRlciBhcyBjLCBzaW5nbGV0b25SZWFkZXIgYXMgcyB9O1xuIl0sIm5hbWVzIjpbIm0iLCJnZXRFbnRyeURhdGFGaWxlcGF0aCIsIlIiLCJnZXRWYWx1ZUF0UHJvcFBhdGgiLCJ3IiwiZ2V0Q29sbGVjdGlvbkZvcm1hdCIsInYiLCJnZXRDb2xsZWN0aW9uUGF0aCIsIm8iLCJvYmplY3QiLCJ5IiwiZ2V0U2x1Z0dsb2JGb3JDb2xsZWN0aW9uIiwiYWEiLCJnZXREYXRhRmlsZUV4dGVuc2lvbiIsImFiIiwiZ2V0U2luZ2xldG9uRm9ybWF0IiwiYyIsImdldFNpbmdsZXRvblBhdGgiLCJ4IiwiZ2V0Q29sbGVjdGlvbkl0ZW1QYXRoIiwibCIsImxvYWREYXRhRmlsZSIsInAiLCJwYXJzZVByb3BzIiwiZiIsImZvcm1hdEZvcm1EYXRhRXJyb3IiLCJSZWFjdCIsImNhY2hlJDEiLCJmdW5jIiwiZ2V0Q2FjaGUiLCJyZWFjdCIsIl9yZWFjdCRjYWNoZSIsImNhY2hlIiwiZ2V0QWxsRW50cmllcyIsInBhcmVudCIsImZzUmVhZGVyIiwiUHJvbWlzZSIsImFsbCIsInJlYWRkaXIiLCJtYXAiLCJkaXJlbnQiLCJuYW1lIiwiZW50cnkiLCJraW5kIiwiZmxhdCIsImxpc3RDb2xsZWN0aW9uIiwiY29sbGVjdGlvblBhdGgiLCJnbG9iIiwiZm9ybWF0SW5mbyIsImV4dGVuc2lvbiIsImVudHJpZXMiLCJzbGljZSIsImxlbmd0aCIsImRhdGFMb2NhdGlvbiIsImZpbGVFeGlzdHMiLCJlbmRzV2l0aCIsImNvbGxlY3Rpb25SZWFkZXIiLCJjb2xsZWN0aW9uIiwiY29uZmlnIiwiY29sbGVjdGlvbkNvbmZpZyIsImNvbGxlY3Rpb25zIiwic2NoZW1hIiwicmVhZCIsInNsdWciLCJhcmdzIiwiX2FyZ3MkIiwicmVhZEl0ZW0iLCJyZXNvbHZlTGlua2VkRmlsZXMiLCJzbHVnRmllbGQiLCJsaXN0IiwicmVhZE9yVGhyb3ciLCJFcnJvciIsInNsdWdzIiwicm9vdFNjaGVtYSIsIml0ZW1EaXIiLCJkZWJ1Z1JlZmVyZW5jZSIsInNsdWdJbmZvIiwiZGF0YUZpbGUiLCJyZWFkRmlsZSIsImxvYWRlZCIsImV4dHJhRmFrZUZpbGUiLCJjb250ZW50RmllbGRQYXRoc1RvRWFnZXJseVJlc29sdmUiLCJ1bmRlZmluZWQiLCJ2YWxpZGF0ZWQiLCJ2YWx1ZSIsInBhdGgiLCJwYXRoV2l0aEFycmF5RmllbGRTbHVncyIsImZvcm1LaW5kIiwicmVhZGVyIiwicGFyc2UiLCJwdXNoIiwiY29udGVudCIsImZpbGVuYW1lIiwiam9pbiIsImNvbnRlbnRFeHRlbnNpb24iLCJjb250ZW50cyIsIl9hd2FpdCRmc1JlYWRlciRyZWFkRiIsInBhcnNlV2l0aFNsdWciLCJwYXJlbnRWYWx1ZSIsImtleU9uUGFyZW50Iiwib3JpZ2luYWxWYWx1ZSIsImVyciIsImZvcm1hdHRlZCIsInNpbmdsZXRvblJlYWRlciIsInNpbmdsZXRvbiIsInNpbmdsZXRvblBhdGgiLCJzaW5nbGV0b25zIiwiX2FyZ3MkMiIsIm9wdHMiLCJhIiwicyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@keystatic/core/dist/generic-0a163b6b.node.react-server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@keystatic/core/dist/index-04c3e71f.node.react-server.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@keystatic/core/dist/index-04c3e71f.node.react-server.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ getInlineNodes),\n/* harmony export */   A: () => (/* binding */ getKeysForArrayValue),\n/* harmony export */   B: () => (/* binding */ setKeysForArrayValue),\n/* harmony export */   C: () => (/* binding */ getSlugFromState),\n/* harmony export */   D: () => (/* binding */ getInitialPropsValue),\n/* harmony export */   E: () => (/* binding */ getAncestorComponentChildFieldDocumentFeatures),\n/* harmony export */   F: () => (/* binding */ isBlock),\n/* harmony export */   G: () => (/* binding */ allMarks),\n/* harmony export */   H: () => (/* binding */ isListNode),\n/* harmony export */   I: () => (/* binding */ isElementActive),\n/* harmony export */   J: () => (/* binding */ getInitialPropsValueFromInitializer),\n/* harmony export */   K: () => (/* binding */ KEYSTATIC_CLOUD_API_URL),\n/* harmony export */   L: () => (/* binding */ aliasesToLabel),\n/* harmony export */   M: () => (/* binding */ aliasesToCanonicalName),\n/* harmony export */   N: () => (/* binding */ canonicalNameToLabel),\n/* harmony export */   O: () => (/* binding */ labelToCanonicalName),\n/* harmony export */   P: () => (/* binding */ languagesWithAliases),\n/* harmony export */   Q: () => (/* binding */ transformProps),\n/* harmony export */   R: () => (/* binding */ getValueAtPropPath),\n/* harmony export */   S: () => (/* binding */ cloneDescendent),\n/* harmony export */   T: () => (/* binding */ areArraysEqual),\n/* harmony export */   U: () => (/* binding */ getSchemaAtPropPath),\n/* harmony export */   V: () => (/* binding */ findChildPropPaths),\n/* harmony export */   W: () => (/* binding */ getSelectedTableArea),\n/* harmony export */   X: () => (/* binding */ getRelativeRowPath),\n/* harmony export */   Y: () => (/* binding */ cell),\n/* harmony export */   Z: () => (/* binding */ clearFormatting),\n/* harmony export */   _: () => (/* binding */ EditorAfterButIgnoringingPointsWithNoContent),\n/* harmony export */   a: () => (/* binding */ KEYSTATIC_CLOUD_HEADERS),\n/* harmony export */   a0: () => (/* binding */ addMarksToChildren),\n/* harmony export */   a1: () => (/* binding */ setLinkForChildren),\n/* harmony export */   a2: () => (/* binding */ forceDisableMarkForChildren),\n/* harmony export */   a3: () => (/* binding */ addMarkToChildren),\n/* harmony export */   a4: () => (/* binding */ getPlaceholderTextForPropPath),\n/* harmony export */   a5: () => (/* binding */ Prism),\n/* harmony export */   a6: () => (/* binding */ _createDocumentEditor),\n/* harmony export */   a7: () => (/* binding */ getWholeDocumentFeaturesForChildField),\n/* harmony export */   a8: () => (/* binding */ serializeProps),\n/* harmony export */   a9: () => (/* binding */ updateTreeWithChanges),\n/* harmony export */   aA: () => (/* binding */ sha1),\n/* harmony export */   aB: () => (/* binding */ getDefaultValue),\n/* harmony export */   aC: () => (/* binding */ DocumentFieldInput),\n/* harmony export */   aD: () => (/* binding */ parseToEditorState),\n/* harmony export */   aE: () => (/* binding */ collectDirectoriesUsedInSchema),\n/* harmony export */   aF: () => (/* binding */ serializeFromEditorState),\n/* harmony export */   aG: () => (/* binding */ parseToEditorStateMDX),\n/* harmony export */   aH: () => (/* binding */ serializeFromEditorStateMDX),\n/* harmony export */   aI: () => (/* binding */ createEditorSchema),\n/* harmony export */   aa: () => (/* binding */ getDataFileExtension),\n/* harmony export */   ab: () => (/* binding */ getSingletonFormat),\n/* harmony export */   ac: () => (/* binding */ isCloudConfig),\n/* harmony export */   ad: () => (/* binding */ FieldDataError),\n/* harmony export */   ae: () => (/* binding */ basicFormFieldWithSimpleReaderParse),\n/* harmony export */   af: () => (/* binding */ CheckboxFieldInput),\n/* harmony export */   ag: () => (/* binding */ DateFieldInput),\n/* harmony export */   ah: () => (/* binding */ assertRequired),\n/* harmony export */   ai: () => (/* binding */ DatetimeFieldInput),\n/* harmony export */   aj: () => (/* binding */ ImageFieldInput),\n/* harmony export */   ak: () => (/* binding */ getSrcPrefix),\n/* harmony export */   al: () => (/* binding */ fixPath),\n/* harmony export */   am: () => (/* binding */ FileFieldInput),\n/* harmony export */   an: () => (/* binding */ NumberFieldInput),\n/* harmony export */   ao: () => (/* binding */ MultiselectFieldInput),\n/* harmony export */   ap: () => (/* binding */ PathReferenceInput),\n/* harmony export */   aq: () => (/* binding */ RelationshipInput),\n/* harmony export */   ar: () => (/* binding */ SelectFieldInput),\n/* harmony export */   as: () => (/* binding */ SlugFieldInput),\n/* harmony export */   at: () => (/* binding */ validateText),\n/* harmony export */   au: () => (/* binding */ UrlFieldInput),\n/* harmony export */   av: () => (/* binding */ BlocksFieldInput),\n/* harmony export */   aw: () => (/* binding */ text),\n/* harmony export */   ax: () => (/* binding */ CloudImageFieldInput),\n/* harmony export */   ay: () => (/* binding */ document$1),\n/* harmony export */   az: () => (/* binding */ IntegerFieldInput),\n/* harmony export */   b: () => (/* binding */ getEntriesInCollectionWithTreeKey),\n/* harmony export */   c: () => (/* binding */ getSingletonPath),\n/* harmony export */   d: () => (/* binding */ getTreeNodeAtPath),\n/* harmony export */   e: () => (/* binding */ treeSha),\n/* harmony export */   f: () => (/* binding */ treeToEntries),\n/* harmony export */   g: () => (/* binding */ getPathPrefix),\n/* harmony export */   h: () => (/* binding */ getBranchPrefix),\n/* harmony export */   i: () => (/* binding */ isGitHubConfig),\n/* harmony export */   j: () => (/* binding */ getSplitCloudProject),\n/* harmony export */   k: () => (/* binding */ getRepoUrl),\n/* harmony export */   l: () => (/* binding */ isLocalConfig),\n/* harmony export */   m: () => (/* binding */ getEntryDataFilepath),\n/* harmony export */   n: () => (/* binding */ nodeTypeMatcher),\n/* harmony export */   o: () => (/* binding */ object),\n/* harmony export */   p: () => (/* binding */ pluralize),\n/* harmony export */   q: () => (/* binding */ getDirectoriesForTreeKey),\n/* harmony export */   r: () => (/* binding */ redirectToCloudAuth),\n/* harmony export */   s: () => (/* binding */ getTreeKey),\n/* harmony export */   t: () => (/* binding */ treeEntriesToTreeNodes),\n/* harmony export */   u: () => (/* binding */ blobSha),\n/* harmony export */   v: () => (/* binding */ getCollectionPath),\n/* harmony export */   w: () => (/* binding */ getCollectionFormat),\n/* harmony export */   x: () => (/* binding */ getCollectionItemPath),\n/* harmony export */   y: () => (/* binding */ getSlugGlobForCollection),\n/* harmony export */   z: () => (/* binding */ updateValue)\n/* harmony export */ });\n/* harmony import */ var _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @markdoc/markdoc */ \"(rsc)/./node_modules/@markdoc/markdoc/dist/index.mjs\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! slate */ \"(rsc)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var emery_assertions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! emery/assertions */ \"(rsc)/./node_modules/emery/assertions/dist/emery-assertions.esm.js\");\n/* harmony import */ var emery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! emery */ \"(rsc)/./node_modules/emery/dist/emery.esm.js\");\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! js-base64 */ \"(rsc)/./node_modules/js-base64/base64.mjs\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var _emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @emotion/weak-memoize */ \"(rsc)/./node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js\");\n\n\n\n\n\n\n\n\nfunction fixPath(path) {\n    return path.replace(/^\\.?\\/+/, \"\").replace(/\\/*$/, \"\");\n}\nconst collectionPath = /\\/\\*\\*?(?:$|\\/)/;\nfunction getConfiguredCollectionPath(config, collection) {\n    var _collectionConfig$pat;\n    const collectionConfig = config.collections[collection];\n    const path = (_collectionConfig$pat = collectionConfig.path) !== null && _collectionConfig$pat !== void 0 ? _collectionConfig$pat : `${collection}/*/`;\n    if (!collectionPath.test(path)) {\n        throw new Error(`Collection path must end with /* or /** or include /*/ or /**/ but ${collection} has ${path}`);\n    }\n    return path;\n}\nfunction getCollectionPath(config, collection) {\n    const configuredPath = getConfiguredCollectionPath(config, collection);\n    const path = fixPath(configuredPath.replace(/\\*\\*?.*$/, \"\"));\n    return path;\n}\nfunction getCollectionFormat(config, collection) {\n    var _collectionConfig$for;\n    const collectionConfig = config.collections[collection];\n    return getFormatInfo((_collectionConfig$for = collectionConfig.format) !== null && _collectionConfig$for !== void 0 ? _collectionConfig$for : \"yaml\", collectionConfig.schema, getConfiguredCollectionPath(config, collection));\n}\nfunction getSingletonFormat(config, singleton) {\n    var _singletonConfig$form, _singletonConfig$path;\n    const singletonConfig = config.singletons[singleton];\n    return getFormatInfo((_singletonConfig$form = singletonConfig.format) !== null && _singletonConfig$form !== void 0 ? _singletonConfig$form : \"yaml\", singletonConfig.schema, (_singletonConfig$path = singletonConfig.path) !== null && _singletonConfig$path !== void 0 ? _singletonConfig$path : `${singleton}/`);\n}\nfunction getCollectionItemPath(config, collection, slug) {\n    const basePath = getCollectionPath(config, collection);\n    const suffix = getCollectionItemSlugSuffix(config, collection);\n    return `${basePath}/${slug}${suffix}`;\n}\nfunction getEntryDataFilepath(dir, formatInfo) {\n    return `${dir}${formatInfo.dataLocation === \"index\" ? \"/index\" : \"\"}${getDataFileExtension(formatInfo)}`;\n}\nfunction getSlugGlobForCollection(config, collection) {\n    const collectionPath = getConfiguredCollectionPath(config, collection);\n    return collectionPath.includes(\"**\") ? \"**\" : \"*\";\n}\nfunction getCollectionItemSlugSuffix(config, collection) {\n    const configuredPath = getConfiguredCollectionPath(config, collection);\n    const path = fixPath(configuredPath.replace(/^[^*]+\\*\\*?/, \"\"));\n    return path ? `/${path}` : \"\";\n}\nfunction getSingletonPath(config, singleton) {\n    var _singleton$path, _singleton$path2;\n    if ((_singleton$path = config.singletons[singleton].path) !== null && _singleton$path !== void 0 && _singleton$path.includes(\"*\")) {\n        throw new Error(`Singleton paths cannot include * but ${singleton} has ${config.singletons[singleton].path}`);\n    }\n    return fixPath((_singleton$path2 = config.singletons[singleton].path) !== null && _singleton$path2 !== void 0 ? _singleton$path2 : singleton);\n}\nfunction getDataFileExtension(formatInfo) {\n    return formatInfo.contentField ? formatInfo.contentField.config.contentExtension : \".\" + formatInfo.data;\n}\nfunction getFormatInfo(format, schema, path) {\n    var _format$data;\n    const dataLocation = path.endsWith(\"/\") ? \"index\" : \"outer\";\n    if (typeof format === \"string\") {\n        return {\n            dataLocation,\n            contentField: undefined,\n            data: format\n        };\n    }\n    let contentField;\n    if (format.contentField) {\n        const field = schema[format.contentField];\n        (0,emery__WEBPACK_IMPORTED_MODULE_1__.assert)((field === null || field === void 0 ? void 0 : field.kind) === \"form\", `${format.contentField} is not a form field`);\n        (0,emery__WEBPACK_IMPORTED_MODULE_1__.assert)(field.formKind === \"content\", `${format.contentField} is not a content field`);\n        contentField = {\n            key: format.contentField,\n            config: field\n        };\n    }\n    return {\n        data: (_format$data = format.data) !== null && _format$data !== void 0 ? _format$data : \"yaml\",\n        contentField,\n        dataLocation\n    };\n}\nfunction getPathPrefix(storage) {\n    if (storage.kind === \"local\" || !storage.pathPrefix) {\n        return undefined;\n    }\n    return fixPath(storage.pathPrefix) + \"/\";\n}\nasync function sha1(content) {\n    return (0,crypto__WEBPACK_IMPORTED_MODULE_2__.createHash)(\"sha1\").update(content).digest(\"hex\");\n}\nconst textEncoder$2 = new TextEncoder();\nfunction blobSha(contents) {\n    const blobPrefix = textEncoder$2.encode(\"blob \" + contents.length + \"\\x00\");\n    const array = new Uint8Array(blobPrefix.byteLength + contents.byteLength);\n    array.set(blobPrefix, 0);\n    array.set(contents, blobPrefix.byteLength);\n    return sha1(array);\n}\nfunction getTreeNodeAtPath(root, path) {\n    const parts = path.split(\"/\");\n    let node = root.get(parts[0]);\n    for (const part of parts.slice(1)){\n        if (!node) return undefined;\n        if (!node.children) return undefined;\n        node = node.children.get(part);\n    }\n    return node;\n}\nfunction getNodeAtPath(tree, path) {\n    let node = tree;\n    for (const part of path.split(\"/\")){\n        if (!node.has(part)) {\n            node.set(part, new Map());\n        }\n        const innerNode = node.get(part);\n        (0,emery__WEBPACK_IMPORTED_MODULE_1__.assert)(innerNode instanceof Map, \"expected tree\");\n        node = innerNode;\n    }\n    return node;\n}\nfunction getFilename(path) {\n    return path.replace(/.*\\//, \"\");\n}\nfunction getDirname(path) {\n    return path.replace(/\\/[^/]+$/, \"\");\n}\nfunction toTreeChanges(changes) {\n    const changesRoot = new Map();\n    for (const deletion of changes.deletions){\n        const parentTree = getNodeAtPath(changesRoot, getDirname(deletion));\n        parentTree.set(getFilename(deletion), \"delete\");\n    }\n    for (const addition of changes.additions){\n        const parentTree = getNodeAtPath(changesRoot, getDirname(addition.path));\n        parentTree.set(getFilename(addition.path), addition.contents);\n    }\n    return changesRoot;\n}\nconst SPACE_CHAR_CODE = 32;\nconst space = new Uint8Array([\n    SPACE_CHAR_CODE\n]);\nconst nullchar = new Uint8Array([\n    0\n]);\nconst tree = textEncoder$2.encode(\"tree \");\n// based on https://github.com/isomorphic-git/isomorphic-git/blob/c09dfa20ffe0ab9e6602e0fa172d72ba8994e443/src/models/GitTree.js#L108-L122\nfunction treeSha(children) {\n    const entries = [\n        ...children\n    ].map(([name, node])=>({\n            name,\n            sha: node.entry.sha,\n            mode: node.entry.mode\n        }));\n    entries.sort((a, b)=>{\n        const aName = a.mode === \"040000\" ? a.name + \"/\" : a.name;\n        const bName = b.mode === \"040000\" ? b.name + \"/\" : b.name;\n        return aName === bName ? 0 : aName < bName ? -1 : 1;\n    });\n    const treeObject = entries.flatMap((entry)=>{\n        const mode = textEncoder$2.encode(entry.mode.replace(/^0/, \"\"));\n        const name = textEncoder$2.encode(entry.name);\n        const sha = hexToBytes(entry.sha);\n        return [\n            mode,\n            space,\n            name,\n            nullchar,\n            sha\n        ];\n    });\n    return sha1(concatBytes([\n        tree,\n        textEncoder$2.encode(treeObject.reduce((sum, val)=>sum + val.byteLength, 0).toString()),\n        nullchar,\n        ...treeObject\n    ]));\n}\nfunction concatBytes(byteArrays) {\n    const totalLength = byteArrays.reduce((sum, arr)=>sum + arr.byteLength, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const arr of byteArrays){\n        result.set(arr, offset);\n        offset += arr.byteLength;\n    }\n    return result;\n}\nfunction hexToBytes(str) {\n    const bytes = new Uint8Array(str.length / 2);\n    for(var i = 0; i < bytes.byteLength; i += 1){\n        const start = i * 2;\n        bytes[i] = parseInt(str.slice(start, start + 2), 16);\n    }\n    return bytes;\n}\nasync function createTreeNodeEntry(path, children) {\n    const sha = await treeSha(children);\n    return {\n        path,\n        mode: \"040000\",\n        type: \"tree\",\n        sha\n    };\n}\nasync function createBlobNodeEntry(path, contents) {\n    const sha = \"sha\" in contents ? contents.sha : await blobSha(contents);\n    return {\n        path,\n        mode: \"100644\",\n        type: \"blob\",\n        sha\n    };\n}\nasync function updateTreeWithChanges(tree, changes) {\n    var _await$updateTree;\n    const newTree = (_await$updateTree = await updateTree(tree, toTreeChanges(changes), [])) !== null && _await$updateTree !== void 0 ? _await$updateTree : new Map();\n    return {\n        entries: treeToEntries(newTree),\n        sha: await treeSha(newTree !== null && newTree !== void 0 ? newTree : new Map())\n    };\n}\nfunction treeToEntries(tree) {\n    return [\n        ...tree.values()\n    ].flatMap((x)=>x.children ? [\n            x.entry,\n            ...treeToEntries(x.children)\n        ] : [\n            x.entry\n        ]);\n}\nasync function updateTree(tree, changedTree, path) {\n    const newTree = new Map(tree);\n    for (const [key, value] of changedTree){\n        if (value === \"delete\") {\n            newTree.delete(key);\n        }\n        if (value instanceof Map) {\n            var _newTree$get$children, _newTree$get;\n            const existingChildren = (_newTree$get$children = (_newTree$get = newTree.get(key)) === null || _newTree$get === void 0 ? void 0 : _newTree$get.children) !== null && _newTree$get$children !== void 0 ? _newTree$get$children : new Map();\n            const children = await updateTree(existingChildren, value, path.concat(key));\n            if (children === undefined) {\n                newTree.delete(key);\n                continue;\n            }\n            const entry = await createTreeNodeEntry(path.concat(key).join(\"/\"), children);\n            newTree.set(key, {\n                entry,\n                children\n            });\n        }\n        if (value instanceof Uint8Array || typeof value === \"object\" && \"sha\" in value) {\n            const entry = await createBlobNodeEntry(path.concat(key).join(\"/\"), value);\n            newTree.set(key, {\n                entry\n            });\n        }\n    }\n    if (newTree.size === 0) {\n        return undefined;\n    }\n    return newTree;\n}\nfunction treeEntriesToTreeNodes(entries) {\n    const root = new Map();\n    const getChildrenAtPath = (parts)=>{\n        var _node;\n        if (parts.length === 0) {\n            return root;\n        }\n        let node = root.get(parts[0]);\n        for (const part of parts.slice(1)){\n            if (!node) return undefined;\n            if (!node.children) return undefined;\n            node = node.children.get(part);\n        }\n        return (_node = node) === null || _node === void 0 ? void 0 : _node.children;\n    };\n    for (const entry of entries){\n        const split = entry.path.split(\"/\");\n        const children = getChildrenAtPath(split.slice(0, -1));\n        if (children) {\n            children.set(split[split.length - 1], {\n                entry,\n                children: entry.type === \"tree\" ? new Map() : undefined\n            });\n        }\n    }\n    return root;\n}\nfunction collectDirectoriesUsedInSchemaInner(schema, directories, seenSchemas) {\n    if (seenSchemas.has(schema)) {\n        return;\n    }\n    seenSchemas.add(schema);\n    if (schema.kind === \"array\") {\n        return collectDirectoriesUsedInSchemaInner(schema.element, directories, seenSchemas);\n    }\n    if (schema.kind === \"child\") {\n        return;\n    }\n    if (schema.kind === \"form\") {\n        if (schema.formKind === \"asset\" && schema.directory !== undefined) {\n            directories.add(fixPath(schema.directory));\n        }\n        if (schema.formKind === \"content\" && schema.directories !== undefined) {\n            for (const directory of schema.directories){\n                directories.add(fixPath(directory));\n            }\n        }\n        return;\n    }\n    if (schema.kind === \"object\") {\n        for (const field of Object.values(schema.fields)){\n            collectDirectoriesUsedInSchemaInner(field, directories, seenSchemas);\n        }\n        return;\n    }\n    if (schema.kind === \"conditional\") {\n        for (const innerSchema of Object.values(schema.values)){\n            collectDirectoriesUsedInSchemaInner(innerSchema, directories, seenSchemas);\n        }\n        return;\n    }\n    (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(schema);\n}\nfunction collectDirectoriesUsedInSchema(schema) {\n    const directories = new Set();\n    collectDirectoriesUsedInSchemaInner(schema, directories, new Set());\n    return directories;\n}\nfunction getDirectoriesForTreeKey(schema, directory, slug, format) {\n    const directories = [\n        fixPath(directory)\n    ];\n    if (format.dataLocation === \"outer\") {\n        directories.push(fixPath(directory) + getDataFileExtension(format));\n    }\n    const toAdd = slug === undefined ? \"\" : `/${slug}`;\n    for (const directory of collectDirectoriesUsedInSchema(schema)){\n        directories.push(directory + toAdd);\n    }\n    return directories;\n}\nfunction getTreeKey(directories, tree) {\n    return directories.map((d)=>{\n        var _getTreeNodeAtPath;\n        return (_getTreeNodeAtPath = getTreeNodeAtPath(tree, d)) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.entry.sha;\n    }).join(\"-\");\n}\nvar pkgJson = {\n    name: \"@keystatic/core\",\n    version: \"0.3.12\",\n    license: \"MIT\",\n    repository: {\n        type: \"git\",\n        url: \"https://github.com/Thinkmill/keystatic/\",\n        directory: \"packages/keystatic\"\n    },\n    type: \"module\",\n    exports: {\n        \"./ui\": {\n            types: \"./dist/keystatic-core-ui.js\",\n            node: {\n                \"react-server\": \"./dist/keystatic-core-ui.node.react-server.js\",\n                \"default\": \"./dist/keystatic-core-ui.node.js\"\n            },\n            \"react-server\": \"./dist/keystatic-core-ui.react-server.js\",\n            \"default\": \"./dist/keystatic-core-ui.js\"\n        },\n        \".\": {\n            types: \"./dist/keystatic-core.js\",\n            node: {\n                \"react-server\": \"./dist/keystatic-core.node.react-server.js\",\n                \"default\": \"./dist/keystatic-core.node.js\"\n            },\n            \"react-server\": \"./dist/keystatic-core.react-server.js\",\n            \"default\": \"./dist/keystatic-core.js\"\n        },\n        \"./api/utils\": {\n            types: \"./dist/keystatic-core-api-utils.js\",\n            node: {\n                \"react-server\": \"./dist/keystatic-core-api-utils.node.react-server.js\",\n                \"default\": \"./dist/keystatic-core-api-utils.node.js\"\n            },\n            \"react-server\": \"./dist/keystatic-core-api-utils.react-server.js\",\n            \"default\": \"./dist/keystatic-core-api-utils.js\"\n        },\n        \"./renderer\": {\n            types: \"./dist/keystatic-core-renderer.js\",\n            node: {\n                \"react-server\": \"./dist/keystatic-core-renderer.node.react-server.js\",\n                \"default\": \"./dist/keystatic-core-renderer.node.js\"\n            },\n            \"react-server\": \"./dist/keystatic-core-renderer.react-server.js\",\n            \"default\": \"./dist/keystatic-core-renderer.js\"\n        },\n        \"./api/generic\": {\n            types: \"./dist/keystatic-core-api-generic.js\",\n            node: {\n                \"react-server\": \"./dist/keystatic-core-api-generic.node.react-server.js\",\n                \"default\": \"./dist/keystatic-core-api-generic.node.js\"\n            },\n            \"react-server\": \"./dist/keystatic-core-api-generic.react-server.js\",\n            \"default\": \"./dist/keystatic-core-api-generic.js\"\n        },\n        \"./reader\": {\n            types: \"./dist/keystatic-core-reader.js\",\n            node: {\n                \"react-server\": \"./dist/keystatic-core-reader.node.react-server.js\",\n                \"default\": \"./dist/keystatic-core-reader.node.js\"\n            },\n            \"react-server\": \"./dist/keystatic-core-reader.react-server.js\",\n            \"default\": \"./dist/keystatic-core-reader.js\"\n        },\n        \"./reader/github\": {\n            types: \"./dist/keystatic-core-reader-github.js\",\n            node: {\n                \"react-server\": \"./dist/keystatic-core-reader-github.node.react-server.js\",\n                \"default\": \"./dist/keystatic-core-reader-github.node.js\"\n            },\n            \"react-server\": \"./dist/keystatic-core-reader-github.react-server.js\",\n            \"default\": \"./dist/keystatic-core-reader-github.js\"\n        },\n        \"./content-components\": {\n            types: \"./dist/keystatic-core-content-components.js\",\n            node: {\n                \"react-server\": \"./dist/keystatic-core-content-components.node.react-server.js\",\n                \"default\": \"./dist/keystatic-core-content-components.node.js\"\n            },\n            \"react-server\": \"./dist/keystatic-core-content-components.react-server.js\",\n            \"default\": \"./dist/keystatic-core-content-components.js\"\n        },\n        \"./component-blocks\": {\n            types: \"./dist/keystatic-core-component-blocks.js\",\n            node: {\n                \"react-server\": \"./dist/keystatic-core-component-blocks.node.react-server.js\",\n                \"default\": \"./dist/keystatic-core-component-blocks.node.js\"\n            },\n            \"react-server\": \"./dist/keystatic-core-component-blocks.react-server.js\",\n            \"default\": \"./dist/keystatic-core-component-blocks.js\"\n        },\n        \"./form/fields/markdoc\": {\n            types: \"./dist/keystatic-core-form-fields-markdoc.js\",\n            node: {\n                \"react-server\": \"./dist/keystatic-core-form-fields-markdoc.node.react-server.js\",\n                \"default\": \"./dist/keystatic-core-form-fields-markdoc.node.js\"\n            },\n            \"react-server\": \"./dist/keystatic-core-form-fields-markdoc.react-server.js\",\n            \"default\": \"./dist/keystatic-core-form-fields-markdoc.js\"\n        },\n        \"./package.json\": \"./package.json\"\n    },\n    files: [\n        \"dist\"\n    ],\n    scripts: {\n        setup: \"ts-gql build && tsx scripts/l10n.cts && tsx scripts/build-prism.cts\",\n        build: \"pnpm run setup && next build\",\n        dev: \"next dev\",\n        start: \"next start\"\n    },\n    dependencies: {\n        \"@babel/runtime\": \"^7.18.3\",\n        \"@braintree/sanitize-url\": \"^6.0.2\",\n        \"@emotion/css\": \"^11.9.0\",\n        \"@emotion/weak-memoize\": \"^0.3.0\",\n        \"@floating-ui/react\": \"^0.24.0\",\n        \"@internationalized/string\": \"^3.1.1\",\n        \"@keystar/ui\": \"^0.7.0\",\n        \"@markdoc/markdoc\": \"^0.3.0\",\n        \"@react-aria/focus\": \"^3.14.3\",\n        \"@react-aria/i18n\": \"^3.8.0\",\n        \"@react-aria/interactions\": \"^3.19.1\",\n        \"@react-aria/overlays\": \"^3.18.1\",\n        \"@react-aria/selection\": \"^3.17.1\",\n        \"@react-aria/utils\": \"^3.21.1\",\n        \"@react-aria/visually-hidden\": \"^3.8.6\",\n        \"@react-stately/collections\": \"^3.10.2\",\n        \"@react-stately/list\": \"^3.10.0\",\n        \"@react-stately/overlays\": \"^3.6.3\",\n        \"@react-stately/utils\": \"^3.8.0\",\n        \"@react-types/shared\": \"^3.21.0\",\n        \"@sindresorhus/slugify\": \"^1.1.2\",\n        \"@ts-gql/tag\": \"^0.7.0\",\n        \"@types/mdast\": \"^4.0.3\",\n        \"@types/node\": \"16.11.13\",\n        \"@types/react\": \"^18.2.8\",\n        \"@types/react-dom\": \"^18.0.11\",\n        \"@urql/core\": \"^4.1.3\",\n        \"@urql/exchange-auth\": \"^2.1.6\",\n        \"@urql/exchange-graphcache\": \"^6.3.3\",\n        \"@urql/exchange-persisted\": \"^4.1.0\",\n        cookie: \"^0.5.0\",\n        \"decimal.js\": \"^10.4.3\",\n        emery: \"^1.4.1\",\n        \"escape-string-regexp\": \"^4.0.0\",\n        \"fast-deep-equal\": \"^3.1.3\",\n        graphql: \"^16.6.0\",\n        \"idb-keyval\": \"^6.2.1\",\n        ignore: \"^5.2.4\",\n        \"iron-webcrypto\": \"^0.10.1\",\n        \"is-hotkey\": \"^0.2.0\",\n        \"js-base64\": \"^3.7.5\",\n        \"js-yaml\": \"^4.1.0\",\n        \"lru-cache\": \"^7.14.1\",\n        \"match-sorter\": \"^6.3.1\",\n        \"mdast-util-from-markdown\": \"^2.0.0\",\n        \"mdast-util-gfm\": \"^3.0.0\",\n        \"mdast-util-gfm-autolink-literal\": \"^2.0.0\",\n        \"mdast-util-gfm-strikethrough\": \"^2.0.0\",\n        \"mdast-util-mdx\": \"^3.0.0\",\n        \"mdast-util-to-markdown\": \"^2.1.0\",\n        \"micromark-extension-gfm\": \"^3.0.0\",\n        \"micromark-extension-gfm-autolink-literal\": \"^2.0.0\",\n        \"micromark-extension-gfm-strikethrough\": \"^2.0.0\",\n        \"micromark-extension-mdxjs\": \"^3.0.0\",\n        minimatch: \"^9.0.3\",\n        \"prosemirror-commands\": \"^1.5.1\",\n        \"prosemirror-history\": \"^1.3.0\",\n        \"prosemirror-keymap\": \"^1.2.1\",\n        \"prosemirror-model\": \"^1.19.0\",\n        \"prosemirror-state\": \"^1.4.2\",\n        \"prosemirror-tables\": \"^1.3.4\",\n        \"prosemirror-transform\": \"^1.7.1\",\n        \"prosemirror-view\": \"^1.30.2\",\n        \"scroll-into-view-if-needed\": \"^3.0.3\",\n        slate: \"^0.91.4\",\n        \"slate-history\": \"^0.86.0\",\n        \"slate-react\": \"^0.91.9\",\n        \"unist-util-visit\": \"^5.0.0\",\n        urql: \"^4.0.0\",\n        zod: \"^3.20.2\"\n    },\n    devDependencies: {\n        \"@jest/expect\": \"^29.7.0\",\n        \"@jest/globals\": \"^29.7.0\",\n        \"@testing-library/user-event\": \"^14.4.3\",\n        \"@ts-gql/compiler\": \"^0.16.1\",\n        \"@ts-gql/eslint-plugin\": \"^0.8.5\",\n        \"@ts-gql/next\": \"^17.0.0\",\n        \"@types/cookie\": \"^0.5.1\",\n        \"@types/is-hotkey\": \"^0.1.7\",\n        \"@types/js-yaml\": \"^4.0.5\",\n        \"@types/prismjs\": \"^1.26.0\",\n        \"@types/signal-exit\": \"^3.0.1\",\n        eslint: \"^8.18.0\",\n        \"fast-glob\": \"^3.2.12\",\n        \"jest-diff\": \"^29.0.1\",\n        outdent: \"^0.8.0\",\n        \"pretty-format\": \"^29.0.1\",\n        prismjs: \"^1.29.0\",\n        react: \"^18.2.0\",\n        \"react-dom\": \"^18.2.0\",\n        \"react-element-to-jsx-string\": \"^15.0.0\",\n        \"resize-observer-polyfill\": \"^1.5.1\",\n        \"signal-exit\": \"^3.0.7\",\n        \"slate-hyperscript\": \"^0.77.0\",\n        tsx: \"^3.8.0\",\n        typescript: \"^5.2.2\"\n    },\n    peerDependencies: {\n        react: \"^18.2.0\",\n        \"react-dom\": \"^18.2.0\"\n    },\n    preconstruct: {\n        entrypoints: [\n            \"index.ts\",\n            \"api/generic.ts\",\n            \"api/utils.ts\",\n            \"reader/index.ts\",\n            \"reader/github.ts\",\n            \"renderer.tsx\",\n            \"ui.tsx\",\n            \"form/fields/markdoc/index.tsx\",\n            \"component-blocks/index.tsx\",\n            \"content-components.ts\"\n        ]\n    },\n    \"ts-gql\": {\n        schema: \"./github.graphql\",\n        mode: \"no-transform\",\n        addTypename: false,\n        scalars: {\n            GitObjectID: \"string\"\n        }\n    },\n    imports: {\n        \"#react-cache-in-react-server\": {\n            \"react-server\": \"./src/reader/react-server-cache.ts\",\n            \"default\": \"./src/reader/noop-cache.ts\"\n        },\n        \"#sha1\": {\n            node: \"./src/sha1/node.ts\",\n            \"default\": \"./src/sha1/webcrypto.ts\"\n        },\n        \"#webcrypto\": {\n            node: \"./src/api/webcrypto/node.ts\",\n            \"default\": \"./src/api/webcrypto/default.ts\"\n        },\n        \"#api-handler\": {\n            node: \"./src/api/api-node.ts\",\n            \"default\": \"./src/api/api-noop.ts\"\n        },\n        \"#field-ui/*\": {\n            \"react-server\": \"./src/form/fields/empty-field-ui.tsx\",\n            \"default\": \"./src/form/fields/*/ui.tsx\"\n        },\n        \"#component-block-primitives\": {\n            \"react-server\": \"./src/form/fields/document/DocumentEditor/primitives/blank-for-react-server.tsx\",\n            \"default\": \"./src/form/fields/document/DocumentEditor/primitives/index.tsx\"\n        },\n        \"#cloud-image-preview\": {\n            \"react-server\": \"./src/component-blocks/blank-for-react-server.tsx\",\n            \"default\": \"./src/component-blocks/cloud-image-preview.tsx\"\n        }\n    }\n};\nfunction object(fields, opts) {\n    return {\n        ...opts,\n        kind: \"object\",\n        fields\n    };\n}\nfunction pluralize(count, options) {\n    const { singular, plural = singular + \"s\", inclusive = true } = options;\n    const variant = count === 1 ? singular : plural;\n    return inclusive ? `${count} ${variant}` : variant;\n}\nfunction getBranchPrefix(config) {\n    return config.storage.kind !== \"local\" ? config.storage.branchPrefix : undefined;\n}\nfunction isGitHubConfig(config) {\n    return config.storage.kind === \"github\";\n}\nfunction isLocalConfig(config) {\n    return config.storage.kind === \"local\";\n}\nfunction isCloudConfig(config) {\n    var _config$cloud;\n    if (config.storage.kind !== \"cloud\") return false;\n    if (!((_config$cloud = config.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project) || !config.cloud.project.includes(\"/\")) {\n        throw new Error(`Keystatic is set to \\`storage: { kind: 'cloud' }\\` but \\`cloud.project\\` isn't set.\nconfig({\n  storage: { kind: 'cloud' },\n  cloud: { project: 'team/project' },\n})`);\n    }\n    return true;\n}\nfunction getSplitCloudProject(config) {\n    var _config$cloud2;\n    if (!((_config$cloud2 = config.cloud) !== null && _config$cloud2 !== void 0 && _config$cloud2.project)) return undefined;\n    const [team, project] = config.cloud.project.split(\"/\");\n    return {\n        team,\n        project\n    };\n}\nfunction getRepoPath(config) {\n    return `${config.mainOwner}/${config.mainRepo}`;\n}\nfunction getRepoUrl(config) {\n    return `https://github.com/${getRepoPath(config)}`;\n}\nfunction getSlugFromState(collectionConfig, state) {\n    const value = state[collectionConfig.slugField];\n    const field = collectionConfig.schema[collectionConfig.slugField];\n    if (field.kind !== \"form\" || field.formKind !== \"slug\") {\n        throw new Error(`slugField is not a slug field`);\n    }\n    return field.serializeWithSlug(value).slug;\n}\nfunction getEntriesInCollectionWithTreeKey(config, collection, rootTree) {\n    var _getTreeNodeAtPath$ch, _getTreeNodeAtPath;\n    const collectionConfig = config.collections[collection];\n    const schema = object(collectionConfig.schema);\n    const formatInfo = getCollectionFormat(config, collection);\n    const extension = getDataFileExtension(formatInfo);\n    const glob = getSlugGlobForCollection(config, collection);\n    const collectionPath = getCollectionPath(config, collection);\n    const directory = (_getTreeNodeAtPath$ch = (_getTreeNodeAtPath = getTreeNodeAtPath(rootTree, collectionPath)) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.children) !== null && _getTreeNodeAtPath$ch !== void 0 ? _getTreeNodeAtPath$ch : new Map();\n    const entries = [];\n    const directoriesUsedInSchema = [\n        ...collectDirectoriesUsedInSchema(schema)\n    ];\n    const suffix = getCollectionItemSlugSuffix(config, collection);\n    const possibleEntries = new Map(directory);\n    if (glob === \"**\") {\n        const handleDirectory = (dir, prefix)=>{\n            for (const [key, entry] of dir){\n                if (entry.children) {\n                    possibleEntries.set(`${prefix}${key}`, entry);\n                    handleDirectory(entry.children, `${prefix}${key}/`);\n                } else {\n                    possibleEntries.set(`${prefix}${key}`, entry);\n                }\n            }\n        };\n        handleDirectory(directory, \"\");\n    }\n    for (const [key, entry] of possibleEntries){\n        if (formatInfo.dataLocation === \"index\") {\n            var _actualEntry$children;\n            const actualEntry = getTreeNodeAtPath(rootTree, getCollectionItemPath(config, collection, key));\n            if (!(actualEntry !== null && actualEntry !== void 0 && (_actualEntry$children = actualEntry.children) !== null && _actualEntry$children !== void 0 && _actualEntry$children.has(\"index\" + extension))) continue;\n            entries.push({\n                key: getTreeKey([\n                    actualEntry.entry.path,\n                    ...directoriesUsedInSchema.map((x)=>`${x}/${key}`)\n                ], rootTree),\n                slug: key,\n                sha: actualEntry.children.get(\"index\" + extension).entry.sha\n            });\n        } else {\n            if (suffix) {\n                const newEntry = getTreeNodeAtPath(rootTree, getCollectionItemPath(config, collection, key) + extension);\n                if (!newEntry || newEntry.children) continue;\n                entries.push({\n                    key: getTreeKey([\n                        entry.entry.path,\n                        getCollectionItemPath(config, collection, key),\n                        ...directoriesUsedInSchema.map((x)=>`${x}/${key}`)\n                    ], rootTree),\n                    slug: key,\n                    sha: newEntry.entry.sha\n                });\n            }\n            if (entry.children || !key.endsWith(extension)) continue;\n            const slug = key.slice(0, -extension.length);\n            entries.push({\n                key: getTreeKey([\n                    entry.entry.path,\n                    getCollectionItemPath(config, collection, slug),\n                    ...directoriesUsedInSchema.map((x)=>`${x}/${slug}`)\n                ], rootTree),\n                slug,\n                sha: entry.entry.sha\n            });\n        }\n    }\n    return entries;\n}\nconst KEYSTATIC_CLOUD_API_URL = \"https://api.keystatic.cloud\";\nconst KEYSTATIC_CLOUD_HEADERS = {\n    \"x-keystatic-version\": pkgJson.version\n};\nconst textEncoder$1 = new TextEncoder();\nasync function redirectToCloudAuth(from, config) {\n    var _config$cloud3;\n    if (!((_config$cloud3 = config.cloud) !== null && _config$cloud3 !== void 0 && _config$cloud3.project)) {\n        throw new Error(\"Not a cloud config\");\n    }\n    const code_verifier = (0,js_base64__WEBPACK_IMPORTED_MODULE_5__.fromUint8Array)(crypto.getRandomValues(new Uint8Array(32)), true);\n    const code_challenge = (0,js_base64__WEBPACK_IMPORTED_MODULE_5__.fromUint8Array)(new Uint8Array(await crypto.subtle.digest(\"SHA-256\", textEncoder$1.encode(code_verifier))), true);\n    const state = (0,js_base64__WEBPACK_IMPORTED_MODULE_5__.fromUint8Array)(crypto.getRandomValues(new Uint8Array(32)), true);\n    localStorage.setItem(\"keystatic-cloud-state\", JSON.stringify({\n        state,\n        from,\n        code_verifier\n    }));\n    const url = new URL(`${KEYSTATIC_CLOUD_API_URL}/oauth/authorize`);\n    url.searchParams.set(\"state\", state);\n    url.searchParams.set(\"client_id\", config.cloud.project);\n    url.searchParams.set(\"redirect_uri\", `${window.location.origin}/keystatic/cloud/oauth/callback`);\n    url.searchParams.set(\"response_type\", \"code\");\n    url.searchParams.set(\"code_challenge_method\", \"S256\");\n    url.searchParams.set(\"code_challenge\", code_challenge);\n    url.searchParams.set(\"keystatic_version\", pkgJson.version);\n    window.location.href = url.toString();\n}\nconst tableCellChildren = [\n    \"paragraph\",\n    \"code\",\n    \"heading\",\n    \"ordered-list\",\n    \"unordered-list\",\n    \"divider\",\n    \"image\"\n];\nconst blockquoteChildren = [\n    ...tableCellChildren,\n    \"table\"\n];\nconst paragraphLike = [\n    ...blockquoteChildren,\n    \"blockquote\"\n];\nconst insideOfLayouts = [\n    ...paragraphLike,\n    \"component-block\"\n];\nfunction blockContainer(args) {\n    return {\n        kind: \"blocks\",\n        allowedChildren: new Set(args.allowedChildren),\n        blockToWrapInlinesIn: args.allowedChildren[0],\n        invalidPositionHandleMode: args.invalidPositionHandleMode\n    };\n}\nfunction inlineContainer(args) {\n    return {\n        kind: \"inlines\",\n        invalidPositionHandleMode: args.invalidPositionHandleMode\n    };\n}\nconst editorSchema = {\n    editor: blockContainer({\n        allowedChildren: [\n            ...insideOfLayouts,\n            \"layout\"\n        ],\n        invalidPositionHandleMode: \"move\"\n    }),\n    layout: blockContainer({\n        allowedChildren: [\n            \"layout-area\"\n        ],\n        invalidPositionHandleMode: \"move\"\n    }),\n    \"layout-area\": blockContainer({\n        allowedChildren: insideOfLayouts,\n        invalidPositionHandleMode: \"unwrap\"\n    }),\n    blockquote: blockContainer({\n        allowedChildren: blockquoteChildren,\n        invalidPositionHandleMode: \"move\"\n    }),\n    paragraph: inlineContainer({\n        invalidPositionHandleMode: \"unwrap\"\n    }),\n    code: inlineContainer({\n        invalidPositionHandleMode: \"move\"\n    }),\n    divider: inlineContainer({\n        invalidPositionHandleMode: \"move\"\n    }),\n    heading: inlineContainer({\n        invalidPositionHandleMode: \"unwrap\"\n    }),\n    \"component-block\": blockContainer({\n        allowedChildren: [\n            \"component-block-prop\",\n            \"component-inline-prop\"\n        ],\n        invalidPositionHandleMode: \"move\"\n    }),\n    \"component-inline-prop\": inlineContainer({\n        invalidPositionHandleMode: \"unwrap\"\n    }),\n    \"component-block-prop\": blockContainer({\n        allowedChildren: insideOfLayouts,\n        invalidPositionHandleMode: \"unwrap\"\n    }),\n    \"ordered-list\": blockContainer({\n        allowedChildren: [\n            \"list-item\"\n        ],\n        invalidPositionHandleMode: \"move\"\n    }),\n    \"unordered-list\": blockContainer({\n        allowedChildren: [\n            \"list-item\"\n        ],\n        invalidPositionHandleMode: \"move\"\n    }),\n    \"list-item\": blockContainer({\n        allowedChildren: [\n            \"list-item-content\",\n            \"ordered-list\",\n            \"unordered-list\"\n        ],\n        invalidPositionHandleMode: \"unwrap\"\n    }),\n    \"list-item-content\": inlineContainer({\n        invalidPositionHandleMode: \"unwrap\"\n    }),\n    image: inlineContainer({\n        invalidPositionHandleMode: \"move\"\n    }),\n    table: blockContainer({\n        invalidPositionHandleMode: \"move\",\n        allowedChildren: [\n            \"table-head\",\n            \"table-body\"\n        ]\n    }),\n    \"table-body\": blockContainer({\n        invalidPositionHandleMode: \"move\",\n        allowedChildren: [\n            \"table-row\"\n        ]\n    }),\n    \"table-row\": blockContainer({\n        invalidPositionHandleMode: \"move\",\n        allowedChildren: [\n            \"table-cell\"\n        ]\n    }),\n    \"table-cell\": blockContainer({\n        invalidPositionHandleMode: \"move\",\n        allowedChildren: tableCellChildren\n    }),\n    \"table-head\": blockContainer({\n        invalidPositionHandleMode: \"move\",\n        allowedChildren: [\n            \"table-row\"\n        ]\n    })\n};\nconst inlineContainerTypes = new Set(Object.entries(editorSchema).filter(([, value])=>value.kind === \"inlines\").map(([type])=>type));\nfunction isInlineContainer(node) {\n    return node.type !== undefined && inlineContainerTypes.has(node.type);\n}\nconst blockTypes = new Set(Object.keys(editorSchema).filter((x)=>x !== \"editor\"));\nfunction isBlock(node) {\n    return blockTypes.has(node.type);\n}\n// to print the editor schema in Graphviz if you want to visualize it\n// function printEditorSchema(editorSchema: EditorSchema) {\n//   return `digraph G {\n//   concentrate=true;\n//   ${Object.keys(editorSchema)\n//     .map(key => {\n//       let val = editorSchema[key];\n//       if (val.kind === 'inlines') {\n//         return `\"${key}\" -> inlines`;\n//       }\n//       if (val.kind === 'blocks') {\n//         return `\"${key}\" -> {${[...val.allowedChildren].map(x => JSON.stringify(x)).join(' ')}}`;\n//       }\n//     })\n//     .join('\\n  ')}\n// }`;\n// }\nfunction getWholeDocumentFeaturesForChildField(editorDocumentFeatures, options) {\n    var _options$formatting, _options$formatting2, _options$formatting3, _options$formatting4, _options$formatting5, _options$formatting6, _options$formatting7;\n    const inlineMarksFromOptions = (_options$formatting = options.formatting) === null || _options$formatting === void 0 ? void 0 : _options$formatting.inlineMarks;\n    const inlineMarks = Object.fromEntries(Object.keys(editorDocumentFeatures.formatting.inlineMarks).map((_mark)=>{\n        const mark = _mark;\n        return [\n            mark,\n            inlineMarksFromOptions === \"inherit\" || (inlineMarksFromOptions === null || inlineMarksFromOptions === void 0 ? void 0 : inlineMarksFromOptions[mark]) === \"inherit\" ? editorDocumentFeatures.formatting.inlineMarks[mark] : false\n        ];\n    }));\n    const headingLevels = (_options$formatting2 = options.formatting) === null || _options$formatting2 === void 0 ? void 0 : _options$formatting2.headingLevels;\n    return {\n        formatting: {\n            inlineMarks,\n            softBreaks: ((_options$formatting3 = options.formatting) === null || _options$formatting3 === void 0 ? void 0 : _options$formatting3.softBreaks) === \"inherit\" && editorDocumentFeatures.formatting.softBreaks,\n            alignment: {\n                center: editorDocumentFeatures.formatting.alignment.center && ((_options$formatting4 = options.formatting) === null || _options$formatting4 === void 0 ? void 0 : _options$formatting4.alignment) === \"inherit\",\n                end: editorDocumentFeatures.formatting.alignment.end && ((_options$formatting5 = options.formatting) === null || _options$formatting5 === void 0 ? void 0 : _options$formatting5.alignment) === \"inherit\"\n            },\n            blockTypes: ((_options$formatting6 = options.formatting) === null || _options$formatting6 === void 0 ? void 0 : _options$formatting6.blockTypes) === \"inherit\" ? editorDocumentFeatures.formatting.blockTypes : {\n                blockquote: false,\n                code: false\n            },\n            headings: headingLevels === \"inherit\" ? editorDocumentFeatures.formatting.headings : {\n                levels: headingLevels ? editorDocumentFeatures.formatting.headings.levels.filter((level)=>headingLevels.includes(level)) : [],\n                schema: editorDocumentFeatures.formatting.headings.schema\n            },\n            listTypes: ((_options$formatting7 = options.formatting) === null || _options$formatting7 === void 0 ? void 0 : _options$formatting7.listTypes) === \"inherit\" ? editorDocumentFeatures.formatting.listTypes : {\n                ordered: false,\n                unordered: false\n            }\n        },\n        dividers: options.dividers === \"inherit\" ? editorDocumentFeatures.dividers : false,\n        images: options.images === \"inherit\" && editorDocumentFeatures.images,\n        layouts: [],\n        links: options.links === \"inherit\" && editorDocumentFeatures.links,\n        tables: options.tables === \"inherit\" && editorDocumentFeatures.tables\n    };\n}\nfunction getDocumentFeaturesForChildField(editorDocumentFeatures, options) {\n    var _options$formatting8, _options$formatting10, _options$formatting11, _options$formatting12, _options$formatting13, _options$formatting14;\n    // an important note for this: normalization based on document features\n    // is done based on the document features returned here\n    // and the editor document features\n    // so the result for any given child prop will be the things that are\n    // allowed by both these document features\n    // AND the editor document features\n    const inlineMarksFromOptions = (_options$formatting8 = options.formatting) === null || _options$formatting8 === void 0 ? void 0 : _options$formatting8.inlineMarks;\n    const inlineMarks = inlineMarksFromOptions === \"inherit\" ? \"inherit\" : Object.fromEntries(Object.keys(editorDocumentFeatures.formatting.inlineMarks).map((mark)=>{\n        return [\n            mark,\n            !!(inlineMarksFromOptions || {})[mark]\n        ];\n    }));\n    if (options.kind === \"inline\") {\n        var _options$formatting9;\n        return {\n            kind: \"inline\",\n            inlineMarks,\n            documentFeatures: {\n                links: options.links === \"inherit\"\n            },\n            softBreaks: ((_options$formatting9 = options.formatting) === null || _options$formatting9 === void 0 ? void 0 : _options$formatting9.softBreaks) === \"inherit\"\n        };\n    }\n    const headingLevels = (_options$formatting10 = options.formatting) === null || _options$formatting10 === void 0 ? void 0 : _options$formatting10.headingLevels;\n    return {\n        kind: \"block\",\n        inlineMarks,\n        softBreaks: ((_options$formatting11 = options.formatting) === null || _options$formatting11 === void 0 ? void 0 : _options$formatting11.softBreaks) === \"inherit\",\n        documentFeatures: {\n            layouts: [],\n            dividers: options.dividers === \"inherit\" ? editorDocumentFeatures.dividers : false,\n            formatting: {\n                alignment: ((_options$formatting12 = options.formatting) === null || _options$formatting12 === void 0 ? void 0 : _options$formatting12.alignment) === \"inherit\" ? editorDocumentFeatures.formatting.alignment : {\n                    center: false,\n                    end: false\n                },\n                blockTypes: ((_options$formatting13 = options.formatting) === null || _options$formatting13 === void 0 ? void 0 : _options$formatting13.blockTypes) === \"inherit\" ? editorDocumentFeatures.formatting.blockTypes : {\n                    blockquote: false,\n                    code: false\n                },\n                headings: headingLevels === \"inherit\" ? editorDocumentFeatures.formatting.headings : {\n                    levels: headingLevels ? editorDocumentFeatures.formatting.headings.levels.filter((level)=>headingLevels.includes(level)) : [],\n                    schema: editorDocumentFeatures.formatting.headings.schema\n                },\n                listTypes: ((_options$formatting14 = options.formatting) === null || _options$formatting14 === void 0 ? void 0 : _options$formatting14.listTypes) === \"inherit\" ? editorDocumentFeatures.formatting.listTypes : {\n                    ordered: false,\n                    unordered: false\n                }\n            },\n            links: options.links === \"inherit\",\n            images: options.images === \"inherit\" ? editorDocumentFeatures.images : false,\n            tables: options.tables === \"inherit\"\n        },\n        componentBlocks: options.componentBlocks === \"inherit\"\n    };\n}\nfunction getSchemaAtPropPathInner(path, value, schema) {\n    // because we're checking the length here\n    // the non-null asserts on shift below are fine\n    if (path.length === 0) {\n        return schema;\n    }\n    if (schema.kind === \"child\" || schema.kind === \"form\") {\n        return;\n    }\n    if (schema.kind === \"conditional\") {\n        const key = path.shift();\n        if (key === \"discriminant\") {\n            return getSchemaAtPropPathInner(path, value.discriminant, schema.discriminant);\n        }\n        if (key === \"value\") {\n            const propVal = schema.values[value.discriminant];\n            return getSchemaAtPropPathInner(path, value.value, propVal);\n        }\n        return;\n    }\n    if (schema.kind === \"object\") {\n        const key = path.shift();\n        return getSchemaAtPropPathInner(path, value[key], schema.fields[key]);\n    }\n    if (schema.kind === \"array\") {\n        const index = path.shift();\n        return getSchemaAtPropPathInner(path, value[index], schema.element);\n    }\n    (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(schema);\n}\nfunction getSchemaAtPropPath(path, value, props) {\n    return getSchemaAtPropPathInner([\n        ...path\n    ], value, {\n        kind: \"object\",\n        fields: props\n    });\n}\nfunction getAncestorSchemas(rootSchema, path, value) {\n    const ancestors = [];\n    const currentPath = [\n        ...path\n    ];\n    let currentProp = rootSchema;\n    let currentValue = value;\n    while(currentPath.length){\n        ancestors.push(currentProp);\n        const key = currentPath.shift(); // this code only runs when path.length is truthy so this non-null assertion is fine\n        if (currentProp.kind === \"array\") {\n            currentProp = currentProp.element;\n            currentValue = currentValue[key];\n        } else if (currentProp.kind === \"conditional\") {\n            currentProp = currentProp.values[value.discriminant];\n            currentValue = currentValue.value;\n        } else if (currentProp.kind === \"object\") {\n            currentValue = currentValue[key];\n            currentProp = currentProp.fields[key];\n        } else if (currentProp.kind === \"child\" || currentProp.kind === \"form\") {\n            throw new Error(`unexpected prop \"${key}\"`);\n        } else {\n            (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(currentProp);\n        }\n    }\n    return ancestors;\n}\nfunction getPlaceholderTextForPropPath(propPath, fields, formProps) {\n    const field = getSchemaAtPropPath(propPath, formProps, fields);\n    if ((field === null || field === void 0 ? void 0 : field.kind) === \"child\" && (field.options.kind === \"block\" && field.options.editIn !== \"modal\" || field.options.kind === \"inline\")) {\n        return field.options.placeholder;\n    }\n    return \"\";\n}\nfunction cloneDescendent(node) {\n    if (slate__WEBPACK_IMPORTED_MODULE_6__.Element.isElement(node)) {\n        return {\n            ...node,\n            children: node.children.map(cloneDescendent)\n        };\n    }\n    return {\n        ...node\n    };\n}\nconst allMarks = [\n    \"bold\",\n    \"italic\",\n    \"underline\",\n    \"strikethrough\",\n    \"code\",\n    \"superscript\",\n    \"subscript\",\n    \"keyboard\"\n];\nconst isElementActive = (editor, format)=>{\n    const [match] = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.nodes(editor, {\n        match: (n)=>n.type === format\n    });\n    return !!match;\n};\nfunction clearFormatting(editor) {\n    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unwrapNodes(editor, {\n        match: (node)=>node.type === \"heading\" || node.type === \"blockquote\" || node.type === \"code\"\n    });\n    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unsetNodes(editor, allMarks, {\n        match: slate__WEBPACK_IMPORTED_MODULE_6__.Text.isText\n    });\n}\nfunction moveChildren(editor, parent, to, shouldMoveNode = ()=>true) {\n    const parentPath = slate__WEBPACK_IMPORTED_MODULE_6__.Path.isPath(parent) ? parent : parent[1];\n    const parentNode = slate__WEBPACK_IMPORTED_MODULE_6__.Path.isPath(parent) ? slate__WEBPACK_IMPORTED_MODULE_6__.Node.get(editor, parentPath) : parent[0];\n    if (!isBlock(parentNode)) return;\n    for(let i = parentNode.children.length - 1; i >= 0; i--){\n        if (shouldMoveNode(parentNode.children[i], i)) {\n            const childPath = [\n                ...parentPath,\n                i\n            ];\n            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.moveNodes(editor, {\n                at: childPath,\n                to\n            });\n        }\n    }\n}\n/**\n * This is equivalent to Editor.after except that it ignores points that have no content\n * like the point in a void text node, an empty text node and the last point in a text node\n */ // TODO: this would probably break if you were trying to get the last point in the editor?\nfunction EditorAfterButIgnoringingPointsWithNoContent(editor, at, { distance = 1 } = {}) {\n    const anchor = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.point(editor, at, {\n        edge: \"end\"\n    });\n    const focus = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.end(editor, []);\n    const range = {\n        anchor,\n        focus\n    };\n    let d = 0;\n    let target;\n    for (const p of slate__WEBPACK_IMPORTED_MODULE_6__.Editor.positions(editor, {\n        at: range\n    })){\n        if (d > distance) {\n            break;\n        }\n        // this is the important change\n        const node = slate__WEBPACK_IMPORTED_MODULE_6__.Node.get(editor, p.path);\n        if (node.text.length === p.offset) {\n            continue;\n        }\n        if (d !== 0) {\n            target = p;\n        }\n        d++;\n    }\n    return target;\n}\nfunction nodeTypeMatcher(...args) {\n    if (args.length === 1) {\n        const type = args[0];\n        return (node)=>node.type === type;\n    }\n    const set = new Set(args);\n    return (node)=>typeof node.type === \"string\" && set.has(node.type);\n}\nfunction getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks) {\n    const ancestorComponentProp = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.above(editor, {\n        match: nodeTypeMatcher(\"component-block-prop\", \"component-inline-prop\")\n    });\n    if (ancestorComponentProp) {\n        const propPath = ancestorComponentProp[0].propPath;\n        const ancestorComponent = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.parent(editor, ancestorComponentProp[1]);\n        if (ancestorComponent[0].type === \"component-block\") {\n            const component = ancestorComponent[0].component;\n            const componentBlock = componentBlocks[component];\n            if (componentBlock && propPath) {\n                const childField = getSchemaAtPropPath(propPath, ancestorComponent[0].props, componentBlock.schema);\n                if ((childField === null || childField === void 0 ? void 0 : childField.kind) === \"child\") {\n                    return getDocumentFeaturesForChildField(editorDocumentFeatures, childField.options);\n                }\n            }\n        }\n    }\n}\n// this is used in react-server environments to avoid bundling UI when the reader API is used\n// if you added a new field and get an error that there's missing a missing export here,\n// you probably just need to add another empty export here\nfunction empty() {\n    throw new Error(\"unexpected call to function that shouldn't be called in React server component environment\");\n}\nlet SlugFieldInput = empty, TextFieldInput = empty, UrlFieldInput = empty, SelectFieldInput = empty, RelationshipInput = empty, PathReferenceInput = empty, MultiselectFieldInput = empty, IntegerFieldInput = empty, NumberFieldInput = empty, ImageFieldInput = empty, FileFieldInput = empty, DatetimeFieldInput = empty, DateFieldInput = empty, CloudImageFieldInput = empty, BlocksFieldInput = empty, DocumentFieldInput = empty, CheckboxFieldInput = empty, createEditorSchema = empty, getDefaultValue = empty, parseToEditorState = empty, serializeFromEditorState = empty, parseToEditorStateMDX = empty, serializeFromEditorStateMDX = empty;\nclass FieldDataError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"FieldDataError\";\n    }\n}\nfunction assertRequired(value, validation, label) {\n    if (value === null && validation !== null && validation !== void 0 && validation.isRequired) {\n        throw new FieldDataError(`${label} is required`);\n    }\n}\nfunction basicFormFieldWithSimpleReaderParse(config) {\n    return {\n        kind: \"form\",\n        Input: config.Input,\n        defaultValue: config.defaultValue,\n        parse: config.parse,\n        serialize: config.serialize,\n        validate: config.validate,\n        reader: {\n            parse (value) {\n                return config.validate(config.parse(value));\n            }\n        },\n        label: config.label\n    };\n}\nconst arrayValuesToElementKeys = new WeakMap();\nlet counter = 0;\nfunction getKeysForArrayValue(value) {\n    if (!arrayValuesToElementKeys.has(value)) {\n        arrayValuesToElementKeys.set(value, Array.from({\n            length: value.length\n        }, getNewArrayElementKey));\n    }\n    return arrayValuesToElementKeys.get(value);\n}\nfunction setKeysForArrayValue(value, elementIds) {\n    arrayValuesToElementKeys.set(value, elementIds);\n}\nfunction getNewArrayElementKey() {\n    return (counter++).toString();\n}\nconst getInitialPropsValue = _getInitialPropsValue;\nfunction _getInitialPropsValue(schema) {\n    switch(schema.kind){\n        case \"form\":\n            return schema.defaultValue();\n        case \"child\":\n            return schema.options.kind === \"block\" ? [\n                {\n                    type: \"paragraph\",\n                    children: [\n                        {\n                            text: \"\"\n                        }\n                    ]\n                }\n            ] : null;\n        case \"conditional\":\n            {\n                const defaultValue = schema.discriminant.defaultValue();\n                return {\n                    discriminant: defaultValue,\n                    value: getInitialPropsValue(schema.values[defaultValue.toString()])\n                };\n            }\n        case \"object\":\n            {\n                const obj = {};\n                for (const key of Object.keys(schema.fields)){\n                    obj[key] = getInitialPropsValue(schema.fields[key]);\n                }\n                return obj;\n            }\n        case \"array\":\n            {\n                return [];\n            }\n    }\n    (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(schema);\n}\nfunction getInitialPropsValueFromInitializer(schema, initializer) {\n    switch(schema.kind){\n        case \"form\":\n            return initializer === undefined ? schema.defaultValue() : initializer;\n        case \"child\":\n            return initializer !== null && initializer !== void 0 ? initializer : schema.options.kind === \"block\" ? [\n                {\n                    type: \"paragraph\",\n                    children: [\n                        {\n                            text: \"\"\n                        }\n                    ]\n                }\n            ] : null;\n        case \"conditional\":\n            {\n                const defaultValue = initializer === undefined ? schema.discriminant.defaultValue() : initializer.discriminant;\n                return {\n                    discriminant: defaultValue,\n                    value: getInitialPropsValueFromInitializer(schema.values[defaultValue.toString()], initializer === undefined ? undefined : initializer.value)\n                };\n            }\n        case \"object\":\n            {\n                const obj = {};\n                for (const key of Object.keys(schema.fields)){\n                    obj[key] = getInitialPropsValueFromInitializer(schema.fields[key], initializer === undefined ? undefined : initializer[key]);\n                }\n                return obj;\n            }\n        case \"array\":\n            {\n                return (initializer !== null && initializer !== void 0 ? initializer : []).map((x)=>getInitialPropsValueFromInitializer(schema.element, x.value));\n            }\n    }\n    (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(schema);\n}\nfunction updateValue(schema, currentValue, updater) {\n    if (updater === undefined) return currentValue;\n    switch(schema.kind){\n        case \"form\":\n            return updater;\n        case \"child\":\n            return updater;\n        case \"conditional\":\n            {\n                return {\n                    discriminant: updater.discriminant,\n                    value: updater.discriminant === currentValue.discriminant ? updateValue(schema.values[updater.discriminant.toString()], currentValue.value, updater.value) : getInitialPropsValueFromInitializer(schema.values[updater.discriminant.toString()], updater.value)\n                };\n            }\n        case \"object\":\n            {\n                const obj = {};\n                for (const key of Object.keys(schema.fields)){\n                    obj[key] = updateValue(schema.fields[key], currentValue[key], updater[key]);\n                }\n                return obj;\n            }\n        case \"array\":\n            {\n                const currentArrVal = currentValue;\n                const newVal = updater;\n                const uniqueKeys = new Set();\n                for (const x of newVal){\n                    if (x.key !== undefined) {\n                        if (uniqueKeys.has(x.key)) {\n                            throw new Error(\"Array elements must have unique keys\");\n                        }\n                        uniqueKeys.add(x.key);\n                    }\n                }\n                const keys = newVal.map((x)=>{\n                    if (x.key !== undefined) return x.key;\n                    let elementKey = getNewArrayElementKey();\n                    // just in case someone gives a key that is above our counter\n                    while(uniqueKeys.has(elementKey)){\n                        elementKey = getNewArrayElementKey();\n                    }\n                    uniqueKeys.add(elementKey);\n                    return elementKey;\n                });\n                const prevKeys = getKeysForArrayValue(currentArrVal);\n                const prevValuesByKey = new Map(currentArrVal.map((value, i)=>{\n                    return [\n                        prevKeys[i],\n                        value\n                    ];\n                }));\n                const val = newVal.map((x, i)=>{\n                    const id = keys[i];\n                    if (prevValuesByKey.has(id)) {\n                        return updateValue(schema.element, prevValuesByKey.get(id), x.value);\n                    }\n                    return getInitialPropsValueFromInitializer(schema.element, x.value);\n                });\n                setKeysForArrayValue(val, keys);\n                return val;\n            }\n    }\n    (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(schema);\n}\nfunction getValueAtPropPath(value, inputPath) {\n    const path = [\n        ...inputPath\n    ];\n    while(path.length){\n        const key = path.shift();\n        value = value[key];\n    }\n    return value;\n}\nfunction traverseProps(schema, value, visitor, path = []) {\n    if (schema.kind === \"form\" || schema.kind === \"child\") {\n        visitor(schema, value, path);\n        return;\n    }\n    if (schema.kind === \"object\") {\n        for (const [key, childProp] of Object.entries(schema.fields)){\n            traverseProps(childProp, value[key], visitor, [\n                ...path,\n                key\n            ]);\n        }\n        visitor(schema, value, path);\n        return;\n    }\n    if (schema.kind === \"array\") {\n        for (const [idx, val] of value.entries()){\n            traverseProps(schema.element, val, visitor, path.concat(idx));\n        }\n        return visitor(schema, value, path);\n    }\n    if (schema.kind === \"conditional\") {\n        const discriminant = value.discriminant;\n        visitor(schema, discriminant, path.concat(\"discriminant\"));\n        traverseProps(schema.values[discriminant.toString()], value.value, visitor, path.concat(\"value\"));\n        visitor(schema, value, path);\n        return;\n    }\n    (0,emery_assertions__WEBPACK_IMPORTED_MODULE_0__.assertNever)(schema);\n}\nfunction transformProps(schema, value, visitors, path = []) {\n    if (schema.kind === \"form\" || schema.kind === \"child\") {\n        if (visitors[schema.kind]) {\n            return visitors[schema.kind](schema, value, path);\n        }\n        return value;\n    }\n    if (schema.kind === \"object\") {\n        const val = Object.fromEntries(Object.entries(schema.fields).map(([key, val])=>{\n            return [\n                key,\n                transformProps(val, value[key], visitors, [\n                    ...path,\n                    key\n                ])\n            ];\n        }));\n        if (visitors.object) {\n            return visitors[schema.kind](schema, val, path);\n        }\n        return val;\n    }\n    if (schema.kind === \"array\") {\n        const val = value.map((val, idx)=>transformProps(schema.element, val, visitors, path.concat(idx)));\n        if (visitors.array) {\n            return visitors[schema.kind](schema, val, path);\n        }\n        return val;\n    }\n    if (schema.kind === \"conditional\") {\n        const discriminant = transformProps(schema.discriminant, value.discriminant, visitors, path.concat(\"discriminant\"));\n        const conditionalVal = transformProps(schema.values[discriminant.toString()], value.value, visitors, path.concat(\"value\"));\n        const val = {\n            discriminant,\n            value: conditionalVal\n        };\n        if (visitors.conditional) {\n            return visitors[schema.kind](schema, val, path);\n        }\n        return val;\n    }\n    (0,emery_assertions__WEBPACK_IMPORTED_MODULE_0__.assertNever)(schema);\n}\nfunction replaceValueAtPropPath(schema, value, newValue, path) {\n    if (path.length === 0) {\n        return newValue;\n    }\n    const [key, ...newPath] = path;\n    if (schema.kind === \"object\") {\n        return {\n            ...value,\n            [key]: replaceValueAtPropPath(schema.fields[key], value[key], newValue, newPath)\n        };\n    }\n    if (schema.kind === \"conditional\") {\n        const conditionalValue = value;\n        // replaceValueAtPropPath should not be used to only update the discriminant of a conditional field\n        // if you want to update the discriminant of a conditional field, replace the value of the whole conditional field\n        (0,emery_assertions__WEBPACK_IMPORTED_MODULE_0__.assert)(key === \"value\");\n        return {\n            discriminant: conditionalValue.discriminant,\n            value: replaceValueAtPropPath(schema.values[key], conditionalValue.value, newValue, newPath)\n        };\n    }\n    if (schema.kind === \"array\") {\n        const prevVal = value;\n        const newVal = [\n            ...prevVal\n        ];\n        setKeysForArrayValue(newVal, getKeysForArrayValue(prevVal));\n        newVal[key] = replaceValueAtPropPath(schema.element, newVal[key], newValue, newPath);\n        return newVal;\n    }\n    // we should never reach here since form or child fields don't contain other fields\n    // so the only thing that can happen to them is to be replaced which happens at the start of this function when path.length === 0\n    (0,emery_assertions__WEBPACK_IMPORTED_MODULE_0__.assert)(schema.kind !== \"form\" && schema.kind !== \"child\");\n    (0,emery_assertions__WEBPACK_IMPORTED_MODULE_0__.assertNever)(schema);\n}\n// a v important note\n// marks in the markdown ast/html are represented quite differently to how they are in slate\n// if you had the markdown **something https://keystonejs.com something**\n// the bold node is the parent of the link node\n// but in slate, marks are only represented on text nodes\nconst currentlyActiveMarks = new Set();\nconst currentlyDisabledMarks = new Set();\nlet currentLink = null;\nfunction addMarkToChildren(mark, cb) {\n    const wasPreviouslyActive = currentlyActiveMarks.has(mark);\n    currentlyActiveMarks.add(mark);\n    try {\n        return cb();\n    } finally{\n        if (!wasPreviouslyActive) {\n            currentlyActiveMarks.delete(mark);\n        }\n    }\n}\nfunction setLinkForChildren(href, cb) {\n    // we'll only use the outer link\n    if (currentLink !== null) {\n        return cb();\n    }\n    currentLink = href;\n    try {\n        return cb();\n    } finally{\n        currentLink = null;\n    }\n}\nfunction addMarksToChildren(marks, cb) {\n    const marksToRemove = new Set();\n    for (const mark of marks){\n        if (!currentlyActiveMarks.has(mark)) {\n            marksToRemove.add(mark);\n        }\n        currentlyActiveMarks.add(mark);\n    }\n    try {\n        return cb();\n    } finally{\n        for (const mark of marksToRemove){\n            currentlyActiveMarks.delete(mark);\n        }\n    }\n}\nfunction forceDisableMarkForChildren(mark, cb) {\n    const wasPreviouslyDisabled = currentlyDisabledMarks.has(mark);\n    currentlyDisabledMarks.add(mark);\n    try {\n        return cb();\n    } finally{\n        if (!wasPreviouslyDisabled) {\n            currentlyDisabledMarks.delete(mark);\n        }\n    }\n}\n/**\n * This type is more strict than `Element & { type: 'link'; }` because `children`\n * is constrained to only contain Text nodes. This can't be assumed generally around the editor\n * (because of potentially future inline components or nested links(which are normalized away but the editor needs to not break if it happens))\n * but where this type is used, we're only going to allow links to contain Text and that's important\n * so that we know a block will never be inside an inline because Slate gets unhappy when that happens\n * (really the link inline should probably be a mark rather than an inline,\n * non-void inlines are probably always bad but that would imply changing the document\n * structure which would be such unnecessary breakage)\n */ function getInlineNodes(text) {\n    const node = {\n        text\n    };\n    for (const mark of currentlyActiveMarks){\n        if (!currentlyDisabledMarks.has(mark)) {\n            node[mark] = true;\n        }\n    }\n    if (currentLink !== null) {\n        return [\n            {\n                text: \"\"\n            },\n            {\n                type: \"link\",\n                href: currentLink,\n                children: [\n                    node\n                ]\n            },\n            {\n                text: \"\"\n            }\n        ];\n    }\n    return [\n        node\n    ];\n}\nclass VariableChildFields extends Error {\n    constructor(){\n        super(\"There are a variable number of child fields\");\n    }\n}\nfunction findSingleChildField(schema) {\n    try {\n        const result = _findConstantChildFields(schema, [], new Set());\n        if (result.length === 1) {\n            return result[0];\n        }\n        return;\n    } catch (err) {\n        if (err instanceof VariableChildFields) {\n            return;\n        }\n        throw err;\n    }\n}\nfunction _findConstantChildFields(schema, path, seenSchemas) {\n    if (seenSchemas.has(schema)) {\n        return [];\n    }\n    seenSchemas.add(schema);\n    switch(schema.kind){\n        case \"form\":\n            return [];\n        case \"child\":\n            return [\n                {\n                    relativePath: path,\n                    options: schema.options,\n                    kind: \"child\"\n                }\n            ];\n        case \"conditional\":\n            {\n                if (couldContainChildField(schema)) {\n                    throw new VariableChildFields();\n                }\n                return [];\n            }\n        case \"array\":\n            {\n                if (schema.asChildTag) {\n                    const child = _findConstantChildFields(schema.element, [], seenSchemas);\n                    if (child.length > 1) {\n                        return [];\n                    }\n                    return [\n                        {\n                            kind: \"array\",\n                            asChildTag: schema.asChildTag,\n                            field: schema,\n                            relativePath: path,\n                            child: child[0]\n                        }\n                    ];\n                }\n                if (couldContainChildField(schema)) {\n                    throw new VariableChildFields();\n                }\n                return [];\n            }\n        case \"object\":\n            {\n                const paths = [];\n                for (const [key, value] of Object.entries(schema.fields)){\n                    paths.push(..._findConstantChildFields(value, path.concat(key), seenSchemas));\n                }\n                return paths;\n            }\n    }\n}\nfunction couldContainChildField(schema, seen = new Set()) {\n    if (seen.has(schema)) {\n        return false;\n    }\n    seen.add(schema);\n    switch(schema.kind){\n        case \"form\":\n            return false;\n        case \"child\":\n            return true;\n        case \"conditional\":\n            return Object.values(schema.values).some((value)=>couldContainChildField(value, seen));\n        case \"object\":\n            return Object.keys(schema.fields).some((key)=>couldContainChildField(schema.fields[key], seen));\n        case \"array\":\n            return couldContainChildField(schema.element, seen);\n    }\n}\nfunction inlineNodeFromMarkdoc(node) {\n    if (node.type === \"inline\") {\n        return inlineChildrenFromMarkdoc(node.children);\n    }\n    if (node.type === \"link\") {\n        return setLinkForChildren(node.attributes.href, ()=>inlineChildrenFromMarkdoc(node.children));\n    }\n    if (node.type === \"text\") {\n        return getInlineNodes(node.attributes.content);\n    }\n    if (node.type === \"strong\") {\n        return addMarkToChildren(\"bold\", ()=>inlineChildrenFromMarkdoc(node.children));\n    }\n    if (node.type === \"code\") {\n        return addMarkToChildren(\"code\", ()=>getInlineNodes(node.attributes.content));\n    }\n    if (node.type === \"em\") {\n        return addMarkToChildren(\"italic\", ()=>inlineChildrenFromMarkdoc(node.children));\n    }\n    if (node.type === \"s\") {\n        return addMarkToChildren(\"strikethrough\", ()=>inlineChildrenFromMarkdoc(node.children));\n    }\n    if (node.type === \"tag\") {\n        if (node.tag === \"u\") {\n            return addMarkToChildren(\"underline\", ()=>inlineChildrenFromMarkdoc(node.children));\n        }\n        if (node.tag === \"kbd\") {\n            return addMarkToChildren(\"keyboard\", ()=>inlineChildrenFromMarkdoc(node.children));\n        }\n        if (node.tag === \"sub\") {\n            return addMarkToChildren(\"subscript\", ()=>inlineChildrenFromMarkdoc(node.children));\n        }\n        if (node.tag === \"sup\") {\n            return addMarkToChildren(\"superscript\", ()=>inlineChildrenFromMarkdoc(node.children));\n        }\n    }\n    if (node.type === \"softbreak\") {\n        return getInlineNodes(\" \");\n    }\n    if (node.type === \"hardbreak\") {\n        return getInlineNodes(\"\\n\");\n    }\n    if (node.tag === \"component-inline-prop\" && Array.isArray(node.attributes.propPath) && node.attributes.propPath.every((x)=>typeof x === \"string\" || typeof x === \"number\")) {\n        return {\n            type: \"component-inline-prop\",\n            children: inlineFromMarkdoc(node.children),\n            propPath: node.attributes.propPath\n        };\n    }\n    throw new Error(`Unknown inline node type: ${node.type}`);\n}\nfunction inlineChildrenFromMarkdoc(nodes) {\n    return nodes.flatMap(inlineNodeFromMarkdoc);\n}\nfunction inlineFromMarkdoc(nodes) {\n    const transformedNodes = nodes.flatMap(inlineNodeFromMarkdoc);\n    const nextNodes = [];\n    let lastNode;\n    for (const [idx, node] of transformedNodes.entries()){\n        var _lastNode;\n        if (node.type === undefined && node.text === \"\" && ((_lastNode = lastNode) === null || _lastNode === void 0 ? void 0 : _lastNode.type) === undefined && idx !== transformedNodes.length - 1) {\n            continue;\n        }\n        nextNodes.push(node);\n        lastNode = node;\n    }\n    if (!nextNodes.length) {\n        nextNodes.push({\n            text: \"\"\n        });\n    }\n    return nextNodes;\n}\nfunction fromMarkdoc(node, componentBlocks) {\n    const nodes = node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks));\n    if (nodes.length === 0) {\n        return [\n            {\n                type: \"paragraph\",\n                children: [\n                    {\n                        text: \"\"\n                    }\n                ]\n            }\n        ];\n    }\n    if (nodes[nodes.length - 1].type !== \"paragraph\") {\n        nodes.push({\n            type: \"paragraph\",\n            children: [\n                {\n                    text: \"\"\n                }\n            ]\n        });\n    }\n    return nodes;\n}\nfunction fromMarkdocNode(node, componentBlocks) {\n    if (node.type === \"blockquote\") {\n        return {\n            type: \"blockquote\",\n            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n        };\n    }\n    if (node.type === \"fence\") {\n        const { language, content, ...rest } = node.attributes;\n        return {\n            type: \"code\",\n            children: [\n                {\n                    text: content.replace(/\\n$/, \"\")\n                }\n            ],\n            ...typeof language === \"string\" ? {\n                language\n            } : {},\n            ...rest\n        };\n    }\n    if (node.type === \"heading\") {\n        return {\n            ...node.attributes,\n            level: node.attributes.level,\n            type: \"heading\",\n            children: inlineFromMarkdoc(node.children)\n        };\n    }\n    if (node.type === \"list\") {\n        return {\n            type: node.attributes.ordered ? \"ordered-list\" : \"unordered-list\",\n            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n        };\n    }\n    if (node.type === \"item\") {\n        var _node$children$;\n        const children = [\n            {\n                type: \"list-item-content\",\n                children: node.children.length ? inlineFromMarkdoc([\n                    node.children[0]\n                ]) : [\n                    {\n                        text: \"\"\n                    }\n                ]\n            }\n        ];\n        if (((_node$children$ = node.children[1]) === null || _node$children$ === void 0 ? void 0 : _node$children$.type) === \"list\") {\n            const list = node.children[1];\n            children.push({\n                type: list.attributes.ordered ? \"ordered-list\" : \"unordered-list\",\n                children: list.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n            });\n        }\n        return {\n            type: \"list-item\",\n            children\n        };\n    }\n    if (node.type === \"paragraph\") {\n        if (node.children.length === 1 && node.children[0].type === \"inline\" && node.children[0].children.length === 1 && node.children[0].children[0].type === \"image\") {\n            var _image$attributes$tit;\n            const image = node.children[0].children[0];\n            return {\n                type: \"image\",\n                src: decodeURI(image.attributes.src),\n                alt: image.attributes.alt,\n                title: (_image$attributes$tit = image.attributes.title) !== null && _image$attributes$tit !== void 0 ? _image$attributes$tit : \"\",\n                children: [\n                    {\n                        text: \"\"\n                    }\n                ]\n            };\n        }\n        const children = inlineFromMarkdoc(node.children);\n        if (children.length === 1 && children[0].type === \"component-inline-prop\") {\n            return children[0];\n        }\n        return {\n            type: \"paragraph\",\n            children,\n            textAlign: node.attributes.textAlign\n        };\n    }\n    if (node.type === \"hr\") {\n        return {\n            type: \"divider\",\n            children: [\n                {\n                    text: \"\"\n                }\n            ]\n        };\n    }\n    if (node.type === \"table\") {\n        return {\n            type: \"table\",\n            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n        };\n    }\n    if (node.type === \"tbody\") {\n        return {\n            type: \"table-body\",\n            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n        };\n    }\n    if (node.type === \"thead\") {\n        if (!node.children.length) return [];\n        return {\n            type: \"table-head\",\n            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n        };\n    }\n    if (node.type === \"tr\") {\n        return {\n            type: \"table-row\",\n            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n        };\n    }\n    if (node.type === \"td\") {\n        return {\n            type: \"table-cell\",\n            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n        };\n    }\n    if (node.type === \"th\") {\n        return {\n            type: \"table-cell\",\n            header: true,\n            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n        };\n    }\n    if (node.type === \"tag\") {\n        if (node.tag === \"table\") {\n            return fromMarkdocNode(node.children[0], componentBlocks);\n        }\n        if (node.tag === \"layout\") {\n            return {\n                type: \"layout\",\n                layout: node.attributes.layout,\n                children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n            };\n        }\n        if (node.tag === \"layout-area\") {\n            return {\n                type: \"layout-area\",\n                children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n            };\n        }\n        if (node.tag === \"component-block\") {\n            return {\n                type: \"component-block\",\n                component: node.attributes.component,\n                props: node.attributes.props,\n                children: node.children.length === 0 ? [\n                    {\n                        type: \"component-inline-prop\",\n                        children: [\n                            {\n                                text: \"\"\n                            }\n                        ]\n                    }\n                ] : node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n            };\n        }\n        if (node.tag === \"component-block-prop\" && Array.isArray(node.attributes.propPath) && node.attributes.propPath.every((x)=>typeof x === \"string\" || typeof x === \"number\")) {\n            return {\n                type: \"component-block-prop\",\n                children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks)),\n                propPath: node.attributes.propPath\n            };\n        }\n        if (node.tag) {\n            const componentBlock = componentBlocks[node.tag];\n            if (componentBlock) {\n                const singleChildField = findSingleChildField({\n                    kind: \"object\",\n                    fields: componentBlock.schema\n                });\n                if (singleChildField) {\n                    const newAttributes = JSON.parse(JSON.stringify(node.attributes));\n                    const children = [];\n                    toChildrenAndProps$1(node.children, children, newAttributes, singleChildField, [], componentBlocks);\n                    return {\n                        type: \"component-block\",\n                        component: node.tag,\n                        props: newAttributes,\n                        children\n                    };\n                }\n                return {\n                    type: \"component-block\",\n                    component: node.tag,\n                    props: node.attributes,\n                    children: node.children.length === 0 ? [\n                        {\n                            type: \"component-inline-prop\",\n                            children: [\n                                {\n                                    text: \"\"\n                                }\n                            ]\n                        }\n                    ] : node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n                };\n            }\n        }\n        throw new Error(`Unknown tag: ${node.tag}`);\n    }\n    return inlineNodeFromMarkdoc(node);\n}\nfunction toChildrenAndProps$1(fromMarkdoc, resultingChildren, value, singleChildField, parentPropPath, componentBlocks) {\n    if (singleChildField.kind === \"child\") {\n        const children = fromMarkdoc.flatMap((x)=>fromMarkdocNode(x, componentBlocks));\n        resultingChildren.push({\n            type: `component-${singleChildField.options.kind}-prop`,\n            propPath: [\n                ...parentPropPath,\n                ...singleChildField.relativePath\n            ],\n            children\n        });\n    }\n    if (singleChildField.kind === \"array\") {\n        const arr = [];\n        for (let [idx, child] of fromMarkdoc.entries()){\n            if (child.type === \"paragraph\") {\n                child = child.children[0].children[0];\n            }\n            if (child.type !== \"tag\") {\n                throw new Error(`expected tag ${singleChildField.asChildTag}, found type: ${child.type}`);\n            }\n            if (child.tag !== singleChildField.asChildTag) {\n                throw new Error(`expected tag ${singleChildField.asChildTag}, found tag: ${child.tag}`);\n            }\n            const attributes = JSON.parse(JSON.stringify(child.attributes));\n            if (singleChildField.child) {\n                toChildrenAndProps$1(child.children, resultingChildren, attributes, singleChildField.child, [\n                    ...parentPropPath,\n                    ...singleChildField.relativePath,\n                    idx\n                ], componentBlocks);\n            }\n            arr.push(attributes);\n        }\n        const key = singleChildField.relativePath[singleChildField.relativePath.length - 1];\n        const parent = getValueAtPropPath(value, singleChildField.relativePath.slice(0, -1));\n        parent[key] = arr;\n    }\n}\nfunction areArraysEqual(a, b) {\n    return a.length === b.length && a.every((x, i)=>x === b[i]);\n}\nfunction normalizeTextBasedOnInlineMarksAndSoftBreaks([node, path], editor, inlineMarks, softBreaks) {\n    const marksToRemove = Object.keys(node).filter((x)=>x !== \"text\" && x !== \"insertMenu\" && inlineMarks[x] !== true);\n    if (marksToRemove.length) {\n        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unsetNodes(editor, marksToRemove, {\n            at: path\n        });\n        return true;\n    }\n    if (!softBreaks) {\n        const hasSoftBreaks = node.text.includes(\"\\n\");\n        if (hasSoftBreaks) {\n            const [parentNode] = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.parent(editor, path);\n            if (parentNode.type !== \"code\") {\n                for (const position of slate__WEBPACK_IMPORTED_MODULE_6__.Editor.positions(editor, {\n                    at: path\n                })){\n                    const character = slate__WEBPACK_IMPORTED_MODULE_6__.Node.get(editor, position.path).text[position.offset];\n                    if (character === \"\\n\") {\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.delete(editor, {\n                            at: position\n                        });\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\nfunction normalizeInlineBasedOnLinks([node, path], editor, links) {\n    if (node.type === \"link\" && !links) {\n        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.insertText(editor, ` (${node.href})`, {\n            at: slate__WEBPACK_IMPORTED_MODULE_6__.Editor.end(editor, path)\n        });\n        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unwrapNodes(editor, {\n            at: path\n        });\n        return true;\n    }\n    return false;\n}\nfunction normalizeElementBasedOnDocumentFeatures([node, path], editor, { formatting, dividers, layouts, links, images, tables }) {\n    if (node.type === \"heading\" && (!formatting.headings.levels.length || !formatting.headings.levels.includes(node.level)) || node.type === \"ordered-list\" && !formatting.listTypes.ordered || node.type === \"unordered-list\" && !formatting.listTypes.unordered || node.type === \"code\" && !formatting.blockTypes.code || node.type === \"blockquote\" && !formatting.blockTypes.blockquote || node.type === \"image\" && !images || node.type === \"table\" && !tables || node.type === \"layout\" && (layouts.length === 0 || !layouts.some((layout)=>areArraysEqual(layout, node.layout)))) {\n        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unwrapNodes(editor, {\n            at: path\n        });\n        return true;\n    }\n    if ((node.type === \"paragraph\" || node.type === \"heading\") && (!formatting.alignment.center && node.textAlign === \"center\" || !formatting.alignment.end && node.textAlign === \"end\" || \"textAlign\" in node && node.textAlign !== \"center\" && node.textAlign !== \"end\")) {\n        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unsetNodes(editor, \"textAlign\", {\n            at: path\n        });\n        return true;\n    }\n    if (node.type === \"divider\" && !dividers) {\n        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n            at: path\n        });\n        return true;\n    }\n    return normalizeInlineBasedOnLinks([\n        node,\n        path\n    ], editor, links);\n}\nfunction withDocumentFeaturesNormalization(documentFeatures, editor) {\n    const { normalizeNode } = editor;\n    editor.normalizeNode = ([node, path])=>{\n        if (slate__WEBPACK_IMPORTED_MODULE_6__.Text.isText(node)) {\n            normalizeTextBasedOnInlineMarksAndSoftBreaks([\n                node,\n                path\n            ], editor, documentFeatures.formatting.inlineMarks, documentFeatures.formatting.softBreaks);\n        } else if (slate__WEBPACK_IMPORTED_MODULE_6__.Element.isElement(node)) {\n            normalizeElementBasedOnDocumentFeatures([\n                node,\n                path\n            ], editor, documentFeatures);\n        }\n        normalizeNode([\n            node,\n            path\n        ]);\n    };\n    return editor;\n}\nfunction getSrcPrefix(publicPath, slug) {\n    return typeof publicPath === \"string\" ? `${publicPath.replace(/\\/*$/, \"\")}/${slug === undefined ? \"\" : slug + \"/\"}` : \"\";\n}\nfunction deserializeFiles(nodes, componentBlocks, files, otherFiles, mode, documentFeatures, slug) {\n    return nodes.map((node)=>{\n        if (node.type === \"component-block\") {\n            const componentBlock = componentBlocks[node.component];\n            if (!componentBlock) return node;\n            const schema = object(componentBlock.schema);\n            return {\n                ...node,\n                props: deserializeProps(schema, node.props, files, otherFiles, mode, slug)\n            };\n        }\n        if (node.type === \"image\" && typeof node.src === \"string\" && mode === \"edit\") {\n            var _ref;\n            const prefix = getSrcPrefixForImageBlock(documentFeatures, slug);\n            const filename = node.src.slice(prefix.length);\n            const content = (_ref = typeof documentFeatures.images === \"object\" && typeof documentFeatures.images.directory === \"string\" ? otherFiles.get(fixPath(documentFeatures.images.directory)) : files) === null || _ref === void 0 ? void 0 : _ref.get(filename);\n            if (!content) {\n                return {\n                    type: \"paragraph\",\n                    children: [\n                        {\n                            text: `Missing image ${filename}`\n                        }\n                    ]\n                };\n            }\n            return {\n                type: \"image\",\n                src: {\n                    filename,\n                    content\n                },\n                alt: node.alt,\n                title: node.title,\n                children: [\n                    {\n                        text: \"\"\n                    }\n                ]\n            };\n        }\n        if (typeof node.type === \"string\") {\n            const children = deserializeFiles(node.children, componentBlocks, files, otherFiles, mode, documentFeatures, slug);\n            return {\n                ...node,\n                children\n            };\n        }\n        return node;\n    });\n}\nfunction deserializeProps(schema, value, files, otherFiles, mode, slug) {\n    return transformProps(schema, value, {\n        form: (schema, value)=>{\n            if (schema.formKind === \"asset\") {\n                var _otherFiles$get;\n                if (mode === \"read\") {\n                    return schema.reader.parse(value);\n                }\n                const filename = schema.filename(value, {\n                    slug,\n                    suggestedFilenamePrefix: undefined\n                });\n                return schema.parse(value, {\n                    asset: filename ? schema.directory ? (_otherFiles$get = otherFiles.get(schema.directory)) === null || _otherFiles$get === void 0 ? void 0 : _otherFiles$get.get(filename) : files.get(filename) : undefined,\n                    slug\n                });\n            }\n            if (schema.formKind === \"content\") {\n                throw new Error(\"Not implemented\");\n            }\n            if (mode === \"read\") {\n                return schema.reader.parse(value);\n            }\n            return schema.parse(value, undefined);\n        }\n    });\n}\nfunction getSrcPrefixForImageBlock(documentFeatures, slug) {\n    return getSrcPrefix(typeof documentFeatures.images === \"object\" ? documentFeatures.images.publicPath : undefined, slug);\n}\nfunction serializeProps(rootValue, rootSchema, // note you might have a slug without a slug field when serializing props inside a component block or etc. in the editor\nslugField, slug, shouldSuggestFilenamePrefix) {\n    const extraFiles = [];\n    return {\n        value: transformProps(rootSchema, rootValue, {\n            form (schema, value, propPath) {\n                if (propPath.length === 1 && slugField === propPath[0]) {\n                    if (schema.formKind !== \"slug\") {\n                        throw new Error(\"slugField is a not a slug field\");\n                    }\n                    return schema.serializeWithSlug(value).value;\n                }\n                if (schema.formKind === \"asset\") {\n                    const { asset, value: forYaml } = schema.serialize(value, {\n                        suggestedFilenamePrefix: shouldSuggestFilenamePrefix ? getPropPathPortion(propPath, rootSchema, rootValue) : undefined,\n                        slug\n                    });\n                    if (asset) {\n                        extraFiles.push({\n                            path: asset.filename,\n                            contents: asset.content,\n                            parent: schema.directory\n                        });\n                    }\n                    return forYaml;\n                }\n                if (schema.formKind === \"content\") {\n                    const { other, external, content, value: forYaml } = schema.serialize(value, {\n                        slug\n                    });\n                    if (content) {\n                        extraFiles.push({\n                            path: getPropPathPortion(propPath, rootSchema, rootValue) + schema.contentExtension,\n                            contents: content,\n                            parent: undefined\n                        });\n                    }\n                    for (const [key, contents] of other){\n                        extraFiles.push({\n                            path: getPropPathPortion(propPath, rootSchema, rootValue) + \"/\" + key,\n                            contents,\n                            parent: undefined\n                        });\n                    }\n                    const allowedDirectories = new Set(schema.directories);\n                    for (const [directory, contents] of external){\n                        if (!allowedDirectories.has(directory)) {\n                            throw new Error(`Invalid directory ${directory} in content field serialization`);\n                        }\n                        for (const [filename, fileContents] of contents){\n                            extraFiles.push({\n                                path: filename,\n                                contents: fileContents,\n                                parent: directory\n                            });\n                        }\n                    }\n                    return forYaml;\n                }\n                return schema.serialize(value).value;\n            },\n            object (_schema, value) {\n                return Object.fromEntries(Object.entries(value).filter(([_, val])=>val !== undefined));\n            },\n            array (_schema, value) {\n                return value.map((val)=>val === undefined ? null : val);\n            },\n            child () {\n                return undefined;\n            }\n        }),\n        extraFiles\n    };\n}\nfunction getPropPathPortion(path, schema, value) {\n    const end = [];\n    for (const portion of path){\n        if (schema.kind === \"array\") {\n            value = value[portion];\n            if (schema.slugField && schema.element.kind === \"object\") {\n                const slug = getSlugFromState({\n                    schema: schema.element.fields,\n                    slugField: schema.slugField\n                }, value);\n                end.push(slug);\n            } else {\n                end.push(portion);\n            }\n            schema = schema.element;\n            continue;\n        }\n        end.push(portion);\n        if (schema.kind === \"object\") {\n            value = value[portion];\n            schema = schema.fields[portion];\n            continue;\n        }\n        if (schema.kind === \"conditional\") {\n            if (portion === \"discriminant\") {\n                schema = schema.discriminant;\n            } else if (portion === \"value\") {\n                schema = schema.values[value.discriminant];\n            }\n            value = value[portion];\n            continue;\n        }\n        throw new Error(`unexpected ${schema.kind}`);\n    }\n    return end.join(\"/\");\n}\nconst { Ast } = _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_7__[\"default\"];\nfunction toInline(nodes) {\n    return new Ast.Node(\"inline\", {}, nodes.flatMap(toMarkdocInline));\n}\nconst markToMarkdoc = {\n    bold: {\n        type: \"strong\"\n    },\n    code: {\n        type: \"code\"\n    },\n    italic: {\n        type: \"em\"\n    },\n    underline: {\n        type: \"tag\",\n        tag: \"u\"\n    },\n    keyboard: {\n        type: \"tag\",\n        tag: \"kbd\"\n    },\n    strikethrough: {\n        type: \"s\"\n    },\n    subscript: {\n        type: \"tag\",\n        tag: \"sub\"\n    },\n    superscript: {\n        type: \"tag\",\n        tag: \"sup\"\n    }\n};\nfunction toMarkdocInline(node) {\n    var _exec, _exec2;\n    if (node.type === \"link\") {\n        return new Ast.Node(\"link\", {\n            href: node.href\n        }, node.children.flatMap(toMarkdocInline));\n    }\n    if (node.type !== undefined) {\n        throw new Error(`unexpected inline node type: ${node.type}`);\n    }\n    const marks = Object.keys(node).filter((mark)=>mark !== \"text\" && mark !== \"code\").sort();\n    const splitByNewLines = node.text.split(/\\n/);\n    if (splitByNewLines.length > 1) {\n        return splitByNewLines.flatMap((x, i)=>{\n            if (i === 0) {\n                return toMarkdocInline({\n                    ...node,\n                    text: x\n                });\n            }\n            const inner = toMarkdocInline({\n                ...node,\n                text: x\n            });\n            return [\n                new Ast.Node(\"hardbreak\"),\n                ...Array.isArray(inner) ? inner : [\n                    inner\n                ]\n            ];\n        });\n    }\n    const leadingWhitespace = (_exec = /^\\s+/.exec(node.text)) === null || _exec === void 0 ? void 0 : _exec[0];\n    const trailingWhitespace = (_exec2 = /\\s+$/.exec(node.text)) === null || _exec2 === void 0 ? void 0 : _exec2[0];\n    let children = node.code ? [\n        new Ast.Node(\"code\", {\n            content: node.text.trim()\n        }, [])\n    ] : [\n        new Ast.Node(\"text\", {\n            content: node.text.trim()\n        })\n    ];\n    for (const mark of marks){\n        const config = markToMarkdoc[mark];\n        if (config) {\n            children = [\n                new Ast.Node(config.type, {}, children, config.tag)\n            ];\n        }\n    }\n    if (/^\\s+$/.test(node.text)) {\n        children.unshift(new Ast.Node(\"text\", {\n            content: leadingWhitespace\n        }, []));\n    } else {\n        if (leadingWhitespace !== null && leadingWhitespace !== void 0 && leadingWhitespace.length) {\n            children.unshift(new Ast.Node(\"text\", {\n                content: leadingWhitespace\n            }, []));\n        }\n        if (trailingWhitespace !== null && trailingWhitespace !== void 0 && trailingWhitespace.length) {\n            children.push(new Ast.Node(\"text\", {\n                content: trailingWhitespace\n            }, []));\n        }\n    }\n    return children;\n}\nfunction toMarkdocDocument(nodes, _config) {\n    const extraFiles = [];\n    const config = {\n        ..._config,\n        extraFiles\n    };\n    const node = new Ast.Node(\"document\", {}, nodes.flatMap((x)=>toMarkdoc(x, config)));\n    return {\n        node,\n        extraFiles\n    };\n}\nfunction toChildrenAndProps(childrenAsMarkdoc, resultingChildren, value, singleChildField) {\n    if (singleChildField.kind === \"child\") {\n        const child = childrenAsMarkdoc.find((x)=>areArraysEqual(x.propPath, singleChildField.relativePath));\n        if (child) {\n            resultingChildren.push(...child.children);\n        }\n        return;\n    }\n    if (singleChildField.kind === \"array\") {\n        const key = singleChildField.relativePath[singleChildField.relativePath.length - 1];\n        const parent = getValueAtPropPath(value, singleChildField.relativePath.slice(0, -1));\n        const valueAtPropPath = parent[key];\n        delete parent[key];\n        const childNodes = new Map();\n        for (const child of childrenAsMarkdoc){\n            const innerPropPath = child.propPath.slice(singleChildField.relativePath.length + 1);\n            const num = child.propPath[singleChildField.relativePath.length];\n            if (childNodes.get(num) === undefined) {\n                childNodes.set(num, []);\n            }\n            childNodes.get(num).push({\n                children: child.children,\n                propPath: innerPropPath\n            });\n        }\n        resultingChildren.push(...valueAtPropPath.map((x, i)=>{\n            var _childNodes$get;\n            const newChildrenAsMarkdoc = (_childNodes$get = childNodes.get(i)) !== null && _childNodes$get !== void 0 ? _childNodes$get : [];\n            const children = [];\n            toChildrenAndProps(newChildrenAsMarkdoc, children, x, singleChildField.child);\n            return new Ast.Node(\"tag\", x, children, singleChildField.asChildTag);\n        }));\n    }\n}\nfunction toMarkdoc(node, config) {\n    if (node.type === \"paragraph\") {\n        const markdocNode = new Ast.Node(\"paragraph\", node.textAlign ? {\n            textAlign: node.textAlign\n        } : {}, [\n            toInline(node.children)\n        ]);\n        if (node.textAlign) {\n            markdocNode.annotations.push({\n                name: \"textAlign\",\n                value: node.textAlign,\n                type: \"attribute\"\n            });\n        }\n        return markdocNode;\n    }\n    if (node.type === \"image\") {\n        config.extraFiles.push({\n            contents: node.src.content,\n            path: node.src.filename,\n            parent: typeof config.documentFeatures.images === \"object\" && typeof config.documentFeatures.images.directory === \"string\" ? fixPath(config.documentFeatures.images.directory) : undefined\n        });\n        return new Ast.Node(\"paragraph\", {}, [\n            new Ast.Node(\"inline\", {}, [\n                new Ast.Node(\"image\", {\n                    src: encodeURI(`${getSrcPrefixForImageBlock(config.documentFeatures, config.slug)}${node.src.filename}`),\n                    alt: node.alt,\n                    title: node.title\n                })\n            ])\n        ]);\n    }\n    if (node.type === \"code\") {\n        const extraAttributes = {};\n        const { children, language, type, ...rest } = node;\n        const schema = typeof config.documentFeatures.formatting.blockTypes.code === \"object\" ? config.documentFeatures.formatting.blockTypes.code.schema : undefined;\n        if (schema && Object.keys(schema.fields).length > 0) {\n            const serialized = serializeProps(getInitialPropsValueFromInitializer(schema, rest), schema, undefined, config.slug, false);\n            Object.assign(extraAttributes, serialized.value);\n            config.extraFiles.push(...serialized.extraFiles);\n        }\n        let content = children[0].text + \"\\n\";\n        const markdocNode = new Ast.Node(\"fence\", {\n            content,\n            language,\n            ...extraAttributes\n        }, [\n            new Ast.Node(\"text\", {\n                content\n            })\n        ]);\n        for (const [key, value] of Object.entries(extraAttributes)){\n            markdocNode.annotations.push({\n                name: key,\n                value,\n                type: \"attribute\"\n            });\n        }\n        return markdocNode;\n    }\n    const _toMarkdoc = (node)=>toMarkdoc(node, config);\n    if (node.type === \"blockquote\") {\n        return new Ast.Node(\"blockquote\", {}, node.children.map(_toMarkdoc));\n    }\n    if (node.type === \"divider\") {\n        return new Ast.Node(\"hr\");\n    }\n    if (node.type === \"table\") {\n        const head = node.children.find((x)=>x.type === \"table-head\");\n        return new Ast.Node(\"tag\", {}, [\n            new Ast.Node(\"table\", {}, [\n                new Ast.Node(\"thead\", {}, head ? head.children.map(_toMarkdoc) : []),\n                _toMarkdoc(node.children.find((x)=>x.type === \"table-body\"))\n            ])\n        ], \"table\");\n    }\n    if (node.type === \"table-body\") {\n        return new Ast.Node(\"tbody\", {}, node.children.map(_toMarkdoc));\n    }\n    if (node.type === \"table-row\") {\n        return new Ast.Node(\"tr\", {}, node.children.map(_toMarkdoc));\n    }\n    if (node.type === \"table-cell\") {\n        return new Ast.Node(node.header ? \"th\" : \"td\", {}, node.children.map(_toMarkdoc));\n    }\n    if (node.type === \"heading\") {\n        const extraAttributes = {};\n        if (node.textAlign) {\n            extraAttributes.textAlign = node.textAlign;\n        }\n        const { children, level, textAlign, type, ...rest } = node;\n        const schema = config.documentFeatures.formatting.headings.schema;\n        if (Object.keys(schema.fields).length > 0) {\n            Object.assign(extraAttributes, serializeProps(getInitialPropsValueFromInitializer(schema, rest), schema, undefined, config.slug, false).value);\n        }\n        const markdocNode = new Ast.Node(\"heading\", {\n            level: node.level,\n            ...extraAttributes\n        }, [\n            toInline(node.children)\n        ]);\n        for (const [key, value] of Object.entries(extraAttributes)){\n            markdocNode.annotations.push({\n                name: key,\n                value,\n                type: \"attribute\"\n            });\n        }\n        return markdocNode;\n    }\n    if (node.type === \"ordered-list\") {\n        return new Ast.Node(\"list\", {\n            ordered: true\n        }, node.children.map(_toMarkdoc));\n    }\n    if (node.type === \"unordered-list\") {\n        return new Ast.Node(\"list\", {\n            ordered: false\n        }, node.children.map(_toMarkdoc));\n    }\n    if (node.type === \"layout\") {\n        return new Ast.Node(\"tag\", {\n            layout: node.layout\n        }, node.children.map(_toMarkdoc), \"layout\");\n    }\n    if (node.type === \"layout-area\") {\n        return new Ast.Node(\"tag\", {}, node.children.flatMap(_toMarkdoc), \"layout-area\");\n    }\n    if (node.type === \"component-block\") {\n        const isVoid = node.children.length === 1 && node.children[0].type === \"component-inline-prop\" && node.children[0].propPath === undefined;\n        const componentBlock = config.componentBlocks[node.component];\n        const childrenAsMarkdoc = [];\n        for (const child of node.children){\n            if ((child.type === \"component-block-prop\" || child.type === \"component-inline-prop\") && child.propPath !== undefined) {\n                childrenAsMarkdoc.push({\n                    type: child.type,\n                    propPath: child.propPath,\n                    children: child.type === \"component-block-prop\" ? child.children.flatMap(_toMarkdoc) : [\n                        toInline(child.children)\n                    ]\n                });\n            }\n        }\n        let attributes = node.props;\n        if (componentBlock) {\n            const serialized = serializeProps(node.props, {\n                kind: \"object\",\n                fields: componentBlock.schema\n            }, undefined, config.slug, false);\n            attributes = serialized.value;\n            config.extraFiles.push(...serialized.extraFiles);\n            const singleChildField = findSingleChildField({\n                kind: \"object\",\n                fields: componentBlock.schema\n            });\n            if (singleChildField) {\n                const children = [];\n                toChildrenAndProps(childrenAsMarkdoc, children, attributes, singleChildField);\n                return new Ast.Node(\"tag\", attributes, children, node.component);\n            }\n        }\n        const children = isVoid ? [] : childrenAsMarkdoc.map((x)=>new Ast.Node(\"tag\", {\n                propPath: x.propPath\n            }, x.children, x.type));\n        return new Ast.Node(\"tag\", attributes, children, node.component);\n    }\n    if (node.type === \"component-block-prop\" || node.type === \"component-inline-prop\") {\n        return new Ast.Node(\"tag\", {\n            propPath: node.propPath\n        }, node.type === \"component-inline-prop\" ? [\n            toInline(node.children)\n        ] : node.children.flatMap(_toMarkdoc), node.type);\n    }\n    if (node.type === \"list-item\") {\n        const listItemContent = node.children[0];\n        if (listItemContent.type !== \"list-item-content\") {\n            throw new Error(\"list item content must contain a list-item-content\");\n        }\n        const inline = toInline(listItemContent.children);\n        const children = [\n            inline\n        ];\n        const nestedList = node.children[1];\n        if (nestedList) {\n            children.push(toMarkdoc(nestedList, config));\n        }\n        return new Ast.Node(\"item\", {}, children);\n    }\n    if (node.type === \"list-item-content\") {\n        throw new Error(\"list-item-content in unexpected position\");\n    }\n    debugger;\n    throw new Error(`unexpected node type: ${node.type}`);\n}\nfunction validateText(val, min, max, fieldLabel, slugInfo) {\n    if (val.length < min) {\n        if (min === 1) {\n            return `${fieldLabel} must not be empty`;\n        } else {\n            return `${fieldLabel} must be at least ${min} characters long`;\n        }\n    }\n    if (val.length > max) {\n        return `${fieldLabel} must be no longer than ${max} characters`;\n    }\n    if (slugInfo) {\n        if (val === \"\") {\n            return `${fieldLabel} must not be empty`;\n        }\n        if (val === \"..\") {\n            return `${fieldLabel} must not be ..`;\n        }\n        if (val === \".\") {\n            return `${fieldLabel} must not be .`;\n        }\n        if (slugInfo.glob === \"**\") {\n            const split = val.split(\"/\");\n            if (split.some((s)=>s === \"..\")) {\n                return `${fieldLabel} must not contain ..`;\n            }\n            if (split.some((s)=>s === \".\")) {\n                return `${fieldLabel} must not be .`;\n            }\n        }\n        if ((slugInfo.glob === \"*\" ? /[\\\\/]/ : /[\\\\]/).test(val)) {\n            return `${fieldLabel} must not contain slashes`;\n        }\n        if (/^\\s|\\s$/.test(val)) {\n            return `${fieldLabel} must not start or end with spaces`;\n        }\n        if (slugInfo.slugs.has(val)) {\n            return `${fieldLabel} must be unique`;\n        }\n    }\n}\nfunction parseAsNormalField(value) {\n    if (value === undefined) {\n        return \"\";\n    }\n    if (typeof value !== \"string\") {\n        throw new FieldDataError(\"Must be a string\");\n    }\n    return value;\n}\nconst emptySet = new Set();\nfunction text({ label, defaultValue = \"\", validation: { length: { max = Infinity, min = 0 } = {} } = {}, description, multiline = false }) {\n    function validate(value, slugField) {\n        const message = validateText(value, min, max, label, slugField);\n        if (message !== undefined) {\n            throw new FieldDataError(message);\n        }\n        return value;\n    }\n    return {\n        kind: \"form\",\n        formKind: \"slug\",\n        label,\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(TextFieldInput, {\n                label: label,\n                description: description,\n                min: min,\n                max: max,\n                multiline: multiline,\n                ...props\n            });\n        },\n        defaultValue () {\n            return typeof defaultValue === \"string\" ? defaultValue : defaultValue();\n        },\n        parse (value, args) {\n            if ((args === null || args === void 0 ? void 0 : args.slug) !== undefined) {\n                return args.slug;\n            }\n            return parseAsNormalField(value);\n        },\n        serialize (value) {\n            return {\n                value: value === \"\" ? undefined : value\n            };\n        },\n        serializeWithSlug (value) {\n            return {\n                slug: value,\n                value: undefined\n            };\n        },\n        reader: {\n            parse (value) {\n                const parsed = parseAsNormalField(value);\n                return validate(parsed, undefined);\n            },\n            parseWithSlug (_value, args) {\n                validate(parseAsNormalField(args.slug), {\n                    glob: args.glob,\n                    slugs: emptySet\n                });\n                return null;\n            }\n        },\n        validate (value, args) {\n            return validate(value, args === null || args === void 0 ? void 0 : args.slugField);\n        }\n    };\n}\n/* eslint-disable */ globalThis.Prism = {\n    manual: true\n};\n/* **********************************************\n     Begin prism-core.js\n********************************************** */ /// <reference lib=\"WebWorker\"/>\nvar _self = globalThis;\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n * @namespace\n * @public\n */ var Prism = function(_self) {\n    // Private helper vars\n    var lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\n    var uniqueId = 0;\n    // The grammar object for plaintext\n    var plainTextGrammar = {};\n    var _ = {\n        /**\n     * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the\n     * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load\n     * additional languages or plugins yourself.\n     *\n     * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.\n     *\n     * You obviously have to change this value before the automatic highlighting started. To do this, you can add an\n     * empty Prism object into the global scope before loading the Prism script like this:\n     *\n     * ```js\n     * window.Prism = window.Prism || {};\n     * Prism.manual = true;\n     * // add a new <script> to load Prism's script\n     * ```\n     *\n     * @default false\n     * @type {boolean}\n     * @memberof Prism\n     * @public\n     */ manual: _self.Prism && _self.Prism.manual,\n        /**\n     * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses\n     * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your\n     * own worker, you don't want it to do this.\n     *\n     * By setting this value to `true`, Prism will not add its own listeners to the worker.\n     *\n     * You obviously have to change this value before Prism executes. To do this, you can add an\n     * empty Prism object into the global scope before loading the Prism script like this:\n     *\n     * ```js\n     * window.Prism = window.Prism || {};\n     * Prism.disableWorkerMessageHandler = true;\n     * // Load Prism's script\n     * ```\n     *\n     * @default false\n     * @type {boolean}\n     * @memberof Prism\n     * @public\n     */ disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,\n        /**\n     * A namespace for utility methods.\n     *\n     * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n     * change or disappear at any time.\n     *\n     * @namespace\n     * @memberof Prism\n     */ util: {\n            encode: function encode(tokens) {\n                if (tokens instanceof Token) {\n                    return new Token(tokens.type, encode(tokens.content), tokens.alias);\n                } else if (Array.isArray(tokens)) {\n                    return tokens.map(encode);\n                } else {\n                    return tokens.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/\\u00a0/g, \" \");\n                }\n            },\n            /**\n       * Returns the name of the type of the given value.\n       *\n       * @param {any} o\n       * @returns {string}\n       * @example\n       * type(null)      === 'Null'\n       * type(undefined) === 'Undefined'\n       * type(123)       === 'Number'\n       * type('foo')     === 'String'\n       * type(true)      === 'Boolean'\n       * type([1, 2])    === 'Array'\n       * type({})        === 'Object'\n       * type(String)    === 'Function'\n       * type(/abc+/)    === 'RegExp'\n       */ type: function(o) {\n                return Object.prototype.toString.call(o).slice(8, -1);\n            },\n            /**\n       * Returns a unique number for the given object. Later calls will still return the same number.\n       *\n       * @param {Object} obj\n       * @returns {number}\n       */ objId: function(obj) {\n                if (!obj[\"__id\"]) {\n                    Object.defineProperty(obj, \"__id\", {\n                        value: ++uniqueId\n                    });\n                }\n                return obj[\"__id\"];\n            },\n            /**\n       * Creates a deep clone of the given object.\n       *\n       * The main intended use of this function is to clone language definitions.\n       *\n       * @param {T} o\n       * @param {Record<number, any>} [visited]\n       * @returns {T}\n       * @template T\n       */ clone: function deepClone(o, visited) {\n                visited = visited || {};\n                var clone;\n                var id;\n                switch(_.util.type(o)){\n                    case \"Object\":\n                        id = _.util.objId(o);\n                        if (visited[id]) {\n                            return visited[id];\n                        }\n                        clone = /** @type {Record<string, any>} */ {};\n                        visited[id] = clone;\n                        for(var key in o){\n                            if (o.hasOwnProperty(key)) {\n                                clone[key] = deepClone(o[key], visited);\n                            }\n                        }\n                        return /** @type {any} */ clone;\n                    case \"Array\":\n                        id = _.util.objId(o);\n                        if (visited[id]) {\n                            return visited[id];\n                        }\n                        clone = [];\n                        visited[id] = clone;\n                        /** @type {Array} */ /** @type {any} */ o.forEach(function(v, i) {\n                            clone[i] = deepClone(v, visited);\n                        });\n                        return /** @type {any} */ clone;\n                    default:\n                        return o;\n                }\n            },\n            /**\n       * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n       *\n       * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n       *\n       * @param {Element} element\n       * @returns {string}\n       */ getLanguage: function(element) {\n                while(element){\n                    var m = lang.exec(element.className);\n                    if (m) {\n                        return m[1].toLowerCase();\n                    }\n                    element = element.parentElement;\n                }\n                return \"none\";\n            },\n            /**\n       * Sets the Prism `language-xxxx` class of the given element.\n       *\n       * @param {Element} element\n       * @param {string} language\n       * @returns {void}\n       */ setLanguage: function(element, language) {\n                // remove all `language-xxxx` classes\n                // (this might leave behind a leading space)\n                element.className = element.className.replace(RegExp(lang, \"gi\"), \"\");\n                // add the new `language-xxxx` class\n                // (using `classList` will automatically clean up spaces for us)\n                element.classList.add(\"language-\" + language);\n            },\n            /**\n       * Returns the script element that is currently executing.\n       *\n       * This does __not__ work for line script element.\n       *\n       * @returns {HTMLScriptElement | null}\n       */ currentScript: function() {\n                if (typeof document === \"undefined\") {\n                    return null;\n                }\n                if (\"currentScript\" in document && 1 < 2 /* hack to trip TS' flow analysis */ ) {\n                    return /** @type {any} */ document.currentScript;\n                }\n                // IE11 workaround\n                // we'll get the src of the current script by parsing IE11's error stack trace\n                // this will not work for inline scripts\n                try {\n                    throw new Error();\n                } catch (err) {\n                    // Get file src url from stack. Specifically works with the format of stack traces in IE.\n                    // A stack will look like this:\n                    //\n                    // Error\n                    //    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)\n                    //    at Global code (http://localhost/components/prism-core.js:606:1)\n                    var src = (/at [^(\\r\\n]*\\((.*):[^:]+:[^:]+\\)$/i.exec(err.stack) || [])[1];\n                    if (src) {\n                        var scripts = document.getElementsByTagName(\"script\");\n                        for(var i in scripts){\n                            if (scripts[i].src == src) {\n                                return scripts[i];\n                            }\n                        }\n                    }\n                    return null;\n                }\n            },\n            /**\n       * Returns whether a given class is active for `element`.\n       *\n       * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n       * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n       * given class is just the given class with a `no-` prefix.\n       *\n       * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n       * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n       * ancestors have the given class or the negated version of it, then the default activation will be returned.\n       *\n       * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n       * version of it, the class is considered active.\n       *\n       * @param {Element} element\n       * @param {string} className\n       * @param {boolean} [defaultActivation=false]\n       * @returns {boolean}\n       */ isActive: function(element, className, defaultActivation) {\n                var no = \"no-\" + className;\n                while(element){\n                    var classList = element.classList;\n                    if (classList.contains(className)) {\n                        return true;\n                    }\n                    if (classList.contains(no)) {\n                        return false;\n                    }\n                    element = element.parentElement;\n                }\n                return !!defaultActivation;\n            }\n        },\n        /**\n     * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n     *\n     * @namespace\n     * @memberof Prism\n     * @public\n     */ languages: {\n            /**\n       * The grammar for plain, unformatted text.\n       */ plain: plainTextGrammar,\n            plaintext: plainTextGrammar,\n            text: plainTextGrammar,\n            txt: plainTextGrammar,\n            /**\n       * Creates a deep copy of the language with the given id and appends the given tokens.\n       *\n       * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n       * will be overwritten at its original position.\n       *\n       * ## Best practices\n       *\n       * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n       * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n       * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n       *\n       * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n       * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n       *\n       * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n       * @param {Grammar} redef The new tokens to append.\n       * @returns {Grammar} The new language created.\n       * @public\n       * @example\n       * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n       *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n       *     // at its original position\n       *     'comment': { ... },\n       *     // CSS doesn't have a 'color' token, so this token will be appended\n       *     'color': /\\b(?:red|green|blue)\\b/\n       * });\n       */ extend: function(id, redef) {\n                var lang = _.util.clone(_.languages[id]);\n                for(var key in redef){\n                    lang[key] = redef[key];\n                }\n                return lang;\n            },\n            /**\n       * Inserts tokens _before_ another token in a language definition or any other grammar.\n       *\n       * ## Usage\n       *\n       * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n       * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n       * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n       * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n       * this:\n       *\n       * ```js\n       * Prism.languages.markup.style = {\n       *     // token\n       * };\n       * ```\n       *\n       * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n       * before existing tokens. For the CSS example above, you would use it like this:\n       *\n       * ```js\n       * Prism.languages.insertBefore('markup', 'cdata', {\n       *     'style': {\n       *         // token\n       *     }\n       * });\n       * ```\n       *\n       * ## Special cases\n       *\n       * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n       * will be ignored.\n       *\n       * This behavior can be used to insert tokens after `before`:\n       *\n       * ```js\n       * Prism.languages.insertBefore('markup', 'comment', {\n       *     'comment': Prism.languages.markup.comment,\n       *     // tokens after 'comment'\n       * });\n       * ```\n       *\n       * ## Limitations\n       *\n       * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n       * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n       * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n       * deleting properties which is necessary to insert at arbitrary positions.\n       *\n       * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n       * Instead, it will create a new object and replace all references to the target object with the new one. This\n       * can be done without temporarily deleting properties, so the iteration order is well-defined.\n       *\n       * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n       * you hold the target object in a variable, then the value of the variable will not change.\n       *\n       * ```js\n       * var oldMarkup = Prism.languages.markup;\n       * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n       *\n       * assert(oldMarkup !== Prism.languages.markup);\n       * assert(newMarkup === Prism.languages.markup);\n       * ```\n       *\n       * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n       * object to be modified.\n       * @param {string} before The key to insert before.\n       * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n       * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n       * object to be modified.\n       *\n       * Defaults to `Prism.languages`.\n       * @returns {Grammar} The new grammar object.\n       * @public\n       */ insertBefore: function(inside, before, insert, root) {\n                root = root || /** @type {any} */ _.languages;\n                var grammar = root[inside];\n                /** @type {Grammar} */ var ret = {};\n                for(var token in grammar){\n                    if (grammar.hasOwnProperty(token)) {\n                        if (token == before) {\n                            for(var newToken in insert){\n                                if (insert.hasOwnProperty(newToken)) {\n                                    ret[newToken] = insert[newToken];\n                                }\n                            }\n                        }\n                        // Do not insert token which also occur in insert. See #1525\n                        if (!insert.hasOwnProperty(token)) {\n                            ret[token] = grammar[token];\n                        }\n                    }\n                }\n                var old = root[inside];\n                root[inside] = ret;\n                // Update references in other language definitions\n                _.languages.DFS(_.languages, function(key, value) {\n                    if (value === old && key != inside) {\n                        this[key] = ret;\n                    }\n                });\n                return ret;\n            },\n            // Traverse a language definition with Depth First Search\n            DFS: function DFS(o, callback, type, visited) {\n                visited = visited || {};\n                var objId = _.util.objId;\n                for(var i in o){\n                    if (o.hasOwnProperty(i)) {\n                        callback.call(o, i, o[i], type || i);\n                        var property = o[i];\n                        var propertyType = _.util.type(property);\n                        if (propertyType === \"Object\" && !visited[objId(property)]) {\n                            visited[objId(property)] = true;\n                            DFS(property, callback, null, visited);\n                        } else if (propertyType === \"Array\" && !visited[objId(property)]) {\n                            visited[objId(property)] = true;\n                            DFS(property, callback, i, visited);\n                        }\n                    }\n                }\n            }\n        },\n        plugins: {},\n        /**\n     * This is the most high-level function in Prism’s API.\n     * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on\n     * each one of them.\n     *\n     * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.\n     *\n     * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.\n     * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.\n     * @memberof Prism\n     * @public\n     */ highlightAll: function(async, callback) {\n            _.highlightAllUnder(document, async, callback);\n        },\n        /**\n     * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls\n     * {@link Prism.highlightElement} on each one of them.\n     *\n     * The following hooks will be run:\n     * 1. `before-highlightall`\n     * 2. `before-all-elements-highlight`\n     * 3. All hooks of {@link Prism.highlightElement} for each element.\n     *\n     * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.\n     * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.\n     * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.\n     * @memberof Prism\n     * @public\n     */ highlightAllUnder: function(container, async, callback) {\n            var env = {\n                callback: callback,\n                container: container,\n                selector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n            };\n            _.hooks.run(\"before-highlightall\", env);\n            env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));\n            _.hooks.run(\"before-all-elements-highlight\", env);\n            for(var i = 0, element; element = env.elements[i++];){\n                _.highlightElement(element, async === true, env.callback);\n            }\n        },\n        /**\n     * Highlights the code inside a single element.\n     *\n     * The following hooks will be run:\n     * 1. `before-sanity-check`\n     * 2. `before-highlight`\n     * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.\n     * 4. `before-insert`\n     * 5. `after-highlight`\n     * 6. `complete`\n     *\n     * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for\n     * the element's language.\n     *\n     * @param {Element} element The element containing the code.\n     * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.\n     * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers\n     * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is\n     * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).\n     *\n     * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for\n     * asynchronous highlighting to work. You can build your own bundle on the\n     * [Download page](https://prismjs.com/download.html).\n     * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.\n     * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.\n     * @memberof Prism\n     * @public\n     */ highlightElement: function(element, async, callback) {\n            // Find language\n            var language = _.util.getLanguage(element);\n            var grammar = _.languages[language];\n            // Set language on the element, if not present\n            _.util.setLanguage(element, language);\n            // Set language on the parent, for styling\n            var parent = element.parentElement;\n            if (parent && parent.nodeName.toLowerCase() === \"pre\") {\n                _.util.setLanguage(parent, language);\n            }\n            var code = element.textContent;\n            var env = {\n                element: element,\n                language: language,\n                grammar: grammar,\n                code: code\n            };\n            function insertHighlightedCode(highlightedCode) {\n                env.highlightedCode = highlightedCode;\n                _.hooks.run(\"before-insert\", env);\n                env.element.innerHTML = env.highlightedCode;\n                _.hooks.run(\"after-highlight\", env);\n                _.hooks.run(\"complete\", env);\n                callback && callback.call(env.element);\n            }\n            _.hooks.run(\"before-sanity-check\", env);\n            // plugins may change/add the parent/element\n            parent = env.element.parentElement;\n            if (parent && parent.nodeName.toLowerCase() === \"pre\" && !parent.hasAttribute(\"tabindex\")) {\n                parent.setAttribute(\"tabindex\", \"0\");\n            }\n            if (!env.code) {\n                _.hooks.run(\"complete\", env);\n                callback && callback.call(env.element);\n                return;\n            }\n            _.hooks.run(\"before-highlight\", env);\n            if (!env.grammar) {\n                insertHighlightedCode(_.util.encode(env.code));\n                return;\n            }\n            if (async && _self.Worker) {\n                var worker = new Worker(_.filename);\n                worker.onmessage = function(evt) {\n                    insertHighlightedCode(evt.data);\n                };\n                worker.postMessage(JSON.stringify({\n                    language: env.language,\n                    code: env.code,\n                    immediateClose: true\n                }));\n            } else {\n                insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));\n            }\n        },\n        /**\n     * Low-level function, only use if you know what you’re doing. It accepts a string of text as input\n     * and the language definitions to use, and returns a string with the HTML produced.\n     *\n     * The following hooks will be run:\n     * 1. `before-tokenize`\n     * 2. `after-tokenize`\n     * 3. `wrap`: On each {@link Token}.\n     *\n     * @param {string} text A string with the code to be highlighted.\n     * @param {Grammar} grammar An object containing the tokens to use.\n     *\n     * Usually a language definition like `Prism.languages.markup`.\n     * @param {string} language The name of the language definition passed to `grammar`.\n     * @returns {string} The highlighted HTML.\n     * @memberof Prism\n     * @public\n     * @example\n     * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n     */ highlight: function(text, grammar, language) {\n            var env = {\n                code: text,\n                grammar: grammar,\n                language: language\n            };\n            _.hooks.run(\"before-tokenize\", env);\n            if (!env.grammar) {\n                throw new Error('The language \"' + env.language + '\" has no grammar.');\n            }\n            env.tokens = _.tokenize(env.code, env.grammar);\n            _.hooks.run(\"after-tokenize\", env);\n            return Token.stringify(_.util.encode(env.tokens), env.language);\n        },\n        /**\n     * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n     * and the language definitions to use, and returns an array with the tokenized code.\n     *\n     * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n     *\n     * This method could be useful in other contexts as well, as a very crude parser.\n     *\n     * @param {string} text A string with the code to be highlighted.\n     * @param {Grammar} grammar An object containing the tokens to use.\n     *\n     * Usually a language definition like `Prism.languages.markup`.\n     * @returns {TokenStream} An array of strings and tokens, a token stream.\n     * @memberof Prism\n     * @public\n     * @example\n     * let code = `var foo = 0;`;\n     * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n     * tokens.forEach(token => {\n     *     if (token instanceof Prism.Token && token.type === 'number') {\n     *         console.log(`Found numeric literal: ${token.content}`);\n     *     }\n     * });\n     */ tokenize: function(text, grammar) {\n            var rest = grammar.rest;\n            if (rest) {\n                for(var token in rest){\n                    grammar[token] = rest[token];\n                }\n                delete grammar.rest;\n            }\n            var tokenList = new LinkedList();\n            addAfter(tokenList, tokenList.head, text);\n            matchGrammar(text, tokenList, grammar, tokenList.head, 0);\n            return toArray(tokenList);\n        },\n        /**\n     * @namespace\n     * @memberof Prism\n     * @public\n     */ hooks: {\n            all: {},\n            /**\n       * Adds the given callback to the list of callbacks for the given hook.\n       *\n       * The callback will be invoked when the hook it is registered for is run.\n       * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n       *\n       * One callback function can be registered to multiple hooks and the same hook multiple times.\n       *\n       * @param {string} name The name of the hook.\n       * @param {HookCallback} callback The callback function which is given environment variables.\n       * @public\n       */ add: function(name, callback) {\n                var hooks = _.hooks.all;\n                hooks[name] = hooks[name] || [];\n                hooks[name].push(callback);\n            },\n            /**\n       * Runs a hook invoking all registered callbacks with the given environment variables.\n       *\n       * Callbacks will be invoked synchronously and in the order in which they were registered.\n       *\n       * @param {string} name The name of the hook.\n       * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n       * @public\n       */ run: function(name, env) {\n                var callbacks = _.hooks.all[name];\n                if (!callbacks || !callbacks.length) {\n                    return;\n                }\n                for(var i = 0, callback; callback = callbacks[i++];){\n                    callback(env);\n                }\n            }\n        },\n        Token: Token\n    };\n    _self.Prism = _;\n    // Typescript note:\n    // The following can be used to import the Token type in JSDoc:\n    //\n    //   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n    /**\n   * Creates a new token.\n   *\n   * @param {string} type See {@link Token#type type}\n   * @param {string | TokenStream} content See {@link Token#content content}\n   * @param {string|string[]} [alias] The alias(es) of the token.\n   * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n   * @class\n   * @global\n   * @public\n   */ function Token(type, content, alias, matchedStr) {\n        /**\n     * The type of the token.\n     *\n     * This is usually the key of a pattern in a {@link Grammar}.\n     *\n     * @type {string}\n     * @see GrammarToken\n     * @public\n     */ this.type = type;\n        /**\n     * The strings or tokens contained by this token.\n     *\n     * This will be a token stream if the pattern matched also defined an `inside` grammar.\n     *\n     * @type {string | TokenStream}\n     * @public\n     */ this.content = content;\n        /**\n     * The alias(es) of the token.\n     *\n     * @type {string|string[]}\n     * @see GrammarToken\n     * @public\n     */ this.alias = alias;\n        // Copy of the full string this token was created from\n        this.length = (matchedStr || \"\").length | 0;\n    }\n    /**\n   * A token stream is an array of strings and {@link Token Token} objects.\n   *\n   * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n   * them.\n   *\n   * 1. No adjacent strings.\n   * 2. No empty strings.\n   *\n   *    The only exception here is the token stream that only contains the empty string and nothing else.\n   *\n   * @typedef {Array<string | Token>} TokenStream\n   * @global\n   * @public\n   */ /**\n   * Converts the given token or token stream to an HTML representation.\n   *\n   * The following hooks will be run:\n   * 1. `wrap`: On each {@link Token}.\n   *\n   * @param {string | Token | TokenStream} o The token or token stream to be converted.\n   * @param {string} language The name of current language.\n   * @returns {string} The HTML representation of the token or token stream.\n   * @memberof Token\n   * @static\n   */ Token.stringify = function stringify(o, language) {\n        if (typeof o == \"string\") {\n            return o;\n        }\n        if (Array.isArray(o)) {\n            var s = \"\";\n            o.forEach(function(e) {\n                s += stringify(e, language);\n            });\n            return s;\n        }\n        var env = {\n            type: o.type,\n            content: stringify(o.content, language),\n            tag: \"span\",\n            classes: [\n                \"token\",\n                o.type\n            ],\n            attributes: {},\n            language: language\n        };\n        var aliases = o.alias;\n        if (aliases) {\n            if (Array.isArray(aliases)) {\n                Array.prototype.push.apply(env.classes, aliases);\n            } else {\n                env.classes.push(aliases);\n            }\n        }\n        _.hooks.run(\"wrap\", env);\n        var attributes = \"\";\n        for(var name in env.attributes){\n            attributes += \" \" + name + '=\"' + (env.attributes[name] || \"\").replace(/\"/g, \"&quot;\") + '\"';\n        }\n        return \"<\" + env.tag + ' class=\"' + env.classes.join(\" \") + '\"' + attributes + \">\" + env.content + \"</\" + env.tag + \">\";\n    };\n    /**\n   * @param {RegExp} pattern\n   * @param {number} pos\n   * @param {string} text\n   * @param {boolean} lookbehind\n   * @returns {RegExpExecArray | null}\n   */ function matchPattern(pattern, pos, text, lookbehind) {\n        pattern.lastIndex = pos;\n        var match = pattern.exec(text);\n        if (match && lookbehind && match[1]) {\n            // change the match to remove the text matched by the Prism lookbehind group\n            var lookbehindLength = match[1].length;\n            match.index += lookbehindLength;\n            match[0] = match[0].slice(lookbehindLength);\n        }\n        return match;\n    }\n    /**\n   * @param {string} text\n   * @param {LinkedList<string | Token>} tokenList\n   * @param {any} grammar\n   * @param {LinkedListNode<string | Token>} startNode\n   * @param {number} startPos\n   * @param {RematchOptions} [rematch]\n   * @returns {void}\n   * @private\n   *\n   * @typedef RematchOptions\n   * @property {string} cause\n   * @property {number} reach\n   */ function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n        for(var token in grammar){\n            if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n                continue;\n            }\n            var patterns = grammar[token];\n            patterns = Array.isArray(patterns) ? patterns : [\n                patterns\n            ];\n            for(var j = 0; j < patterns.length; ++j){\n                if (rematch && rematch.cause == token + \",\" + j) {\n                    return;\n                }\n                var patternObj = patterns[j];\n                var inside = patternObj.inside;\n                var lookbehind = !!patternObj.lookbehind;\n                var greedy = !!patternObj.greedy;\n                var alias = patternObj.alias;\n                if (greedy && !patternObj.pattern.global) {\n                    // Without the global flag, lastIndex won't work\n                    var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n                    patternObj.pattern = RegExp(patternObj.pattern.source, flags + \"g\");\n                }\n                /** @type {RegExp} */ var pattern = patternObj.pattern || patternObj;\n                for(// iterate the token list and keep track of the current token/string position\n                var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next){\n                    if (rematch && pos >= rematch.reach) {\n                        break;\n                    }\n                    var str = currentNode.value;\n                    if (tokenList.length > text.length) {\n                        // Something went terribly wrong, ABORT, ABORT!\n                        return;\n                    }\n                    if (str instanceof Token) {\n                        continue;\n                    }\n                    var removeCount = 1; // this is the to parameter of removeBetween\n                    var match;\n                    if (greedy) {\n                        match = matchPattern(pattern, pos, text, lookbehind);\n                        if (!match || match.index >= text.length) {\n                            break;\n                        }\n                        var from = match.index;\n                        var to = match.index + match[0].length;\n                        var p = pos;\n                        // find the node that contains the match\n                        p += currentNode.value.length;\n                        while(from >= p){\n                            currentNode = currentNode.next;\n                            p += currentNode.value.length;\n                        }\n                        // adjust pos (and p)\n                        p -= currentNode.value.length;\n                        pos = p;\n                        // the current node is a Token, then the match starts inside another Token, which is invalid\n                        if (currentNode.value instanceof Token) {\n                            continue;\n                        }\n                        // find the last node which is affected by this match\n                        for(var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === \"string\"); k = k.next){\n                            removeCount++;\n                            p += k.value.length;\n                        }\n                        removeCount--;\n                        // replace with the new match\n                        str = text.slice(pos, p);\n                        match.index -= pos;\n                    } else {\n                        match = matchPattern(pattern, 0, str, lookbehind);\n                        if (!match) {\n                            continue;\n                        }\n                    }\n                    // eslint-disable-next-line no-redeclare\n                    var from = match.index;\n                    var matchStr = match[0];\n                    var before = str.slice(0, from);\n                    var after = str.slice(from + matchStr.length);\n                    var reach = pos + str.length;\n                    if (rematch && reach > rematch.reach) {\n                        rematch.reach = reach;\n                    }\n                    var removeFrom = currentNode.prev;\n                    if (before) {\n                        removeFrom = addAfter(tokenList, removeFrom, before);\n                        pos += before.length;\n                    }\n                    removeRange(tokenList, removeFrom, removeCount);\n                    var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n                    currentNode = addAfter(tokenList, removeFrom, wrapped);\n                    if (after) {\n                        addAfter(tokenList, currentNode, after);\n                    }\n                    if (removeCount > 1) {\n                        // at least one Token object was removed, so we have to do some rematching\n                        // this can only happen if the current pattern is greedy\n                        /** @type {RematchOptions} */ var nestedRematch = {\n                            cause: token + \",\" + j,\n                            reach: reach\n                        };\n                        matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);\n                        // the reach might have been extended because of the rematching\n                        if (rematch && nestedRematch.reach > rematch.reach) {\n                            rematch.reach = nestedRematch.reach;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n   * @typedef LinkedListNode\n   * @property {T} value\n   * @property {LinkedListNode<T> | null} prev The previous node.\n   * @property {LinkedListNode<T> | null} next The next node.\n   * @template T\n   * @private\n   */ /**\n   * @template T\n   * @private\n   */ function LinkedList() {\n        /** @type {LinkedListNode<T>} */ var head = {\n            value: null,\n            prev: null,\n            next: null\n        };\n        /** @type {LinkedListNode<T>} */ var tail = {\n            value: null,\n            prev: head,\n            next: null\n        };\n        head.next = tail;\n        /** @type {LinkedListNode<T>} */ this.head = head;\n        /** @type {LinkedListNode<T>} */ this.tail = tail;\n        this.length = 0;\n    }\n    /**\n   * Adds a new node with the given value to the list.\n   *\n   * @param {LinkedList<T>} list\n   * @param {LinkedListNode<T>} node\n   * @param {T} value\n   * @returns {LinkedListNode<T>} The added node.\n   * @template T\n   */ function addAfter(list, node, value) {\n        // assumes that node != list.tail && values.length >= 0\n        var next = node.next;\n        var newNode = {\n            value: value,\n            prev: node,\n            next: next\n        };\n        node.next = newNode;\n        next.prev = newNode;\n        list.length++;\n        return newNode;\n    }\n    /**\n   * Removes `count` nodes after the given node. The given node will not be removed.\n   *\n   * @param {LinkedList<T>} list\n   * @param {LinkedListNode<T>} node\n   * @param {number} count\n   * @template T\n   */ function removeRange(list, node, count) {\n        var next = node.next;\n        for(var i = 0; i < count && next !== list.tail; i++){\n            next = next.next;\n        }\n        node.next = next;\n        next.prev = node;\n        list.length -= i;\n    }\n    /**\n   * @param {LinkedList<T>} list\n   * @returns {T[]}\n   * @template T\n   */ function toArray(list) {\n        var array = [];\n        var node = list.head.next;\n        while(node !== list.tail){\n            array.push(node.value);\n            node = node.next;\n        }\n        return array;\n    }\n    if (!_self.document) {\n        if (!_self.addEventListener) {\n            // in Node.js\n            return _;\n        }\n        if (!_.disableWorkerMessageHandler) {\n            // In worker\n            _self.addEventListener(\"message\", function(evt) {\n                var message = JSON.parse(evt.data);\n                var lang = message.language;\n                var code = message.code;\n                var immediateClose = message.immediateClose;\n                _self.postMessage(_.highlight(code, _.languages[lang], lang));\n                if (immediateClose) {\n                    _self.close();\n                }\n            }, false);\n        }\n        return _;\n    }\n    // Get current script and highlight\n    var script = _.util.currentScript();\n    if (script) {\n        _.filename = script.src;\n        if (script.hasAttribute(\"data-manual\")) {\n            _.manual = true;\n        }\n    }\n    function highlightAutomaticallyCallback() {\n        if (!_.manual) {\n            _.highlightAll();\n        }\n    }\n    if (!_.manual) {\n        // If the document state is \"loading\", then we'll use DOMContentLoaded.\n        // If the document state is \"interactive\" and the prism.js script is deferred, then we'll also use the\n        // DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they\n        // might take longer one animation frame to execute which can create a race condition where only some plugins have\n        // been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.\n        // See https://github.com/PrismJS/prism/issues/2102\n        var readyState = document.readyState;\n        if (readyState === \"loading\" || readyState === \"interactive\" && script && script.defer) {\n            document.addEventListener(\"DOMContentLoaded\", highlightAutomaticallyCallback);\n        } else {\n            if (window.requestAnimationFrame) {\n                window.requestAnimationFrame(highlightAutomaticallyCallback);\n            } else {\n                window.setTimeout(highlightAutomaticallyCallback, 16);\n            }\n        }\n    }\n    return _;\n}(_self);\n// some additional documentation/types\n/**\n * The expansion of a simple `RegExp` literal to support additional properties.\n *\n * @typedef GrammarToken\n * @property {RegExp} pattern The regular expression of the token.\n * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)\n * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.\n * @property {boolean} [greedy=false] Whether the token is greedy.\n * @property {string|string[]} [alias] An optional alias or list of aliases.\n * @property {Grammar} [inside] The nested grammar of this token.\n *\n * The `inside` grammar will be used to tokenize the text value of each token of this kind.\n *\n * This can be used to make nested and even recursive language definitions.\n *\n * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\n * each another.\n * @global\n * @public\n */ /**\n * @typedef Grammar\n * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}\n * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.\n * @global\n * @public\n */ /**\n * A function which will invoked after an element was successfully highlighted.\n *\n * @callback HighlightCallback\n * @param {Element} element The element successfully highlighted.\n * @returns {void}\n * @global\n * @public\n */ /**\n * @callback HookCallback\n * @param {Object<string, any>} env The environment variables of the hook.\n * @returns {void}\n * @global\n * @public\n */ /* **********************************************\n     Begin prism-markup.js\n********************************************** */ Prism.languages.markup = {\n    \"comment\": {\n        pattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n        greedy: true\n    },\n    \"prolog\": {\n        pattern: /<\\?[\\s\\S]+?\\?>/,\n        greedy: true\n    },\n    \"doctype\": {\n        // https://www.w3.org/TR/xml/#NT-doctypedecl\n        pattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n        greedy: true,\n        inside: {\n            \"internal-subset\": {\n                pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n                lookbehind: true,\n                greedy: true,\n                inside: null // see below\n            },\n            \"string\": {\n                pattern: /\"[^\"]*\"|'[^']*'/,\n                greedy: true\n            },\n            \"punctuation\": /^<!|>$|[[\\]]/,\n            \"doctype-tag\": /^DOCTYPE/i,\n            \"name\": /[^\\s<>'\"]+/\n        }\n    },\n    \"cdata\": {\n        pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n        greedy: true\n    },\n    \"tag\": {\n        pattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n        greedy: true,\n        inside: {\n            \"tag\": {\n                pattern: /^<\\/?[^\\s>\\/]+/,\n                inside: {\n                    \"punctuation\": /^<\\/?/,\n                    \"namespace\": /^[^\\s>\\/:]+:/\n                }\n            },\n            \"special-attr\": [],\n            \"attr-value\": {\n                pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n                inside: {\n                    \"punctuation\": [\n                        {\n                            pattern: /^=/,\n                            alias: \"attr-equals\"\n                        },\n                        {\n                            pattern: /^(\\s*)[\"']|[\"']$/,\n                            lookbehind: true\n                        }\n                    ]\n                }\n            },\n            \"punctuation\": /\\/?>/,\n            \"attr-name\": {\n                pattern: /[^\\s>\\/]+/,\n                inside: {\n                    \"namespace\": /^[^\\s>\\/:]+:/\n                }\n            }\n        }\n    },\n    \"entity\": [\n        {\n            pattern: /&[\\da-z]{1,8};/i,\n            alias: \"named-entity\"\n        },\n        /&#x?[\\da-f]{1,8};/i\n    ]\n};\nPrism.languages.markup[\"tag\"].inside[\"attr-value\"].inside[\"entity\"] = Prism.languages.markup[\"entity\"];\nPrism.languages.markup[\"doctype\"].inside[\"internal-subset\"].inside = Prism.languages.markup;\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add(\"wrap\", function(env) {\n    if (env.type === \"entity\") {\n        env.attributes[\"title\"] = env.content.replace(/&amp;/, \"&\");\n    }\n});\nObject.defineProperty(Prism.languages.markup.tag, \"addInlined\", {\n    /**\n   * Adds an inlined language to markup.\n   *\n   * An example of an inlined language is CSS with `<style>` tags.\n   *\n   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addInlined('style', 'css');\n   */ value: function addInlined(tagName, lang) {\n        var includedCdataInside = {};\n        includedCdataInside[\"language-\" + lang] = {\n            pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n            lookbehind: true,\n            inside: Prism.languages[lang]\n        };\n        includedCdataInside[\"cdata\"] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n        var inside = {\n            \"included-cdata\": {\n                pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n                inside: includedCdataInside\n            }\n        };\n        inside[\"language-\" + lang] = {\n            pattern: /[\\s\\S]+/,\n            inside: Prism.languages[lang]\n        };\n        var def = {};\n        def[tagName] = {\n            pattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function() {\n                return tagName;\n            }), \"i\"),\n            lookbehind: true,\n            greedy: true,\n            inside: inside\n        };\n        Prism.languages.insertBefore(\"markup\", \"cdata\", def);\n    }\n});\nObject.defineProperty(Prism.languages.markup.tag, \"addAttribute\", {\n    /**\n   * Adds an pattern to highlight languages embedded in HTML attributes.\n   *\n   * An example of an inlined language is CSS with `style` attributes.\n   *\n   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addAttribute('style', 'css');\n   */ value: function(attrName, lang) {\n        Prism.languages.markup.tag.inside[\"special-attr\"].push({\n            pattern: RegExp(/(^|[\"'\\s])/.source + \"(?:\" + attrName + \")\" + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source, \"i\"),\n            lookbehind: true,\n            inside: {\n                \"attr-name\": /^[^\\s=]+/,\n                \"attr-value\": {\n                    pattern: /=[\\s\\S]+/,\n                    inside: {\n                        \"value\": {\n                            pattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n                            lookbehind: true,\n                            alias: [\n                                lang,\n                                \"language-\" + lang\n                            ],\n                            inside: Prism.languages[lang]\n                        },\n                        \"punctuation\": [\n                            {\n                                pattern: /^=/,\n                                alias: \"attr-equals\"\n                            },\n                            /\"|'/\n                        ]\n                    }\n                }\n            }\n        });\n    }\n});\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\nPrism.languages.xml = Prism.languages.extend(\"markup\", {});\nPrism.languages.ssml = Prism.languages.xml;\nPrism.languages.atom = Prism.languages.xml;\nPrism.languages.rss = Prism.languages.xml;\n/* **********************************************\n     Begin prism-css.js\n********************************************** */ (function(Prism) {\n    var string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n    Prism.languages.css = {\n        \"comment\": /\\/\\*[\\s\\S]*?\\*\\//,\n        \"atrule\": {\n            pattern: RegExp(\"@[\\\\w-](?:\" + /[^;{\\s\"']|\\s+(?!\\s)/.source + \"|\" + string.source + \")*?\" + /(?:;|(?=\\s*\\{))/.source),\n            inside: {\n                \"rule\": /^@[\\w-]+/,\n                \"selector-function-argument\": {\n                    pattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n                    lookbehind: true,\n                    alias: \"selector\"\n                },\n                \"keyword\": {\n                    pattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n                    lookbehind: true\n                }\n            }\n        },\n        \"url\": {\n            // https://drafts.csswg.org/css-values-3/#urls\n            pattern: RegExp(\"\\\\burl\\\\((?:\" + string.source + \"|\" + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + \")\\\\)\", \"i\"),\n            greedy: true,\n            inside: {\n                \"function\": /^url/i,\n                \"punctuation\": /^\\(|\\)$/,\n                \"string\": {\n                    pattern: RegExp(\"^\" + string.source + \"$\"),\n                    alias: \"url\"\n                }\n            }\n        },\n        \"selector\": {\n            pattern: RegExp(\"(^|[{}\\\\s])[^{}\\\\s](?:[^{};\\\"'\\\\s]|\\\\s+(?![\\\\s{])|\" + string.source + \")*(?=\\\\s*\\\\{)\"),\n            lookbehind: true\n        },\n        \"string\": {\n            pattern: string,\n            greedy: true\n        },\n        \"property\": {\n            pattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n            lookbehind: true\n        },\n        \"important\": /!important\\b/i,\n        \"function\": {\n            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n            lookbehind: true\n        },\n        \"punctuation\": /[(){};:,]/\n    };\n    Prism.languages.css[\"atrule\"].inside.rest = Prism.languages.css;\n    var markup = Prism.languages.markup;\n    if (markup) {\n        markup.tag.addInlined(\"style\", \"css\");\n        markup.tag.addAttribute(\"style\", \"css\");\n    }\n})(Prism);\n/* **********************************************\n     Begin prism-clike.js\n********************************************** */ Prism.languages.clike = {\n    \"comment\": [\n        {\n            pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n            lookbehind: true,\n            greedy: true\n        },\n        {\n            pattern: /(^|[^\\\\:])\\/\\/.*/,\n            lookbehind: true,\n            greedy: true\n        }\n    ],\n    \"string\": {\n        pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n        greedy: true\n    },\n    \"class-name\": {\n        pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n        lookbehind: true,\n        inside: {\n            \"punctuation\": /[.\\\\]/\n        }\n    },\n    \"keyword\": /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"function\": /\\b\\w+(?=\\()/,\n    \"number\": /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n    \"operator\": /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n    \"punctuation\": /[{}[\\];(),.:]/\n};\n/* **********************************************\n     Begin prism-javascript.js\n********************************************** */ Prism.languages.javascript = Prism.languages.extend(\"clike\", {\n    \"class-name\": [\n        Prism.languages.clike[\"class-name\"],\n        {\n            pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n            lookbehind: true\n        }\n    ],\n    \"keyword\": [\n        {\n            pattern: /((?:^|\\})\\s*)catch\\b/,\n            lookbehind: true\n        },\n        {\n            pattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n            lookbehind: true\n        }\n    ],\n    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n    \"function\": /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n    \"number\": {\n        pattern: RegExp(/(^|[^\\w$])/.source + \"(?:\" + // constant\n        (/NaN|Infinity/.source + \"|\" + // binary integer\n        /0[bB][01]+(?:_[01]+)*n?/.source + \"|\" + // octal integer\n        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + \"|\" + // hexadecimal integer\n        /0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source + \"|\" + // decimal bigint\n        /\\d+(?:_\\d+)*n/.source + \"|\" + // decimal number (integer or float) but no bigint\n        /(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source) + \")\" + /(?![\\w$])/.source),\n        lookbehind: true\n    },\n    \"operator\": /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\nPrism.languages.javascript[\"class-name\"][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\nPrism.languages.insertBefore(\"javascript\", \"keyword\", {\n    \"regex\": {\n        pattern: RegExp(// lookbehind\n        // eslint-disable-next-line regexp/no-dupe-characters-character-class\n        /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source + // Regex pattern:\n        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n        // with the only syntax, so we have to define 2 different regex patterns.\n        /\\//.source + \"(?:\" + /(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source + \"|\" + // `v` flag syntax. This supports 3 levels of nested character classes.\n        /(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + \")\" + // lookahead\n        /(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n            \"regex-source\": {\n                pattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n                lookbehind: true,\n                alias: \"language-regex\",\n                inside: Prism.languages.regex\n            },\n            \"regex-delimiter\": /^\\/|\\/$/,\n            \"regex-flags\": /^[a-z]+$/\n        }\n    },\n    // This must be declared before keyword because we use \"function\" inside the look-forward\n    \"function-variable\": {\n        pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n        alias: \"function\"\n    },\n    \"parameter\": [\n        {\n            pattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        },\n        {\n            pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        },\n        {\n            pattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        },\n        {\n            pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        }\n    ],\n    \"constant\": /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\nPrism.languages.insertBefore(\"javascript\", \"string\", {\n    \"hashbang\": {\n        pattern: /^#!.*/,\n        greedy: true,\n        alias: \"comment\"\n    },\n    \"template-string\": {\n        pattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n        greedy: true,\n        inside: {\n            \"template-punctuation\": {\n                pattern: /^`|`$/,\n                alias: \"string\"\n            },\n            \"interpolation\": {\n                pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n                lookbehind: true,\n                inside: {\n                    \"interpolation-punctuation\": {\n                        pattern: /^\\$\\{|\\}$/,\n                        alias: \"punctuation\"\n                    },\n                    rest: Prism.languages.javascript\n                }\n            },\n            \"string\": /[\\s\\S]+/\n        }\n    },\n    \"string-property\": {\n        pattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n        lookbehind: true,\n        greedy: true,\n        alias: \"property\"\n    }\n});\nPrism.languages.insertBefore(\"javascript\", \"operator\", {\n    \"literal-property\": {\n        pattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n        lookbehind: true,\n        alias: \"property\"\n    }\n});\nif (Prism.languages.markup) {\n    Prism.languages.markup.tag.addInlined(\"script\", \"javascript\");\n    // add attribute support for all DOM events.\n    // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n    Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, \"javascript\");\n}\nPrism.languages.js = Prism.languages.javascript;\n/* **********************************************\n     Begin prism-file-highlight.js\n********************************************** */ (function() {\n    if (typeof Prism === \"undefined\" || typeof document === \"undefined\") {\n        return;\n    }\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\n    if (!Element.prototype.matches) {\n        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n    }\n    var LOADING_MESSAGE = \"Loading…\";\n    var FAILURE_MESSAGE = function(status, message) {\n        return \"✖ Error \" + status + \" while fetching file: \" + message;\n    };\n    var FAILURE_EMPTY_MESSAGE = \"✖ Error: File does not exist or is empty\";\n    var EXTENSIONS = {\n        \"js\": \"javascript\",\n        \"py\": \"python\",\n        \"rb\": \"ruby\",\n        \"ps1\": \"powershell\",\n        \"psm1\": \"powershell\",\n        \"sh\": \"bash\",\n        \"bat\": \"batch\",\n        \"h\": \"c\",\n        \"tex\": \"latex\"\n    };\n    var STATUS_ATTR = \"data-src-status\";\n    var STATUS_LOADING = \"loading\";\n    var STATUS_LOADED = \"loaded\";\n    var STATUS_FAILED = \"failed\";\n    var SELECTOR = \"pre[data-src]:not([\" + STATUS_ATTR + '=\"' + STATUS_LOADED + '\"])' + \":not([\" + STATUS_ATTR + '=\"' + STATUS_LOADING + '\"])';\n    /**\n   * Loads the given file.\n   *\n   * @param {string} src The URL or path of the source file to load.\n   * @param {(result: string) => void} success\n   * @param {(reason: string) => void} error\n   */ function loadFile(src, success, error) {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", src, true);\n        xhr.onreadystatechange = function() {\n            if (xhr.readyState == 4) {\n                if (xhr.status < 400 && xhr.responseText) {\n                    success(xhr.responseText);\n                } else {\n                    if (xhr.status >= 400) {\n                        error(FAILURE_MESSAGE(xhr.status, xhr.statusText));\n                    } else {\n                        error(FAILURE_EMPTY_MESSAGE);\n                    }\n                }\n            }\n        };\n        xhr.send(null);\n    }\n    /**\n   * Parses the given range.\n   *\n   * This returns a range with inclusive ends.\n   *\n   * @param {string | null | undefined} range\n   * @returns {[number, number | undefined] | undefined}\n   */ function parseRange(range) {\n        var m = /^\\s*(\\d+)\\s*(?:(,)\\s*(?:(\\d+)\\s*)?)?$/.exec(range || \"\");\n        if (m) {\n            var start = Number(m[1]);\n            var comma = m[2];\n            var end = m[3];\n            if (!comma) {\n                return [\n                    start,\n                    start\n                ];\n            }\n            if (!end) {\n                return [\n                    start,\n                    undefined\n                ];\n            }\n            return [\n                start,\n                Number(end)\n            ];\n        }\n        return undefined;\n    }\n    Prism.hooks.add(\"before-highlightall\", function(env) {\n        env.selector += \", \" + SELECTOR;\n    });\n    Prism.hooks.add(\"before-sanity-check\", function(env) {\n        var pre = /** @type {HTMLPreElement} */ env.element;\n        if (pre.matches(SELECTOR)) {\n            env.code = \"\"; // fast-path the whole thing and go to complete\n            pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading\n            // add code element with loading message\n            var code = pre.appendChild(document.createElement(\"CODE\"));\n            code.textContent = LOADING_MESSAGE;\n            var src = pre.getAttribute(\"data-src\");\n            var language = env.language;\n            if (language === \"none\") {\n                // the language might be 'none' because there is no language set;\n                // in this case, we want to use the extension as the language\n                var extension = (/\\.(\\w+)$/.exec(src) || [\n                    ,\n                    \"none\"\n                ])[1];\n                language = EXTENSIONS[extension] || extension;\n            }\n            // set language classes\n            Prism.util.setLanguage(code, language);\n            Prism.util.setLanguage(pre, language);\n            // preload the language\n            var autoloader = Prism.plugins.autoloader;\n            if (autoloader) {\n                autoloader.loadLanguages(language);\n            }\n            // load file\n            loadFile(src, function(text) {\n                // mark as loaded\n                pre.setAttribute(STATUS_ATTR, STATUS_LOADED);\n                // handle data-range\n                var range = parseRange(pre.getAttribute(\"data-range\"));\n                if (range) {\n                    var lines = text.split(/\\r\\n?|\\n/g);\n                    // the range is one-based and inclusive on both ends\n                    var start = range[0];\n                    var end = range[1] == null ? lines.length : range[1];\n                    if (start < 0) {\n                        start += lines.length;\n                    }\n                    start = Math.max(0, Math.min(start - 1, lines.length));\n                    if (end < 0) {\n                        end += lines.length;\n                    }\n                    end = Math.max(0, Math.min(end, lines.length));\n                    text = lines.slice(start, end).join(\"\\n\");\n                    // add data-start for line numbers\n                    if (!pre.hasAttribute(\"data-start\")) {\n                        pre.setAttribute(\"data-start\", String(start + 1));\n                    }\n                }\n                // highlight code\n                code.textContent = text;\n                Prism.highlightElement(code);\n            }, function(error) {\n                // mark as failed\n                pre.setAttribute(STATUS_ATTR, STATUS_FAILED);\n                code.textContent = error;\n            });\n        }\n    });\n    Prism.plugins.fileHighlight = {\n        /**\n     * Executes the File Highlight plugin for all matching `pre` elements under the given container.\n     *\n     * Note: Elements which are already loaded or currently loading will not be touched by this method.\n     *\n     * @param {ParentNode} [container=document]\n     */ highlight: function highlight(container) {\n            var elements = (container || document).querySelectorAll(SELECTOR);\n            for(var i = 0, element; element = elements[i++];){\n                Prism.highlightElement(element);\n            }\n        }\n    };\n    var logged = false;\n    /** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */ Prism.fileHighlight = function() {\n        if (!logged) {\n            console.warn(\"Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.\");\n            logged = true;\n        }\n        Prism.plugins.fileHighlight.highlight.apply(this, arguments);\n    };\n})();\nPrism.languages.clike = {\n    \"comment\": [\n        {\n            pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n            lookbehind: true,\n            greedy: true\n        },\n        {\n            pattern: /(^|[^\\\\:])\\/\\/.*/,\n            lookbehind: true,\n            greedy: true\n        }\n    ],\n    \"string\": {\n        pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n        greedy: true\n    },\n    \"class-name\": {\n        pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n        lookbehind: true,\n        inside: {\n            \"punctuation\": /[.\\\\]/\n        }\n    },\n    \"keyword\": /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"function\": /\\b\\w+(?=\\()/,\n    \"number\": /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n    \"operator\": /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n    \"punctuation\": /[{}[\\];(),.:]/\n};\nPrism.languages.c = Prism.languages.extend(\"clike\", {\n    \"comment\": {\n        pattern: /\\/\\/(?:[^\\r\\n\\\\]|\\\\(?:\\r\\n?|\\n|(?![\\r\\n])))*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n        greedy: true\n    },\n    \"string\": {\n        // https://en.cppreference.com/w/c/language/string_literal\n        pattern: /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n        greedy: true\n    },\n    \"class-name\": {\n        pattern: /(\\b(?:enum|struct)\\s+(?:__attribute__\\s*\\(\\([\\s\\S]*?\\)\\)\\s*)?)\\w+|\\b[a-z]\\w*_t\\b/,\n        lookbehind: true\n    },\n    \"keyword\": /\\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b/,\n    \"function\": /\\b[a-z_]\\w*(?=\\s*\\()/i,\n    \"number\": /(?:\\b0x(?:[\\da-f]+(?:\\.[\\da-f]*)?|\\.[\\da-f]+)(?:p[+-]?\\d+)?|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)[ful]{0,4}/i,\n    \"operator\": />>=?|<<=?|->|([-+&|:])\\1|[?:~]|[-+*/%&|^!=<>]=?/\n});\nPrism.languages.insertBefore(\"c\", \"string\", {\n    \"char\": {\n        // https://en.cppreference.com/w/c/language/character_constant\n        pattern: /'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n]){0,32}'/,\n        greedy: true\n    }\n});\nPrism.languages.insertBefore(\"c\", \"string\", {\n    \"macro\": {\n        // allow for multiline macro definitions\n        // spaces after the # character compile fine with gcc\n        pattern: /(^[\\t ]*)#\\s*[a-z](?:[^\\r\\n\\\\/]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\\\\(?:\\r\\n|[\\s\\S]))*/im,\n        lookbehind: true,\n        greedy: true,\n        alias: \"property\",\n        inside: {\n            \"string\": [\n                {\n                    // highlight the path of the include statement as a string\n                    pattern: /^(#\\s*include\\s*)<[^>]+>/,\n                    lookbehind: true\n                },\n                Prism.languages.c[\"string\"]\n            ],\n            \"char\": Prism.languages.c[\"char\"],\n            \"comment\": Prism.languages.c[\"comment\"],\n            \"macro-name\": [\n                {\n                    pattern: /(^#\\s*define\\s+)\\w+\\b(?!\\()/i,\n                    lookbehind: true\n                },\n                {\n                    pattern: /(^#\\s*define\\s+)\\w+\\b(?=\\()/i,\n                    lookbehind: true,\n                    alias: \"function\"\n                }\n            ],\n            // highlight macro directives as keywords\n            \"directive\": {\n                pattern: /^(#\\s*)[a-z]+/,\n                lookbehind: true,\n                alias: \"keyword\"\n            },\n            \"directive-hash\": /^#/,\n            \"punctuation\": /##|\\\\(?=[\\r\\n])/,\n            \"expression\": {\n                pattern: /\\S[\\s\\S]*/,\n                inside: Prism.languages.c\n            }\n        }\n    }\n});\nPrism.languages.insertBefore(\"c\", \"function\", {\n    // highlight predefined macros as constants\n    \"constant\": /\\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\\b/\n});\ndelete Prism.languages.c[\"boolean\"];\n(function(Prism) {\n    var keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n    var modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function() {\n        return keyword.source;\n    });\n    Prism.languages.cpp = Prism.languages.extend(\"c\", {\n        \"class-name\": [\n            {\n                pattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source.replace(/<keyword>/g, function() {\n                    return keyword.source;\n                })),\n                lookbehind: true\n            },\n            // This is intended to capture the class name of method implementations like:\n            //   void foo::bar() const {}\n            // However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n            // it starts with an uppercase letter. This approximation should give decent results.\n            /\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/,\n            // This will capture the class name before destructors like:\n            //   Foo::~Foo() {}\n            /\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i,\n            // This also intends to capture the class name of method implementations but here the class has template\n            // parameters, so it can't be a namespace (until C++ adds generic namespaces).\n            /\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/\n        ],\n        \"keyword\": keyword,\n        \"number\": {\n            pattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n            greedy: true\n        },\n        \"operator\": />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n        \"boolean\": /\\b(?:false|true)\\b/\n    });\n    Prism.languages.insertBefore(\"cpp\", \"string\", {\n        \"module\": {\n            // https://en.cppreference.com/w/cpp/language/modules\n            pattern: RegExp(/(\\b(?:import|module)\\s+)/.source + \"(?:\" + // header-name\n            /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source + \"|\" + // module name or partition or both\n            /<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function() {\n                return modName;\n            }) + \")\"),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"string\": /^[<\"][\\s\\S]+/,\n                \"operator\": /:/,\n                \"punctuation\": /\\./\n            }\n        },\n        \"raw-string\": {\n            pattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n            alias: \"string\",\n            greedy: true\n        }\n    });\n    Prism.languages.insertBefore(\"cpp\", \"keyword\", {\n        \"generic-function\": {\n            pattern: /\\b(?!operator\\b)[a-z_]\\w*\\s*<(?:[^<>]|<[^<>]*>)*>(?=\\s*\\()/i,\n            inside: {\n                \"function\": /^\\w+/,\n                \"generic\": {\n                    pattern: /<[\\s\\S]+/,\n                    alias: \"class-name\",\n                    inside: Prism.languages.cpp\n                }\n            }\n        }\n    });\n    Prism.languages.insertBefore(\"cpp\", \"operator\", {\n        \"double-colon\": {\n            pattern: /::/,\n            alias: \"punctuation\"\n        }\n    });\n    Prism.languages.insertBefore(\"cpp\", \"class-name\", {\n        // the base clause is an optional list of parent classes\n        // https://en.cppreference.com/w/cpp/language/class\n        \"base-clause\": {\n            pattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n            lookbehind: true,\n            greedy: true,\n            inside: Prism.languages.extend(\"cpp\", {})\n        }\n    });\n    Prism.languages.insertBefore(\"inside\", \"double-colon\", {\n        // All untokenized words that are not namespaces should be class names\n        \"class-name\": /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n    }, Prism.languages.cpp[\"base-clause\"]);\n})(Prism);\nPrism.languages.arduino = Prism.languages.extend(\"cpp\", {\n    \"keyword\": /\\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\\b/,\n    \"constant\": /\\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\\b/,\n    \"builtin\": /\\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\\b/\n});\nPrism.languages.ino = Prism.languages.arduino;\n(function(Prism) {\n    // $ set | grep '^[A-Z][^[:space:]]*=' | cut -d= -f1 | tr '\\n' '|'\n    // + LC_ALL, RANDOM, REPLY, SECONDS.\n    // + make sure PS1..4 are here as they are not always set,\n    // - some useless things.\n    var envVars = \"\\\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\\\b\";\n    var commandAfterHeredoc = {\n        pattern: /(^([\"']?)\\w+\\2)[ \\t]+\\S.*/,\n        lookbehind: true,\n        alias: \"punctuation\",\n        // this looks reasonably well in all themes\n        inside: null // see below\n    };\n    var insideString = {\n        \"bash\": commandAfterHeredoc,\n        \"environment\": {\n            pattern: RegExp(\"\\\\$\" + envVars),\n            alias: \"constant\"\n        },\n        \"variable\": [\n            // [0]: Arithmetic Environment\n            {\n                pattern: /\\$?\\(\\([\\s\\S]+?\\)\\)/,\n                greedy: true,\n                inside: {\n                    // If there is a $ sign at the beginning highlight $(( and )) as variable\n                    \"variable\": [\n                        {\n                            pattern: /(^\\$\\(\\([\\s\\S]+)\\)\\)/,\n                            lookbehind: true\n                        },\n                        /^\\$\\(\\(/\n                    ],\n                    \"number\": /\\b0x[\\dA-Fa-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[Ee]-?\\d+)?/,\n                    // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic\n                    \"operator\": /--|\\+\\+|\\*\\*=?|<<=?|>>=?|&&|\\|\\||[=!+\\-*/%<>^&|]=?|[?~:]/,\n                    // If there is no $ sign at the beginning highlight (( and )) as punctuation\n                    \"punctuation\": /\\(\\(?|\\)\\)?|,|;/\n                }\n            },\n            // [1]: Command Substitution\n            {\n                pattern: /\\$\\((?:\\([^)]+\\)|[^()])+\\)|`[^`]+`/,\n                greedy: true,\n                inside: {\n                    \"variable\": /^\\$\\(|^`|\\)$|`$/\n                }\n            },\n            // [2]: Brace expansion\n            {\n                pattern: /\\$\\{[^}]+\\}/,\n                greedy: true,\n                inside: {\n                    \"operator\": /:[-=?+]?|[!\\/]|##?|%%?|\\^\\^?|,,?/,\n                    \"punctuation\": /[\\[\\]]/,\n                    \"environment\": {\n                        pattern: RegExp(\"(\\\\{)\" + envVars),\n                        lookbehind: true,\n                        alias: \"constant\"\n                    }\n                }\n            },\n            /\\$(?:\\w+|[#?*!@$])/\n        ],\n        // Escape sequences from echo and printf's manuals, and escaped quotes.\n        \"entity\": /\\\\(?:[abceEfnrtv\\\\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/\n    };\n    Prism.languages.bash = {\n        \"shebang\": {\n            pattern: /^#!\\s*\\/.*/,\n            alias: \"important\"\n        },\n        \"comment\": {\n            pattern: /(^|[^\"{\\\\$])#.*/,\n            lookbehind: true\n        },\n        \"function-name\": [\n            // a) function foo {\n            // b) foo() {\n            // c) function foo() {\n            // but not “foo {”\n            {\n                // a) and c)\n                pattern: /(\\bfunction\\s+)[\\w-]+(?=(?:\\s*\\(?:\\s*\\))?\\s*\\{)/,\n                lookbehind: true,\n                alias: \"function\"\n            },\n            {\n                // b)\n                pattern: /\\b[\\w-]+(?=\\s*\\(\\s*\\)\\s*\\{)/,\n                alias: \"function\"\n            }\n        ],\n        // Highlight variable names as variables in for and select beginnings.\n        \"for-or-select\": {\n            pattern: /(\\b(?:for|select)\\s+)\\w+(?=\\s+in\\s)/,\n            alias: \"variable\",\n            lookbehind: true\n        },\n        // Highlight variable names as variables in the left-hand part\n        // of assignments (“=” and “+=”).\n        \"assign-left\": {\n            pattern: /(^|[\\s;|&]|[<>]\\()\\w+(?:\\.\\w+)*(?=\\+?=)/,\n            inside: {\n                \"environment\": {\n                    pattern: RegExp(\"(^|[\\\\s;|&]|[<>]\\\\()\" + envVars),\n                    lookbehind: true,\n                    alias: \"constant\"\n                }\n            },\n            alias: \"variable\",\n            lookbehind: true\n        },\n        // Highlight parameter names as variables\n        \"parameter\": {\n            pattern: /(^|\\s)-{1,2}(?:\\w+:[+-]?)?\\w+(?:\\.\\w+)*(?=[=\\s]|$)/,\n            alias: \"variable\",\n            lookbehind: true\n        },\n        \"string\": [\n            // Support for Here-documents https://en.wikipedia.org/wiki/Here_document\n            {\n                pattern: /((?:^|[^<])<<-?\\s*)(\\w+)\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\2/,\n                lookbehind: true,\n                greedy: true,\n                inside: insideString\n            },\n            // Here-document with quotes around the tag\n            // → No expansion (so no “inside”).\n            {\n                pattern: /((?:^|[^<])<<-?\\s*)([\"'])(\\w+)\\2\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\3/,\n                lookbehind: true,\n                greedy: true,\n                inside: {\n                    \"bash\": commandAfterHeredoc\n                }\n            },\n            // “Normal” string\n            {\n                // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html\n                pattern: /(^|[^\\\\](?:\\\\\\\\)*)\"(?:\\\\[\\s\\S]|\\$\\([^)]+\\)|\\$(?!\\()|`[^`]+`|[^\"\\\\`$])*\"/,\n                lookbehind: true,\n                greedy: true,\n                inside: insideString\n            },\n            {\n                // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html\n                pattern: /(^|[^$\\\\])'[^']*'/,\n                lookbehind: true,\n                greedy: true\n            },\n            {\n                // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html\n                pattern: /\\$'(?:[^'\\\\]|\\\\[\\s\\S])*'/,\n                greedy: true,\n                inside: {\n                    \"entity\": insideString.entity\n                }\n            }\n        ],\n        \"environment\": {\n            pattern: RegExp(\"\\\\$?\" + envVars),\n            alias: \"constant\"\n        },\n        \"variable\": insideString.variable,\n        \"function\": {\n            pattern: /(^|[\\s;|&]|[<>]\\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\\s;|&])/,\n            lookbehind: true\n        },\n        \"keyword\": {\n            pattern: /(^|[\\s;|&]|[<>]\\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\\s;|&])/,\n            lookbehind: true\n        },\n        // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html\n        \"builtin\": {\n            pattern: /(^|[\\s;|&]|[<>]\\()(?:\\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\\s;|&])/,\n            lookbehind: true,\n            // Alias added to make those easier to distinguish from strings.\n            alias: \"class-name\"\n        },\n        \"boolean\": {\n            pattern: /(^|[\\s;|&]|[<>]\\()(?:false|true)(?=$|[)\\s;|&])/,\n            lookbehind: true\n        },\n        \"file-descriptor\": {\n            pattern: /\\B&\\d\\b/,\n            alias: \"important\"\n        },\n        \"operator\": {\n            // Lots of redirections here, but not just that.\n            pattern: /\\d?<>|>\\||\\+=|=[=~]?|!=?|<<[<-]?|[&\\d]?>>|\\d[<>]&?|[<>][&=]?|&[>&]?|\\|[&|]?/,\n            inside: {\n                \"file-descriptor\": {\n                    pattern: /^\\d/,\n                    alias: \"important\"\n                }\n            }\n        },\n        \"punctuation\": /\\$?\\(\\(?|\\)\\)?|\\.\\.|[{}[\\];\\\\]/,\n        \"number\": {\n            pattern: /(^|\\s)(?:[1-9]\\d*|0)(?:[.,]\\d+)?\\b/,\n            lookbehind: true\n        }\n    };\n    commandAfterHeredoc.inside = Prism.languages.bash;\n    /* Patterns in command substitution. */ var toBeCopied = [\n        \"comment\",\n        \"function-name\",\n        \"for-or-select\",\n        \"assign-left\",\n        \"parameter\",\n        \"string\",\n        \"environment\",\n        \"function\",\n        \"keyword\",\n        \"builtin\",\n        \"boolean\",\n        \"file-descriptor\",\n        \"operator\",\n        \"punctuation\",\n        \"number\"\n    ];\n    var inside = insideString.variable[1].inside;\n    for(var i = 0; i < toBeCopied.length; i++){\n        inside[toBeCopied[i]] = Prism.languages.bash[toBeCopied[i]];\n    }\n    Prism.languages.sh = Prism.languages.bash;\n    Prism.languages.shell = Prism.languages.bash;\n})(Prism);\n(function(Prism) {\n    /**\n   * Replaces all placeholders \"<<n>>\" of given pattern with the n-th replacement (zero based).\n   *\n   * Note: This is a simple text based replacement. Be careful when using backreferences!\n   *\n   * @param {string} pattern the given pattern.\n   * @param {string[]} replacements a list of replacement which can be inserted into the given pattern.\n   * @returns {string} the pattern with all placeholders replaced with their corresponding replacements.\n   * @example replace(/a<<0>>a/.source, [/b+/.source]) === /a(?:b+)a/.source\n   */ function replace(pattern, replacements) {\n        return pattern.replace(/<<(\\d+)>>/g, function(m, index) {\n            return \"(?:\" + replacements[+index] + \")\";\n        });\n    }\n    /**\n   * @param {string} pattern\n   * @param {string[]} replacements\n   * @param {string} [flags]\n   * @returns {RegExp}\n   */ function re(pattern, replacements, flags) {\n        return RegExp(replace(pattern, replacements), flags || \"\");\n    }\n    /**\n   * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.\n   *\n   * @param {string} pattern\n   * @param {number} depthLog2\n   * @returns {string}\n   */ function nested(pattern, depthLog2) {\n        for(var i = 0; i < depthLog2; i++){\n            pattern = pattern.replace(/<<self>>/g, function() {\n                return \"(?:\" + pattern + \")\";\n            });\n        }\n        return pattern.replace(/<<self>>/g, \"[^\\\\s\\\\S]\");\n    }\n    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/\n    var keywordKinds = {\n        // keywords which represent a return or variable type\n        type: \"bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void\",\n        // keywords which are used to declare a type\n        typeDeclaration: \"class enum interface record struct\",\n        // contextual keywords\n        // (\"var\" and \"dynamic\" are missing because they are used like types)\n        contextual: \"add alias and ascending async await by descending from(?=\\\\s*(?:\\\\w|$)) get global group into init(?=\\\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\\\s*{)\",\n        // all other keywords\n        other: \"abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield\"\n    };\n    // keywords\n    function keywordsToPattern(words) {\n        return \"\\\\b(?:\" + words.trim().replace(/ /g, \"|\") + \")\\\\b\";\n    }\n    var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);\n    var keywords = RegExp(keywordsToPattern(keywordKinds.type + \" \" + keywordKinds.typeDeclaration + \" \" + keywordKinds.contextual + \" \" + keywordKinds.other));\n    var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + \" \" + keywordKinds.contextual + \" \" + keywordKinds.other);\n    var nonContextualKeywords = keywordsToPattern(keywordKinds.type + \" \" + keywordKinds.typeDeclaration + \" \" + keywordKinds.other);\n    // types\n    var generic = nested(/<(?:[^<>;=+\\-*/%&|^]|<<self>>)*>/.source, 2); // the idea behind the other forbidden characters is to prevent false positives. Same for tupleElement.\n    var nestedRound = nested(/\\((?:[^()]|<<self>>)*\\)/.source, 2);\n    var name = /@?\\b[A-Za-z_]\\w*\\b/.source;\n    var genericName = replace(/<<0>>(?:\\s*<<1>>)?/.source, [\n        name,\n        generic\n    ]);\n    var identifier = replace(/(?!<<0>>)<<1>>(?:\\s*\\.\\s*<<1>>)*/.source, [\n        nonTypeKeywords,\n        genericName\n    ]);\n    var array = /\\[\\s*(?:,\\s*)*\\]/.source;\n    var typeExpressionWithoutTuple = replace(/<<0>>(?:\\s*(?:\\?\\s*)?<<1>>)*(?:\\s*\\?)?/.source, [\n        identifier,\n        array\n    ]);\n    var tupleElement = replace(/[^,()<>[\\];=+\\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [\n        generic,\n        nestedRound,\n        array\n    ]);\n    var tuple = replace(/\\(<<0>>+(?:,<<0>>+)+\\)/.source, [\n        tupleElement\n    ]);\n    var typeExpression = replace(/(?:<<0>>|<<1>>)(?:\\s*(?:\\?\\s*)?<<2>>)*(?:\\s*\\?)?/.source, [\n        tuple,\n        identifier,\n        array\n    ]);\n    var typeInside = {\n        \"keyword\": keywords,\n        \"punctuation\": /[<>()?,.:[\\]]/\n    };\n    // strings & characters\n    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#character-literals\n    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#string-literals\n    var character = /'(?:[^\\r\\n'\\\\]|\\\\.|\\\\[Uux][\\da-fA-F]{1,8})'/.source; // simplified pattern\n    var regularString = /\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/.source;\n    var verbatimString = /@\"(?:\"\"|\\\\[\\s\\S]|[^\\\\\"])*\"(?!\")/.source;\n    Prism.languages.csharp = Prism.languages.extend(\"clike\", {\n        \"string\": [\n            {\n                pattern: re(/(^|[^$\\\\])<<0>>/.source, [\n                    verbatimString\n                ]),\n                lookbehind: true,\n                greedy: true\n            },\n            {\n                pattern: re(/(^|[^@$\\\\])<<0>>/.source, [\n                    regularString\n                ]),\n                lookbehind: true,\n                greedy: true\n            }\n        ],\n        \"class-name\": [\n            {\n                // Using static\n                // using static System.Math;\n                pattern: re(/(\\busing\\s+static\\s+)<<0>>(?=\\s*;)/.source, [\n                    identifier\n                ]),\n                lookbehind: true,\n                inside: typeInside\n            },\n            {\n                // Using alias (type)\n                // using Project = PC.MyCompany.Project;\n                pattern: re(/(\\busing\\s+<<0>>\\s*=\\s*)<<1>>(?=\\s*;)/.source, [\n                    name,\n                    typeExpression\n                ]),\n                lookbehind: true,\n                inside: typeInside\n            },\n            {\n                // Using alias (alias)\n                // using Project = PC.MyCompany.Project;\n                pattern: re(/(\\busing\\s+)<<0>>(?=\\s*=)/.source, [\n                    name\n                ]),\n                lookbehind: true\n            },\n            {\n                // Type declarations\n                // class Foo<A, B>\n                // interface Foo<out A, B>\n                pattern: re(/(\\b<<0>>\\s+)<<1>>/.source, [\n                    typeDeclarationKeywords,\n                    genericName\n                ]),\n                lookbehind: true,\n                inside: typeInside\n            },\n            {\n                // Single catch exception declaration\n                // catch(Foo)\n                // (things like catch(Foo e) is covered by variable declaration)\n                pattern: re(/(\\bcatch\\s*\\(\\s*)<<0>>/.source, [\n                    identifier\n                ]),\n                lookbehind: true,\n                inside: typeInside\n            },\n            {\n                // Name of the type parameter of generic constraints\n                // where Foo : class\n                pattern: re(/(\\bwhere\\s+)<<0>>/.source, [\n                    name\n                ]),\n                lookbehind: true\n            },\n            {\n                // Casts and checks via as and is.\n                // as Foo<A>, is Bar<B>\n                // (things like if(a is Foo b) is covered by variable declaration)\n                pattern: re(/(\\b(?:is(?:\\s+not)?|as)\\s+)<<0>>/.source, [\n                    typeExpressionWithoutTuple\n                ]),\n                lookbehind: true,\n                inside: typeInside\n            },\n            {\n                // Variable, field and parameter declaration\n                // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)\n                pattern: re(/\\b<<0>>(?=\\s+(?!<<1>>|with\\s*\\{)<<2>>(?:\\s*[=,;:{)\\]]|\\s+(?:in|when)\\b))/.source, [\n                    typeExpression,\n                    nonContextualKeywords,\n                    name\n                ]),\n                inside: typeInside\n            }\n        ],\n        \"keyword\": keywords,\n        // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals\n        \"number\": /(?:\\b0(?:x[\\da-f_]*[\\da-f]|b[01_]*[01])|(?:\\B\\.\\d+(?:_+\\d+)*|\\b\\d+(?:_+\\d+)*(?:\\.\\d+(?:_+\\d+)*)?)(?:e[-+]?\\d+(?:_+\\d+)*)?)(?:[dflmu]|lu|ul)?\\b/i,\n        \"operator\": />>=?|<<=?|[-=]>|([-+&|])\\1|~|\\?\\?=?|[-+*/%&|^!=<>]=?/,\n        \"punctuation\": /\\?\\.?|::|[{}[\\];(),.:]/\n    });\n    Prism.languages.insertBefore(\"csharp\", \"number\", {\n        \"range\": {\n            pattern: /\\.\\./,\n            alias: \"operator\"\n        }\n    });\n    Prism.languages.insertBefore(\"csharp\", \"punctuation\", {\n        \"named-parameter\": {\n            pattern: re(/([(,]\\s*)<<0>>(?=\\s*:)/.source, [\n                name\n            ]),\n            lookbehind: true,\n            alias: \"punctuation\"\n        }\n    });\n    Prism.languages.insertBefore(\"csharp\", \"class-name\", {\n        \"namespace\": {\n            // namespace Foo.Bar {}\n            // using Foo.Bar;\n            pattern: re(/(\\b(?:namespace|using)\\s+)<<0>>(?:\\s*\\.\\s*<<0>>)*(?=\\s*[;{])/.source, [\n                name\n            ]),\n            lookbehind: true,\n            inside: {\n                \"punctuation\": /\\./\n            }\n        },\n        \"type-expression\": {\n            // default(Foo), typeof(Foo<Bar>), sizeof(int)\n            pattern: re(/(\\b(?:default|sizeof|typeof)\\s*\\(\\s*(?!\\s))(?:[^()\\s]|\\s(?!\\s)|<<0>>)*(?=\\s*\\))/.source, [\n                nestedRound\n            ]),\n            lookbehind: true,\n            alias: \"class-name\",\n            inside: typeInside\n        },\n        \"return-type\": {\n            // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0\n            // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];\n            // int Foo => 0; int Foo { get; set } = 0;\n            pattern: re(/<<0>>(?=\\s+(?:<<1>>\\s*(?:=>|[({]|\\.\\s*this\\s*\\[)|this\\s*\\[))/.source, [\n                typeExpression,\n                identifier\n            ]),\n            inside: typeInside,\n            alias: \"class-name\"\n        },\n        \"constructor-invocation\": {\n            // new List<Foo<Bar[]>> { }\n            pattern: re(/(\\bnew\\s+)<<0>>(?=\\s*[[({])/.source, [\n                typeExpression\n            ]),\n            lookbehind: true,\n            inside: typeInside,\n            alias: \"class-name\"\n        },\n        /*'explicit-implementation': {\n    \t// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();\n    \tpattern: replace(/\\b<<0>>(?=\\.<<1>>)/, className, methodOrPropertyDeclaration),\n    \tinside: classNameInside,\n    \talias: 'class-name'\n    },*/ \"generic-method\": {\n            // foo<Bar>()\n            pattern: re(/<<0>>\\s*<<1>>(?=\\s*\\()/.source, [\n                name,\n                generic\n            ]),\n            inside: {\n                \"function\": re(/^<<0>>/.source, [\n                    name\n                ]),\n                \"generic\": {\n                    pattern: RegExp(generic),\n                    alias: \"class-name\",\n                    inside: typeInside\n                }\n            }\n        },\n        \"type-list\": {\n            // The list of types inherited or of generic constraints\n            // class Foo<F> : Bar, IList<FooBar>\n            // where F : Bar, IList<int>\n            pattern: re(/\\b((?:<<0>>\\s+<<1>>|record\\s+<<1>>\\s*<<5>>|where\\s+<<2>>)\\s*:\\s*)(?:<<3>>|<<4>>|<<1>>\\s*<<5>>|<<6>>)(?:\\s*,\\s*(?:<<3>>|<<4>>|<<6>>))*(?=\\s*(?:where|[{;]|=>|$))/.source, [\n                typeDeclarationKeywords,\n                genericName,\n                name,\n                typeExpression,\n                keywords.source,\n                nestedRound,\n                /\\bnew\\s*\\(\\s*\\)/.source\n            ]),\n            lookbehind: true,\n            inside: {\n                \"record-arguments\": {\n                    pattern: re(/(^(?!new\\s*\\()<<0>>\\s*)<<1>>/.source, [\n                        genericName,\n                        nestedRound\n                    ]),\n                    lookbehind: true,\n                    greedy: true,\n                    inside: Prism.languages.csharp\n                },\n                \"keyword\": keywords,\n                \"class-name\": {\n                    pattern: RegExp(typeExpression),\n                    greedy: true,\n                    inside: typeInside\n                },\n                \"punctuation\": /[,()]/\n            }\n        },\n        \"preprocessor\": {\n            pattern: /(^[\\t ]*)#.*/m,\n            lookbehind: true,\n            alias: \"property\",\n            inside: {\n                // highlight preprocessor directives as keywords\n                \"directive\": {\n                    pattern: /(#)\\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\\b/,\n                    lookbehind: true,\n                    alias: \"keyword\"\n                }\n            }\n        }\n    });\n    // attributes\n    var regularStringOrCharacter = regularString + \"|\" + character;\n    var regularStringCharacterOrComment = replace(/\\/(?![*/])|\\/\\/[^\\r\\n]*[\\r\\n]|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|<<0>>/.source, [\n        regularStringOrCharacter\n    ]);\n    var roundExpression = nested(replace(/[^\"'/()]|<<0>>|\\(<<self>>*\\)/.source, [\n        regularStringCharacterOrComment\n    ]), 2);\n    // https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/#attribute-targets\n    var attrTarget = /\\b(?:assembly|event|field|method|module|param|property|return|type)\\b/.source;\n    var attr = replace(/<<0>>(?:\\s*\\(<<1>>*\\))?/.source, [\n        identifier,\n        roundExpression\n    ]);\n    Prism.languages.insertBefore(\"csharp\", \"class-name\", {\n        \"attribute\": {\n            // Attributes\n            // [Foo], [Foo(1), Bar(2, Prop = \"foo\")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]\n            pattern: re(/((?:^|[^\\s\\w>)?])\\s*\\[\\s*)(?:<<0>>\\s*:\\s*)?<<1>>(?:\\s*,\\s*<<1>>)*(?=\\s*\\])/.source, [\n                attrTarget,\n                attr\n            ]),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"target\": {\n                    pattern: re(/^<<0>>(?=\\s*:)/.source, [\n                        attrTarget\n                    ]),\n                    alias: \"keyword\"\n                },\n                \"attribute-arguments\": {\n                    pattern: re(/\\(<<0>>*\\)/.source, [\n                        roundExpression\n                    ]),\n                    inside: Prism.languages.csharp\n                },\n                \"class-name\": {\n                    pattern: RegExp(identifier),\n                    inside: {\n                        \"punctuation\": /\\./\n                    }\n                },\n                \"punctuation\": /[:,]/\n            }\n        }\n    });\n    // string interpolation\n    var formatString = /:[^}\\r\\n]+/.source;\n    // multi line\n    var mInterpolationRound = nested(replace(/[^\"'/()]|<<0>>|\\(<<self>>*\\)/.source, [\n        regularStringCharacterOrComment\n    ]), 2);\n    var mInterpolation = replace(/\\{(?!\\{)(?:(?![}:])<<0>>)*<<1>>?\\}/.source, [\n        mInterpolationRound,\n        formatString\n    ]);\n    // single line\n    var sInterpolationRound = nested(replace(/[^\"'/()]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|<<0>>|\\(<<self>>*\\)/.source, [\n        regularStringOrCharacter\n    ]), 2);\n    var sInterpolation = replace(/\\{(?!\\{)(?:(?![}:])<<0>>)*<<1>>?\\}/.source, [\n        sInterpolationRound,\n        formatString\n    ]);\n    function createInterpolationInside(interpolation, interpolationRound) {\n        return {\n            \"interpolation\": {\n                pattern: re(/((?:^|[^{])(?:\\{\\{)*)<<0>>/.source, [\n                    interpolation\n                ]),\n                lookbehind: true,\n                inside: {\n                    \"format-string\": {\n                        pattern: re(/(^\\{(?:(?![}:])<<0>>)*)<<1>>(?=\\}$)/.source, [\n                            interpolationRound,\n                            formatString\n                        ]),\n                        lookbehind: true,\n                        inside: {\n                            \"punctuation\": /^:/\n                        }\n                    },\n                    \"punctuation\": /^\\{|\\}$/,\n                    \"expression\": {\n                        pattern: /[\\s\\S]+/,\n                        alias: \"language-csharp\",\n                        inside: Prism.languages.csharp\n                    }\n                }\n            },\n            \"string\": /[\\s\\S]+/\n        };\n    }\n    Prism.languages.insertBefore(\"csharp\", \"string\", {\n        \"interpolation-string\": [\n            {\n                pattern: re(/(^|[^\\\\])(?:\\$@|@\\$)\"(?:\"\"|\\\\[\\s\\S]|\\{\\{|<<0>>|[^\\\\{\"])*\"/.source, [\n                    mInterpolation\n                ]),\n                lookbehind: true,\n                greedy: true,\n                inside: createInterpolationInside(mInterpolation, mInterpolationRound)\n            },\n            {\n                pattern: re(/(^|[^@\\\\])\\$\"(?:\\\\.|\\{\\{|<<0>>|[^\\\\\"{])*\"/.source, [\n                    sInterpolation\n                ]),\n                lookbehind: true,\n                greedy: true,\n                inside: createInterpolationInside(sInterpolation, sInterpolationRound)\n            }\n        ],\n        \"char\": {\n            pattern: RegExp(character),\n            greedy: true\n        }\n    });\n    Prism.languages.dotnet = Prism.languages.cs = Prism.languages.csharp;\n})(Prism);\nPrism.languages.markup = {\n    \"comment\": {\n        pattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n        greedy: true\n    },\n    \"prolog\": {\n        pattern: /<\\?[\\s\\S]+?\\?>/,\n        greedy: true\n    },\n    \"doctype\": {\n        // https://www.w3.org/TR/xml/#NT-doctypedecl\n        pattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n        greedy: true,\n        inside: {\n            \"internal-subset\": {\n                pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n                lookbehind: true,\n                greedy: true,\n                inside: null // see below\n            },\n            \"string\": {\n                pattern: /\"[^\"]*\"|'[^']*'/,\n                greedy: true\n            },\n            \"punctuation\": /^<!|>$|[[\\]]/,\n            \"doctype-tag\": /^DOCTYPE/i,\n            \"name\": /[^\\s<>'\"]+/\n        }\n    },\n    \"cdata\": {\n        pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n        greedy: true\n    },\n    \"tag\": {\n        pattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n        greedy: true,\n        inside: {\n            \"tag\": {\n                pattern: /^<\\/?[^\\s>\\/]+/,\n                inside: {\n                    \"punctuation\": /^<\\/?/,\n                    \"namespace\": /^[^\\s>\\/:]+:/\n                }\n            },\n            \"special-attr\": [],\n            \"attr-value\": {\n                pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n                inside: {\n                    \"punctuation\": [\n                        {\n                            pattern: /^=/,\n                            alias: \"attr-equals\"\n                        },\n                        {\n                            pattern: /^(\\s*)[\"']|[\"']$/,\n                            lookbehind: true\n                        }\n                    ]\n                }\n            },\n            \"punctuation\": /\\/?>/,\n            \"attr-name\": {\n                pattern: /[^\\s>\\/]+/,\n                inside: {\n                    \"namespace\": /^[^\\s>\\/:]+:/\n                }\n            }\n        }\n    },\n    \"entity\": [\n        {\n            pattern: /&[\\da-z]{1,8};/i,\n            alias: \"named-entity\"\n        },\n        /&#x?[\\da-f]{1,8};/i\n    ]\n};\nPrism.languages.markup[\"tag\"].inside[\"attr-value\"].inside[\"entity\"] = Prism.languages.markup[\"entity\"];\nPrism.languages.markup[\"doctype\"].inside[\"internal-subset\"].inside = Prism.languages.markup;\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add(\"wrap\", function(env) {\n    if (env.type === \"entity\") {\n        env.attributes[\"title\"] = env.content.replace(/&amp;/, \"&\");\n    }\n});\nObject.defineProperty(Prism.languages.markup.tag, \"addInlined\", {\n    /**\n   * Adds an inlined language to markup.\n   *\n   * An example of an inlined language is CSS with `<style>` tags.\n   *\n   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addInlined('style', 'css');\n   */ value: function addInlined(tagName, lang) {\n        var includedCdataInside = {};\n        includedCdataInside[\"language-\" + lang] = {\n            pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n            lookbehind: true,\n            inside: Prism.languages[lang]\n        };\n        includedCdataInside[\"cdata\"] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n        var inside = {\n            \"included-cdata\": {\n                pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n                inside: includedCdataInside\n            }\n        };\n        inside[\"language-\" + lang] = {\n            pattern: /[\\s\\S]+/,\n            inside: Prism.languages[lang]\n        };\n        var def = {};\n        def[tagName] = {\n            pattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function() {\n                return tagName;\n            }), \"i\"),\n            lookbehind: true,\n            greedy: true,\n            inside: inside\n        };\n        Prism.languages.insertBefore(\"markup\", \"cdata\", def);\n    }\n});\nObject.defineProperty(Prism.languages.markup.tag, \"addAttribute\", {\n    /**\n   * Adds an pattern to highlight languages embedded in HTML attributes.\n   *\n   * An example of an inlined language is CSS with `style` attributes.\n   *\n   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addAttribute('style', 'css');\n   */ value: function(attrName, lang) {\n        Prism.languages.markup.tag.inside[\"special-attr\"].push({\n            pattern: RegExp(/(^|[\"'\\s])/.source + \"(?:\" + attrName + \")\" + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source, \"i\"),\n            lookbehind: true,\n            inside: {\n                \"attr-name\": /^[^\\s=]+/,\n                \"attr-value\": {\n                    pattern: /=[\\s\\S]+/,\n                    inside: {\n                        \"value\": {\n                            pattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n                            lookbehind: true,\n                            alias: [\n                                lang,\n                                \"language-\" + lang\n                            ],\n                            inside: Prism.languages[lang]\n                        },\n                        \"punctuation\": [\n                            {\n                                pattern: /^=/,\n                                alias: \"attr-equals\"\n                            },\n                            /\"|'/\n                        ]\n                    }\n                }\n            }\n        });\n    }\n});\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\nPrism.languages.xml = Prism.languages.extend(\"markup\", {});\nPrism.languages.ssml = Prism.languages.xml;\nPrism.languages.atom = Prism.languages.xml;\nPrism.languages.rss = Prism.languages.xml;\n(function(Prism) {\n    var string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n    Prism.languages.css = {\n        \"comment\": /\\/\\*[\\s\\S]*?\\*\\//,\n        \"atrule\": {\n            pattern: RegExp(\"@[\\\\w-](?:\" + /[^;{\\s\"']|\\s+(?!\\s)/.source + \"|\" + string.source + \")*?\" + /(?:;|(?=\\s*\\{))/.source),\n            inside: {\n                \"rule\": /^@[\\w-]+/,\n                \"selector-function-argument\": {\n                    pattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n                    lookbehind: true,\n                    alias: \"selector\"\n                },\n                \"keyword\": {\n                    pattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n                    lookbehind: true\n                }\n            }\n        },\n        \"url\": {\n            // https://drafts.csswg.org/css-values-3/#urls\n            pattern: RegExp(\"\\\\burl\\\\((?:\" + string.source + \"|\" + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + \")\\\\)\", \"i\"),\n            greedy: true,\n            inside: {\n                \"function\": /^url/i,\n                \"punctuation\": /^\\(|\\)$/,\n                \"string\": {\n                    pattern: RegExp(\"^\" + string.source + \"$\"),\n                    alias: \"url\"\n                }\n            }\n        },\n        \"selector\": {\n            pattern: RegExp(\"(^|[{}\\\\s])[^{}\\\\s](?:[^{};\\\"'\\\\s]|\\\\s+(?![\\\\s{])|\" + string.source + \")*(?=\\\\s*\\\\{)\"),\n            lookbehind: true\n        },\n        \"string\": {\n            pattern: string,\n            greedy: true\n        },\n        \"property\": {\n            pattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n            lookbehind: true\n        },\n        \"important\": /!important\\b/i,\n        \"function\": {\n            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n            lookbehind: true\n        },\n        \"punctuation\": /[(){};:,]/\n    };\n    Prism.languages.css[\"atrule\"].inside.rest = Prism.languages.css;\n    var markup = Prism.languages.markup;\n    if (markup) {\n        markup.tag.addInlined(\"style\", \"css\");\n        markup.tag.addAttribute(\"style\", \"css\");\n    }\n})(Prism);\n(function(Prism) {\n    Prism.languages.diff = {\n        \"coord\": [\n            // Match all kinds of coord lines (prefixed by \"+++\", \"---\" or \"***\").\n            /^(?:\\*{3}|-{3}|\\+{3}).*$/m,\n            // Match \"@@ ... @@\" coord lines in unified diff.\n            /^@@.*@@$/m,\n            // Match coord lines in normal diff (starts with a number).\n            /^\\d.*$/m\n        ]\n    };\n    /**\n   * A map from the name of a block to its line prefix.\n   *\n   * @type {Object<string, string>}\n   */ var PREFIXES = {\n        \"deleted-sign\": \"-\",\n        \"deleted-arrow\": \"<\",\n        \"inserted-sign\": \"+\",\n        \"inserted-arrow\": \">\",\n        \"unchanged\": \" \",\n        \"diff\": \"!\"\n    };\n    // add a token for each prefix\n    Object.keys(PREFIXES).forEach(function(name) {\n        var prefix = PREFIXES[name];\n        var alias = [];\n        if (!/^\\w+$/.test(name)) {\n            // \"deleted-sign\" -> \"deleted\"\n            alias.push(/\\w+/.exec(name)[0]);\n        }\n        if (name === \"diff\") {\n            alias.push(\"bold\");\n        }\n        Prism.languages.diff[name] = {\n            pattern: RegExp(\"^(?:[\" + prefix + \"].*(?:\\r\\n?|\\n|(?![\\\\s\\\\S])))+\", \"m\"),\n            alias: alias,\n            inside: {\n                \"line\": {\n                    pattern: /(.)(?=[\\s\\S]).*(?:\\r\\n?|\\n)?/,\n                    lookbehind: true\n                },\n                \"prefix\": {\n                    pattern: /[\\s\\S]/,\n                    alias: /\\w+/.exec(name)[0]\n                }\n            }\n        };\n    });\n    // make prefixes available to Diff plugin\n    Object.defineProperty(Prism.languages.diff, \"PREFIXES\", {\n        value: PREFIXES\n    });\n})(Prism);\nPrism.languages.go = Prism.languages.extend(\"clike\", {\n    \"string\": {\n        pattern: /(^|[^\\\\])\"(?:\\\\.|[^\"\\\\\\r\\n])*\"|`[^`]*`/,\n        lookbehind: true,\n        greedy: true\n    },\n    \"keyword\": /\\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\\b/,\n    \"boolean\": /\\b(?:_|false|iota|nil|true)\\b/,\n    \"number\": [\n        // binary and octal integers\n        /\\b0(?:b[01_]+|o[0-7_]+)i?\\b/i,\n        // hexadecimal integers and floats\n        /\\b0x(?:[a-f\\d_]+(?:\\.[a-f\\d_]*)?|\\.[a-f\\d_]+)(?:p[+-]?\\d+(?:_\\d+)*)?i?(?!\\w)/i,\n        // decimal integers and floats\n        /(?:\\b\\d[\\d_]*(?:\\.[\\d_]*)?|\\B\\.\\d[\\d_]*)(?:e[+-]?[\\d_]+)?i?(?!\\w)/i\n    ],\n    \"operator\": /[*\\/%^!=]=?|\\+[=+]?|-[=-]?|\\|[=|]?|&(?:=|&|\\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\\.\\.\\./,\n    \"builtin\": /\\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\\b/\n});\nPrism.languages.insertBefore(\"go\", \"string\", {\n    \"char\": {\n        pattern: /'(?:\\\\.|[^'\\\\\\r\\n]){0,10}'/,\n        greedy: true\n    }\n});\ndelete Prism.languages.go[\"class-name\"];\nPrism.languages.ini = {\n    /**\n   * The component mimics the behavior of the Win32 API parser.\n   *\n   * @see {@link https://github.com/PrismJS/prism/issues/2775#issuecomment-787477723}\n   */ \"comment\": {\n        pattern: /(^[ \\f\\t\\v]*)[#;][^\\n\\r]*/m,\n        lookbehind: true\n    },\n    \"section\": {\n        pattern: /(^[ \\f\\t\\v]*)\\[[^\\n\\r\\]]*\\]?/m,\n        lookbehind: true,\n        inside: {\n            \"section-name\": {\n                pattern: /(^\\[[ \\f\\t\\v]*)[^ \\f\\t\\v\\]]+(?:[ \\f\\t\\v]+[^ \\f\\t\\v\\]]+)*/,\n                lookbehind: true,\n                alias: \"selector\"\n            },\n            \"punctuation\": /\\[|\\]/\n        }\n    },\n    \"key\": {\n        pattern: /(^[ \\f\\t\\v]*)[^ \\f\\n\\r\\t\\v=]+(?:[ \\f\\t\\v]+[^ \\f\\n\\r\\t\\v=]+)*(?=[ \\f\\t\\v]*=)/m,\n        lookbehind: true,\n        alias: \"attr-name\"\n    },\n    \"value\": {\n        pattern: /(=[ \\f\\t\\v]*)[^ \\f\\n\\r\\t\\v]+(?:[ \\f\\t\\v]+[^ \\f\\n\\r\\t\\v]+)*/,\n        lookbehind: true,\n        alias: \"attr-value\",\n        inside: {\n            \"inner-value\": {\n                pattern: /^(\"|').+(?=\\1$)/,\n                lookbehind: true\n            }\n        }\n    },\n    \"punctuation\": /=/\n};\n(function(Prism) {\n    var keywords = /\\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\\s*[(){}[\\]<>=%~.:,;?+\\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\\b/;\n    // full package (optional) + parent classes (optional)\n    var classNamePrefix = /(?:[a-z]\\w*\\s*\\.\\s*)*(?:[A-Z]\\w*\\s*\\.\\s*)*/.source;\n    // based on the java naming conventions\n    var className = {\n        pattern: RegExp(/(^|[^\\w.])/.source + classNamePrefix + /[A-Z](?:[\\d_A-Z]*[a-z]\\w*)?\\b/.source),\n        lookbehind: true,\n        inside: {\n            \"namespace\": {\n                pattern: /^[a-z]\\w*(?:\\s*\\.\\s*[a-z]\\w*)*(?:\\s*\\.)?/,\n                inside: {\n                    \"punctuation\": /\\./\n                }\n            },\n            \"punctuation\": /\\./\n        }\n    };\n    Prism.languages.java = Prism.languages.extend(\"clike\", {\n        \"string\": {\n            pattern: /(^|[^\\\\])\"(?:\\\\.|[^\"\\\\\\r\\n])*\"/,\n            lookbehind: true,\n            greedy: true\n        },\n        \"class-name\": [\n            className,\n            {\n                // variables, parameters, and constructor references\n                // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)\n                pattern: RegExp(/(^|[^\\w.])/.source + classNamePrefix + /[A-Z]\\w*(?=\\s+\\w+\\s*[;,=()]|\\s*(?:\\[[\\s,]*\\]\\s*)?::\\s*new\\b)/.source),\n                lookbehind: true,\n                inside: className.inside\n            },\n            {\n                // class names based on keyword\n                // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)\n                pattern: RegExp(/(\\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\\s+)/.source + classNamePrefix + /[A-Z]\\w*\\b/.source),\n                lookbehind: true,\n                inside: className.inside\n            }\n        ],\n        \"keyword\": keywords,\n        \"function\": [\n            Prism.languages.clike.function,\n            {\n                pattern: /(::\\s*)[a-z_]\\w*/,\n                lookbehind: true\n            }\n        ],\n        \"number\": /\\b0b[01][01_]*L?\\b|\\b0x(?:\\.[\\da-f_p+-]+|[\\da-f_]+(?:\\.[\\da-f_p+-]+)?)\\b|(?:\\b\\d[\\d_]*(?:\\.[\\d_]*)?|\\B\\.\\d[\\d_]*)(?:e[+-]?\\d[\\d_]*)?[dfl]?/i,\n        \"operator\": {\n            pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\\+\\+|&&|\\|\\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,\n            lookbehind: true\n        },\n        \"constant\": /\\b[A-Z][A-Z_\\d]+\\b/\n    });\n    Prism.languages.insertBefore(\"java\", \"string\", {\n        \"triple-quoted-string\": {\n            // http://openjdk.java.net/jeps/355#Description\n            pattern: /\"\"\"[ \\t]*[\\r\\n](?:(?:\"|\"\")?(?:\\\\.|[^\"\\\\]))*\"\"\"/,\n            greedy: true,\n            alias: \"string\"\n        },\n        \"char\": {\n            pattern: /'(?:\\\\.|[^'\\\\\\r\\n]){1,6}'/,\n            greedy: true\n        }\n    });\n    Prism.languages.insertBefore(\"java\", \"class-name\", {\n        \"annotation\": {\n            pattern: /(^|[^.])@\\w+(?:\\s*\\.\\s*\\w+)*/,\n            lookbehind: true,\n            alias: \"punctuation\"\n        },\n        \"generics\": {\n            pattern: /<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&))*>)*>)*>)*>/,\n            inside: {\n                \"class-name\": className,\n                \"keyword\": keywords,\n                \"punctuation\": /[<>(),.:]/,\n                \"operator\": /[?&|]/\n            }\n        },\n        \"import\": [\n            {\n                pattern: RegExp(/(\\bimport\\s+)/.source + classNamePrefix + /(?:[A-Z]\\w*|\\*)(?=\\s*;)/.source),\n                lookbehind: true,\n                inside: {\n                    \"namespace\": className.inside.namespace,\n                    \"punctuation\": /\\./,\n                    \"operator\": /\\*/,\n                    \"class-name\": /\\w+/\n                }\n            },\n            {\n                pattern: RegExp(/(\\bimport\\s+static\\s+)/.source + classNamePrefix + /(?:\\w+|\\*)(?=\\s*;)/.source),\n                lookbehind: true,\n                alias: \"static\",\n                inside: {\n                    \"namespace\": className.inside.namespace,\n                    \"static\": /\\b\\w+$/,\n                    \"punctuation\": /\\./,\n                    \"operator\": /\\*/,\n                    \"class-name\": /\\w+/\n                }\n            }\n        ],\n        \"namespace\": {\n            pattern: RegExp(/(\\b(?:exports|import(?:\\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\\s+)(?!<keyword>)[a-z]\\w*(?:\\.[a-z]\\w*)*\\.?/.source.replace(/<keyword>/g, function() {\n                return keywords.source;\n            })),\n            lookbehind: true,\n            inside: {\n                \"punctuation\": /\\./\n            }\n        }\n    });\n})(Prism);\n(function(Prism) {\n    var specialEscape = {\n        pattern: /\\\\[\\\\(){}[\\]^$+*?|.]/,\n        alias: \"escape\"\n    };\n    var escape = /\\\\(?:x[\\da-fA-F]{2}|u[\\da-fA-F]{4}|u\\{[\\da-fA-F]+\\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/;\n    var charSet = {\n        pattern: /\\.|\\\\[wsd]|\\\\p\\{[^{}]+\\}/i,\n        alias: \"class-name\"\n    };\n    var charSetWithoutDot = {\n        pattern: /\\\\[wsd]|\\\\p\\{[^{}]+\\}/i,\n        alias: \"class-name\"\n    };\n    var rangeChar = \"(?:[^\\\\\\\\-]|\" + escape.source + \")\";\n    var range = RegExp(rangeChar + \"-\" + rangeChar);\n    // the name of a capturing group\n    var groupName = {\n        pattern: /(<|')[^<>']+(?=[>']$)/,\n        lookbehind: true,\n        alias: \"variable\"\n    };\n    Prism.languages.regex = {\n        \"char-class\": {\n            pattern: /((?:^|[^\\\\])(?:\\\\\\\\)*)\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/,\n            lookbehind: true,\n            inside: {\n                \"char-class-negation\": {\n                    pattern: /(^\\[)\\^/,\n                    lookbehind: true,\n                    alias: \"operator\"\n                },\n                \"char-class-punctuation\": {\n                    pattern: /^\\[|\\]$/,\n                    alias: \"punctuation\"\n                },\n                \"range\": {\n                    pattern: range,\n                    inside: {\n                        \"escape\": escape,\n                        \"range-punctuation\": {\n                            pattern: /-/,\n                            alias: \"operator\"\n                        }\n                    }\n                },\n                \"special-escape\": specialEscape,\n                \"char-set\": charSetWithoutDot,\n                \"escape\": escape\n            }\n        },\n        \"special-escape\": specialEscape,\n        \"char-set\": charSet,\n        \"backreference\": [\n            {\n                // a backreference which is not an octal escape\n                pattern: /\\\\(?![123][0-7]{2})[1-9]/,\n                alias: \"keyword\"\n            },\n            {\n                pattern: /\\\\k<[^<>']+>/,\n                alias: \"keyword\",\n                inside: {\n                    \"group-name\": groupName\n                }\n            }\n        ],\n        \"anchor\": {\n            pattern: /[$^]|\\\\[ABbGZz]/,\n            alias: \"function\"\n        },\n        \"escape\": escape,\n        \"group\": [\n            {\n                // https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html\n                // https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs\n                // (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)\n                pattern: /\\((?:\\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,\n                alias: \"punctuation\",\n                inside: {\n                    \"group-name\": groupName\n                }\n            },\n            {\n                pattern: /\\)/,\n                alias: \"punctuation\"\n            }\n        ],\n        \"quantifier\": {\n            pattern: /(?:[+*?]|\\{\\d+(?:,\\d*)?\\})[?+]?/,\n            alias: \"number\"\n        },\n        \"alternation\": {\n            pattern: /\\|/,\n            alias: \"keyword\"\n        }\n    };\n})(Prism);\nPrism.languages.javascript = Prism.languages.extend(\"clike\", {\n    \"class-name\": [\n        Prism.languages.clike[\"class-name\"],\n        {\n            pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n            lookbehind: true\n        }\n    ],\n    \"keyword\": [\n        {\n            pattern: /((?:^|\\})\\s*)catch\\b/,\n            lookbehind: true\n        },\n        {\n            pattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n            lookbehind: true\n        }\n    ],\n    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n    \"function\": /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n    \"number\": {\n        pattern: RegExp(/(^|[^\\w$])/.source + \"(?:\" + // constant\n        (/NaN|Infinity/.source + \"|\" + // binary integer\n        /0[bB][01]+(?:_[01]+)*n?/.source + \"|\" + // octal integer\n        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + \"|\" + // hexadecimal integer\n        /0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source + \"|\" + // decimal bigint\n        /\\d+(?:_\\d+)*n/.source + \"|\" + // decimal number (integer or float) but no bigint\n        /(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source) + \")\" + /(?![\\w$])/.source),\n        lookbehind: true\n    },\n    \"operator\": /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\nPrism.languages.javascript[\"class-name\"][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\nPrism.languages.insertBefore(\"javascript\", \"keyword\", {\n    \"regex\": {\n        pattern: RegExp(// lookbehind\n        // eslint-disable-next-line regexp/no-dupe-characters-character-class\n        /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source + // Regex pattern:\n        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n        // with the only syntax, so we have to define 2 different regex patterns.\n        /\\//.source + \"(?:\" + /(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source + \"|\" + // `v` flag syntax. This supports 3 levels of nested character classes.\n        /(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + \")\" + // lookahead\n        /(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n            \"regex-source\": {\n                pattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n                lookbehind: true,\n                alias: \"language-regex\",\n                inside: Prism.languages.regex\n            },\n            \"regex-delimiter\": /^\\/|\\/$/,\n            \"regex-flags\": /^[a-z]+$/\n        }\n    },\n    // This must be declared before keyword because we use \"function\" inside the look-forward\n    \"function-variable\": {\n        pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n        alias: \"function\"\n    },\n    \"parameter\": [\n        {\n            pattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        },\n        {\n            pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        },\n        {\n            pattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        },\n        {\n            pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        }\n    ],\n    \"constant\": /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\nPrism.languages.insertBefore(\"javascript\", \"string\", {\n    \"hashbang\": {\n        pattern: /^#!.*/,\n        greedy: true,\n        alias: \"comment\"\n    },\n    \"template-string\": {\n        pattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n        greedy: true,\n        inside: {\n            \"template-punctuation\": {\n                pattern: /^`|`$/,\n                alias: \"string\"\n            },\n            \"interpolation\": {\n                pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n                lookbehind: true,\n                inside: {\n                    \"interpolation-punctuation\": {\n                        pattern: /^\\$\\{|\\}$/,\n                        alias: \"punctuation\"\n                    },\n                    rest: Prism.languages.javascript\n                }\n            },\n            \"string\": /[\\s\\S]+/\n        }\n    },\n    \"string-property\": {\n        pattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n        lookbehind: true,\n        greedy: true,\n        alias: \"property\"\n    }\n});\nPrism.languages.insertBefore(\"javascript\", \"operator\", {\n    \"literal-property\": {\n        pattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n        lookbehind: true,\n        alias: \"property\"\n    }\n});\nif (Prism.languages.markup) {\n    Prism.languages.markup.tag.addInlined(\"script\", \"javascript\");\n    // add attribute support for all DOM events.\n    // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n    Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, \"javascript\");\n}\nPrism.languages.js = Prism.languages.javascript;\n(function(Prism) {\n    var javascript = Prism.util.clone(Prism.languages.javascript);\n    var space = /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source;\n    var braces = /(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})/.source;\n    var spread = /(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})/.source;\n    /**\n   * @param {string} source\n   * @param {string} [flags]\n   */ function re(source, flags) {\n        source = source.replace(/<S>/g, function() {\n            return space;\n        }).replace(/<BRACES>/g, function() {\n            return braces;\n        }).replace(/<SPREAD>/g, function() {\n            return spread;\n        });\n        return RegExp(source, flags);\n    }\n    spread = re(spread).source;\n    Prism.languages.jsx = Prism.languages.extend(\"markup\", javascript);\n    Prism.languages.jsx.tag.pattern = re(/<\\/?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\\/?)?>/.source);\n    Prism.languages.jsx.tag.inside[\"tag\"].pattern = /^<\\/?[^\\s>\\/]*/;\n    Prism.languages.jsx.tag.inside[\"attr-value\"].pattern = /=(?!\\{)(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s'\">]+)/;\n    Prism.languages.jsx.tag.inside[\"tag\"].inside[\"class-name\"] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/;\n    Prism.languages.jsx.tag.inside[\"comment\"] = javascript[\"comment\"];\n    Prism.languages.insertBefore(\"inside\", \"attr-name\", {\n        \"spread\": {\n            pattern: re(/<SPREAD>/.source),\n            inside: Prism.languages.jsx\n        }\n    }, Prism.languages.jsx.tag);\n    Prism.languages.insertBefore(\"inside\", \"special-attr\", {\n        \"script\": {\n            // Allow for two levels of nesting\n            pattern: re(/=<BRACES>/.source),\n            alias: \"language-javascript\",\n            inside: {\n                \"script-punctuation\": {\n                    pattern: /^=(?=\\{)/,\n                    alias: \"punctuation\"\n                },\n                rest: Prism.languages.jsx\n            }\n        }\n    }, Prism.languages.jsx.tag);\n    // The following will handle plain text inside tags\n    var stringifyToken = function(token) {\n        if (!token) {\n            return \"\";\n        }\n        if (typeof token === \"string\") {\n            return token;\n        }\n        if (typeof token.content === \"string\") {\n            return token.content;\n        }\n        return token.content.map(stringifyToken).join(\"\");\n    };\n    var walkTokens = function(tokens) {\n        var openedTags = [];\n        for(var i = 0; i < tokens.length; i++){\n            var token = tokens[i];\n            var notTagNorBrace = false;\n            if (typeof token !== \"string\") {\n                if (token.type === \"tag\" && token.content[0] && token.content[0].type === \"tag\") {\n                    // We found a tag, now find its kind\n                    if (token.content[0].content[0].content === \"</\") {\n                        // Closing tag\n                        if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n                            // Pop matching opening tag\n                            openedTags.pop();\n                        }\n                    } else {\n                        if (token.content[token.content.length - 1].content === \"/>\") ;\n                        else {\n                            // Opening tag\n                            openedTags.push({\n                                tagName: stringifyToken(token.content[0].content[1]),\n                                openedBraces: 0\n                            });\n                        }\n                    }\n                } else if (openedTags.length > 0 && token.type === \"punctuation\" && token.content === \"{\") {\n                    // Here we might have entered a JSX context inside a tag\n                    openedTags[openedTags.length - 1].openedBraces++;\n                } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === \"punctuation\" && token.content === \"}\") {\n                    // Here we might have left a JSX context inside a tag\n                    openedTags[openedTags.length - 1].openedBraces--;\n                } else {\n                    notTagNorBrace = true;\n                }\n            }\n            if (notTagNorBrace || typeof token === \"string\") {\n                if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n                    // Here we are inside a tag, and not inside a JSX context.\n                    // That's plain text: drop any tokens matched.\n                    var plainText = stringifyToken(token);\n                    // And merge text with adjacent text\n                    if (i < tokens.length - 1 && (typeof tokens[i + 1] === \"string\" || tokens[i + 1].type === \"plain-text\")) {\n                        plainText += stringifyToken(tokens[i + 1]);\n                        tokens.splice(i + 1, 1);\n                    }\n                    if (i > 0 && (typeof tokens[i - 1] === \"string\" || tokens[i - 1].type === \"plain-text\")) {\n                        plainText = stringifyToken(tokens[i - 1]) + plainText;\n                        tokens.splice(i - 1, 1);\n                        i--;\n                    }\n                    tokens[i] = new Prism.Token(\"plain-text\", plainText, null, plainText);\n                }\n            }\n            if (token.content && typeof token.content !== \"string\") {\n                walkTokens(token.content);\n            }\n        }\n    };\n    Prism.hooks.add(\"after-tokenize\", function(env) {\n        if (env.language !== \"jsx\" && env.language !== \"tsx\") {\n            return;\n        }\n        walkTokens(env.tokens);\n    });\n})(Prism);\n// https://www.json.org/json-en.html\nPrism.languages.json = {\n    \"property\": {\n        pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?=\\s*:)/,\n        lookbehind: true,\n        greedy: true\n    },\n    \"string\": {\n        pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?!\\s*:)/,\n        lookbehind: true,\n        greedy: true\n    },\n    \"comment\": {\n        pattern: /\\/\\/.*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n        greedy: true\n    },\n    \"number\": /-?\\b\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n    \"punctuation\": /[{}[\\],]/,\n    \"operator\": /:/,\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"null\": {\n        pattern: /\\bnull\\b/,\n        alias: \"keyword\"\n    }\n};\nPrism.languages.webmanifest = Prism.languages.json;\n(function(Prism) {\n    Prism.languages.kotlin = Prism.languages.extend(\"clike\", {\n        \"keyword\": {\n            // The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get\n            pattern: /(^|[^.])\\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\\b/,\n            lookbehind: true\n        },\n        \"function\": [\n            {\n                pattern: /(?:`[^\\r\\n`]+`|\\b\\w+)(?=\\s*\\()/,\n                greedy: true\n            },\n            {\n                pattern: /(\\.)(?:`[^\\r\\n`]+`|\\w+)(?=\\s*\\{)/,\n                lookbehind: true,\n                greedy: true\n            }\n        ],\n        \"number\": /\\b(?:0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\\d+(?:_\\d+)*(?:\\.\\d+(?:_\\d+)*)?(?:[eE][+-]?\\d+(?:_\\d+)*)?[fFL]?)\\b/,\n        \"operator\": /\\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\\/*%<>]=?|[?:]:?|\\.\\.|&&|\\|\\||\\b(?:and|inv|or|shl|shr|ushr|xor)\\b/\n    });\n    delete Prism.languages.kotlin[\"class-name\"];\n    var interpolationInside = {\n        \"interpolation-punctuation\": {\n            pattern: /^\\$\\{?|\\}$/,\n            alias: \"punctuation\"\n        },\n        \"expression\": {\n            pattern: /[\\s\\S]+/,\n            inside: Prism.languages.kotlin\n        }\n    };\n    Prism.languages.insertBefore(\"kotlin\", \"string\", {\n        // https://kotlinlang.org/spec/expressions.html#string-interpolation-expressions\n        \"string-literal\": [\n            {\n                pattern: /\"\"\"(?:[^$]|\\$(?:(?!\\{)|\\{[^{}]*\\}))*?\"\"\"/,\n                alias: \"multiline\",\n                inside: {\n                    \"interpolation\": {\n                        pattern: /\\$(?:[a-z_]\\w*|\\{[^{}]*\\})/i,\n                        inside: interpolationInside\n                    },\n                    \"string\": /[\\s\\S]+/\n                }\n            },\n            {\n                pattern: /\"(?:[^\"\\\\\\r\\n$]|\\\\.|\\$(?:(?!\\{)|\\{[^{}]*\\}))*\"/,\n                alias: \"singleline\",\n                inside: {\n                    \"interpolation\": {\n                        pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$(?:[a-z_]\\w*|\\{[^{}]*\\})/i,\n                        lookbehind: true,\n                        inside: interpolationInside\n                    },\n                    \"string\": /[\\s\\S]+/\n                }\n            }\n        ],\n        \"char\": {\n            // https://kotlinlang.org/spec/expressions.html#character-literals\n            pattern: /'(?:[^'\\\\\\r\\n]|\\\\(?:.|u[a-fA-F0-9]{0,4}))'/,\n            greedy: true\n        }\n    });\n    delete Prism.languages.kotlin[\"string\"];\n    Prism.languages.insertBefore(\"kotlin\", \"keyword\", {\n        \"annotation\": {\n            pattern: /\\B@(?:\\w+:)?(?:[A-Z]\\w*|\\[[^\\]]+\\])/,\n            alias: \"builtin\"\n        }\n    });\n    Prism.languages.insertBefore(\"kotlin\", \"function\", {\n        \"label\": {\n            pattern: /\\b\\w+@|@\\w+\\b/,\n            alias: \"symbol\"\n        }\n    });\n    Prism.languages.kt = Prism.languages.kotlin;\n    Prism.languages.kts = Prism.languages.kotlin;\n})(Prism);\n/* FIXME :\n :extend() is not handled specifically : its highlighting is buggy.\n Mixin usage must be inside a ruleset to be highlighted.\n At-rules (e.g. import) containing interpolations are buggy.\n Detached rulesets are highlighted as at-rules.\n A comment before a mixin usage prevents the latter to be properly highlighted.\n */ Prism.languages.less = Prism.languages.extend(\"css\", {\n    \"comment\": [\n        /\\/\\*[\\s\\S]*?\\*\\//,\n        {\n            pattern: /(^|[^\\\\])\\/\\/.*/,\n            lookbehind: true\n        }\n    ],\n    \"atrule\": {\n        pattern: /@[\\w-](?:\\((?:[^(){}]|\\([^(){}]*\\))*\\)|[^(){};\\s]|\\s+(?!\\s))*?(?=\\s*\\{)/,\n        inside: {\n            \"punctuation\": /[:()]/\n        }\n    },\n    // selectors and mixins are considered the same\n    \"selector\": {\n        pattern: /(?:@\\{[\\w-]+\\}|[^{};\\s@])(?:@\\{[\\w-]+\\}|\\((?:[^(){}]|\\([^(){}]*\\))*\\)|[^(){};@\\s]|\\s+(?!\\s))*?(?=\\s*\\{)/,\n        inside: {\n            // mixin parameters\n            \"variable\": /@+[\\w-]+/\n        }\n    },\n    \"property\": /(?:@\\{[\\w-]+\\}|[\\w-])+(?:\\+_?)?(?=\\s*:)/,\n    \"operator\": /[+\\-*\\/]/\n});\nPrism.languages.insertBefore(\"less\", \"property\", {\n    \"variable\": [\n        // Variable declaration (the colon must be consumed!)\n        {\n            pattern: /@[\\w-]+\\s*:/,\n            inside: {\n                \"punctuation\": /:/\n            }\n        },\n        // Variable usage\n        /@@?[\\w-]+/\n    ],\n    \"mixin-usage\": {\n        pattern: /([{;]\\s*)[.#](?!\\d)[\\w-].*?(?=[(;])/,\n        lookbehind: true,\n        alias: \"function\"\n    }\n});\nPrism.languages.lua = {\n    \"comment\": /^#!.+|--(?:\\[(=*)\\[[\\s\\S]*?\\]\\1\\]|.*)/m,\n    // \\z may be used to skip the following space\n    \"string\": {\n        pattern: /([\"'])(?:(?!\\1)[^\\\\\\r\\n]|\\\\z(?:\\r\\n|\\s)|\\\\(?:\\r\\n|[^z]))*\\1|\\[(=*)\\[[\\s\\S]*?\\]\\2\\]/,\n        greedy: true\n    },\n    \"number\": /\\b0x[a-f\\d]+(?:\\.[a-f\\d]*)?(?:p[+-]?\\d+)?\\b|\\b\\d+(?:\\.\\B|(?:\\.\\d*)?(?:e[+-]?\\d+)?\\b)|\\B\\.\\d+(?:e[+-]?\\d+)?\\b/i,\n    \"keyword\": /\\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\\b/,\n    \"function\": /(?!\\d)\\w+(?=\\s*(?:[({]))/,\n    \"operator\": [\n        /[-+*%^&|#]|\\/\\/?|<[<=]?|>[>=]?|[=~]=?/,\n        {\n            // Match \"..\" but don't break \"...\"\n            pattern: /(^|[^.])\\.\\.(?!\\.)/,\n            lookbehind: true\n        }\n    ],\n    \"punctuation\": /[\\[\\](){},;]|\\.+|:+/\n};\nPrism.languages.makefile = {\n    \"comment\": {\n        pattern: /(^|[^\\\\])#(?:\\\\(?:\\r\\n|[\\s\\S])|[^\\\\\\r\\n])*/,\n        lookbehind: true\n    },\n    \"string\": {\n        pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n        greedy: true\n    },\n    \"builtin-target\": {\n        pattern: /\\.[A-Z][^:#=\\s]+(?=\\s*:(?!=))/,\n        alias: \"builtin\"\n    },\n    \"target\": {\n        pattern: /^(?:[^:=\\s]|[ \\t]+(?![\\s:]))+(?=\\s*:(?!=))/m,\n        alias: \"symbol\",\n        inside: {\n            \"variable\": /\\$+(?:(?!\\$)[^(){}:#=\\s]+|(?=[({]))/\n        }\n    },\n    \"variable\": /\\$+(?:(?!\\$)[^(){}:#=\\s]+|\\([@*%<^+?][DF]\\)|(?=[({]))/,\n    // Directives\n    \"keyword\": /-include\\b|\\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\\b/,\n    \"function\": {\n        pattern: /(\\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \\t])/,\n        lookbehind: true\n    },\n    \"operator\": /(?:::|[?:+!])?=|[|@]/,\n    \"punctuation\": /[:;(){}]/\n};\n(function(Prism) {\n    // https://yaml.org/spec/1.2/spec.html#c-ns-anchor-property\n    // https://yaml.org/spec/1.2/spec.html#c-ns-alias-node\n    var anchorOrAlias = /[*&][^\\s[\\]{},]+/;\n    // https://yaml.org/spec/1.2/spec.html#c-ns-tag-property\n    var tag = /!(?:<[\\w\\-%#;/?:@&=+$,.!~*'()[\\]]+>|(?:[a-zA-Z\\d-]*!)?[\\w\\-%#;/?:@&=+$.~*'()]+)?/;\n    // https://yaml.org/spec/1.2/spec.html#c-ns-properties(n,c)\n    var properties = \"(?:\" + tag.source + \"(?:[ \t]+\" + anchorOrAlias.source + \")?|\" + anchorOrAlias.source + \"(?:[ \t]+\" + tag.source + \")?)\";\n    // https://yaml.org/spec/1.2/spec.html#ns-plain(n,c)\n    // This is a simplified version that doesn't support \"#\" and multiline keys\n    // All these long scarry character classes are simplified versions of YAML's characters\n    var plainKey = /(?:[^\\s\\x00-\\x08\\x0e-\\x1f!\"#%&'*,\\-:>?@[\\]`{|}\\x7f-\\x84\\x86-\\x9f\\ud800-\\udfff\\ufffe\\uffff]|[?:-]<PLAIN>)(?:[ \\t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {\n        return /[^\\s\\x00-\\x08\\x0e-\\x1f,[\\]{}\\x7f-\\x84\\x86-\\x9f\\ud800-\\udfff\\ufffe\\uffff]/.source;\n    });\n    var string = /\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"|'(?:[^'\\\\\\r\\n]|\\\\.)*'/.source;\n    /**\n   *\n   * @param {string} value\n   * @param {string} [flags]\n   * @returns {RegExp}\n   */ function createValuePattern(value, flags) {\n        flags = (flags || \"\").replace(/m/g, \"\") + \"m\"; // add m flag\n        var pattern = /([:\\-,[{]\\s*(?:\\s<<prop>>[ \\t]+)?)(?:<<value>>)(?=[ \\t]*(?:$|,|\\]|\\}|(?:[\\r\\n]\\s*)?#))/.source.replace(/<<prop>>/g, function() {\n            return properties;\n        }).replace(/<<value>>/g, function() {\n            return value;\n        });\n        return RegExp(pattern, flags);\n    }\n    Prism.languages.yaml = {\n        \"scalar\": {\n            pattern: RegExp(/([\\-:]\\s*(?:\\s<<prop>>[ \\t]+)?[|>])[ \\t]*(?:((?:\\r?\\n|\\r)[ \\t]+)\\S[^\\r\\n]*(?:\\2[^\\r\\n]+)*)/.source.replace(/<<prop>>/g, function() {\n                return properties;\n            })),\n            lookbehind: true,\n            alias: \"string\"\n        },\n        \"comment\": /#.*/,\n        \"key\": {\n            pattern: RegExp(/((?:^|[:\\-,[{\\r\\n?])[ \\t]*(?:<<prop>>[ \\t]+)?)<<key>>(?=\\s*:\\s)/.source.replace(/<<prop>>/g, function() {\n                return properties;\n            }).replace(/<<key>>/g, function() {\n                return \"(?:\" + plainKey + \"|\" + string + \")\";\n            })),\n            lookbehind: true,\n            greedy: true,\n            alias: \"atrule\"\n        },\n        \"directive\": {\n            pattern: /(^[ \\t]*)%.+/m,\n            lookbehind: true,\n            alias: \"important\"\n        },\n        \"datetime\": {\n            pattern: createValuePattern(/\\d{4}-\\d\\d?-\\d\\d?(?:[tT]|[ \\t]+)\\d\\d?:\\d{2}:\\d{2}(?:\\.\\d*)?(?:[ \\t]*(?:Z|[-+]\\d\\d?(?::\\d{2})?))?|\\d{4}-\\d{2}-\\d{2}|\\d\\d?:\\d{2}(?::\\d{2}(?:\\.\\d*)?)?/.source),\n            lookbehind: true,\n            alias: \"number\"\n        },\n        \"boolean\": {\n            pattern: createValuePattern(/false|true/.source, \"i\"),\n            lookbehind: true,\n            alias: \"important\"\n        },\n        \"null\": {\n            pattern: createValuePattern(/null|~/.source, \"i\"),\n            lookbehind: true,\n            alias: \"important\"\n        },\n        \"string\": {\n            pattern: createValuePattern(string),\n            lookbehind: true,\n            greedy: true\n        },\n        \"number\": {\n            pattern: createValuePattern(/[+-]?(?:0x[\\da-f]+|0o[0-7]+|(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?|\\.inf|\\.nan)/.source, \"i\"),\n            lookbehind: true\n        },\n        \"tag\": tag,\n        \"important\": anchorOrAlias,\n        \"punctuation\": /---|[:[\\]{}\\-,|>?]|\\.\\.\\./\n    };\n    Prism.languages.yml = Prism.languages.yaml;\n})(Prism);\n(function(Prism) {\n    // Allow only one line break\n    var inner = /(?:\\\\.|[^\\\\\\n\\r]|(?:\\n|\\r\\n?)(?![\\r\\n]))/.source;\n    /**\n   * This function is intended for the creation of the bold or italic pattern.\n   *\n   * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.\n   *\n   * _Note:_ Keep in mind that this adds a capturing group.\n   *\n   * @param {string} pattern\n   * @returns {RegExp}\n   */ function createInline(pattern) {\n        pattern = pattern.replace(/<inner>/g, function() {\n            return inner;\n        });\n        return RegExp(/((?:^|[^\\\\])(?:\\\\{2})*)/.source + \"(?:\" + pattern + \")\");\n    }\n    var tableCell = /(?:\\\\.|``(?:[^`\\r\\n]|`(?!`))+``|`[^`\\r\\n]+`|[^\\\\|\\r\\n`])+/.source;\n    var tableRow = /\\|?__(?:\\|__)+\\|?(?:(?:\\n|\\r\\n?)|(?![\\s\\S]))/.source.replace(/__/g, function() {\n        return tableCell;\n    });\n    var tableLine = /\\|?[ \\t]*:?-{3,}:?[ \\t]*(?:\\|[ \\t]*:?-{3,}:?[ \\t]*)+\\|?(?:\\n|\\r\\n?)/.source;\n    Prism.languages.markdown = Prism.languages.extend(\"markup\", {});\n    Prism.languages.insertBefore(\"markdown\", \"prolog\", {\n        \"front-matter-block\": {\n            pattern: /(^(?:\\s*[\\r\\n])?)---(?!.)[\\s\\S]*?[\\r\\n]---(?!.)/,\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"punctuation\": /^---|---$/,\n                \"front-matter\": {\n                    pattern: /\\S+(?:\\s+\\S+)*/,\n                    alias: [\n                        \"yaml\",\n                        \"language-yaml\"\n                    ],\n                    inside: Prism.languages.yaml\n                }\n            }\n        },\n        \"blockquote\": {\n            // > ...\n            pattern: /^>(?:[\\t ]*>)*/m,\n            alias: \"punctuation\"\n        },\n        \"table\": {\n            pattern: RegExp(\"^\" + tableRow + tableLine + \"(?:\" + tableRow + \")*\", \"m\"),\n            inside: {\n                \"table-data-rows\": {\n                    pattern: RegExp(\"^(\" + tableRow + tableLine + \")(?:\" + tableRow + \")*$\"),\n                    lookbehind: true,\n                    inside: {\n                        \"table-data\": {\n                            pattern: RegExp(tableCell),\n                            inside: Prism.languages.markdown\n                        },\n                        \"punctuation\": /\\|/\n                    }\n                },\n                \"table-line\": {\n                    pattern: RegExp(\"^(\" + tableRow + \")\" + tableLine + \"$\"),\n                    lookbehind: true,\n                    inside: {\n                        \"punctuation\": /\\||:?-{3,}:?/\n                    }\n                },\n                \"table-header-row\": {\n                    pattern: RegExp(\"^\" + tableRow + \"$\"),\n                    inside: {\n                        \"table-header\": {\n                            pattern: RegExp(tableCell),\n                            alias: \"important\",\n                            inside: Prism.languages.markdown\n                        },\n                        \"punctuation\": /\\|/\n                    }\n                }\n            }\n        },\n        \"code\": [\n            {\n                // Prefixed by 4 spaces or 1 tab and preceded by an empty line\n                pattern: /((?:^|\\n)[ \\t]*\\n|(?:^|\\r\\n?)[ \\t]*\\r\\n?)(?: {4}|\\t).+(?:(?:\\n|\\r\\n?)(?: {4}|\\t).+)*/,\n                lookbehind: true,\n                alias: \"keyword\"\n            },\n            {\n                // ```optional language\n                // code block\n                // ```\n                pattern: /^```[\\s\\S]*?^```$/m,\n                greedy: true,\n                inside: {\n                    \"code-block\": {\n                        pattern: /^(```.*(?:\\n|\\r\\n?))[\\s\\S]+?(?=(?:\\n|\\r\\n?)^```$)/m,\n                        lookbehind: true\n                    },\n                    \"code-language\": {\n                        pattern: /^(```).+/,\n                        lookbehind: true\n                    },\n                    \"punctuation\": /```/\n                }\n            }\n        ],\n        \"title\": [\n            {\n                // title 1\n                // =======\n                // title 2\n                // -------\n                pattern: /\\S.*(?:\\n|\\r\\n?)(?:==+|--+)(?=[ \\t]*$)/m,\n                alias: \"important\",\n                inside: {\n                    punctuation: /==+$|--+$/\n                }\n            },\n            {\n                // # title 1\n                // ###### title 6\n                pattern: /(^\\s*)#.+/m,\n                lookbehind: true,\n                alias: \"important\",\n                inside: {\n                    punctuation: /^#+|#+$/\n                }\n            }\n        ],\n        \"hr\": {\n            // ***\n            // ---\n            // * * *\n            // -----------\n            pattern: /(^\\s*)([*-])(?:[\\t ]*\\2){2,}(?=\\s*$)/m,\n            lookbehind: true,\n            alias: \"punctuation\"\n        },\n        \"list\": {\n            // * item\n            // + item\n            // - item\n            // 1. item\n            pattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m,\n            lookbehind: true,\n            alias: \"punctuation\"\n        },\n        \"url-reference\": {\n            // [id]: http://example.com \"Optional title\"\n            // [id]: http://example.com 'Optional title'\n            // [id]: http://example.com (Optional title)\n            // [id]: <http://example.com> \"Optional title\"\n            pattern: /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\)))?/,\n            inside: {\n                \"variable\": {\n                    pattern: /^(!?\\[)[^\\]]+/,\n                    lookbehind: true\n                },\n                \"string\": /(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\))$/,\n                \"punctuation\": /^[\\[\\]!:]|[<>]/\n            },\n            alias: \"url\"\n        },\n        \"bold\": {\n            // **strong**\n            // __strong__\n            // allow one nested instance of italic text using the same delimiter\n            pattern: createInline(/\\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\\b|\\*\\*(?:(?!\\*)<inner>|\\*(?:(?!\\*)<inner>)+\\*)+\\*\\*/.source),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"content\": {\n                    pattern: /(^..)[\\s\\S]+(?=..$)/,\n                    lookbehind: true,\n                    inside: {} // see below\n                },\n                \"punctuation\": /\\*\\*|__/\n            }\n        },\n        \"italic\": {\n            // *em*\n            // _em_\n            // allow one nested instance of bold text using the same delimiter\n            pattern: createInline(/\\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\\b|\\*(?:(?!\\*)<inner>|\\*\\*(?:(?!\\*)<inner>)+\\*\\*)+\\*/.source),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"content\": {\n                    pattern: /(^.)[\\s\\S]+(?=.$)/,\n                    lookbehind: true,\n                    inside: {} // see below\n                },\n                \"punctuation\": /[*_]/\n            }\n        },\n        \"strike\": {\n            // ~~strike through~~\n            // ~strike~\n            // eslint-disable-next-line regexp/strict\n            pattern: createInline(/(~~?)(?:(?!~)<inner>)+\\2/.source),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"content\": {\n                    pattern: /(^~~?)[\\s\\S]+(?=\\1$)/,\n                    lookbehind: true,\n                    inside: {} // see below\n                },\n                \"punctuation\": /~~?/\n            }\n        },\n        \"code-snippet\": {\n            // `code`\n            // ``code``\n            pattern: /(^|[^\\\\`])(?:``[^`\\r\\n]+(?:`[^`\\r\\n]+)*``(?!`)|`[^`\\r\\n]+`(?!`))/,\n            lookbehind: true,\n            greedy: true,\n            alias: [\n                \"code\",\n                \"keyword\"\n            ]\n        },\n        \"url\": {\n            // [example](http://example.com \"Optional title\")\n            // [example][id]\n            // [example] [id]\n            pattern: createInline(/!?\\[(?:(?!\\])<inner>)+\\](?:\\([^\\s)]+(?:[\\t ]+\"(?:\\\\.|[^\"\\\\])*\")?\\)|[ \\t]?\\[(?:(?!\\])<inner>)+\\])/.source),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"operator\": /^!/,\n                \"content\": {\n                    pattern: /(^\\[)[^\\]]+(?=\\])/,\n                    lookbehind: true,\n                    inside: {} // see below\n                },\n                \"variable\": {\n                    pattern: /(^\\][ \\t]?\\[)[^\\]]+(?=\\]$)/,\n                    lookbehind: true\n                },\n                \"url\": {\n                    pattern: /(^\\]\\()[^\\s)]+/,\n                    lookbehind: true\n                },\n                \"string\": {\n                    pattern: /(^[ \\t]+)\"(?:\\\\.|[^\"\\\\])*\"(?=\\)$)/,\n                    lookbehind: true\n                }\n            }\n        }\n    });\n    [\n        \"url\",\n        \"bold\",\n        \"italic\",\n        \"strike\"\n    ].forEach(function(token) {\n        [\n            \"url\",\n            \"bold\",\n            \"italic\",\n            \"strike\",\n            \"code-snippet\"\n        ].forEach(function(inside) {\n            if (token !== inside) {\n                Prism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];\n            }\n        });\n    });\n    Prism.hooks.add(\"after-tokenize\", function(env) {\n        if (env.language !== \"markdown\" && env.language !== \"md\") {\n            return;\n        }\n        function walkTokens(tokens) {\n            if (!tokens || typeof tokens === \"string\") {\n                return;\n            }\n            for(var i = 0, l = tokens.length; i < l; i++){\n                var token = tokens[i];\n                if (token.type !== \"code\") {\n                    walkTokens(token.content);\n                    continue;\n                }\n                /*\n         * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token\n         * is optional. But the grammar is defined so that there is only one case we have to handle:\n         *\n         * token.content = [\n         *     <span class=\"punctuation\">```</span>,\n         *     <span class=\"code-language\">xxxx</span>,\n         *     '\\n', // exactly one new lines (\\r or \\n or \\r\\n)\n         *     <span class=\"code-block\">...</span>,\n         *     '\\n', // exactly one new lines again\n         *     <span class=\"punctuation\">```</span>\n         * ];\n         */ var codeLang = token.content[1];\n                var codeBlock = token.content[3];\n                if (codeLang && codeBlock && codeLang.type === \"code-language\" && codeBlock.type === \"code-block\" && typeof codeLang.content === \"string\") {\n                    // this might be a language that Prism does not support\n                    // do some replacements to support C++, C#, and F#\n                    var lang = codeLang.content.replace(/\\b#/g, \"sharp\").replace(/\\b\\+\\+/g, \"pp\");\n                    // only use the first word\n                    lang = (/[a-z][\\w-]*/i.exec(lang) || [\n                        \"\"\n                    ])[0].toLowerCase();\n                    var alias = \"language-\" + lang;\n                    // add alias\n                    if (!codeBlock.alias) {\n                        codeBlock.alias = [\n                            alias\n                        ];\n                    } else if (typeof codeBlock.alias === \"string\") {\n                        codeBlock.alias = [\n                            codeBlock.alias,\n                            alias\n                        ];\n                    } else {\n                        codeBlock.alias.push(alias);\n                    }\n                }\n            }\n        }\n        walkTokens(env.tokens);\n    });\n    Prism.hooks.add(\"wrap\", function(env) {\n        if (env.type !== \"code-block\") {\n            return;\n        }\n        var codeLang = \"\";\n        for(var i = 0, l = env.classes.length; i < l; i++){\n            var cls = env.classes[i];\n            var match = /language-(.+)/.exec(cls);\n            if (match) {\n                codeLang = match[1];\n                break;\n            }\n        }\n        var grammar = Prism.languages[codeLang];\n        if (!grammar) {\n            if (codeLang && codeLang !== \"none\" && Prism.plugins.autoloader) {\n                var id = \"md-\" + new Date().valueOf() + \"-\" + Math.floor(Math.random() * 1e16);\n                env.attributes[\"id\"] = id;\n                Prism.plugins.autoloader.loadLanguages(codeLang, function() {\n                    var ele = document.getElementById(id);\n                    if (ele) {\n                        ele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);\n                    }\n                });\n            }\n        } else {\n            env.content = Prism.highlight(textContent(env.content), grammar, codeLang);\n        }\n    });\n    var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, \"gi\");\n    /**\n   * A list of known entity names.\n   *\n   * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.\n   *\n   * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}\n   */ var KNOWN_ENTITY_NAMES = {\n        \"amp\": \"&\",\n        \"lt\": \"<\",\n        \"gt\": \">\",\n        \"quot\": '\"'\n    };\n    // IE 11 doesn't support `String.fromCodePoint`\n    var fromCodePoint = String.fromCodePoint || String.fromCharCode;\n    /**\n   * Returns the text content of a given HTML source code string.\n   *\n   * @param {string} html\n   * @returns {string}\n   */ function textContent(html) {\n        // remove all tags\n        var text = html.replace(tagPattern, \"\");\n        // decode known entities\n        text = text.replace(/&(\\w{1,8}|#x?[\\da-f]{1,8});/gi, function(m, code) {\n            code = code.toLowerCase();\n            if (code[0] === \"#\") {\n                var value;\n                if (code[1] === \"x\") {\n                    value = parseInt(code.slice(2), 16);\n                } else {\n                    value = Number(code.slice(1));\n                }\n                return fromCodePoint(value);\n            } else {\n                var known = KNOWN_ENTITY_NAMES[code];\n                if (known) {\n                    return known;\n                }\n                // unable to decode\n                return m;\n            }\n        });\n        return text;\n    }\n    Prism.languages.md = Prism.languages.markdown;\n})(Prism);\nPrism.languages.objectivec = Prism.languages.extend(\"c\", {\n    \"string\": {\n        pattern: /@?\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n        greedy: true\n    },\n    \"keyword\": /\\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\\b/,\n    \"operator\": /-[->]?|\\+\\+?|!=?|<<?=?|>>?=?|==?|&&?|\\|\\|?|[~^%?*\\/@]/\n});\ndelete Prism.languages.objectivec[\"class-name\"];\nPrism.languages.objc = Prism.languages.objectivec;\n(function(Prism) {\n    var brackets = /(?:\\((?:[^()\\\\]|\\\\[\\s\\S])*\\)|\\{(?:[^{}\\\\]|\\\\[\\s\\S])*\\}|\\[(?:[^[\\]\\\\]|\\\\[\\s\\S])*\\]|<(?:[^<>\\\\]|\\\\[\\s\\S])*>)/.source;\n    Prism.languages.perl = {\n        \"comment\": [\n            {\n                // POD\n                pattern: /(^\\s*)=\\w[\\s\\S]*?=cut.*/m,\n                lookbehind: true,\n                greedy: true\n            },\n            {\n                pattern: /(^|[^\\\\$])#.*/,\n                lookbehind: true,\n                greedy: true\n            }\n        ],\n        // TODO Could be nice to handle Heredoc too.\n        \"string\": [\n            {\n                pattern: RegExp(/\\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\\s*/.source + \"(?:\" + [\n                    // q/.../\n                    /([^a-zA-Z0-9\\s{(\\[<])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/.source,\n                    // q a...a\n                    // eslint-disable-next-line regexp/strict\n                    /([a-zA-Z0-9])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2/.source,\n                    // q(...)\n                    // q{...}\n                    // q[...]\n                    // q<...>\n                    brackets\n                ].join(\"|\") + \")\"),\n                greedy: true\n            },\n            // \"...\", `...`\n            {\n                pattern: /(\"|`)(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/,\n                greedy: true\n            },\n            // '...'\n            // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '\n            {\n                pattern: /'(?:[^'\\\\\\r\\n]|\\\\.)*'/,\n                greedy: true\n            }\n        ],\n        \"regex\": [\n            {\n                pattern: RegExp(/\\b(?:m|qr)(?![a-zA-Z0-9])\\s*/.source + \"(?:\" + [\n                    // m/.../\n                    /([^a-zA-Z0-9\\s{(\\[<])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/.source,\n                    // m a...a\n                    // eslint-disable-next-line regexp/strict\n                    /([a-zA-Z0-9])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2/.source,\n                    // m(...)\n                    // m{...}\n                    // m[...]\n                    // m<...>\n                    brackets\n                ].join(\"|\") + \")\" + /[msixpodualngc]*/.source),\n                greedy: true\n            },\n            // The lookbehinds prevent -s from breaking\n            {\n                pattern: RegExp(/(^|[^-])\\b(?:s|tr|y)(?![a-zA-Z0-9])\\s*/.source + \"(?:\" + [\n                    // s/.../.../\n                    // eslint-disable-next-line regexp/strict\n                    /([^a-zA-Z0-9\\s{(\\[<])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2/.source,\n                    // s a...a...a\n                    // eslint-disable-next-line regexp/strict\n                    /([a-zA-Z0-9])(?:(?!\\3)[^\\\\]|\\\\[\\s\\S])*\\3(?:(?!\\3)[^\\\\]|\\\\[\\s\\S])*\\3/.source,\n                    // s(...)(...)\n                    // s{...}{...}\n                    // s[...][...]\n                    // s<...><...>\n                    // s(...)[...]\n                    brackets + /\\s*/.source + brackets\n                ].join(\"|\") + \")\" + /[msixpodualngcer]*/.source),\n                lookbehind: true,\n                greedy: true\n            },\n            // /.../\n            // The look-ahead tries to prevent two divisions on\n            // the same line from being highlighted as regex.\n            // This does not support multi-line regex.\n            {\n                pattern: /\\/(?:[^\\/\\\\\\r\\n]|\\\\.)*\\/[msixpodualngc]*(?=\\s*(?:$|[\\r\\n,.;})&|\\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\\b))/,\n                greedy: true\n            }\n        ],\n        // FIXME Not sure about the handling of ::, ', and #\n        \"variable\": [\n            // ${^POSTMATCH}\n            /[&*$@%]\\{\\^[A-Z]+\\}/,\n            // $^V\n            /[&*$@%]\\^[A-Z_]/,\n            // ${...}\n            /[&*$@%]#?(?=\\{)/,\n            // $foo\n            /[&*$@%]#?(?:(?:::)*'?(?!\\d)[\\w$]+(?![\\w$]))+(?:::)*/,\n            // $1\n            /[&*$@%]\\d+/,\n            // $_, @_, %!\n            // The negative lookahead prevents from breaking the %= operator\n            /(?!%=)[$@%][!\"#$%&'()*+,\\-.\\/:;<=>?@[\\\\\\]^_`{|}~]/\n        ],\n        \"filehandle\": {\n            // <>, <FOO>, _\n            pattern: /<(?![<=])\\S*?>|\\b_\\b/,\n            alias: \"symbol\"\n        },\n        \"v-string\": {\n            // v1.2, 1.2.3\n            pattern: /v\\d+(?:\\.\\d+)*|\\d+(?:\\.\\d+){2,}/,\n            alias: \"string\"\n        },\n        \"function\": {\n            pattern: /(\\bsub[ \\t]+)\\w+/,\n            lookbehind: true\n        },\n        \"keyword\": /\\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\\b/,\n        \"number\": /\\b(?:0x[\\dA-Fa-f](?:_?[\\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\\d(?:_?\\d)*)?\\.)?\\d(?:_?\\d)*(?:[Ee][+-]?\\d+)?)\\b/,\n        \"operator\": /-[rwxoRWXOezsfdlpSbctugkTBMAC]\\b|\\+[+=]?|-[-=>]?|\\*\\*?=?|\\/\\/?=?|=[=~>]?|~[~=]?|\\|\\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\\.(?:=|\\.\\.?)?|[\\\\?]|\\bx(?:=|\\b)|\\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\\b/,\n        \"punctuation\": /[{}[\\];(),:]/\n    };\n})(Prism);\n(function(Prism) {\n    /**\n   * Returns the placeholder for the given language id and index.\n   *\n   * @param {string} language\n   * @param {string|number} index\n   * @returns {string}\n   */ function getPlaceholder(language, index) {\n        return \"___\" + language.toUpperCase() + index + \"___\";\n    }\n    Object.defineProperties(Prism.languages[\"markup-templating\"] = {}, {\n        buildPlaceholders: {\n            /**\n       * Tokenize all inline templating expressions matching `placeholderPattern`.\n       *\n       * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n       * `true` will be replaced.\n       *\n       * @param {object} env The environment of the `before-tokenize` hook.\n       * @param {string} language The language id.\n       * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n       * @param {(match: string) => boolean} [replaceFilter]\n       */ value: function(env, language, placeholderPattern, replaceFilter) {\n                if (env.language !== language) {\n                    return;\n                }\n                var tokenStack = env.tokenStack = [];\n                env.code = env.code.replace(placeholderPattern, function(match) {\n                    if (typeof replaceFilter === \"function\" && !replaceFilter(match)) {\n                        return match;\n                    }\n                    var i = tokenStack.length;\n                    var placeholder;\n                    // Check for existing strings\n                    while(env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1){\n                        ++i;\n                    }\n                    // Create a sparse array\n                    tokenStack[i] = match;\n                    return placeholder;\n                });\n                // Switch the grammar to markup\n                env.grammar = Prism.languages.markup;\n            }\n        },\n        tokenizePlaceholders: {\n            /**\n       * Replace placeholders with proper tokens after tokenizing.\n       *\n       * @param {object} env The environment of the `after-tokenize` hook.\n       * @param {string} language The language id.\n       */ value: function(env, language) {\n                if (env.language !== language || !env.tokenStack) {\n                    return;\n                }\n                // Switch the grammar back\n                env.grammar = Prism.languages[language];\n                var j = 0;\n                var keys = Object.keys(env.tokenStack);\n                function walkTokens(tokens) {\n                    for(var i = 0; i < tokens.length; i++){\n                        // all placeholders are replaced already\n                        if (j >= keys.length) {\n                            break;\n                        }\n                        var token = tokens[i];\n                        if (typeof token === \"string\" || token.content && typeof token.content === \"string\") {\n                            var k = keys[j];\n                            var t = env.tokenStack[k];\n                            var s = typeof token === \"string\" ? token : token.content;\n                            var placeholder = getPlaceholder(language, k);\n                            var index = s.indexOf(placeholder);\n                            if (index > -1) {\n                                ++j;\n                                var before = s.substring(0, index);\n                                var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), \"language-\" + language, t);\n                                var after = s.substring(index + placeholder.length);\n                                var replacement = [];\n                                if (before) {\n                                    replacement.push.apply(replacement, walkTokens([\n                                        before\n                                    ]));\n                                }\n                                replacement.push(middle);\n                                if (after) {\n                                    replacement.push.apply(replacement, walkTokens([\n                                        after\n                                    ]));\n                                }\n                                if (typeof token === \"string\") {\n                                    tokens.splice.apply(tokens, [\n                                        i,\n                                        1\n                                    ].concat(replacement));\n                                } else {\n                                    token.content = replacement;\n                                }\n                            }\n                        } else if (token.content /* && typeof token.content !== 'string' */ ) {\n                            walkTokens(token.content);\n                        }\n                    }\n                    return tokens;\n                }\n                walkTokens(env.tokens);\n            }\n        }\n    });\n})(Prism);\n/**\n * Original by Aaron Harun: http://aahacreative.com/2012/07/31/php-syntax-highlighting-prism/\n * Modified by Miles Johnson: http://milesj.me\n * Rewritten by Tom Pavelec\n *\n * Supports PHP 5.3 - 8.0\n */ (function(Prism) {\n    var comment = /\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*|#(?!\\[).*/;\n    var constant = [\n        {\n            pattern: /\\b(?:false|true)\\b/i,\n            alias: \"boolean\"\n        },\n        {\n            pattern: /(::\\s*)\\b[a-z_]\\w*\\b(?!\\s*\\()/i,\n            greedy: true,\n            lookbehind: true\n        },\n        {\n            pattern: /(\\b(?:case|const)\\s+)\\b[a-z_]\\w*(?=\\s*[;=])/i,\n            greedy: true,\n            lookbehind: true\n        },\n        /\\b(?:null)\\b/i,\n        /\\b[A-Z_][A-Z0-9_]*\\b(?!\\s*\\()/\n    ];\n    var number = /\\b0b[01]+(?:_[01]+)*\\b|\\b0o[0-7]+(?:_[0-7]+)*\\b|\\b0x[\\da-f]+(?:_[\\da-f]+)*\\b|(?:\\b\\d+(?:_\\d+)*\\.?(?:\\d+(?:_\\d+)*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i;\n    var operator = /<?=>|\\?\\?=?|\\.{3}|\\??->|[!=]=?=?|::|\\*\\*=?|--|\\+\\+|&&|\\|\\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;\n    var punctuation = /[{}\\[\\](),:;]/;\n    Prism.languages.php = {\n        \"delimiter\": {\n            pattern: /\\?>$|^<\\?(?:php(?=\\s)|=)?/i,\n            alias: \"important\"\n        },\n        \"comment\": comment,\n        \"variable\": /\\$+(?:\\w+\\b|(?=\\{))/,\n        \"package\": {\n            pattern: /(namespace\\s+|use\\s+(?:function\\s+)?)(?:\\\\?\\b[a-z_]\\w*)+\\b(?!\\\\)/i,\n            lookbehind: true,\n            inside: {\n                \"punctuation\": /\\\\/\n            }\n        },\n        \"class-name-definition\": {\n            pattern: /(\\b(?:class|enum|interface|trait)\\s+)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n            lookbehind: true,\n            alias: \"class-name\"\n        },\n        \"function-definition\": {\n            pattern: /(\\bfunction\\s+)[a-z_]\\w*(?=\\s*\\()/i,\n            lookbehind: true,\n            alias: \"function\"\n        },\n        \"keyword\": [\n            {\n                pattern: /(\\(\\s*)\\b(?:array|bool|boolean|float|int|integer|object|string)\\b(?=\\s*\\))/i,\n                alias: \"type-casting\",\n                greedy: true,\n                lookbehind: true\n            },\n            {\n                pattern: /([(,?]\\s*)\\b(?:array(?!\\s*\\()|bool|callable|(?:false|null)(?=\\s*\\|)|float|int|iterable|mixed|object|self|static|string)\\b(?=\\s*\\$)/i,\n                alias: \"type-hint\",\n                greedy: true,\n                lookbehind: true\n            },\n            {\n                pattern: /(\\)\\s*:\\s*(?:\\?\\s*)?)\\b(?:array(?!\\s*\\()|bool|callable|(?:false|null)(?=\\s*\\|)|float|int|iterable|mixed|never|object|self|static|string|void)\\b/i,\n                alias: \"return-type\",\n                greedy: true,\n                lookbehind: true\n            },\n            {\n                pattern: /\\b(?:array(?!\\s*\\()|bool|float|int|iterable|mixed|object|string|void)\\b/i,\n                alias: \"type-declaration\",\n                greedy: true\n            },\n            {\n                pattern: /(\\|\\s*)(?:false|null)\\b|\\b(?:false|null)(?=\\s*\\|)/i,\n                alias: \"type-declaration\",\n                greedy: true,\n                lookbehind: true\n            },\n            {\n                pattern: /\\b(?:parent|self|static)(?=\\s*::)/i,\n                alias: \"static-context\",\n                greedy: true\n            },\n            {\n                // yield from\n                pattern: /(\\byield\\s+)from\\b/i,\n                lookbehind: true\n            },\n            // `class` is always a keyword unlike other keywords\n            /\\bclass\\b/i,\n            {\n                // https://www.php.net/manual/en/reserved.keywords.php\n                //\n                // keywords cannot be preceded by \"->\"\n                // the complex lookbehind means `(?<!(?:->|::)\\s*)`\n                pattern: /((?:^|[^\\s>:]|(?:^|[^-])>|(?:^|[^:]):)\\s*)\\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\\b/i,\n                lookbehind: true\n            }\n        ],\n        \"argument-name\": {\n            pattern: /([(,]\\s*)\\b[a-z_]\\w*(?=\\s*:(?!:))/i,\n            lookbehind: true\n        },\n        \"class-name\": [\n            {\n                pattern: /(\\b(?:extends|implements|instanceof|new(?!\\s+self|\\s+static))\\s+|\\bcatch\\s*\\()\\b[a-z_]\\w*(?!\\\\)\\b/i,\n                greedy: true,\n                lookbehind: true\n            },\n            {\n                pattern: /(\\|\\s*)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n                greedy: true,\n                lookbehind: true\n            },\n            {\n                pattern: /\\b[a-z_]\\w*(?!\\\\)\\b(?=\\s*\\|)/i,\n                greedy: true\n            },\n            {\n                pattern: /(\\|\\s*)(?:\\\\?\\b[a-z_]\\w*)+\\b/i,\n                alias: \"class-name-fully-qualified\",\n                greedy: true,\n                lookbehind: true,\n                inside: {\n                    \"punctuation\": /\\\\/\n                }\n            },\n            {\n                pattern: /(?:\\\\?\\b[a-z_]\\w*)+\\b(?=\\s*\\|)/i,\n                alias: \"class-name-fully-qualified\",\n                greedy: true,\n                inside: {\n                    \"punctuation\": /\\\\/\n                }\n            },\n            {\n                pattern: /(\\b(?:extends|implements|instanceof|new(?!\\s+self\\b|\\s+static\\b))\\s+|\\bcatch\\s*\\()(?:\\\\?\\b[a-z_]\\w*)+\\b(?!\\\\)/i,\n                alias: \"class-name-fully-qualified\",\n                greedy: true,\n                lookbehind: true,\n                inside: {\n                    \"punctuation\": /\\\\/\n                }\n            },\n            {\n                pattern: /\\b[a-z_]\\w*(?=\\s*\\$)/i,\n                alias: \"type-declaration\",\n                greedy: true\n            },\n            {\n                pattern: /(?:\\\\?\\b[a-z_]\\w*)+(?=\\s*\\$)/i,\n                alias: [\n                    \"class-name-fully-qualified\",\n                    \"type-declaration\"\n                ],\n                greedy: true,\n                inside: {\n                    \"punctuation\": /\\\\/\n                }\n            },\n            {\n                pattern: /\\b[a-z_]\\w*(?=\\s*::)/i,\n                alias: \"static-context\",\n                greedy: true\n            },\n            {\n                pattern: /(?:\\\\?\\b[a-z_]\\w*)+(?=\\s*::)/i,\n                alias: [\n                    \"class-name-fully-qualified\",\n                    \"static-context\"\n                ],\n                greedy: true,\n                inside: {\n                    \"punctuation\": /\\\\/\n                }\n            },\n            {\n                pattern: /([(,?]\\s*)[a-z_]\\w*(?=\\s*\\$)/i,\n                alias: \"type-hint\",\n                greedy: true,\n                lookbehind: true\n            },\n            {\n                pattern: /([(,?]\\s*)(?:\\\\?\\b[a-z_]\\w*)+(?=\\s*\\$)/i,\n                alias: [\n                    \"class-name-fully-qualified\",\n                    \"type-hint\"\n                ],\n                greedy: true,\n                lookbehind: true,\n                inside: {\n                    \"punctuation\": /\\\\/\n                }\n            },\n            {\n                pattern: /(\\)\\s*:\\s*(?:\\?\\s*)?)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n                alias: \"return-type\",\n                greedy: true,\n                lookbehind: true\n            },\n            {\n                pattern: /(\\)\\s*:\\s*(?:\\?\\s*)?)(?:\\\\?\\b[a-z_]\\w*)+\\b(?!\\\\)/i,\n                alias: [\n                    \"class-name-fully-qualified\",\n                    \"return-type\"\n                ],\n                greedy: true,\n                lookbehind: true,\n                inside: {\n                    \"punctuation\": /\\\\/\n                }\n            }\n        ],\n        \"constant\": constant,\n        \"function\": {\n            pattern: /(^|[^\\\\\\w])\\\\?[a-z_](?:[\\w\\\\]*\\w)?(?=\\s*\\()/i,\n            lookbehind: true,\n            inside: {\n                \"punctuation\": /\\\\/\n            }\n        },\n        \"property\": {\n            pattern: /(->\\s*)\\w+/,\n            lookbehind: true\n        },\n        \"number\": number,\n        \"operator\": operator,\n        \"punctuation\": punctuation\n    };\n    var string_interpolation = {\n        pattern: /\\{\\$(?:\\{(?:\\{[^{}]+\\}|[^{}]+)\\}|[^{}])+\\}|(^|[^\\\\{])\\$+(?:\\w+(?:\\[[^\\r\\n\\[\\]]+\\]|->\\w+)?)/,\n        lookbehind: true,\n        inside: Prism.languages.php\n    };\n    var string = [\n        {\n            pattern: /<<<'([^']+)'[\\r\\n](?:.*[\\r\\n])*?\\1;/,\n            alias: \"nowdoc-string\",\n            greedy: true,\n            inside: {\n                \"delimiter\": {\n                    pattern: /^<<<'[^']+'|[a-z_]\\w*;$/i,\n                    alias: \"symbol\",\n                    inside: {\n                        \"punctuation\": /^<<<'?|[';]$/\n                    }\n                }\n            }\n        },\n        {\n            pattern: /<<<(?:\"([^\"]+)\"[\\r\\n](?:.*[\\r\\n])*?\\1;|([a-z_]\\w*)[\\r\\n](?:.*[\\r\\n])*?\\2;)/i,\n            alias: \"heredoc-string\",\n            greedy: true,\n            inside: {\n                \"delimiter\": {\n                    pattern: /^<<<(?:\"[^\"]+\"|[a-z_]\\w*)|[a-z_]\\w*;$/i,\n                    alias: \"symbol\",\n                    inside: {\n                        \"punctuation\": /^<<<\"?|[\";]$/\n                    }\n                },\n                \"interpolation\": string_interpolation\n            }\n        },\n        {\n            pattern: /`(?:\\\\[\\s\\S]|[^\\\\`])*`/,\n            alias: \"backtick-quoted-string\",\n            greedy: true\n        },\n        {\n            pattern: /'(?:\\\\[\\s\\S]|[^\\\\'])*'/,\n            alias: \"single-quoted-string\",\n            greedy: true\n        },\n        {\n            pattern: /\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"/,\n            alias: \"double-quoted-string\",\n            greedy: true,\n            inside: {\n                \"interpolation\": string_interpolation\n            }\n        }\n    ];\n    Prism.languages.insertBefore(\"php\", \"variable\", {\n        \"string\": string,\n        \"attribute\": {\n            pattern: /#\\[(?:[^\"'\\/#]|\\/(?![*/])|\\/\\/.*$|#(?!\\[).*$|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*')+\\](?=\\s*[a-z$#])/im,\n            greedy: true,\n            inside: {\n                \"attribute-content\": {\n                    pattern: /^(#\\[)[\\s\\S]+(?=\\]$)/,\n                    lookbehind: true,\n                    // inside can appear subset of php\n                    inside: {\n                        \"comment\": comment,\n                        \"string\": string,\n                        \"attribute-class-name\": [\n                            {\n                                pattern: /([^:]|^)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n                                alias: \"class-name\",\n                                greedy: true,\n                                lookbehind: true\n                            },\n                            {\n                                pattern: /([^:]|^)(?:\\\\?\\b[a-z_]\\w*)+/i,\n                                alias: [\n                                    \"class-name\",\n                                    \"class-name-fully-qualified\"\n                                ],\n                                greedy: true,\n                                lookbehind: true,\n                                inside: {\n                                    \"punctuation\": /\\\\/\n                                }\n                            }\n                        ],\n                        \"constant\": constant,\n                        \"number\": number,\n                        \"operator\": operator,\n                        \"punctuation\": punctuation\n                    }\n                },\n                \"delimiter\": {\n                    pattern: /^#\\[|\\]$/,\n                    alias: \"punctuation\"\n                }\n            }\n        }\n    });\n    Prism.hooks.add(\"before-tokenize\", function(env) {\n        if (!/<\\?/.test(env.code)) {\n            return;\n        }\n        var phpPattern = /<\\?(?:[^\"'/#]|\\/(?![*/])|(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|(?:\\/\\/|#(?!\\[))(?:[^?\\n\\r]|\\?(?!>))*(?=$|\\?>|[\\r\\n])|#\\[|\\/\\*(?:[^*]|\\*(?!\\/))*(?:\\*\\/|$))*?(?:\\?>|$)/g;\n        Prism.languages[\"markup-templating\"].buildPlaceholders(env, \"php\", phpPattern);\n    });\n    Prism.hooks.add(\"after-tokenize\", function(env) {\n        Prism.languages[\"markup-templating\"].tokenizePlaceholders(env, \"php\");\n    });\n})(Prism);\nPrism.languages.python = {\n    \"comment\": {\n        pattern: /(^|[^\\\\])#.*/,\n        lookbehind: true,\n        greedy: true\n    },\n    \"string-interpolation\": {\n        pattern: /(?:f|fr|rf)(?:(\"\"\"|''')[\\s\\S]*?\\1|(\"|')(?:\\\\.|(?!\\2)[^\\\\\\r\\n])*\\2)/i,\n        greedy: true,\n        inside: {\n            \"interpolation\": {\n                // \"{\" <expression> <optional \"!s\", \"!r\", or \"!a\"> <optional \":\" format specifier> \"}\"\n                pattern: /((?:^|[^{])(?:\\{\\{)*)\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}])+\\})+\\})+\\}/,\n                lookbehind: true,\n                inside: {\n                    \"format-spec\": {\n                        pattern: /(:)[^:(){}]+(?=\\}$)/,\n                        lookbehind: true\n                    },\n                    \"conversion-option\": {\n                        pattern: /![sra](?=[:}]$)/,\n                        alias: \"punctuation\"\n                    },\n                    rest: null\n                }\n            },\n            \"string\": /[\\s\\S]+/\n        }\n    },\n    \"triple-quoted-string\": {\n        pattern: /(?:[rub]|br|rb)?(\"\"\"|''')[\\s\\S]*?\\1/i,\n        greedy: true,\n        alias: \"string\"\n    },\n    \"string\": {\n        pattern: /(?:[rub]|br|rb)?(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/i,\n        greedy: true\n    },\n    \"function\": {\n        pattern: /((?:^|\\s)def[ \\t]+)[a-zA-Z_]\\w*(?=\\s*\\()/g,\n        lookbehind: true\n    },\n    \"class-name\": {\n        pattern: /(\\bclass\\s+)\\w+/i,\n        lookbehind: true\n    },\n    \"decorator\": {\n        pattern: /(^[\\t ]*)@\\w+(?:\\.\\w+)*/m,\n        lookbehind: true,\n        alias: [\n            \"annotation\",\n            \"punctuation\"\n        ],\n        inside: {\n            \"punctuation\": /\\./\n        }\n    },\n    \"keyword\": /\\b(?:_(?=\\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\\b/,\n    \"builtin\": /\\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\\b/,\n    \"boolean\": /\\b(?:False|None|True)\\b/,\n    \"number\": /\\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\\b|(?:\\b\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\B\\.\\d+(?:_\\d+)*)(?:e[+-]?\\d+(?:_\\d+)*)?j?(?!\\w)/i,\n    \"operator\": /[-+%=]=?|!=|:=|\\*\\*?=?|\\/\\/?=?|<[<=>]?|>[=>]?|[&|^~]/,\n    \"punctuation\": /[{}[\\];(),.:]/\n};\nPrism.languages.python[\"string-interpolation\"].inside[\"interpolation\"].inside.rest = Prism.languages.python;\nPrism.languages.py = Prism.languages.python;\nPrism.languages.r = {\n    \"comment\": /#.*/,\n    \"string\": {\n        pattern: /(['\"])(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n        greedy: true\n    },\n    \"percent-operator\": {\n        // Includes user-defined operators\n        // and %%, %*%, %/%, %in%, %o%, %x%\n        pattern: /%[^%\\s]*%/,\n        alias: \"operator\"\n    },\n    \"boolean\": /\\b(?:FALSE|TRUE)\\b/,\n    \"ellipsis\": /\\.\\.(?:\\.|\\d+)/,\n    \"number\": [\n        /\\b(?:Inf|NaN)\\b/,\n        /(?:\\b0x[\\dA-Fa-f]+(?:\\.\\d*)?|\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[EePp][+-]?\\d+)?[iL]?/\n    ],\n    \"keyword\": /\\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\\b/,\n    \"operator\": /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\\|\\|?|[+*\\/^$@~]/,\n    \"punctuation\": /[(){}\\[\\],;]/\n};\n/**\n * Original by Samuel Flores\n *\n * Adds the following new token classes:\n *     constant, builtin, variable, symbol, regex\n */ (function(Prism) {\n    Prism.languages.ruby = Prism.languages.extend(\"clike\", {\n        \"comment\": {\n            pattern: /#.*|^=begin\\s[\\s\\S]*?^=end/m,\n            greedy: true\n        },\n        \"class-name\": {\n            pattern: /(\\b(?:class|module)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+|\\b[A-Z_]\\w*(?=\\s*\\.\\s*new\\b)/,\n            lookbehind: true,\n            inside: {\n                \"punctuation\": /[.\\\\]/\n            }\n        },\n        \"keyword\": /\\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\\b/,\n        \"operator\": /\\.{2,3}|&\\.|===|<?=>|[!=]?~|(?:&&|\\|\\||<<|>>|\\*\\*|[+\\-*/%<>!^&|=])=?|[?:]/,\n        \"punctuation\": /[(){}[\\].,;]/\n    });\n    Prism.languages.insertBefore(\"ruby\", \"operator\", {\n        \"double-colon\": {\n            pattern: /::/,\n            alias: \"punctuation\"\n        }\n    });\n    var interpolation = {\n        pattern: /((?:^|[^\\\\])(?:\\\\{2})*)#\\{(?:[^{}]|\\{[^{}]*\\})*\\}/,\n        lookbehind: true,\n        inside: {\n            \"content\": {\n                pattern: /^(#\\{)[\\s\\S]+(?=\\}$)/,\n                lookbehind: true,\n                inside: Prism.languages.ruby\n            },\n            \"delimiter\": {\n                pattern: /^#\\{|\\}$/,\n                alias: \"punctuation\"\n            }\n        }\n    };\n    delete Prism.languages.ruby.function;\n    var percentExpression = \"(?:\" + [\n        /([^a-zA-Z0-9\\s{(\\[<=])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/.source,\n        /\\((?:[^()\\\\]|\\\\[\\s\\S]|\\((?:[^()\\\\]|\\\\[\\s\\S])*\\))*\\)/.source,\n        /\\{(?:[^{}\\\\]|\\\\[\\s\\S]|\\{(?:[^{}\\\\]|\\\\[\\s\\S])*\\})*\\}/.source,\n        /\\[(?:[^\\[\\]\\\\]|\\\\[\\s\\S]|\\[(?:[^\\[\\]\\\\]|\\\\[\\s\\S])*\\])*\\]/.source,\n        /<(?:[^<>\\\\]|\\\\[\\s\\S]|<(?:[^<>\\\\]|\\\\[\\s\\S])*>)*>/.source\n    ].join(\"|\") + \")\";\n    var symbolName = /(?:\"(?:\\\\.|[^\"\\\\\\r\\n])*\"|(?:\\b[a-zA-Z_]\\w*|[^\\s\\0-\\x7F]+)[?!]?|\\$.)/.source;\n    Prism.languages.insertBefore(\"ruby\", \"keyword\", {\n        \"regex-literal\": [\n            {\n                pattern: RegExp(/%r/.source + percentExpression + /[egimnosux]{0,6}/.source),\n                greedy: true,\n                inside: {\n                    \"interpolation\": interpolation,\n                    \"regex\": /[\\s\\S]+/\n                }\n            },\n            {\n                pattern: /(^|[^/])\\/(?!\\/)(?:\\[[^\\r\\n\\]]+\\]|\\\\.|[^[/\\\\\\r\\n])+\\/[egimnosux]{0,6}(?=\\s*(?:$|[\\r\\n,.;})#]))/,\n                lookbehind: true,\n                greedy: true,\n                inside: {\n                    \"interpolation\": interpolation,\n                    \"regex\": /[\\s\\S]+/\n                }\n            }\n        ],\n        \"variable\": /[@$]+[a-zA-Z_]\\w*(?:[?!]|\\b)/,\n        \"symbol\": [\n            {\n                pattern: RegExp(/(^|[^:]):/.source + symbolName),\n                lookbehind: true,\n                greedy: true\n            },\n            {\n                pattern: RegExp(/([\\r\\n{(,][ \\t]*)/.source + symbolName + /(?=:(?!:))/.source),\n                lookbehind: true,\n                greedy: true\n            }\n        ],\n        \"method-definition\": {\n            pattern: /(\\bdef\\s+)\\w+(?:\\s*\\.\\s*\\w+)?/,\n            lookbehind: true,\n            inside: {\n                \"function\": /\\b\\w+$/,\n                \"keyword\": /^self\\b/,\n                \"class-name\": /^\\w+/,\n                \"punctuation\": /\\./\n            }\n        }\n    });\n    Prism.languages.insertBefore(\"ruby\", \"string\", {\n        \"string-literal\": [\n            {\n                pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),\n                greedy: true,\n                inside: {\n                    \"interpolation\": interpolation,\n                    \"string\": /[\\s\\S]+/\n                }\n            },\n            {\n                pattern: /(\"|')(?:#\\{[^}]+\\}|#(?!\\{)|\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\#\\r\\n])*\\1/,\n                greedy: true,\n                inside: {\n                    \"interpolation\": interpolation,\n                    \"string\": /[\\s\\S]+/\n                }\n            },\n            {\n                pattern: /<<[-~]?([a-z_]\\w*)[\\r\\n](?:.*[\\r\\n])*?[\\t ]*\\1/i,\n                alias: \"heredoc-string\",\n                greedy: true,\n                inside: {\n                    \"delimiter\": {\n                        pattern: /^<<[-~]?[a-z_]\\w*|\\b[a-z_]\\w*$/i,\n                        inside: {\n                            \"symbol\": /\\b\\w+/,\n                            \"punctuation\": /^<<[-~]?/\n                        }\n                    },\n                    \"interpolation\": interpolation,\n                    \"string\": /[\\s\\S]+/\n                }\n            },\n            {\n                pattern: /<<[-~]?'([a-z_]\\w*)'[\\r\\n](?:.*[\\r\\n])*?[\\t ]*\\1/i,\n                alias: \"heredoc-string\",\n                greedy: true,\n                inside: {\n                    \"delimiter\": {\n                        pattern: /^<<[-~]?'[a-z_]\\w*'|\\b[a-z_]\\w*$/i,\n                        inside: {\n                            \"symbol\": /\\b\\w+/,\n                            \"punctuation\": /^<<[-~]?'|'$/\n                        }\n                    },\n                    \"string\": /[\\s\\S]+/\n                }\n            }\n        ],\n        \"command-literal\": [\n            {\n                pattern: RegExp(/%x/.source + percentExpression),\n                greedy: true,\n                inside: {\n                    \"interpolation\": interpolation,\n                    \"command\": {\n                        pattern: /[\\s\\S]+/,\n                        alias: \"string\"\n                    }\n                }\n            },\n            {\n                pattern: /`(?:#\\{[^}]+\\}|#(?!\\{)|\\\\(?:\\r\\n|[\\s\\S])|[^\\\\`#\\r\\n])*`/,\n                greedy: true,\n                inside: {\n                    \"interpolation\": interpolation,\n                    \"command\": {\n                        pattern: /[\\s\\S]+/,\n                        alias: \"string\"\n                    }\n                }\n            }\n        ]\n    });\n    delete Prism.languages.ruby.string;\n    Prism.languages.insertBefore(\"ruby\", \"number\", {\n        \"builtin\": /\\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\\b/,\n        \"constant\": /\\b[A-Z][A-Z0-9_]*(?:[?!]|\\b)/\n    });\n    Prism.languages.rb = Prism.languages.ruby;\n})(Prism);\n(function(Prism) {\n    var multilineComment = /\\/\\*(?:[^*/]|\\*(?!\\/)|\\/(?!\\*)|<self>)*\\*\\//.source;\n    for(var i = 0; i < 2; i++){\n        // support 4 levels of nested comments\n        multilineComment = multilineComment.replace(/<self>/g, function() {\n            return multilineComment;\n        });\n    }\n    multilineComment = multilineComment.replace(/<self>/g, function() {\n        return /[^\\s\\S]/.source;\n    });\n    Prism.languages.rust = {\n        \"comment\": [\n            {\n                pattern: RegExp(/(^|[^\\\\])/.source + multilineComment),\n                lookbehind: true,\n                greedy: true\n            },\n            {\n                pattern: /(^|[^\\\\:])\\/\\/.*/,\n                lookbehind: true,\n                greedy: true\n            }\n        ],\n        \"string\": {\n            pattern: /b?\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|b?r(#*)\"(?:[^\"]|\"(?!\\1))*\"\\1/,\n            greedy: true\n        },\n        \"char\": {\n            pattern: /b?'(?:\\\\(?:x[0-7][\\da-fA-F]|u\\{(?:[\\da-fA-F]_*){1,6}\\}|.)|[^\\\\\\r\\n\\t'])'/,\n            greedy: true\n        },\n        \"attribute\": {\n            pattern: /#!?\\[(?:[^\\[\\]\"]|\"(?:\\\\[\\s\\S]|[^\\\\\"])*\")*\\]/,\n            greedy: true,\n            alias: \"attr-name\",\n            inside: {\n                \"string\": null // see below\n            }\n        },\n        // Closure params should not be confused with bitwise OR |\n        \"closure-params\": {\n            pattern: /([=(,:]\\s*|\\bmove\\s*)\\|[^|]*\\||\\|[^|]*\\|(?=\\s*(?:\\{|->))/,\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"closure-punctuation\": {\n                    pattern: /^\\||\\|$/,\n                    alias: \"punctuation\"\n                },\n                rest: null // see below\n            }\n        },\n        \"lifetime-annotation\": {\n            pattern: /'\\w+/,\n            alias: \"symbol\"\n        },\n        \"fragment-specifier\": {\n            pattern: /(\\$\\w+:)[a-z]+/,\n            lookbehind: true,\n            alias: \"punctuation\"\n        },\n        \"variable\": /\\$\\w+/,\n        \"function-definition\": {\n            pattern: /(\\bfn\\s+)\\w+/,\n            lookbehind: true,\n            alias: \"function\"\n        },\n        \"type-definition\": {\n            pattern: /(\\b(?:enum|struct|trait|type|union)\\s+)\\w+/,\n            lookbehind: true,\n            alias: \"class-name\"\n        },\n        \"module-declaration\": [\n            {\n                pattern: /(\\b(?:crate|mod)\\s+)[a-z][a-z_\\d]*/,\n                lookbehind: true,\n                alias: \"namespace\"\n            },\n            {\n                pattern: /(\\b(?:crate|self|super)\\s*)::\\s*[a-z][a-z_\\d]*\\b(?:\\s*::(?:\\s*[a-z][a-z_\\d]*\\s*::)*)?/,\n                lookbehind: true,\n                alias: \"namespace\",\n                inside: {\n                    \"punctuation\": /::/\n                }\n            }\n        ],\n        \"keyword\": [\n            // https://github.com/rust-lang/reference/blob/master/src/keywords.md\n            /\\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\\b/,\n            // primitives and str\n            // https://doc.rust-lang.org/stable/rust-by-example/primitives.html\n            /\\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\\b/\n        ],\n        // functions can technically start with an upper-case letter, but this will introduce a lot of false positives\n        // and Rust's naming conventions recommend snake_case anyway.\n        // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html\n        \"function\": /\\b[a-z_]\\w*(?=\\s*(?:::\\s*<|\\())/,\n        \"macro\": {\n            pattern: /\\b\\w+!/,\n            alias: \"property\"\n        },\n        \"constant\": /\\b[A-Z_][A-Z_\\d]+\\b/,\n        \"class-name\": /\\b[A-Z]\\w*\\b/,\n        \"namespace\": {\n            pattern: /(?:\\b[a-z][a-z_\\d]*\\s*::\\s*)*\\b[a-z][a-z_\\d]*\\s*::(?!\\s*<)/,\n            inside: {\n                \"punctuation\": /::/\n            }\n        },\n        // Hex, oct, bin, dec numbers with visual separators and type suffix\n        \"number\": /\\b(?:0x[\\dA-Fa-f](?:_?[\\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\\d(?:_?\\d)*)?\\.)?\\d(?:_?\\d)*(?:[Ee][+-]?\\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\\b/,\n        \"boolean\": /\\b(?:false|true)\\b/,\n        \"punctuation\": /->|\\.\\.=|\\.{1,3}|::|[{}[\\];(),:]/,\n        \"operator\": /[-+*\\/%!^]=?|=[=>]?|&[&=]?|\\|[|=]?|<<?=?|>>?=?|[@?]/\n    };\n    Prism.languages.rust[\"closure-params\"].inside.rest = Prism.languages.rust;\n    Prism.languages.rust[\"attribute\"].inside[\"string\"] = Prism.languages.rust[\"string\"];\n})(Prism);\n(function(Prism) {\n    Prism.languages.sass = Prism.languages.extend(\"css\", {\n        // Sass comments don't need to be closed, only indented\n        \"comment\": {\n            pattern: /^([ \\t]*)\\/[\\/*].*(?:(?:\\r?\\n|\\r)\\1[ \\t].+)*/m,\n            lookbehind: true,\n            greedy: true\n        }\n    });\n    Prism.languages.insertBefore(\"sass\", \"atrule\", {\n        // We want to consume the whole line\n        \"atrule-line\": {\n            // Includes support for = and + shortcuts\n            pattern: /^(?:[ \\t]*)[@+=].+/m,\n            greedy: true,\n            inside: {\n                \"atrule\": /(?:@[\\w-]+|[+=])/\n            }\n        }\n    });\n    delete Prism.languages.sass.atrule;\n    var variable = /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/;\n    var operator = [\n        /[+*\\/%]|[=!]=|<=?|>=?|\\b(?:and|not|or)\\b/,\n        {\n            pattern: /(\\s)-(?=\\s)/,\n            lookbehind: true\n        }\n    ];\n    Prism.languages.insertBefore(\"sass\", \"property\", {\n        // We want to consume the whole line\n        \"variable-line\": {\n            pattern: /^[ \\t]*\\$.+/m,\n            greedy: true,\n            inside: {\n                \"punctuation\": /:/,\n                \"variable\": variable,\n                \"operator\": operator\n            }\n        },\n        // We want to consume the whole line\n        \"property-line\": {\n            pattern: /^[ \\t]*(?:[^:\\s]+ *:.*|:[^:\\s].*)/m,\n            greedy: true,\n            inside: {\n                \"property\": [\n                    /[^:\\s]+(?=\\s*:)/,\n                    {\n                        pattern: /(:)[^:\\s]+/,\n                        lookbehind: true\n                    }\n                ],\n                \"punctuation\": /:/,\n                \"variable\": variable,\n                \"operator\": operator,\n                \"important\": Prism.languages.sass.important\n            }\n        }\n    });\n    delete Prism.languages.sass.property;\n    delete Prism.languages.sass.important;\n    // Now that whole lines for other patterns are consumed,\n    // what's left should be selectors\n    Prism.languages.insertBefore(\"sass\", \"punctuation\", {\n        \"selector\": {\n            pattern: /^([ \\t]*)\\S(?:,[^,\\r\\n]+|[^,\\r\\n]*)(?:,[^,\\r\\n]+)*(?:,(?:\\r?\\n|\\r)\\1[ \\t]+\\S(?:,[^,\\r\\n]+|[^,\\r\\n]*)(?:,[^,\\r\\n]+)*)*/m,\n            lookbehind: true,\n            greedy: true\n        }\n    });\n})(Prism);\nPrism.languages.scss = Prism.languages.extend(\"css\", {\n    \"comment\": {\n        pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n        lookbehind: true\n    },\n    \"atrule\": {\n        pattern: /@[\\w-](?:\\([^()]+\\)|[^()\\s]|\\s+(?!\\s))*?(?=\\s+[{;])/,\n        inside: {\n            \"rule\": /@[\\w-]+/\n        }\n    },\n    // url, compassified\n    \"url\": /(?:[-a-z]+-)?url(?=\\()/i,\n    // CSS selector regex is not appropriate for Sass\n    // since there can be lot more things (var, @ directive, nesting..)\n    // a selector must start at the end of a property or after a brace (end of other rules or nesting)\n    // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable\n    // the end of a selector is found when there is no rules in it ( {} or {\\s}) or if there is a property (because an interpolated var\n    // can \"pass\" as a selector- e.g: proper#{$erty})\n    // this one was hard to do, so please be careful if you edit this one :)\n    \"selector\": {\n        // Initial look-ahead is used to prevent matching of blank selectors\n        pattern: /(?=\\S)[^@;{}()]?(?:[^@;{}()\\s]|\\s+(?!\\s)|#\\{\\$[-\\w]+\\})+(?=\\s*\\{(?:\\}|\\s|[^}][^:{}]*[:{][^}]))/,\n        inside: {\n            \"parent\": {\n                pattern: /&/,\n                alias: \"important\"\n            },\n            \"placeholder\": /%[-\\w]+/,\n            \"variable\": /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n        }\n    },\n    \"property\": {\n        pattern: /(?:[-\\w]|\\$[-\\w]|#\\{\\$[-\\w]+\\})+(?=\\s*:)/,\n        inside: {\n            \"variable\": /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n        }\n    }\n});\nPrism.languages.insertBefore(\"scss\", \"atrule\", {\n    \"keyword\": [\n        /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\\b/i,\n        {\n            pattern: /( )(?:from|through)(?= )/,\n            lookbehind: true\n        }\n    ]\n});\nPrism.languages.insertBefore(\"scss\", \"important\", {\n    // var and interpolated vars\n    \"variable\": /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n});\nPrism.languages.insertBefore(\"scss\", \"function\", {\n    \"module-modifier\": {\n        pattern: /\\b(?:as|hide|show|with)\\b/i,\n        alias: \"keyword\"\n    },\n    \"placeholder\": {\n        pattern: /%[-\\w]+/,\n        alias: \"selector\"\n    },\n    \"statement\": {\n        pattern: /\\B!(?:default|optional)\\b/i,\n        alias: \"keyword\"\n    },\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"null\": {\n        pattern: /\\bnull\\b/,\n        alias: \"keyword\"\n    },\n    \"operator\": {\n        pattern: /(\\s)(?:[-+*\\/%]|[=!]=|<=?|>=?|and|not|or)(?=\\s)/,\n        lookbehind: true\n    }\n});\nPrism.languages.scss[\"atrule\"].inside.rest = Prism.languages.scss;\nPrism.languages.sql = {\n    \"comment\": {\n        pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|(?:--|\\/\\/|#).*)/,\n        lookbehind: true\n    },\n    \"variable\": [\n        {\n            pattern: /@([\"'`])(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1/,\n            greedy: true\n        },\n        /@[\\w.$]+/\n    ],\n    \"string\": {\n        pattern: /(^|[^@\\\\])(\"|')(?:\\\\[\\s\\S]|(?!\\2)[^\\\\]|\\2\\2)*\\2/,\n        greedy: true,\n        lookbehind: true\n    },\n    \"identifier\": {\n        pattern: /(^|[^@\\\\])`(?:\\\\[\\s\\S]|[^`\\\\]|``)*`/,\n        greedy: true,\n        lookbehind: true,\n        inside: {\n            \"punctuation\": /^`|`$/\n        }\n    },\n    \"function\": /\\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\\s*\\()/i,\n    // Should we highlight user defined functions too?\n    \"keyword\": /\\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\\b/i,\n    \"boolean\": /\\b(?:FALSE|NULL|TRUE)\\b/i,\n    \"number\": /\\b0x[\\da-f]+\\b|\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+\\b/i,\n    \"operator\": /[-+*\\/=%^~]|&&?|\\|\\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\\b/i,\n    \"punctuation\": /[;[\\]()`,.]/\n};\nPrism.languages.swift = {\n    \"comment\": {\n        // Nested comments are supported up to 2 levels\n        pattern: /(^|[^\\\\:])(?:\\/\\/.*|\\/\\*(?:[^/*]|\\/(?!\\*)|\\*(?!\\/)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*\\*\\/)/,\n        lookbehind: true,\n        greedy: true\n    },\n    \"string-literal\": [\n        // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html\n        {\n            pattern: RegExp(/(^|[^\"#])/.source + \"(?:\" + /\"(?:\\\\(?:\\((?:[^()]|\\([^()]*\\))*\\)|\\r\\n|[^(])|[^\\\\\\r\\n\"])*\"/.source + \"|\" + /\"\"\"(?:\\\\(?:\\((?:[^()]|\\([^()]*\\))*\\)|[^(])|[^\\\\\"]|\"(?!\"\"))*\"\"\"/.source + \")\" + /(?![\"#])/.source),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"interpolation\": {\n                    pattern: /(\\\\\\()(?:[^()]|\\([^()]*\\))*(?=\\))/,\n                    lookbehind: true,\n                    inside: null // see below\n                },\n                \"interpolation-punctuation\": {\n                    pattern: /^\\)|\\\\\\($/,\n                    alias: \"punctuation\"\n                },\n                \"punctuation\": /\\\\(?=[\\r\\n])/,\n                \"string\": /[\\s\\S]+/\n            }\n        },\n        {\n            pattern: RegExp(/(^|[^\"#])(#+)/.source + \"(?:\" + /\"(?:\\\\(?:#+\\((?:[^()]|\\([^()]*\\))*\\)|\\r\\n|[^#])|[^\\\\\\r\\n])*?\"/.source + \"|\" + /\"\"\"(?:\\\\(?:#+\\((?:[^()]|\\([^()]*\\))*\\)|[^#])|[^\\\\])*?\"\"\"/.source + \")\" + \"\\\\2\"),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"interpolation\": {\n                    pattern: /(\\\\#+\\()(?:[^()]|\\([^()]*\\))*(?=\\))/,\n                    lookbehind: true,\n                    inside: null // see below\n                },\n                \"interpolation-punctuation\": {\n                    pattern: /^\\)|\\\\#+\\($/,\n                    alias: \"punctuation\"\n                },\n                \"string\": /[\\s\\S]+/\n            }\n        }\n    ],\n    \"directive\": {\n        // directives with conditions\n        pattern: RegExp(/#/.source + \"(?:\" + (/(?:elseif|if)\\b/.source + \"(?:[ \t]*\" + /(?:![ \\t]*)?(?:\\b\\w+\\b(?:[ \\t]*\\((?:[^()]|\\([^()]*\\))*\\))?|\\((?:[^()]|\\([^()]*\\))*\\))(?:[ \\t]*(?:&&|\\|\\|))?/.source + \")+\") + \"|\" + /(?:else|endif)\\b/.source + \")\"),\n        alias: \"property\",\n        inside: {\n            \"directive-name\": /^#\\w+/,\n            \"boolean\": /\\b(?:false|true)\\b/,\n            \"number\": /\\b\\d+(?:\\.\\d+)*\\b/,\n            \"operator\": /!|&&|\\|\\||[<>]=?/,\n            \"punctuation\": /[(),]/\n        }\n    },\n    \"literal\": {\n        pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\\b/,\n        alias: \"constant\"\n    },\n    \"other-directive\": {\n        pattern: /#\\w+\\b/,\n        alias: \"property\"\n    },\n    \"attribute\": {\n        pattern: /@\\w+/,\n        alias: \"atrule\"\n    },\n    \"function-definition\": {\n        pattern: /(\\bfunc\\s+)\\w+/,\n        lookbehind: true,\n        alias: \"function\"\n    },\n    \"label\": {\n        // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141\n        pattern: /\\b(break|continue)\\s+\\w+|\\b[a-zA-Z_]\\w*(?=\\s*:\\s*(?:for|repeat|while)\\b)/,\n        lookbehind: true,\n        alias: \"important\"\n    },\n    \"keyword\": /\\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\\b/,\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"nil\": {\n        pattern: /\\bnil\\b/,\n        alias: \"constant\"\n    },\n    \"short-argument\": /\\$\\d+\\b/,\n    \"omit\": {\n        pattern: /\\b_\\b/,\n        alias: \"keyword\"\n    },\n    \"number\": /\\b(?:[\\d_]+(?:\\.[\\de_]+)?|0x[a-f0-9_]+(?:\\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\\b/i,\n    // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.\n    \"class-name\": /\\b[A-Z](?:[A-Z_\\d]*[a-z]\\w*)?\\b/,\n    \"function\": /\\b[a-z_]\\w*(?=\\s*\\()/i,\n    \"constant\": /\\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\\b/,\n    // Operators are generic in Swift. Developers can even create new operators (e.g. +++).\n    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481\n    // This regex only supports ASCII operators.\n    \"operator\": /[-+*/%=!<>&|^~?]+|\\.[.\\-+*/%=!<>&|^~?]+/,\n    \"punctuation\": /[{}[\\]();,.:\\\\]/\n};\nPrism.languages.swift[\"string-literal\"].forEach(function(rule) {\n    rule.inside[\"interpolation\"].inside = Prism.languages.swift;\n});\n(function(Prism) {\n    Prism.languages.typescript = Prism.languages.extend(\"javascript\", {\n        \"class-name\": {\n            pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|type)\\s+)(?!keyof\\b)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?:\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,\n            lookbehind: true,\n            greedy: true,\n            inside: null // see below\n        },\n        \"builtin\": /\\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\\b/\n    });\n    // The keywords TypeScript adds to JavaScript\n    Prism.languages.typescript.keyword.push(/\\b(?:abstract|declare|is|keyof|readonly|require)\\b/, // keywords that have to be followed by an identifier\n    /\\b(?:asserts|infer|interface|module|namespace|type)\\b(?=\\s*(?:[{_$a-zA-Z\\xA0-\\uFFFF]|$))/, // This is for `import type *, {}`\n    /\\btype\\b(?=\\s*(?:[\\{*]|$))/);\n    // doesn't work with TS because TS is too complex\n    delete Prism.languages.typescript[\"parameter\"];\n    delete Prism.languages.typescript[\"literal-property\"];\n    // a version of typescript specifically for highlighting types\n    var typeInside = Prism.languages.extend(\"typescript\", {});\n    delete typeInside[\"class-name\"];\n    Prism.languages.typescript[\"class-name\"].inside = typeInside;\n    Prism.languages.insertBefore(\"typescript\", \"function\", {\n        \"decorator\": {\n            pattern: /@[$\\w\\xA0-\\uFFFF]+/,\n            inside: {\n                \"at\": {\n                    pattern: /^@/,\n                    alias: \"operator\"\n                },\n                \"function\": /^[\\s\\S]+/\n            }\n        },\n        \"generic-function\": {\n            // e.g. foo<T extends \"bar\" | \"baz\">( ...\n            pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\\s*\\()/,\n            greedy: true,\n            inside: {\n                \"function\": /^#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/,\n                \"generic\": {\n                    pattern: /<[\\s\\S]+/,\n                    // everything after the first <\n                    alias: \"class-name\",\n                    inside: typeInside\n                }\n            }\n        }\n    });\n    Prism.languages.ts = Prism.languages.typescript;\n})(Prism);\n(function(Prism) {\n    var typescript = Prism.util.clone(Prism.languages.typescript);\n    Prism.languages.tsx = Prism.languages.extend(\"jsx\", typescript);\n    // doesn't work with TS because TS is too complex\n    delete Prism.languages.tsx[\"parameter\"];\n    delete Prism.languages.tsx[\"literal-property\"];\n    // This will prevent collisions between TSX tags and TS generic types.\n    // Idea by https://github.com/karlhorky\n    // Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928\n    var tag = Prism.languages.tsx.tag;\n    tag.pattern = RegExp(/(^|[^\\w$]|(?=<\\/))/.source + \"(?:\" + tag.pattern.source + \")\", tag.pattern.flags);\n    tag.lookbehind = true;\n})(Prism);\nPrism.languages.basic = {\n    \"comment\": {\n        pattern: /(?:!|REM\\b).+/i,\n        inside: {\n            \"keyword\": /^REM/i\n        }\n    },\n    \"string\": {\n        pattern: /\"(?:\"\"|[!#$%&'()*,\\/:;<=>?^\\w +\\-.])*\"/,\n        greedy: true\n    },\n    \"number\": /(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:E[+-]?\\d+)?/i,\n    \"keyword\": /\\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\\$|\\b)/i,\n    \"function\": /\\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\\$|\\b)/i,\n    \"operator\": /<[=>]?|>=?|[+\\-*\\/^=&]|\\b(?:AND|EQV|IMP|NOT|OR|XOR)\\b/i,\n    \"punctuation\": /[,;:()]/\n};\nPrism.languages.vbnet = Prism.languages.extend(\"basic\", {\n    \"comment\": [\n        {\n            pattern: /(?:!|REM\\b).+/i,\n            inside: {\n                \"keyword\": /^REM/i\n            }\n        },\n        {\n            pattern: /(^|[^\\\\:])'.*/,\n            lookbehind: true,\n            greedy: true\n        }\n    ],\n    \"string\": {\n        pattern: /(^|[^\"])\"(?:\"\"|[^\"])*\"(?!\")/,\n        lookbehind: true,\n        greedy: true\n    },\n    \"keyword\": /(?:\\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\\$|\\b)/i,\n    \"punctuation\": /[,;:(){}]/\n});\nconst languages = [\n    {\n        label: \"C\",\n        value: \"c\"\n    },\n    {\n        label: \"C++\",\n        value: \"cpp\"\n    },\n    {\n        label: \"Arduino\",\n        value: \"arduino\"\n    },\n    {\n        label: \"Bash\",\n        value: \"bash\"\n    },\n    {\n        label: \"C#\",\n        value: \"csharp\"\n    },\n    {\n        label: \"CSS\",\n        value: \"css\"\n    },\n    {\n        label: \"Diff\",\n        value: \"diff\"\n    },\n    {\n        label: \"Go\",\n        value: \"go\"\n    },\n    {\n        label: \"INI\",\n        value: \"ini\"\n    },\n    {\n        label: \"Java\",\n        value: \"java\"\n    },\n    {\n        label: \"JavaScript\",\n        value: \"javascript\"\n    },\n    {\n        label: \"JSX\",\n        value: \"jsx\"\n    },\n    {\n        label: \"JSON\",\n        value: \"json\"\n    },\n    {\n        label: \"Kotlin\",\n        value: \"kotlin\"\n    },\n    {\n        label: \"Less\",\n        value: \"less\"\n    },\n    {\n        label: \"Lua\",\n        value: \"lua\"\n    },\n    {\n        label: \"Makefile\",\n        value: \"makefile\"\n    },\n    {\n        label: \"Markdown\",\n        value: \"markdown\"\n    },\n    {\n        label: \"Objective-C\",\n        value: \"objectivec\"\n    },\n    {\n        label: \"Perl\",\n        value: \"perl\"\n    },\n    {\n        label: \"PHP\",\n        value: \"php\"\n    },\n    {\n        label: \"Python\",\n        value: \"python\"\n    },\n    {\n        label: \"R\",\n        value: \"r\"\n    },\n    {\n        label: \"Ruby\",\n        value: \"ruby\"\n    },\n    {\n        label: \"Rust\",\n        value: \"rust\"\n    },\n    {\n        label: \"Sass\",\n        value: \"sass\"\n    },\n    {\n        label: \"SCSS\",\n        value: \"scss\"\n    },\n    {\n        label: \"SQL\",\n        value: \"sql\"\n    },\n    {\n        label: \"Swift\",\n        value: \"swift\"\n    },\n    {\n        label: \"TypeScript\",\n        value: \"typescript\"\n    },\n    {\n        label: \"TSX\",\n        value: \"tsx\"\n    },\n    {\n        label: \"VB.NET\",\n        value: \"vbnet\"\n    },\n    {\n        label: \"YAML\",\n        value: \"yaml\"\n    }\n];\nconst canonicalNameToLabel = new Map(languages.map((x)=>[\n        x.value,\n        x.label\n    ]));\nconst labelToCanonicalName = new Map(languages.map((x)=>[\n        x.label,\n        x.value\n    ]));\nconst languageToCanonicalName = new Map(languages.map((lang)=>[\n        Prism.languages[lang.value],\n        lang.value\n    ]));\nconst aliasesToCanonicalName = new Map(Object.keys(Prism.languages).flatMap((lang)=>{\n    const canonicalName = languageToCanonicalName.get(Prism.languages[lang]);\n    if (canonicalName === undefined) {\n        return [];\n    }\n    return [\n        [\n            lang,\n            canonicalName\n        ]\n    ];\n}));\nconst languagesToAliases = new Map(languages.map((lang)=>[\n        lang.value,\n        []\n    ]));\nfor (const [alias, canonicalName] of aliasesToCanonicalName){\n    languagesToAliases.get(canonicalName).push(alias);\n}\nconst languagesWithAliases = [\n    {\n        label: \"Plain text\",\n        value: \"plain\",\n        aliases: []\n    },\n    ...[\n        ...languagesToAliases\n    ].map(([canonicalName, aliases])=>({\n            label: canonicalNameToLabel.get(canonicalName),\n            value: canonicalName,\n            aliases\n        }))\n];\nconst aliasesToLabel = new Map([\n    ...aliasesToCanonicalName\n].map(([alias, canonicalName])=>[\n        alias,\n        canonicalNameToLabel.get(canonicalName)\n    ]));\nconst codeBlockShortcutPattern = /^```(\\w+)? ?$/;\nfunction withCodeBlock(documentFeatures, componentBlocks, editor) {\n    const { insertBreak, normalizeNode, insertText } = editor;\n    function codeBlockShortcut(block) {\n        var _aliasesToCanonicalNa;\n        if ((block === null || block === void 0 ? void 0 : block[0].type) !== \"paragraph\" || block[0].children.length !== 1 || block[0].children[0].type !== undefined) {\n            return false;\n        }\n        const match = codeBlockShortcutPattern.exec(block[0].children[0].text);\n        if (!match) {\n            return false;\n        }\n        const locationDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, documentFeatures, componentBlocks);\n        if (locationDocumentFeatures && (locationDocumentFeatures.kind === \"inline\" || !locationDocumentFeatures.documentFeatures.formatting.blockTypes.code)) {\n            return false;\n        }\n        // so that this starts a new undo group\n        editor.history.undos.push({\n            operations: [],\n            selectionBefore: editor.selection\n        });\n        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.select(editor, block[1]);\n        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.delete(editor);\n        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.wrapNodes(editor, {\n            type: \"code\",\n            ...match[1] ? {\n                language: (_aliasesToCanonicalNa = aliasesToCanonicalName.get(match[1].toLowerCase())) !== null && _aliasesToCanonicalNa !== void 0 ? _aliasesToCanonicalNa : match[1]\n            } : {},\n            children: []\n        }, {\n            match: (node)=>node.type === \"paragraph\"\n        });\n        return true;\n    }\n    editor.insertBreak = ()=>{\n        const block = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.above(editor, {\n            match: isBlock\n        });\n        if ((block === null || block === void 0 ? void 0 : block[0].type) === \"code\" && slate__WEBPACK_IMPORTED_MODULE_6__.Text.isText(block[0].children[0])) {\n            const text = block[0].children[0].text;\n            if (text[text.length - 1] === \"\\n\" && editor.selection && slate__WEBPACK_IMPORTED_MODULE_6__.Range.isCollapsed(editor.selection) && slate__WEBPACK_IMPORTED_MODULE_6__.Point.equals(slate__WEBPACK_IMPORTED_MODULE_6__.Editor.end(editor, block[1]), editor.selection.anchor)) {\n                insertBreak();\n                slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.setNodes(editor, {\n                    type: \"paragraph\",\n                    children: []\n                });\n                slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.delete(editor, {\n                    distance: 1,\n                    at: {\n                        path: [\n                            ...block[1],\n                            0\n                        ],\n                        offset: text.length - 1\n                    }\n                });\n                return;\n            }\n            editor.insertText(\"\\n\");\n            return;\n        }\n        if (editor.selection && slate__WEBPACK_IMPORTED_MODULE_6__.Range.isCollapsed(editor.selection) && codeBlockShortcut(block)) {\n            return;\n        }\n        insertBreak();\n    };\n    editor.insertText = (text)=>{\n        insertText(text);\n        if (text === \" \" && editor.selection && slate__WEBPACK_IMPORTED_MODULE_6__.Range.isCollapsed(editor.selection)) {\n            codeBlockShortcut(slate__WEBPACK_IMPORTED_MODULE_6__.Editor.above(editor, {\n                match: isBlock\n            }));\n        }\n    };\n    editor.normalizeNode = ([node, path])=>{\n        if (node.type === \"code\" && slate__WEBPACK_IMPORTED_MODULE_6__.Element.isElement(node)) {\n            for (const [index, childNode] of node.children.entries()){\n                if (!slate__WEBPACK_IMPORTED_MODULE_6__.Text.isText(childNode)) {\n                    if (editor.isVoid(childNode)) {\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n                            at: [\n                                ...path,\n                                index\n                            ]\n                        });\n                    } else {\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unwrapNodes(editor, {\n                            at: [\n                                ...path,\n                                index\n                            ]\n                        });\n                    }\n                    return;\n                }\n                const marks = Object.keys(childNode).filter((x)=>x !== \"text\");\n                if (marks.length) {\n                    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unsetNodes(editor, marks, {\n                        at: [\n                            ...path,\n                            index\n                        ]\n                    });\n                    return;\n                }\n            }\n        }\n        normalizeNode([\n            node,\n            path\n        ]);\n    };\n    return editor;\n}\nfunction findChildPropPathsForProp(value, schema, path) {\n    switch(schema.kind){\n        case \"form\":\n            return [];\n        case \"child\":\n            return [\n                {\n                    path: path,\n                    options: schema.options\n                }\n            ];\n        case \"conditional\":\n            return findChildPropPathsForProp(value.value, schema.values[value.discriminant], path.concat(\"value\"));\n        case \"object\":\n            {\n                const paths = [];\n                Object.keys(schema.fields).forEach((key)=>{\n                    paths.push(...findChildPropPathsForProp(value[key], schema.fields[key], path.concat(key)));\n                });\n                return paths;\n            }\n        case \"array\":\n            {\n                const paths = [];\n                value.forEach((val, i)=>{\n                    paths.push(...findChildPropPathsForProp(val, schema.element, path.concat(i)));\n                });\n                return paths;\n            }\n    }\n}\nfunction findChildPropPaths(value, props) {\n    const propPaths = findChildPropPathsForProp(value, {\n        kind: \"object\",\n        fields: props\n    }, []);\n    if (!propPaths.length) {\n        return [\n            {\n                path: undefined,\n                options: {\n                    kind: \"inline\",\n                    placeholder: \"\"\n                }\n            }\n        ];\n    }\n    return propPaths;\n}\nfunction getAncestorComponentBlock(editor) {\n    if (editor.selection) {\n        const ancestorEntry = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.above(editor, {\n            match: (node)=>isBlock(node) && node.type !== \"paragraph\"\n        });\n        if (ancestorEntry && (ancestorEntry[0].type === \"component-block-prop\" || ancestorEntry[0].type === \"component-inline-prop\")) {\n            return {\n                isInside: true,\n                componentBlock: slate__WEBPACK_IMPORTED_MODULE_6__.Editor.parent(editor, ancestorEntry[1]),\n                prop: ancestorEntry\n            };\n        }\n    }\n    return {\n        isInside: false\n    };\n}\nconst alreadyNormalizedThings = new WeakMap();\nfunction normalizeNodeWithinComponentProp([node, path], editor, fieldOptions) {\n    let alreadyNormalizedNodes = alreadyNormalizedThings.get(fieldOptions);\n    if (!alreadyNormalizedNodes) {\n        alreadyNormalizedNodes = new WeakSet();\n        alreadyNormalizedThings.set(fieldOptions, alreadyNormalizedNodes);\n    }\n    if (alreadyNormalizedNodes.has(node)) {\n        return false;\n    }\n    let didNormalization = false;\n    if (fieldOptions.inlineMarks !== \"inherit\" && slate__WEBPACK_IMPORTED_MODULE_6__.Text.isText(node)) {\n        didNormalization = normalizeTextBasedOnInlineMarksAndSoftBreaks([\n            node,\n            path\n        ], editor, fieldOptions.inlineMarks, fieldOptions.softBreaks);\n    }\n    if (slate__WEBPACK_IMPORTED_MODULE_6__.Element.isElement(node)) {\n        let childrenHasChanged = node.children.map((node, i)=>normalizeNodeWithinComponentProp([\n                node,\n                [\n                    ...path,\n                    i\n                ]\n            ], editor, fieldOptions))// .map then .some because we don't want to exit early\n        .some((x)=>x);\n        if (fieldOptions.kind === \"block\") {\n            if (node.type === \"component-block\") {\n                if (!fieldOptions.componentBlocks) {\n                    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unwrapNodes(editor, {\n                        at: path\n                    });\n                    didNormalization = true;\n                }\n            } else {\n                didNormalization = normalizeElementBasedOnDocumentFeatures([\n                    node,\n                    path\n                ], editor, fieldOptions.documentFeatures) || childrenHasChanged;\n            }\n        } else {\n            didNormalization = normalizeInlineBasedOnLinks([\n                node,\n                path\n            ], editor, fieldOptions.documentFeatures.links);\n        }\n    }\n    if (didNormalization === false) {\n        alreadyNormalizedNodes.add(node);\n    }\n    return didNormalization;\n}\nfunction canSchemaContainChildField(rootSchema) {\n    const queue = new Set([\n        rootSchema\n    ]);\n    for (const schema of queue){\n        if (schema.kind === \"form\") ;\n        else if (schema.kind === \"child\") {\n            return true;\n        } else if (schema.kind === \"array\") {\n            queue.add(schema.element);\n        } else if (schema.kind === \"object\") {\n            for (const innerProp of Object.values(schema.fields)){\n                queue.add(innerProp);\n            }\n        } else if (schema.kind === \"conditional\") {\n            for (const innerProp of Object.values(schema.values)){\n                queue.add(innerProp);\n            }\n        } else {\n            (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(schema);\n        }\n    }\n    return false;\n}\nfunction doesSchemaOnlyEverContainASingleChildField(rootSchema) {\n    const queue = new Set([\n        rootSchema\n    ]);\n    let hasFoundChildField = false;\n    for (const schema of queue){\n        if (schema.kind === \"form\") ;\n        else if (schema.kind === \"child\") {\n            if (hasFoundChildField) {\n                return false;\n            }\n            hasFoundChildField = true;\n        } else if (schema.kind === \"array\") {\n            if (canSchemaContainChildField(schema.element)) {\n                return false;\n            }\n        } else if (schema.kind === \"object\") {\n            for (const innerProp of Object.values(schema.fields)){\n                queue.add(innerProp);\n            }\n        } else if (schema.kind === \"conditional\") {\n            for (const innerProp of Object.values(schema.values)){\n                queue.add(innerProp);\n            }\n        } else {\n            (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(schema);\n        }\n    }\n    return hasFoundChildField;\n}\nfunction findArrayFieldsWithSingleChildField(schema, value) {\n    const propPaths = [];\n    traverseProps(schema, value, (schema, value, path)=>{\n        if (schema.kind === \"array\" && doesSchemaOnlyEverContainASingleChildField(schema.element)) {\n            propPaths.push([\n                path,\n                schema\n            ]);\n        }\n    });\n    return propPaths;\n}\nfunction isEmptyChildFieldNode(element) {\n    const firstChild = element.children[0];\n    return element.children.length === 1 && (element.type === \"component-inline-prop\" && firstChild.type === undefined && firstChild.text === \"\" || element.type === \"component-block-prop\" && firstChild.type === \"paragraph\" && firstChild.children.length === 1 && firstChild.children[0].type === undefined && firstChild.children[0].text === \"\");\n}\nfunction withComponentBlocks(blockComponents, editorDocumentFeatures, editor) {\n    // note that conflicts between the editor document features\n    // and the child field document features are dealt with elsewhere\n    const memoizedGetDocumentFeaturesForChildField = (0,_emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((options)=>{\n        return getDocumentFeaturesForChildField(editorDocumentFeatures, options);\n    });\n    const { normalizeNode, deleteBackward, insertBreak } = editor;\n    editor.deleteBackward = (unit)=>{\n        if (editor.selection) {\n            const ancestorComponentBlock = getAncestorComponentBlock(editor);\n            if (ancestorComponentBlock.isInside && slate__WEBPACK_IMPORTED_MODULE_6__.Range.isCollapsed(editor.selection) && slate__WEBPACK_IMPORTED_MODULE_6__.Editor.isStart(editor, editor.selection.anchor, ancestorComponentBlock.prop[1]) && ancestorComponentBlock.prop[1][ancestorComponentBlock.prop[1].length - 1] === 0) {\n                slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unwrapNodes(editor, {\n                    at: ancestorComponentBlock.componentBlock[1]\n                });\n                return;\n            }\n        }\n        deleteBackward(unit);\n    };\n    editor.insertBreak = ()=>{\n        const ancestorComponentBlock = getAncestorComponentBlock(editor);\n        if (editor.selection && ancestorComponentBlock.isInside) {\n            const { prop: [componentPropNode, componentPropPath], componentBlock: [componentBlockNode, componentBlockPath] } = ancestorComponentBlock;\n            const isLastProp = componentPropPath[componentPropPath.length - 1] === componentBlockNode.children.length - 1;\n            if (componentPropNode.type === \"component-block-prop\") {\n                const [[paragraphNode, paragraphPath]] = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.nodes(editor, {\n                    match: (node)=>node.type === \"paragraph\"\n                });\n                const isLastParagraph = paragraphPath[paragraphPath.length - 1] === componentPropNode.children.length - 1;\n                if (slate__WEBPACK_IMPORTED_MODULE_6__.Node.string(paragraphNode) === \"\" && isLastParagraph) {\n                    if (isLastProp) {\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.moveNodes(editor, {\n                            at: paragraphPath,\n                            to: slate__WEBPACK_IMPORTED_MODULE_6__.Path.next(ancestorComponentBlock.componentBlock[1])\n                        });\n                    } else {\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.move(editor, {\n                            distance: 1,\n                            unit: \"line\"\n                        });\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n                            at: paragraphPath\n                        });\n                    }\n                    return;\n                }\n            }\n            if (componentPropNode.type === \"component-inline-prop\") {\n                slate__WEBPACK_IMPORTED_MODULE_6__.Editor.withoutNormalizing(editor, ()=>{\n                    const componentBlock = blockComponents[componentBlockNode.component];\n                    if (componentPropNode.propPath !== undefined && componentBlock !== undefined) {\n                        const rootSchema = {\n                            kind: \"object\",\n                            fields: componentBlock.schema\n                        };\n                        const ancestorFields = getAncestorSchemas(rootSchema, componentPropNode.propPath, componentBlockNode.props);\n                        const idx = [\n                            ...ancestorFields\n                        ].reverse().findIndex((item)=>item.kind === \"array\");\n                        if (idx !== -1) {\n                            const arrayFieldIdx = ancestorFields.length - 1 - idx;\n                            const arrayField = ancestorFields[arrayFieldIdx];\n                            (0,emery__WEBPACK_IMPORTED_MODULE_1__.assert)(arrayField.kind === \"array\");\n                            const val = getValueAtPropPath(componentBlockNode.props, componentPropNode.propPath.slice(0, arrayFieldIdx));\n                            if (doesSchemaOnlyEverContainASingleChildField(arrayField.element)) {\n                                if (slate__WEBPACK_IMPORTED_MODULE_6__.Node.string(componentPropNode) === \"\" && val.length - 1 === componentPropNode.propPath[arrayFieldIdx]) {\n                                    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n                                        at: componentPropPath\n                                    });\n                                    if (isLastProp) {\n                                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.insertNodes(editor, {\n                                            type: \"paragraph\",\n                                            children: [\n                                                {\n                                                    text: \"\"\n                                                }\n                                            ]\n                                        }, {\n                                            at: slate__WEBPACK_IMPORTED_MODULE_6__.Path.next(componentBlockPath)\n                                        });\n                                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_6__.Path.next(componentBlockPath));\n                                    } else {\n                                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.move(editor, {\n                                            distance: 1,\n                                            unit: \"line\"\n                                        });\n                                    }\n                                } else {\n                                    insertBreak();\n                                }\n                                return;\n                            }\n                        }\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.splitNodes(editor, {\n                        always: true\n                    });\n                    const splitNodePath = slate__WEBPACK_IMPORTED_MODULE_6__.Path.next(componentPropPath);\n                    if (isLastProp) {\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.moveNodes(editor, {\n                            at: splitNodePath,\n                            to: slate__WEBPACK_IMPORTED_MODULE_6__.Path.next(componentBlockPath)\n                        });\n                    } else {\n                        moveChildren(editor, splitNodePath, [\n                            ...slate__WEBPACK_IMPORTED_MODULE_6__.Path.next(splitNodePath),\n                            0\n                        ]);\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n                            at: splitNodePath\n                        });\n                    }\n                });\n                return;\n            }\n        }\n        insertBreak();\n    };\n    editor.normalizeNode = (entry)=>{\n        const [node, path] = entry;\n        if (node.type === \"component-inline-prop\" && !node.propPath && (node.children.length !== 1 || !slate__WEBPACK_IMPORTED_MODULE_6__.Text.isText(node.children[0]) || node.children[0].text !== \"\")) {\n            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n                at: path\n            });\n            return;\n        }\n        if (node.type === \"component-block\") {\n            const componentBlock = blockComponents[node.component];\n            if (componentBlock) {\n                const rootSchema = {\n                    kind: \"object\",\n                    fields: componentBlock.schema\n                };\n                const updatedProps = addMissingFields(node.props, rootSchema);\n                if (updatedProps !== node.props) {\n                    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.setNodes(editor, {\n                        props: updatedProps\n                    }, {\n                        at: path\n                    });\n                    return;\n                }\n                for (const [propPath, arrayField] of findArrayFieldsWithSingleChildField(rootSchema, node.props)){\n                    if (node.children.length === 1 && node.children[0].type === \"component-inline-prop\" && node.children[0].propPath === undefined) {\n                        break;\n                    }\n                    const nodesWithin = [];\n                    for (const [idx, childNode] of node.children.entries()){\n                        if ((childNode.type === \"component-block-prop\" || childNode.type === \"component-inline-prop\") && childNode.propPath !== undefined) {\n                            const subPath = childNode.propPath.concat();\n                            while(subPath.length){\n                                if (typeof subPath.pop() === \"number\") break;\n                            }\n                            if (areArraysEqual(propPath, subPath)) {\n                                nodesWithin.push([\n                                    idx,\n                                    childNode\n                                ]);\n                            }\n                        }\n                    }\n                    const arrVal = getValueAtPropPath(node.props, propPath);\n                    const prevKeys = getKeysForArrayValue(arrVal);\n                    const prevKeysSet = new Set(prevKeys);\n                    const alreadyUsedIndicies = new Set();\n                    const newVal = [];\n                    const newKeys = [];\n                    const getNewKey = ()=>{\n                        let key = getNewArrayElementKey();\n                        while(prevKeysSet.has(key)){\n                            key = getNewArrayElementKey();\n                        }\n                        return key;\n                    };\n                    for (const [, node] of nodesWithin){\n                        const idxFromValue = node.propPath[propPath.length];\n                        (0,emery__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof idxFromValue === \"number\");\n                        if (arrVal.length <= idxFromValue || alreadyUsedIndicies.has(idxFromValue) && isEmptyChildFieldNode(node)) {\n                            newVal.push(getInitialPropsValue(arrayField.element));\n                            newKeys.push(getNewKey());\n                        } else {\n                            alreadyUsedIndicies.add(idxFromValue);\n                            newVal.push(arrVal[idxFromValue]);\n                            newKeys.push(alreadyUsedIndicies.has(idxFromValue) ? getNewKey() : prevKeys[idxFromValue]);\n                        }\n                    }\n                    setKeysForArrayValue(newVal, newKeys);\n                    if (!areArraysEqual(arrVal, newVal)) {\n                        const transformedProps = replaceValueAtPropPath(rootSchema, node.props, newVal, propPath);\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.setNodes(editor, {\n                            props: transformedProps\n                        }, {\n                            at: path\n                        });\n                        for (const [idx, [idxInChildrenOfBlock, nodeWithin]] of nodesWithin.entries()){\n                            const newPropPath = [\n                                ...nodeWithin.propPath\n                            ];\n                            newPropPath[propPath.length] = idx;\n                            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.setNodes(editor, {\n                                propPath: newPropPath\n                            }, {\n                                at: [\n                                    ...path,\n                                    idxInChildrenOfBlock\n                                ]\n                            });\n                        }\n                        return;\n                    }\n                }\n                const missingKeys = new Map(findChildPropPaths(node.props, componentBlock.schema).map((x)=>[\n                        JSON.stringify(x.path),\n                        x.options.kind\n                    ]));\n                node.children.forEach((node)=>{\n                    (0,emery__WEBPACK_IMPORTED_MODULE_1__.assert)(node.type === \"component-block-prop\" || node.type === \"component-inline-prop\");\n                    missingKeys.delete(JSON.stringify(node.propPath));\n                });\n                if (missingKeys.size) {\n                    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.insertNodes(editor, [\n                        ...missingKeys\n                    ].map(([prop, kind])=>({\n                            type: `component-${kind}-prop`,\n                            propPath: prop ? JSON.parse(prop) : prop,\n                            children: [\n                                {\n                                    text: \"\"\n                                }\n                            ]\n                        })), {\n                        at: [\n                            ...path,\n                            node.children.length\n                        ]\n                    });\n                    return;\n                }\n                const foundProps = new Set();\n                const stringifiedInlinePropPaths = {};\n                findChildPropPaths(node.props, blockComponents[node.component].schema).forEach((x, index)=>{\n                    stringifiedInlinePropPaths[JSON.stringify(x.path)] = {\n                        options: x.options,\n                        index\n                    };\n                });\n                for (const [index, childNode] of node.children.entries()){\n                    if (// children that are not these will be handled by\n                    // the generic allowedChildren normalization\n                    childNode.type !== \"component-inline-prop\" && childNode.type !== \"component-block-prop\") {\n                        continue;\n                    }\n                    const childPath = [\n                        ...path,\n                        index\n                    ];\n                    const stringifiedPropPath = JSON.stringify(childNode.propPath);\n                    if (stringifiedInlinePropPaths[stringifiedPropPath] === undefined) {\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n                            at: childPath\n                        });\n                        return;\n                    }\n                    if (foundProps.has(stringifiedPropPath)) {\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n                            at: childPath\n                        });\n                        return;\n                    }\n                    foundProps.add(stringifiedPropPath);\n                    const propInfo = stringifiedInlinePropPaths[stringifiedPropPath];\n                    const expectedIndex = propInfo.index;\n                    if (index !== expectedIndex) {\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.moveNodes(editor, {\n                            at: childPath,\n                            to: [\n                                ...path,\n                                expectedIndex\n                            ]\n                        });\n                        return;\n                    }\n                    const expectedChildNodeType = `component-${propInfo.options.kind}-prop`;\n                    if (childNode.type !== expectedChildNodeType) {\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.setNodes(editor, {\n                            type: expectedChildNodeType\n                        }, {\n                            at: childPath\n                        });\n                        return;\n                    }\n                    const documentFeatures = memoizedGetDocumentFeaturesForChildField(propInfo.options);\n                    if (normalizeNodeWithinComponentProp([\n                        childNode,\n                        childPath\n                    ], editor, documentFeatures)) {\n                        return;\n                    }\n                }\n            }\n        }\n        normalizeNode(entry);\n    };\n    return editor;\n}\n// the only thing that this will fix is a new field being added to an object field, nothing else.\nfunction addMissingFields(value, schema) {\n    if (schema.kind === \"child\" || schema.kind === \"form\") {\n        return value;\n    }\n    if (schema.kind === \"conditional\") {\n        const conditionalValue = value;\n        const updatedInnerValue = addMissingFields(conditionalValue.value, schema.values[conditionalValue.discriminant.toString()]);\n        if (updatedInnerValue === conditionalValue.value) {\n            return value;\n        }\n        return {\n            discriminant: conditionalValue.discriminant,\n            value: updatedInnerValue\n        };\n    }\n    if (schema.kind === \"array\") {\n        const arrValue = value;\n        const newArrValue = arrValue.map((x)=>addMissingFields(x, schema.element));\n        if (areArraysEqual(arrValue, newArrValue)) {\n            return value;\n        }\n        return newArrValue;\n    }\n    if (schema.kind === \"object\") {\n        const objectValue = value;\n        let hasChanged = false;\n        const newObjectValue = {};\n        for (const [key, innerSchema] of Object.entries(schema.fields)){\n            const innerValue = objectValue[key];\n            if (innerValue === undefined) {\n                hasChanged = true;\n                newObjectValue[key] = getInitialPropsValue(innerSchema);\n                continue;\n            }\n            const newInnerValue = addMissingFields(innerValue, innerSchema);\n            if (newInnerValue !== innerValue) {\n                hasChanged = true;\n            }\n            newObjectValue[key] = newInnerValue;\n        }\n        if (hasChanged) {\n            return newObjectValue;\n        }\n        return value;\n    }\n    (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(schema);\n}\nconst paragraphElement = ()=>({\n        type: \"paragraph\",\n        children: [\n            {\n                text: \"\"\n            }\n        ]\n    });\nfunction withParagraphs(editor) {\n    const { normalizeNode } = editor;\n    editor.normalizeNode = (entry)=>{\n        const [node, path] = entry;\n        if (slate__WEBPACK_IMPORTED_MODULE_6__.Editor.isEditor(node)) {\n            let lastNode = node.children[node.children.length - 1];\n            if ((lastNode === null || lastNode === void 0 ? void 0 : lastNode.type) !== \"paragraph\") {\n                slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.insertNodes(editor, paragraphElement(), {\n                    at: [\n                        ...path,\n                        node.children.length\n                    ]\n                });\n                return;\n            }\n        }\n        normalizeNode(entry);\n    };\n    return editor;\n}\nfunction withLayouts(editor) {\n    const { normalizeNode, deleteBackward } = editor;\n    editor.deleteBackward = (unit)=>{\n        if (editor.selection && slate__WEBPACK_IMPORTED_MODULE_6__.Range.isCollapsed(editor.selection) && // this is just an little optimisation\n        // we're only doing things if we're at the start of a layout area\n        // and the start of anything will always be offset 0\n        // so we'll bailout if we're not at offset 0\n        editor.selection.anchor.offset === 0) {\n            const [aboveNode, abovePath] = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.above(editor, {\n                match: (node)=>node.type === \"layout-area\"\n            }) || [\n                editor,\n                []\n            ];\n            if (aboveNode.type === \"layout-area\" && slate__WEBPACK_IMPORTED_MODULE_6__.Point.equals(slate__WEBPACK_IMPORTED_MODULE_6__.Editor.start(editor, abovePath), editor.selection.anchor)) {\n                return;\n            }\n        }\n        deleteBackward(unit);\n    };\n    editor.normalizeNode = (entry)=>{\n        const [node, path] = entry;\n        if (slate__WEBPACK_IMPORTED_MODULE_6__.Element.isElement(node) && node.type === \"layout\") {\n            if (node.layout === undefined) {\n                slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unwrapNodes(editor, {\n                    at: path\n                });\n                return;\n            }\n            if (node.children.length < node.layout.length) {\n                slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.insertNodes(editor, Array.from({\n                    length: node.layout.length - node.children.length\n                }).map(()=>({\n                        type: \"layout-area\",\n                        children: [\n                            paragraphElement()\n                        ]\n                    })), {\n                    at: [\n                        ...path,\n                        node.children.length\n                    ]\n                });\n                return;\n            }\n            if (node.children.length > node.layout.length) {\n                Array.from({\n                    length: node.children.length - node.layout.length\n                }).map((_, i)=>i).reverse().forEach((i)=>{\n                    const layoutAreaToRemovePath = [\n                        ...path,\n                        i + node.layout.length\n                    ];\n                    const child = node.children[i + node.layout.length];\n                    moveChildren(editor, layoutAreaToRemovePath, [\n                        ...path,\n                        node.layout.length - 1,\n                        node.children[node.layout.length - 1].children.length\n                    ], (node)=>node.type !== \"paragraph\" || slate__WEBPACK_IMPORTED_MODULE_6__.Node.string(child) !== \"\");\n                    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n                        at: layoutAreaToRemovePath\n                    });\n                });\n                return;\n            }\n        }\n        normalizeNode(entry);\n    };\n    return editor;\n}\nconst markdownLinkPattern = /(^|\\s)\\[(.+?)\\]\\((\\S+)\\)$/;\nfunction withLink(editorDocumentFeatures, componentBlocks, editor) {\n    const { insertText, isInline, normalizeNode } = editor;\n    editor.isInline = (element)=>{\n        return element.type === \"link\" ? true : isInline(element);\n    };\n    if (editorDocumentFeatures.links) {\n        editor.insertText = (text)=>{\n            insertText(text);\n            if (text !== \")\" || !editor.selection) {\n                return;\n            }\n            const startOfBlock = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.start(editor, slate__WEBPACK_IMPORTED_MODULE_6__.Editor.above(editor, {\n                match: isBlock\n            })[1]);\n            const startOfBlockToEndOfShortcutString = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.string(editor, {\n                anchor: editor.selection.anchor,\n                focus: startOfBlock\n            });\n            const match = markdownLinkPattern.exec(startOfBlockToEndOfShortcutString);\n            if (!match) {\n                return;\n            }\n            const ancestorComponentChildFieldDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks);\n            if ((ancestorComponentChildFieldDocumentFeatures === null || ancestorComponentChildFieldDocumentFeatures === void 0 ? void 0 : ancestorComponentChildFieldDocumentFeatures.documentFeatures.links) === false) {\n                return;\n            }\n            const [, maybeWhitespace, linkText, href] = match;\n            // by doing this, the insertText(')') above will happen in a different undo than the link replacement\n            // so that means that when someone does an undo after this\n            // it will undo to the state of \"[content](link)\" rather than \"[content](link\" (note the missing closing bracket)\n            editor.history.undos.push({\n                operations: [],\n                selectionBefore: editor.selection\n            });\n            const startOfShortcut = match.index === 0 ? startOfBlock : EditorAfterButIgnoringingPointsWithNoContent(editor, startOfBlock, {\n                distance: match.index\n            });\n            const startOfLinkText = EditorAfterButIgnoringingPointsWithNoContent(editor, startOfShortcut, {\n                distance: maybeWhitespace === \"\" ? 1 : 2\n            });\n            const endOfLinkText = EditorAfterButIgnoringingPointsWithNoContent(editor, startOfLinkText, {\n                distance: linkText.length\n            });\n            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.delete(editor, {\n                at: {\n                    anchor: endOfLinkText,\n                    focus: editor.selection.anchor\n                }\n            });\n            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.delete(editor, {\n                at: {\n                    anchor: startOfShortcut,\n                    focus: startOfLinkText\n                }\n            });\n            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.wrapNodes(editor, {\n                type: \"link\",\n                href,\n                children: []\n            }, {\n                at: {\n                    anchor: editor.selection.anchor,\n                    focus: startOfShortcut\n                },\n                split: true\n            });\n            const nextNode = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.next(editor);\n            if (nextNode) {\n                slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.select(editor, nextNode[1]);\n            }\n        };\n    }\n    editor.normalizeNode = ([node, path])=>{\n        if (node.type === \"link\") {\n            if (slate__WEBPACK_IMPORTED_MODULE_6__.Node.string(node) === \"\") {\n                slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unwrapNodes(editor, {\n                    at: path\n                });\n                return;\n            }\n            for (const [idx, child] of node.children.entries()){\n                if (child.type === \"link\") {\n                    // links cannot contain links\n                    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unwrapNodes(editor, {\n                        at: [\n                            ...path,\n                            idx\n                        ]\n                    });\n                    return;\n                }\n            }\n        }\n        if (isInlineContainer(node)) {\n            let lastMergableLink = null;\n            for (const [idx, child] of node.children.entries()){\n                var _lastMergableLink;\n                if (child.type === \"link\" && child.href === ((_lastMergableLink = lastMergableLink) === null || _lastMergableLink === void 0 ? void 0 : _lastMergableLink.node.href)) {\n                    const firstLinkPath = [\n                        ...path,\n                        lastMergableLink.index\n                    ];\n                    const secondLinkPath = [\n                        ...path,\n                        idx\n                    ];\n                    const to = [\n                        ...firstLinkPath,\n                        lastMergableLink.node.children.length\n                    ];\n                    // note this is going in reverse, js doesn't have double-ended iterators so it's a for(;;)\n                    for(let i = child.children.length - 1; i >= 0; i--){\n                        const childPath = [\n                            ...secondLinkPath,\n                            i\n                        ];\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.moveNodes(editor, {\n                            at: childPath,\n                            to\n                        });\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n                        at: secondLinkPath\n                    });\n                    return;\n                }\n                if (!slate__WEBPACK_IMPORTED_MODULE_6__.Text.isText(child) || child.text !== \"\") {\n                    lastMergableLink = null;\n                }\n                if (child.type === \"link\") {\n                    lastMergableLink = {\n                        index: idx,\n                        node: child\n                    };\n                }\n            }\n        }\n        normalizeNode([\n            node,\n            path\n        ]);\n    };\n    return editor;\n}\nconst isListType = (type)=>type === \"ordered-list\" || type === \"unordered-list\";\nconst isListNode = (node)=>isListType(node.type);\nfunction getAncestorList(editor) {\n    if (editor.selection) {\n        const listItem = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.above(editor, {\n            match: nodeTypeMatcher(\"list-item\")\n        });\n        const list = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.above(editor, {\n            match: isListNode\n        });\n        if (listItem && list) {\n            return {\n                isInside: true,\n                listItem,\n                list\n            };\n        }\n    }\n    return {\n        isInside: false\n    };\n}\nfunction withList(editor) {\n    const { insertBreak, normalizeNode, deleteBackward } = editor;\n    editor.deleteBackward = (unit)=>{\n        if (editor.selection) {\n            const ancestorList = getAncestorList(editor);\n            if (ancestorList.isInside && slate__WEBPACK_IMPORTED_MODULE_6__.Range.isCollapsed(editor.selection) && slate__WEBPACK_IMPORTED_MODULE_6__.Editor.isStart(editor, editor.selection.anchor, ancestorList.list[1])) {\n                slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unwrapNodes(editor, {\n                    match: isListNode,\n                    split: true\n                });\n                return;\n            }\n        }\n        deleteBackward(unit);\n    };\n    editor.insertBreak = ()=>{\n        const [listItem] = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.nodes(editor, {\n            match: (node)=>node.type === \"list-item\",\n            mode: \"lowest\"\n        });\n        if (listItem && slate__WEBPACK_IMPORTED_MODULE_6__.Node.string(listItem[0]) === \"\") {\n            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unwrapNodes(editor, {\n                match: isListNode,\n                split: true\n            });\n            return;\n        }\n        insertBreak();\n    };\n    editor.normalizeNode = (entry)=>{\n        const [node, path] = entry;\n        if (slate__WEBPACK_IMPORTED_MODULE_6__.Element.isElement(node) || slate__WEBPACK_IMPORTED_MODULE_6__.Editor.isEditor(node)) {\n            const isElementBeingNormalizedAList = isListNode(node);\n            for (const [childNode, childPath] of slate__WEBPACK_IMPORTED_MODULE_6__.Node.children(editor, path)){\n                const index = childPath[childPath.length - 1];\n                // merge sibling lists\n                if (isListNode(childNode)) {\n                    var _node$children;\n                    if (((_node$children = node.children[childPath[childPath.length - 1] + 1]) === null || _node$children === void 0 ? void 0 : _node$children.type) === childNode.type) {\n                        const siblingNodePath = slate__WEBPACK_IMPORTED_MODULE_6__.Path.next(childPath);\n                        moveChildren(editor, siblingNodePath, [\n                            ...childPath,\n                            childNode.children.length\n                        ]);\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n                            at: siblingNodePath\n                        });\n                        return;\n                    }\n                    if (isElementBeingNormalizedAList) {\n                        const previousChild = node.children[index - 1];\n                        if (slate__WEBPACK_IMPORTED_MODULE_6__.Element.isElement(previousChild)) {\n                            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.moveNodes(editor, {\n                                at: childPath,\n                                to: [\n                                    ...slate__WEBPACK_IMPORTED_MODULE_6__.Path.previous(childPath),\n                                    previousChild.children.length - 1\n                                ]\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unwrapNodes(editor, {\n                                at: childPath\n                            });\n                        }\n                        return;\n                    }\n                }\n                if (node.type === \"list-item\" && childNode.type !== \"list-item-content\" && index === 0 && isBlock(childNode)) {\n                    if (path[path.length - 1] !== 0) {\n                        const previousChild = slate__WEBPACK_IMPORTED_MODULE_6__.Node.get(editor, slate__WEBPACK_IMPORTED_MODULE_6__.Path.previous(path));\n                        if (slate__WEBPACK_IMPORTED_MODULE_6__.Element.isElement(previousChild)) {\n                            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.moveNodes(editor, {\n                                at: path,\n                                to: [\n                                    ...slate__WEBPACK_IMPORTED_MODULE_6__.Path.previous(path),\n                                    previousChild.children.length\n                                ]\n                            });\n                            return;\n                        }\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unwrapNodes(editor, {\n                        at: childPath\n                    });\n                    return;\n                }\n                if (node.type === \"list-item\" && childNode.type === \"list-item-content\" && index !== 0) {\n                    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.splitNodes(editor, {\n                        at: childPath\n                    });\n                    return;\n                }\n            }\n        }\n        normalizeNode(entry);\n    };\n    return editor;\n}\nfunction order(a, b) {\n    return {\n        start: Math.min(a, b),\n        end: Math.max(a, b)\n    };\n}\nfunction getRelativeRowPath(hasHead, rowIndex) {\n    return hasHead ? rowIndex === 0 ? [\n        0,\n        0\n    ] : [\n        1,\n        rowIndex - 1\n    ] : [\n        0,\n        rowIndex\n    ];\n}\nfunction getSelectedTableArea(editor) {\n    var _Editor$above, _editor$selection, _Editor$above2, _editor$selection2;\n    const anchor = (_Editor$above = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.above(editor, {\n        match: nodeTypeMatcher(\"table-cell\"),\n        at: (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor.path\n    })) === null || _Editor$above === void 0 ? void 0 : _Editor$above[1];\n    const focus = (_Editor$above2 = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.above(editor, {\n        match: nodeTypeMatcher(\"table-cell\"),\n        at: (_editor$selection2 = editor.selection) === null || _editor$selection2 === void 0 ? void 0 : _editor$selection2.focus.path\n    })) === null || _Editor$above2 === void 0 ? void 0 : _Editor$above2[1];\n    const table = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.above(editor, {\n        match: nodeTypeMatcher(\"table\")\n    });\n    if (editor.selection && table && slate__WEBPACK_IMPORTED_MODULE_6__.Element.isElement(table[0].children[0]) && anchor && focus && slate__WEBPACK_IMPORTED_MODULE_6__.Path.equals(anchor.slice(0, -3), focus.slice(0, -3))) {\n        const [start, end] = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.edges(editor, editor.selection);\n        return {\n            tablePath: table[1],\n            table: table[0],\n            singleCell: slate__WEBPACK_IMPORTED_MODULE_6__.Path.equals(anchor, focus) ? slate__WEBPACK_IMPORTED_MODULE_6__.Point.equals(slate__WEBPACK_IMPORTED_MODULE_6__.Editor.start(editor, anchor), start) && slate__WEBPACK_IMPORTED_MODULE_6__.Point.equals(slate__WEBPACK_IMPORTED_MODULE_6__.Editor.end(editor, anchor), end) && !slate__WEBPACK_IMPORTED_MODULE_6__.Point.equals(start, end) ? \"selected\" : \"not-selected\" : \"many\",\n            row: order(anchor[anchor.length - 2] + anchor[anchor.length - 3], focus[focus.length - 2] + focus[anchor.length - 3]),\n            column: order(anchor[anchor.length - 1], focus[focus.length - 1])\n        };\n    }\n}\nconst cell = (header)=>({\n        type: \"table-cell\",\n        ...header ? {\n            header: true\n        } : {},\n        children: [\n            {\n                type: \"paragraph\",\n                children: [\n                    {\n                        text: \"\"\n                    }\n                ]\n            }\n        ]\n    });\nfunction cloneDescendant(node) {\n    if (slate__WEBPACK_IMPORTED_MODULE_6__.Text.isText(node)) return {\n        ...node\n    };\n    return {\n        ...node,\n        children: node.children.map(cloneDescendant)\n    };\n}\nfunction withTable(editor) {\n    const { deleteFragment, normalizeNode, getFragment, insertFragment, deleteBackward } = editor;\n    editor.insertFragment = (fragment)=>{\n        const selectedTableArea = getSelectedTableArea(editor);\n        if (!selectedTableArea || fragment.length !== 1 || fragment[0].type !== \"table\") {\n            insertFragment(fragment);\n            return;\n        }\n        const newRows = fragment[0].children.flatMap((child)=>child.type === \"table-head\" || child.type === \"table-body\" ? child.children : []);\n        if (!newRows.every(nodeTypeMatcher(\"table-row\"))) {\n            insertFragment(fragment);\n            return;\n        }\n        let { row, column, tablePath, table } = selectedTableArea;\n        const existingBody = selectedTableArea.table.children[selectedTableArea.table.children.length === 1 ? 0 : 1];\n        if (newRows[0].type !== \"table-row\" || existingBody.type !== \"table-body\" || existingBody.children[0].type !== \"table-row\") {\n            insertFragment(fragment);\n            return;\n        }\n        const hasHead = table.children[0].type === \"table-head\";\n        if (selectedTableArea.singleCell !== \"many\") {\n            row = {\n                start: row.start,\n                end: Math.min(row.start + newRows.length - 1, existingBody.children.length - 1 + (hasHead ? 1 : 0))\n            };\n            column = {\n                start: column.start,\n                end: Math.min(column.start + newRows[0].children.length - 1, existingBody.children[0].children.length - 1)\n            };\n        }\n        slate__WEBPACK_IMPORTED_MODULE_6__.Editor.withoutNormalizing(editor, ()=>{\n            for(let rowIndex = row.start; rowIndex <= row.end; rowIndex++){\n                const newRow = newRows[(rowIndex - row.start) % newRows.length];\n                for(let cellIndex = column.start; cellIndex <= column.end; cellIndex++){\n                    const relativeCellPath = [\n                        ...getRelativeRowPath(hasHead, rowIndex),\n                        cellIndex\n                    ];\n                    const cell = slate__WEBPACK_IMPORTED_MODULE_6__.Node.get(table, relativeCellPath);\n                    const newCell = newRow.children[(cellIndex - column.start) % newRow.children.length];\n                    if (cell.type !== \"table-cell\" || newCell.type !== \"table-cell\") {\n                        continue;\n                    }\n                    const cellPath = [\n                        ...tablePath,\n                        ...relativeCellPath\n                    ];\n                    for (const childIdx of [\n                        ...cell.children.keys()\n                    ].reverse()){\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n                            at: [\n                                ...cellPath,\n                                childIdx\n                            ]\n                        });\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.insertNodes(editor, newCell.children.map(cloneDescendant), {\n                        at: [\n                            ...cellPath,\n                            0\n                        ]\n                    });\n                }\n            }\n            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.setSelection(editor, {\n                anchor: slate__WEBPACK_IMPORTED_MODULE_6__.Editor.start(editor, [\n                    ...tablePath,\n                    ...getRelativeRowPath(hasHead, row.start),\n                    column.start\n                ]),\n                focus: slate__WEBPACK_IMPORTED_MODULE_6__.Editor.end(editor, [\n                    ...tablePath,\n                    ...getRelativeRowPath(hasHead, row.end),\n                    column.end\n                ])\n            });\n        });\n    };\n    editor.deleteBackward = (unit)=>{\n        if (editor.selection && slate__WEBPACK_IMPORTED_MODULE_6__.Range.isCollapsed(editor.selection) && editor.selection.anchor.offset === 0) {\n            const tableCell = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.above(editor, {\n                match: nodeTypeMatcher(\"table-cell\")\n            });\n            if (tableCell && tableCell[0].children[0].type === \"paragraph\" && tableCell[0].children[0].children[0].type === undefined && slate__WEBPACK_IMPORTED_MODULE_6__.Path.equals(editor.selection.anchor.path, [\n                ...tableCell[1],\n                0,\n                0\n            ])) {\n                return;\n            }\n        }\n        deleteBackward(unit);\n    };\n    editor.getFragment = ()=>{\n        const selectedTableArea = getSelectedTableArea(editor);\n        if (selectedTableArea && selectedTableArea.singleCell !== \"not-selected\") {\n            var _table$children$;\n            const { table } = selectedTableArea;\n            const first = table.children[0].type === \"table-head\" || table.children[0].type === \"table-body\" ? table.children[0] : undefined;\n            if (!first) {\n                return getFragment();\n            }\n            const second = ((_table$children$ = table.children[1]) === null || _table$children$ === void 0 ? void 0 : _table$children$.type) === \"table-body\" ? table.children[1] : undefined;\n            const body = second || first;\n            const hasHead = first.type === \"table-head\";\n            const isSelectionInHead = selectedTableArea.row.start === 0 && !!second;\n            const columnLength = selectedTableArea.column.end - selectedTableArea.column.start + 1;\n            return [\n                {\n                    type: \"table\",\n                    children: [\n                        ...isSelectionInHead ? [\n                            {\n                                type: \"table-head\",\n                                children: [\n                                    {\n                                        type: \"table-row\",\n                                        children: Array.from({\n                                            length: columnLength\n                                        }).map((_, columnIndex)=>first.children[0].children[columnIndex + selectedTableArea.column.start])\n                                    }\n                                ]\n                            }\n                        ] : [],\n                        {\n                            type: \"table-body\",\n                            children: Array.from({\n                                length: selectedTableArea.row.end - selectedTableArea.row.start + (isSelectionInHead ? 0 : 1)\n                            }).map((_, rowIndex)=>({\n                                    type: \"table-row\",\n                                    children: Array.from({\n                                        length: columnLength\n                                    }).map((_, columnIndex)=>body.children[rowIndex + selectedTableArea.row.start - (hasHead && !isSelectionInHead ? 1 : 0)].children[columnIndex + selectedTableArea.column.start])\n                                }))\n                        }\n                    ]\n                }\n            ];\n        }\n        return getFragment();\n    };\n    editor.deleteFragment = (direction)=>{\n        if (!editor.selection || slate__WEBPACK_IMPORTED_MODULE_6__.Range.isCollapsed(editor.selection)) {\n            deleteFragment(direction);\n            return;\n        }\n        const selectedTableArea = getSelectedTableArea(editor);\n        if (!selectedTableArea || selectedTableArea.singleCell === \"not-selected\") {\n            deleteFragment(direction);\n            return;\n        }\n        const headOrBody = selectedTableArea.table.children[0];\n        if (!slate__WEBPACK_IMPORTED_MODULE_6__.Element.isElement(headOrBody) || !slate__WEBPACK_IMPORTED_MODULE_6__.Element.isElement(headOrBody.children[0])) {\n            deleteFragment(direction);\n            return;\n        }\n        const maxRowIdx = selectedTableArea.table.children.reduce((sum, headOrBody)=>sum + (headOrBody.type === \"table-head\" || headOrBody.type === \"table-body\" ? headOrBody.children.length : 0), 0) - 1;\n        const { row, column, tablePath } = selectedTableArea;\n        // note the fact that hasWholeColumnSelected uses row and hasWholeRowSelected uses column\n        // is not a mistake. if a whole column has been selected, then the starting row is 0 and the end is the last row\n        const hasWholeColumnSelected = row.start === 0 && row.end === maxRowIdx;\n        const hasWholeRowSelected = column.start === 0 && column.end === headOrBody.children[0].children.length - 1;\n        if (hasWholeColumnSelected && hasWholeRowSelected) {\n            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n                at: tablePath\n            });\n            return;\n        }\n        const hasHead = headOrBody.type === \"table-head\";\n        if (hasWholeRowSelected) {\n            slate__WEBPACK_IMPORTED_MODULE_6__.Editor.withoutNormalizing(editor, ()=>{\n                for(let i = row.end; i >= row.start; i--){\n                    if (hasHead) {\n                        if (i === 0) {\n                            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n                                at: [\n                                    ...tablePath,\n                                    0\n                                ]\n                            });\n                            continue;\n                        }\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n                            at: [\n                                ...tablePath,\n                                1,\n                                i - 1\n                            ]\n                        });\n                        continue;\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n                        at: [\n                            ...tablePath,\n                            0,\n                            i\n                        ]\n                    });\n                }\n            });\n            return;\n        }\n        if (hasWholeColumnSelected) {\n            slate__WEBPACK_IMPORTED_MODULE_6__.Editor.withoutNormalizing(editor, ()=>{\n                for(let i = column.end; i >= column.start; i--){\n                    for(let rowIdx = 0; rowIdx <= maxRowIdx; rowIdx++){\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n                            at: [\n                                ...tablePath,\n                                ...getRelativeRowPath(hasHead, rowIdx),\n                                i\n                            ]\n                        });\n                    }\n                }\n                const selectionPath = [\n                    ...tablePath,\n                    0,\n                    0,\n                    column.start\n                ];\n                const point = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.start(editor, column.start === 0 ? selectionPath : slate__WEBPACK_IMPORTED_MODULE_6__.Path.previous(selectionPath));\n                slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.select(editor, point);\n            });\n            return;\n        }\n        const selectionStart = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.start(editor, editor.selection).path;\n        slate__WEBPACK_IMPORTED_MODULE_6__.Editor.withoutNormalizing(editor, ()=>{\n            for(let rowIndex = row.start; rowIndex <= row.end; rowIndex++){\n                for(let cellIndex = column.start; cellIndex <= column.end; cellIndex++){\n                    const relativeCellPath = [\n                        ...getRelativeRowPath(hasHead, rowIndex),\n                        cellIndex\n                    ];\n                    const cell = slate__WEBPACK_IMPORTED_MODULE_6__.Node.get(selectedTableArea.table, relativeCellPath);\n                    if (!slate__WEBPACK_IMPORTED_MODULE_6__.Element.isElement(cell)) {\n                        continue;\n                    }\n                    const cellPath = [\n                        ...tablePath,\n                        ...relativeCellPath\n                    ];\n                    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.insertNodes(editor, {\n                        type: \"paragraph\",\n                        children: [\n                            {\n                                text: \"\"\n                            }\n                        ]\n                    }, {\n                        at: [\n                            ...cellPath,\n                            0\n                        ]\n                    });\n                    for (const childIdx of [\n                        ...cell.children.keys()\n                    ].reverse()){\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.removeNodes(editor, {\n                            at: [\n                                ...cellPath,\n                                childIdx + 1\n                            ]\n                        });\n                    }\n                }\n            }\n            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.select(editor, selectionStart);\n        });\n    };\n    editor.normalizeNode = (entry)=>{\n        const [node, path] = entry;\n        if (node.type === \"table-head\" && node.children.length > 1) {\n            moveChildren(editor, path, slate__WEBPACK_IMPORTED_MODULE_6__.Path.next(path), (_, i)=>i !== 0);\n            return;\n        }\n        let didUpdateThings = false;\n        for (const parent of [\n            \"table-body\",\n            \"table-head\"\n        ]){\n            if (node.type === parent) {\n                for (const [rowIdx, row] of node.children.entries()){\n                    if (row.type === \"table-row\") {\n                        for (const [cellIdx, cell] of row.children.entries()){\n                            if (cell.type === \"table-cell\") {\n                                const at = [\n                                    ...path,\n                                    rowIdx,\n                                    cellIdx\n                                ];\n                                if (cell.header && parent === \"table-body\") {\n                                    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unsetNodes(editor, \"header\", {\n                                        at\n                                    });\n                                    didUpdateThings = true;\n                                }\n                                if (!cell.header && parent === \"table-head\") {\n                                    slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.setNodes(editor, {\n                                        header: true\n                                    }, {\n                                        at\n                                    });\n                                    didUpdateThings = true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (didUpdateThings) {\n            return;\n        }\n        if (node.type === \"table\") {\n            const maxRowCount = node.children.reduce((max, node)=>node.type === \"table-head\" || node.type === \"table-body\" ? node.children.reduce((max, node)=>node.type === \"table-row\" ? Math.max(max, node.children.length) : max, max) : max, 0);\n            let didInsert = false;\n            for (const [idx, child] of node.children.entries()){\n                if (child.type === \"table-body\" || child.type === \"table-head\") {\n                    for (const [rowIdx, row] of child.children.entries()){\n                        if (row.type === \"table-row\" && row.children.length !== maxRowCount) {\n                            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.insertNodes(editor, Array.from({\n                                length: maxRowCount - row.children.length\n                            }, ()=>cell(child.type === \"table-head\")), {\n                                at: [\n                                    ...path,\n                                    idx,\n                                    rowIdx,\n                                    row.children.length\n                                ]\n                            });\n                            didInsert = true;\n                        }\n                    }\n                }\n            }\n            if (didInsert) {\n                return;\n            }\n            if (node.children.length === 1 && node.children[0].type === \"table-head\") {\n                slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.insertNodes(editor, {\n                    type: \"table-body\",\n                    children: Array.from({\n                        length: node.children[0].children.length\n                    }, ()=>cell(false))\n                }, {\n                    at: [\n                        ...path,\n                        1\n                    ]\n                });\n                return;\n            }\n            if (node.children.length === 2 && node.children[1].type === \"table-head\") {\n                slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.moveNodes(editor, {\n                    at: [\n                        ...path,\n                        1\n                    ],\n                    to: [\n                        ...path,\n                        0\n                    ]\n                });\n                return;\n            }\n            if (node.children.length > 2) {\n                moveChildren(editor, path, slate__WEBPACK_IMPORTED_MODULE_6__.Path.next(path), (_, i)=>i !== 0 && i !== 1);\n                return;\n            }\n        }\n        normalizeNode(entry);\n    };\n    return editor;\n}\nfunction createDocumentEditorForNormalization(documentFeatures, componentBlocks) {\n    return _createDocumentEditor((0,slate__WEBPACK_IMPORTED_MODULE_6__.createEditor)(), documentFeatures, componentBlocks);\n}\nfunction _createDocumentEditor(baseEditor, documentFeatures, componentBlocks) {\n    return withBlocksSchema(withParagraphs(withLink(documentFeatures, componentBlocks, withList(withTable(withComponentBlocks(componentBlocks, documentFeatures, withVoidElements(withLayouts(withCodeBlock(documentFeatures, componentBlocks, withDocumentFeaturesNormalization(documentFeatures, baseEditor))))))))));\n}\nfunction withBlocksSchema(editor) {\n    const { normalizeNode } = editor;\n    editor.normalizeNode = ([node, path])=>{\n        if (!slate__WEBPACK_IMPORTED_MODULE_6__.Text.isText(node) && node.type !== \"link\") {\n            const nodeType = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.isEditor(node) ? \"editor\" : node.type;\n            if (typeof nodeType !== \"string\" || editorSchema[nodeType] === undefined) {\n                slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unwrapNodes(editor, {\n                    at: path\n                });\n                return;\n            }\n            const info = editorSchema[nodeType];\n            if (info.kind === \"blocks\" && node.children.length !== 0 && node.children.every((child)=>!isBlock(child))) {\n                slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.wrapNodes(editor, {\n                    type: info.blockToWrapInlinesIn,\n                    children: []\n                }, {\n                    at: path,\n                    match: (node)=>!isBlock(node)\n                });\n                return;\n            }\n            let didUpdate = false;\n            for (const [index, childNode] of [\n                ...node.children.entries()\n            ].reverse()){\n                const childPath = [\n                    ...path,\n                    index\n                ];\n                if (info.kind === \"inlines\") {\n                    if (!slate__WEBPACK_IMPORTED_MODULE_6__.Text.isText(childNode) && isBlock(childNode)) {\n                        handleNodeInInvalidPosition(editor, [\n                            childNode,\n                            childPath\n                        ], path);\n                        didUpdate = true;\n                        continue;\n                    }\n                } else {\n                    if (!isBlock(childNode)) {\n                        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.wrapNodes(editor, {\n                            type: info.blockToWrapInlinesIn,\n                            children: []\n                        }, {\n                            at: childPath\n                        });\n                        didUpdate = true;\n                        continue;\n                    }\n                    if (!info.allowedChildren.has(childNode.type)) {\n                        handleNodeInInvalidPosition(editor, [\n                            childNode,\n                            childPath\n                        ], path);\n                        didUpdate = true;\n                        continue;\n                    }\n                }\n            }\n            if (didUpdate) {\n                return;\n            }\n        }\n        normalizeNode([\n            node,\n            path\n        ]);\n    };\n    return editor;\n}\nfunction handleNodeInInvalidPosition(editor, [node, path], ancestorPath) {\n    const nodeType = node.type;\n    const childNodeInfo = editorSchema[nodeType];\n    // the parent of a block will never be an inline so this casting is okay\n    const ancestorNode = slate__WEBPACK_IMPORTED_MODULE_6__.Node.get(editor, ancestorPath);\n    const parentNodeType = slate__WEBPACK_IMPORTED_MODULE_6__.Editor.isEditor(ancestorNode) ? \"editor\" : ancestorNode.type;\n    const parentNodeInfo = editorSchema[parentNodeType];\n    if (!childNodeInfo || childNodeInfo.invalidPositionHandleMode === \"unwrap\") {\n        if (parentNodeInfo.kind === \"blocks\" && parentNodeInfo.blockToWrapInlinesIn) {\n            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.setNodes(editor, {\n                type: parentNodeInfo.blockToWrapInlinesIn,\n                ...Object.fromEntries(Object.keys(node).filter((key)=>key !== \"type\" && key !== \"children\").map((key)=>[\n                        key,\n                        null\n                    ])) // the Slate types don't understand that null is allowed and it will unset properties with setNodes\n            }, {\n                at: path\n            });\n            return;\n        }\n        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unwrapNodes(editor, {\n            at: path\n        });\n        return;\n    }\n    const info = editorSchema[ancestorNode.type || \"editor\"];\n    if ((info === null || info === void 0 ? void 0 : info.kind) === \"blocks\" && info.allowedChildren.has(nodeType)) {\n        if (ancestorPath.length === 0) {\n            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.moveNodes(editor, {\n                at: path,\n                to: [\n                    path[0] + 1\n                ]\n            });\n        } else {\n            slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.moveNodes(editor, {\n                at: path,\n                to: slate__WEBPACK_IMPORTED_MODULE_6__.Path.next(ancestorPath)\n            });\n        }\n        return;\n    }\n    if (slate__WEBPACK_IMPORTED_MODULE_6__.Editor.isEditor(ancestorNode)) {\n        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.moveNodes(editor, {\n            at: path,\n            to: [\n                path[0] + 1\n            ]\n        });\n        slate__WEBPACK_IMPORTED_MODULE_6__.Transforms.unwrapNodes(editor, {\n            at: [\n                path[0] + 1\n            ]\n        });\n        return;\n    }\n    handleNodeInInvalidPosition(editor, [\n        node,\n        path\n    ], ancestorPath.slice(0, -1));\n}\nfunction withVoidElements(editor) {\n    const { isVoid } = editor;\n    editor.isVoid = (node)=>{\n        return node.type === \"divider\" || node.type === \"image\" || isVoid(node);\n    };\n    return editor;\n}\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nconst defaultAltField = text({\n    label: \"Alt text\",\n    description: \"This text will be used by screen readers and search engines.\"\n});\nconst emptyTitleField = basicFormFieldWithSimpleReaderParse({\n    Input () {\n        return null;\n    },\n    defaultValue () {\n        return \"\";\n    },\n    parse (value) {\n        if (value === undefined) return \"\";\n        if (typeof value !== \"string\") {\n            throw new FieldDataError(\"Must be string\");\n        }\n        return value;\n    },\n    validate (value) {\n        return value;\n    },\n    serialize (value) {\n        return {\n            value\n        };\n    },\n    label: \"Title\"\n});\nfunction normaliseDocumentFeatures(config) {\n    var _config$formatting, _formatting$alignment, _formatting$alignment2, _formatting$blockType, _formatting$inlineMar, _formatting$inlineMar2, _formatting$inlineMar3, _formatting$inlineMar4, _formatting$inlineMar5, _formatting$inlineMar6, _formatting$inlineMar7, _formatting$inlineMar8, _formatting$listTypes, _formatting$listTypes2, _imagesConfig$schema$, _imagesConfig$schema, _imagesConfig$schema$2, _imagesConfig$schema2;\n    const formatting = config.formatting === true ? {\n        // alignment: true, // not supported natively in markdown\n        blockTypes: true,\n        headingLevels: true,\n        inlineMarks: true,\n        listTypes: true,\n        softBreaks: true\n    } : (_config$formatting = config.formatting) !== null && _config$formatting !== void 0 ? _config$formatting : {};\n    const imagesConfig = config.images === true ? {} : config.images;\n    return {\n        formatting: {\n            alignment: formatting.alignment === true ? {\n                center: true,\n                end: true\n            } : {\n                center: !!((_formatting$alignment = formatting.alignment) !== null && _formatting$alignment !== void 0 && _formatting$alignment.center),\n                end: !!((_formatting$alignment2 = formatting.alignment) !== null && _formatting$alignment2 !== void 0 && _formatting$alignment2.end)\n            },\n            blockTypes: (formatting === null || formatting === void 0 ? void 0 : formatting.blockTypes) === true ? {\n                blockquote: true,\n                code: {\n                    schema: object({})\n                }\n            } : {\n                blockquote: !!((_formatting$blockType = formatting.blockTypes) !== null && _formatting$blockType !== void 0 && _formatting$blockType.blockquote),\n                code: ((_formatting$blockType2)=>{\n                    if (((_formatting$blockType2 = formatting.blockTypes) === null || _formatting$blockType2 === void 0 ? void 0 : _formatting$blockType2.code) === undefined) {\n                        return false;\n                    }\n                    if (formatting.blockTypes.code === true || !formatting.blockTypes.code.schema) {\n                        return {\n                            schema: object({})\n                        };\n                    }\n                    for (const key of [\n                        \"type\",\n                        \"children\",\n                        \"language\"\n                    ]){\n                        if (key in formatting.blockTypes.code.schema) {\n                            throw new Error(`\"${key}\" cannot be a key in the schema for code blocks`);\n                        }\n                    }\n                    return {\n                        schema: object(formatting.blockTypes.code.schema)\n                    };\n                })()\n            },\n            headings: ((_obj$schema)=>{\n                const opt = formatting === null || formatting === void 0 ? void 0 : formatting.headingLevels;\n                const obj = typeof opt === \"object\" && \"levels\" in opt ? opt : {\n                    levels: opt,\n                    schema: undefined\n                };\n                if (obj.schema) {\n                    for (const key of [\n                        \"type\",\n                        \"children\",\n                        \"level\",\n                        \"textAlign\"\n                    ]){\n                        if (key in obj.schema) {\n                            throw new Error(`\"${key}\" cannot be a key in the schema for headings`);\n                        }\n                    }\n                }\n                return {\n                    levels: [\n                        ...new Set(obj.levels === true ? [\n                            1,\n                            2,\n                            3,\n                            4,\n                            5,\n                            6\n                        ] : obj.levels)\n                    ],\n                    schema: object((_obj$schema = obj.schema) !== null && _obj$schema !== void 0 ? _obj$schema : {})\n                };\n            })(),\n            inlineMarks: formatting.inlineMarks === true ? {\n                bold: true,\n                code: true,\n                italic: true,\n                keyboard: false,\n                // not supported natively in markdown\n                strikethrough: true,\n                subscript: false,\n                // not supported natively in markdown\n                superscript: false,\n                // not supported natively in markdown\n                underline: false // not supported natively in markdown\n            } : {\n                bold: !!((_formatting$inlineMar = formatting.inlineMarks) !== null && _formatting$inlineMar !== void 0 && _formatting$inlineMar.bold),\n                code: !!((_formatting$inlineMar2 = formatting.inlineMarks) !== null && _formatting$inlineMar2 !== void 0 && _formatting$inlineMar2.code),\n                italic: !!((_formatting$inlineMar3 = formatting.inlineMarks) !== null && _formatting$inlineMar3 !== void 0 && _formatting$inlineMar3.italic),\n                strikethrough: !!((_formatting$inlineMar4 = formatting.inlineMarks) !== null && _formatting$inlineMar4 !== void 0 && _formatting$inlineMar4.strikethrough),\n                underline: !!((_formatting$inlineMar5 = formatting.inlineMarks) !== null && _formatting$inlineMar5 !== void 0 && _formatting$inlineMar5.underline),\n                keyboard: !!((_formatting$inlineMar6 = formatting.inlineMarks) !== null && _formatting$inlineMar6 !== void 0 && _formatting$inlineMar6.keyboard),\n                subscript: !!((_formatting$inlineMar7 = formatting.inlineMarks) !== null && _formatting$inlineMar7 !== void 0 && _formatting$inlineMar7.subscript),\n                superscript: !!((_formatting$inlineMar8 = formatting.inlineMarks) !== null && _formatting$inlineMar8 !== void 0 && _formatting$inlineMar8.superscript)\n            },\n            listTypes: formatting.listTypes === true ? {\n                ordered: true,\n                unordered: true\n            } : {\n                ordered: !!((_formatting$listTypes = formatting.listTypes) !== null && _formatting$listTypes !== void 0 && _formatting$listTypes.ordered),\n                unordered: !!((_formatting$listTypes2 = formatting.listTypes) !== null && _formatting$listTypes2 !== void 0 && _formatting$listTypes2.unordered)\n            },\n            softBreaks: !!formatting.softBreaks\n        },\n        links: !!config.links,\n        layouts: [\n            ...new Set((config.layouts || []).map((x)=>JSON.stringify(x)))\n        ].map((x)=>JSON.parse(x)),\n        dividers: !!config.dividers,\n        images: imagesConfig === undefined ? false : {\n            ...imagesConfig,\n            schema: {\n                alt: (_imagesConfig$schema$ = (_imagesConfig$schema = imagesConfig.schema) === null || _imagesConfig$schema === void 0 ? void 0 : _imagesConfig$schema.alt) !== null && _imagesConfig$schema$ !== void 0 ? _imagesConfig$schema$ : defaultAltField,\n                title: (_imagesConfig$schema$2 = (_imagesConfig$schema2 = imagesConfig.schema) === null || _imagesConfig$schema2 === void 0 ? void 0 : _imagesConfig$schema2.title) !== null && _imagesConfig$schema$2 !== void 0 ? _imagesConfig$schema$2 : emptyTitleField\n            }\n        },\n        tables: !!config.tables\n    };\n}\nfunction document$1({ label, componentBlocks = {}, description, ...documentFeaturesConfig }) {\n    const documentFeatures = normaliseDocumentFeatures(documentFeaturesConfig);\n    const parse = (mode)=>(_value, data)=>{\n            const markdoc = textDecoder.decode(data.content);\n            const document1 = fromMarkdoc(_markdoc_markdoc__WEBPACK_IMPORTED_MODULE_7__[\"default\"].parse(markdoc), componentBlocks);\n            const editor = createDocumentEditorForNormalization(documentFeatures, componentBlocks);\n            editor.children = document1;\n            slate__WEBPACK_IMPORTED_MODULE_6__.Editor.normalize(editor, {\n                force: true\n            });\n            return deserializeFiles(editor.children, componentBlocks, data.other, data.external || new Map(), mode, documentFeatures, data.slug);\n        };\n    return {\n        kind: \"form\",\n        formKind: \"content\",\n        defaultValue () {\n            return [\n                {\n                    type: \"paragraph\",\n                    children: [\n                        {\n                            text: \"\"\n                        }\n                    ]\n                }\n            ];\n        },\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(DocumentFieldInput, {\n                componentBlocks: componentBlocks,\n                description: description,\n                label: label,\n                documentFeatures: documentFeatures,\n                ...props\n            });\n        },\n        parse: parse(\"edit\"),\n        contentExtension: \".mdoc\",\n        validate (value) {\n            return value;\n        },\n        directories: [\n            ...collectDirectoriesUsedInSchema(object(Object.fromEntries(Object.entries(componentBlocks).map(([name, block])=>[\n                    name,\n                    object(block.schema)\n                ])))),\n            ...typeof documentFeatures.images === \"object\" && typeof documentFeatures.images.directory === \"string\" ? [\n                fixPath(documentFeatures.images.directory)\n            ] : []\n        ],\n        serialize (value, opts) {\n            const { extraFiles, node } = toMarkdocDocument(value, {\n                componentBlocks,\n                documentFeatures,\n                slug: opts.slug\n            });\n            const other = new Map();\n            const external = new Map();\n            for (const file of extraFiles){\n                if (file.parent === undefined) {\n                    other.set(file.path, file.contents);\n                    continue;\n                }\n                if (!external.has(file.parent)) {\n                    external.set(file.parent, new Map());\n                }\n                external.get(file.parent).set(file.path, file.contents);\n            }\n            return {\n                content: textEncoder.encode(_markdoc_markdoc__WEBPACK_IMPORTED_MODULE_7__[\"default\"].format(_markdoc_markdoc__WEBPACK_IMPORTED_MODULE_7__[\"default\"].parse(_markdoc_markdoc__WEBPACK_IMPORTED_MODULE_7__[\"default\"].format(node)))),\n                other,\n                external,\n                value: undefined\n            };\n        },\n        reader: {\n            parse: parse(\"read\")\n        }\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3QvaW5kZXgtMDRjM2U3MWYubm9kZS5yZWFjdC1zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDd0U7QUFDM0I7QUFDeEM7QUFDRDtBQUNQO0FBQ0k7QUFDUTtBQUVoRCxTQUFTbUIsUUFBUUMsSUFBSTtJQUNuQixPQUFPQSxLQUFLQyxPQUFPLENBQUMsV0FBVyxJQUFJQSxPQUFPLENBQUMsUUFBUTtBQUNyRDtBQUNBLE1BQU1DLGlCQUFpQjtBQUN2QixTQUFTQyw0QkFBNEJDLE1BQU0sRUFBRUMsVUFBVTtJQUNyRCxJQUFJQztJQUNKLE1BQU1DLG1CQUFtQkgsT0FBT0ksV0FBVyxDQUFDSCxXQUFXO0lBQ3ZELE1BQU1MLE9BQU8sQ0FBQ00sd0JBQXdCQyxpQkFBaUJQLElBQUksTUFBTSxRQUFRTSwwQkFBMEIsS0FBSyxJQUFJQSx3QkFBd0IsQ0FBQyxFQUFFRCxXQUFXLEdBQUcsQ0FBQztJQUN0SixJQUFJLENBQUNILGVBQWVPLElBQUksQ0FBQ1QsT0FBTztRQUM5QixNQUFNLElBQUlVLE1BQU0sQ0FBQyxtRUFBbUUsRUFBRUwsV0FBVyxLQUFLLEVBQUVMLEtBQUssQ0FBQztJQUNoSDtJQUNBLE9BQU9BO0FBQ1Q7QUFDQSxTQUFTVyxrQkFBa0JQLE1BQU0sRUFBRUMsVUFBVTtJQUMzQyxNQUFNTyxpQkFBaUJULDRCQUE0QkMsUUFBUUM7SUFDM0QsTUFBTUwsT0FBT0QsUUFBUWEsZUFBZVgsT0FBTyxDQUFDLFlBQVk7SUFDeEQsT0FBT0Q7QUFDVDtBQUNBLFNBQVNhLG9CQUFvQlQsTUFBTSxFQUFFQyxVQUFVO0lBQzdDLElBQUlTO0lBQ0osTUFBTVAsbUJBQW1CSCxPQUFPSSxXQUFXLENB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QUssV0FBVztnQkFBQ3hKLFFBQVFxVSxpQkFBaUJaLE1BQU0sQ0FBQ2pLLFNBQVM7YUFBRSxHQUFHLEVBQUU7U0FBRTtRQUNqVTRRLFdBQVU1UixLQUFLLEVBQUVnRSxJQUFJO1lBQ25CLE1BQU0sRUFDSm1WLFVBQVUsRUFDVm5kLElBQUksRUFDTCxHQUFHaWYsa0JBQWtCamIsT0FBTztnQkFDM0I4TDtnQkFDQUQ7Z0JBQ0EzUyxNQUFNOEssS0FBSzlLLElBQUk7WUFDakI7WUFDQSxNQUFNb2dCLFFBQVEsSUFBSTljO1lBQ2xCLE1BQU0rYyxXQUFXLElBQUkvYztZQUNyQixLQUFLLE1BQU0rbEMsUUFBUXBwQixXQUFZO2dCQUM3QixJQUFJb3BCLEtBQUsxMEIsTUFBTSxLQUFLeFQsV0FBVztvQkFDN0JpZixNQUFNM2QsR0FBRyxDQUFDNG1DLEtBQUs5cUMsSUFBSSxFQUFFOHFDLEtBQUtubkMsUUFBUTtvQkFDbEM7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDbWUsU0FBU2hkLEdBQUcsQ0FBQ2dtQyxLQUFLMTBCLE1BQU0sR0FBRztvQkFDOUIwTCxTQUFTNWQsR0FBRyxDQUFDNG1DLEtBQUsxMEIsTUFBTSxFQUFFLElBQUlyUjtnQkFDaEM7Z0JBQ0ErYyxTQUFTdGQsR0FBRyxDQUFDc21DLEtBQUsxMEIsTUFBTSxFQUFFbFMsR0FBRyxDQUFDNG1DLEtBQUs5cUMsSUFBSSxFQUFFOHFDLEtBQUtubkMsUUFBUTtZQUN4RDtZQUNBLE9BQU87Z0JBQ0xOLFNBQVN1bEMsWUFBWS9rQyxNQUFNLENBQUNqRiwrREFBYyxDQUFDQSw4REFBYSxDQUFDQSwrREFBYyxDQUFDMkY7Z0JBQ3hFc2Q7Z0JBQ0FDO2dCQUNBdlosT0FBTzNGO1lBQ1Q7UUFDRjtRQUNBeVgsUUFBUTtZQUNOSCxPQUFPQSxNQUFNO1FBQ2Y7SUFDRjtBQUNGO0FBRW03RSIsInNvdXJjZXMiOlsid2VicGFjazovL0BrZXlzdGF0aWMvdGVtcGxhdGVzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9Aa2V5c3RhdGljL2NvcmUvZGlzdC9pbmRleC0wNGMzZTcxZi5ub2RlLnJlYWN0LXNlcnZlci5qcz8wNmRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNYXJrZG9jIGZyb20gJ0BtYXJrZG9jL21hcmtkb2MnO1xuaW1wb3J0IHsgRWxlbWVudCBhcyBFbGVtZW50JDEsIFBhdGgsIE5vZGUsIFRyYW5zZm9ybXMsIEVkaXRvciwgVGV4dCwgUmFuZ2UsIFBvaW50LCBjcmVhdGVFZGl0b3IgfSBmcm9tICdzbGF0ZSc7XG5pbXBvcnQgeyBhc3NlcnROZXZlciBhcyBhc3NlcnROZXZlciQxLCBhc3NlcnQgYXMgYXNzZXJ0JDEgfSBmcm9tICdlbWVyeS9hc3NlcnRpb25zJztcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0TmV2ZXIgfSBmcm9tICdlbWVyeSc7XG5pbXBvcnQgeyBmcm9tVWludDhBcnJheSB9IGZyb20gJ2pzLWJhc2U2NCc7XG5pbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB3ZWFrTWVtb2l6ZSBmcm9tICdAZW1vdGlvbi93ZWFrLW1lbW9pemUnO1xuXG5mdW5jdGlvbiBmaXhQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXlxcLj9cXC8rLywgJycpLnJlcGxhY2UoL1xcLyokLywgJycpO1xufVxuY29uc3QgY29sbGVjdGlvblBhdGggPSAvXFwvXFwqXFwqPyg/OiR8XFwvKS87XG5mdW5jdGlvbiBnZXRDb25maWd1cmVkQ29sbGVjdGlvblBhdGgoY29uZmlnLCBjb2xsZWN0aW9uKSB7XG4gIHZhciBfY29sbGVjdGlvbkNvbmZpZyRwYXQ7XG4gIGNvbnN0IGNvbGxlY3Rpb25Db25maWcgPSBjb25maWcuY29sbGVjdGlvbnNbY29sbGVjdGlvbl07XG4gIGNvbnN0IHBhdGggPSAoX2NvbGxlY3Rpb25Db25maWckcGF0ID0gY29sbGVjdGlvbkNvbmZpZy5wYXRoKSAhPT0gbnVsbCAmJiBfY29sbGVjdGlvbkNvbmZpZyRwYXQgIT09IHZvaWQgMCA/IF9jb2xsZWN0aW9uQ29uZmlnJHBhdCA6IGAke2NvbGxlY3Rpb259LyovYDtcbiAgaWYgKCFjb2xsZWN0aW9uUGF0aC50ZXN0KHBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb2xsZWN0aW9uIHBhdGggbXVzdCBlbmQgd2l0aCAvKiBvciAvKiogb3IgaW5jbHVkZSAvKi8gb3IgLyoqLyBidXQgJHtjb2xsZWN0aW9ufSBoYXMgJHtwYXRofWApO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gZ2V0Q29sbGVjdGlvblBhdGgoY29uZmlnLCBjb2xsZWN0aW9uKSB7XG4gIGNvbnN0IGNvbmZpZ3VyZWRQYXRoID0gZ2V0Q29uZmlndXJlZENvbGxlY3Rpb25QYXRoKGNvbmZpZywgY29sbGVjdGlvbik7XG4gIGNvbnN0IHBhdGggPSBmaXhQYXRoKGNvbmZpZ3VyZWRQYXRoLnJlcGxhY2UoL1xcKlxcKj8uKiQvLCAnJykpO1xuICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGdldENvbGxlY3Rpb25Gb3JtYXQoY29uZmlnLCBjb2xsZWN0aW9uKSB7XG4gIHZhciBfY29sbGVjdGlvbkNvbmZpZyRmb3I7XG4gIGNvbnN0IGNvbGxlY3Rpb25Db25maWcgPSBjb25maWcuY29sbGVjdGlvbnNbY29sbGVjdGlvbl07XG4gIHJldHVybiBnZXRGb3JtYXRJbmZvKChfY29sbGVjdGlvbkNvbmZpZyRmb3IgPSBjb2xsZWN0aW9uQ29uZmlnLmZvcm1hdCkgIT09IG51bGwgJiYgX2NvbGxlY3Rpb25Db25maWckZm9yICE9PSB2b2lkIDAgPyBfY29sbGVjdGlvbkNvbmZpZyRmb3IgOiAneWFtbCcsIGNvbGxlY3Rpb25Db25maWcuc2NoZW1hLCBnZXRDb25maWd1cmVkQ29sbGVjdGlvblBhdGgoY29uZmlnLCBjb2xsZWN0aW9uKSk7XG59XG5mdW5jdGlvbiBnZXRTaW5nbGV0b25Gb3JtYXQoY29uZmlnLCBzaW5nbGV0b24pIHtcbiAgdmFyIF9zaW5nbGV0b25Db25maWckZm9ybSwgX3NpbmdsZXRvbkNvbmZpZyRwYXRoO1xuICBjb25zdCBzaW5nbGV0b25Db25maWcgPSBjb25maWcuc2luZ2xldG9uc1tzaW5nbGV0b25dO1xuICByZXR1cm4gZ2V0Rm9ybWF0SW5mbygoX3NpbmdsZXRvbkNvbmZpZyRmb3JtID0gc2luZ2xldG9uQ29uZmlnLmZvcm1hdCkgIT09IG51bGwgJiYgX3NpbmdsZXRvbkNvbmZpZyRmb3JtICE9PSB2b2lkIDAgPyBfc2luZ2xldG9uQ29uZmlnJGZvcm0gOiAneWFtbCcsIHNpbmdsZXRvbkNvbmZpZy5zY2hlbWEsIChfc2luZ2xldG9uQ29uZmlnJHBhdGggPSBzaW5nbGV0b25Db25maWcucGF0aCkgIT09IG51bGwgJiYgX3NpbmdsZXRvbkNvbmZpZyRwYXRoICE9PSB2b2lkIDAgPyBfc2luZ2xldG9uQ29uZmlnJHBhdGggOiBgJHtzaW5nbGV0b259L2ApO1xufVxuZnVuY3Rpb24gZ2V0Q29sbGVjdGlvbkl0ZW1QYXRoKGNvbmZpZywgY29sbGVjdGlvbiwgc2x1Zykge1xuICBjb25zdCBiYXNlUGF0aCA9IGdldENvbGxlY3Rpb25QYXRoKGNvbmZpZywgY29sbGVjdGlvbik7XG4gIGNvbnN0IHN1ZmZpeCA9IGdldENvbGxlY3Rpb25JdGVtU2x1Z1N1ZmZpeChjb25maWcsIGNvbGxlY3Rpb24pO1xuICByZXR1cm4gYCR7YmFzZVBhdGh9LyR7c2x1Z30ke3N1ZmZpeH1gO1xufVxuZnVuY3Rpb24gZ2V0RW50cnlEYXRhRmlsZXBhdGgoZGlyLCBmb3JtYXRJbmZvKSB7XG4gIHJldHVybiBgJHtkaXJ9JHtmb3JtYXRJbmZvLmRhdGFMb2NhdGlvbiA9PT0gJ2luZGV4JyA/ICcvaW5kZXgnIDogJyd9JHtnZXREYXRhRmlsZUV4dGVuc2lvbihmb3JtYXRJbmZvKX1gO1xufVxuZnVuY3Rpb24gZ2V0U2x1Z0dsb2JGb3JDb2xsZWN0aW9uKGNvbmZpZywgY29sbGVjdGlvbikge1xuICBjb25zdCBjb2xsZWN0aW9uUGF0aCA9IGdldENvbmZpZ3VyZWRDb2xsZWN0aW9uUGF0aChjb25maWcsIGNvbGxlY3Rpb24pO1xuICByZXR1cm4gY29sbGVjdGlvblBhdGguaW5jbHVkZXMoJyoqJykgPyAnKionIDogJyonO1xufVxuZnVuY3Rpb24gZ2V0Q29sbGVjdGlvbkl0ZW1TbHVnU3VmZml4KGNvbmZpZywgY29sbGVjdGlvbikge1xuICBjb25zdCBjb25maWd1cmVkUGF0aCA9IGdldENvbmZpZ3VyZWRDb2xsZWN0aW9uUGF0aChjb25maWcsIGNvbGxlY3Rpb24pO1xuICBjb25zdCBwYXRoID0gZml4UGF0aChjb25maWd1cmVkUGF0aC5yZXBsYWNlKC9eW14qXStcXCpcXCo/LywgJycpKTtcbiAgcmV0dXJuIHBhdGggPyBgLyR7cGF0aH1gIDogJyc7XG59XG5mdW5jdGlvbiBnZXRTaW5nbGV0b25QYXRoKGNvbmZpZywgc2luZ2xldG9uKSB7XG4gIHZhciBfc2luZ2xldG9uJHBhdGgsIF9zaW5nbGV0b24kcGF0aDI7XG4gIGlmICgoX3NpbmdsZXRvbiRwYXRoID0gY29uZmlnLnNpbmdsZXRvbnNbc2luZ2xldG9uXS5wYXRoKSAhPT0gbnVsbCAmJiBfc2luZ2xldG9uJHBhdGggIT09IHZvaWQgMCAmJiBfc2luZ2xldG9uJHBhdGguaW5jbHVkZXMoJyonKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU2luZ2xldG9uIHBhdGhzIGNhbm5vdCBpbmNsdWRlICogYnV0ICR7c2luZ2xldG9ufSBoYXMgJHtjb25maWcuc2luZ2xldG9uc1tzaW5nbGV0b25dLnBhdGh9YCk7XG4gIH1cbiAgcmV0dXJuIGZpeFBhdGgoKF9zaW5nbGV0b24kcGF0aDIgPSBjb25maWcuc2luZ2xldG9uc1tzaW5nbGV0b25dLnBhdGgpICE9PSBudWxsICYmIF9zaW5nbGV0b24kcGF0aDIgIT09IHZvaWQgMCA/IF9zaW5nbGV0b24kcGF0aDIgOiBzaW5nbGV0b24pO1xufVxuZnVuY3Rpb24gZ2V0RGF0YUZpbGVFeHRlbnNpb24oZm9ybWF0SW5mbykge1xuICByZXR1cm4gZm9ybWF0SW5mby5jb250ZW50RmllbGQgPyBmb3JtYXRJbmZvLmNvbnRlbnRGaWVsZC5jb25maWcuY29udGVudEV4dGVuc2lvbiA6ICcuJyArIGZvcm1hdEluZm8uZGF0YTtcbn1cbmZ1bmN0aW9uIGdldEZvcm1hdEluZm8oZm9ybWF0LCBzY2hlbWEsIHBhdGgpIHtcbiAgdmFyIF9mb3JtYXQkZGF0YTtcbiAgY29uc3QgZGF0YUxvY2F0aW9uID0gcGF0aC5lbmRzV2l0aCgnLycpID8gJ2luZGV4JyA6ICdvdXRlcic7XG4gIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhTG9jYXRpb24sXG4gICAgICBjb250ZW50RmllbGQ6IHVuZGVmaW5lZCxcbiAgICAgIGRhdGE6IGZvcm1hdFxuICAgIH07XG4gIH1cbiAgbGV0IGNvbnRlbnRGaWVsZDtcbiAgaWYgKGZvcm1hdC5jb250ZW50RmllbGQpIHtcbiAgICBjb25zdCBmaWVsZCA9IHNjaGVtYVtmb3JtYXQuY29udGVudEZpZWxkXTtcbiAgICBhc3NlcnQoKGZpZWxkID09PSBudWxsIHx8IGZpZWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZC5raW5kKSA9PT0gJ2Zvcm0nLCBgJHtmb3JtYXQuY29udGVudEZpZWxkfSBpcyBub3QgYSBmb3JtIGZpZWxkYCk7XG4gICAgYXNzZXJ0KGZpZWxkLmZvcm1LaW5kID09PSAnY29udGVudCcsIGAke2Zvcm1hdC5jb250ZW50RmllbGR9IGlzIG5vdCBhIGNvbnRlbnQgZmllbGRgKTtcbiAgICBjb250ZW50RmllbGQgPSB7XG4gICAgICBrZXk6IGZvcm1hdC5jb250ZW50RmllbGQsXG4gICAgICBjb25maWc6IGZpZWxkXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRhdGE6IChfZm9ybWF0JGRhdGEgPSBmb3JtYXQuZGF0YSkgIT09IG51bGwgJiYgX2Zvcm1hdCRkYXRhICE9PSB2b2lkIDAgPyBfZm9ybWF0JGRhdGEgOiAneWFtbCcsXG4gICAgY29udGVudEZpZWxkLFxuICAgIGRhdGFMb2NhdGlvblxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UGF0aFByZWZpeChzdG9yYWdlKSB7XG4gIGlmIChzdG9yYWdlLmtpbmQgPT09ICdsb2NhbCcgfHwgIXN0b3JhZ2UucGF0aFByZWZpeCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGZpeFBhdGgoc3RvcmFnZS5wYXRoUHJlZml4KSArICcvJztcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2hhMShjb250ZW50KSB7XG4gIHJldHVybiBjcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKGNvbnRlbnQpLmRpZ2VzdCgnaGV4Jyk7XG59XG5cbmNvbnN0IHRleHRFbmNvZGVyJDIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIGJsb2JTaGEoY29udGVudHMpIHtcbiAgY29uc3QgYmxvYlByZWZpeCA9IHRleHRFbmNvZGVyJDIuZW5jb2RlKCdibG9iICcgKyBjb250ZW50cy5sZW5ndGggKyAnXFwwJyk7XG4gIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYmxvYlByZWZpeC5ieXRlTGVuZ3RoICsgY29udGVudHMuYnl0ZUxlbmd0aCk7XG4gIGFycmF5LnNldChibG9iUHJlZml4LCAwKTtcbiAgYXJyYXkuc2V0KGNvbnRlbnRzLCBibG9iUHJlZml4LmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gc2hhMShhcnJheSk7XG59XG5mdW5jdGlvbiBnZXRUcmVlTm9kZUF0UGF0aChyb290LCBwYXRoKSB7XG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICBsZXQgbm9kZSA9IHJvb3QuZ2V0KHBhcnRzWzBdKTtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzLnNsaWNlKDEpKSB7XG4gICAgaWYgKCFub2RlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICghbm9kZS5jaGlsZHJlbikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBub2RlID0gbm9kZS5jaGlsZHJlbi5nZXQocGFydCk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBnZXROb2RlQXRQYXRoKHRyZWUsIHBhdGgpIHtcbiAgbGV0IG5vZGUgPSB0cmVlO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGF0aC5zcGxpdCgnLycpKSB7XG4gICAgaWYgKCFub2RlLmhhcyhwYXJ0KSkge1xuICAgICAgbm9kZS5zZXQocGFydCwgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgY29uc3QgaW5uZXJOb2RlID0gbm9kZS5nZXQocGFydCk7XG4gICAgYXNzZXJ0KGlubmVyTm9kZSBpbnN0YW5jZW9mIE1hcCwgJ2V4cGVjdGVkIHRyZWUnKTtcbiAgICBub2RlID0gaW5uZXJOb2RlO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZ2V0RmlsZW5hbWUocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKC8uKlxcLy8sICcnKTtcbn1cbmZ1bmN0aW9uIGdldERpcm5hbWUocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC9bXi9dKyQvLCAnJyk7XG59XG5mdW5jdGlvbiB0b1RyZWVDaGFuZ2VzKGNoYW5nZXMpIHtcbiAgY29uc3QgY2hhbmdlc1Jvb3QgPSBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgZGVsZXRpb24gb2YgY2hhbmdlcy5kZWxldGlvbnMpIHtcbiAgICBjb25zdCBwYXJlbnRUcmVlID0gZ2V0Tm9kZUF0UGF0aChjaGFuZ2VzUm9vdCwgZ2V0RGlybmFtZShkZWxldGlvbikpO1xuICAgIHBhcmVudFRyZWUuc2V0KGdldEZpbGVuYW1lKGRlbGV0aW9uKSwgJ2RlbGV0ZScpO1xuICB9XG4gIGZvciAoY29uc3QgYWRkaXRpb24gb2YgY2hhbmdlcy5hZGRpdGlvbnMpIHtcbiAgICBjb25zdCBwYXJlbnRUcmVlID0gZ2V0Tm9kZUF0UGF0aChjaGFuZ2VzUm9vdCwgZ2V0RGlybmFtZShhZGRpdGlvbi5wYXRoKSk7XG4gICAgcGFyZW50VHJlZS5zZXQoZ2V0RmlsZW5hbWUoYWRkaXRpb24ucGF0aCksIGFkZGl0aW9uLmNvbnRlbnRzKTtcbiAgfVxuICByZXR1cm4gY2hhbmdlc1Jvb3Q7XG59XG5jb25zdCBTUEFDRV9DSEFSX0NPREUgPSAzMjtcbmNvbnN0IHNwYWNlID0gbmV3IFVpbnQ4QXJyYXkoW1NQQUNFX0NIQVJfQ09ERV0pO1xuY29uc3QgbnVsbGNoYXIgPSBuZXcgVWludDhBcnJheShbMF0pO1xuY29uc3QgdHJlZSA9IHRleHRFbmNvZGVyJDIuZW5jb2RlKCd0cmVlICcpO1xuXG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vaXNvbW9ycGhpYy1naXQvaXNvbW9ycGhpYy1naXQvYmxvYi9jMDlkZmEyMGZmZTBhYjllNjYwMmUwZmExNzJkNzJiYTg5OTRlNDQzL3NyYy9tb2RlbHMvR2l0VHJlZS5qcyNMMTA4LUwxMjJcbmZ1bmN0aW9uIHRyZWVTaGEoY2hpbGRyZW4pIHtcbiAgY29uc3QgZW50cmllcyA9IFsuLi5jaGlsZHJlbl0ubWFwKChbbmFtZSwgbm9kZV0pID0+ICh7XG4gICAgbmFtZSxcbiAgICBzaGE6IG5vZGUuZW50cnkuc2hhLFxuICAgIG1vZGU6IG5vZGUuZW50cnkubW9kZVxuICB9KSk7XG4gIGVudHJpZXMuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGFOYW1lID0gYS5tb2RlID09PSAnMDQwMDAwJyA/IGEubmFtZSArICcvJyA6IGEubmFtZTtcbiAgICBjb25zdCBiTmFtZSA9IGIubW9kZSA9PT0gJzA0MDAwMCcgPyBiLm5hbWUgKyAnLycgOiBiLm5hbWU7XG4gICAgcmV0dXJuIGFOYW1lID09PSBiTmFtZSA/IDAgOiBhTmFtZSA8IGJOYW1lID8gLTEgOiAxO1xuICB9KTtcbiAgY29uc3QgdHJlZU9iamVjdCA9IGVudHJpZXMuZmxhdE1hcChlbnRyeSA9PiB7XG4gICAgY29uc3QgbW9kZSA9IHRleHRFbmNvZGVyJDIuZW5jb2RlKGVudHJ5Lm1vZGUucmVwbGFjZSgvXjAvLCAnJykpO1xuICAgIGNvbnN0IG5hbWUgPSB0ZXh0RW5jb2RlciQyLmVuY29kZShlbnRyeS5uYW1lKTtcbiAgICBjb25zdCBzaGEgPSBoZXhUb0J5dGVzKGVudHJ5LnNoYSk7XG4gICAgcmV0dXJuIFttb2RlLCBzcGFjZSwgbmFtZSwgbnVsbGNoYXIsIHNoYV07XG4gIH0pO1xuICByZXR1cm4gc2hhMShjb25jYXRCeXRlcyhbdHJlZSwgdGV4dEVuY29kZXIkMi5lbmNvZGUodHJlZU9iamVjdC5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwuYnl0ZUxlbmd0aCwgMCkudG9TdHJpbmcoKSksIG51bGxjaGFyLCAuLi50cmVlT2JqZWN0XSkpO1xufVxuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoYnl0ZUFycmF5cykge1xuICBjb25zdCB0b3RhbExlbmd0aCA9IGJ5dGVBcnJheXMucmVkdWNlKChzdW0sIGFycikgPT4gc3VtICsgYXJyLmJ5dGVMZW5ndGgsIDApO1xuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IGFyciBvZiBieXRlQXJyYXlzKSB7XG4gICAgcmVzdWx0LnNldChhcnIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGFyci5ieXRlTGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBoZXhUb0J5dGVzKHN0cikge1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGggLyAyKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5ieXRlTGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBzdGFydCA9IGkgKiAyO1xuICAgIGJ5dGVzW2ldID0gcGFyc2VJbnQoc3RyLnNsaWNlKHN0YXJ0LCBzdGFydCArIDIpLCAxNik7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlVHJlZU5vZGVFbnRyeShwYXRoLCBjaGlsZHJlbikge1xuICBjb25zdCBzaGEgPSBhd2FpdCB0cmVlU2hhKGNoaWxkcmVuKTtcbiAgcmV0dXJuIHtcbiAgICBwYXRoLFxuICAgIG1vZGU6ICcwNDAwMDAnLFxuICAgIHR5cGU6ICd0cmVlJyxcbiAgICBzaGFcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUJsb2JOb2RlRW50cnkocGF0aCwgY29udGVudHMpIHtcbiAgY29uc3Qgc2hhID0gJ3NoYScgaW4gY29udGVudHMgPyBjb250ZW50cy5zaGEgOiBhd2FpdCBibG9iU2hhKGNvbnRlbnRzKTtcbiAgcmV0dXJuIHtcbiAgICBwYXRoLFxuICAgIG1vZGU6ICcxMDA2NDQnLFxuICAgIHR5cGU6ICdibG9iJyxcbiAgICBzaGFcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVRyZWVXaXRoQ2hhbmdlcyh0cmVlLCBjaGFuZ2VzKSB7XG4gIHZhciBfYXdhaXQkdXBkYXRlVHJlZTtcbiAgY29uc3QgbmV3VHJlZSA9IChfYXdhaXQkdXBkYXRlVHJlZSA9IGF3YWl0IHVwZGF0ZVRyZWUodHJlZSwgdG9UcmVlQ2hhbmdlcyhjaGFuZ2VzKSwgW10pKSAhPT0gbnVsbCAmJiBfYXdhaXQkdXBkYXRlVHJlZSAhPT0gdm9pZCAwID8gX2F3YWl0JHVwZGF0ZVRyZWUgOiBuZXcgTWFwKCk7XG4gIHJldHVybiB7XG4gICAgZW50cmllczogdHJlZVRvRW50cmllcyhuZXdUcmVlKSxcbiAgICBzaGE6IGF3YWl0IHRyZWVTaGEobmV3VHJlZSAhPT0gbnVsbCAmJiBuZXdUcmVlICE9PSB2b2lkIDAgPyBuZXdUcmVlIDogbmV3IE1hcCgpKVxuICB9O1xufVxuZnVuY3Rpb24gdHJlZVRvRW50cmllcyh0cmVlKSB7XG4gIHJldHVybiBbLi4udHJlZS52YWx1ZXMoKV0uZmxhdE1hcCh4ID0+IHguY2hpbGRyZW4gPyBbeC5lbnRyeSwgLi4udHJlZVRvRW50cmllcyh4LmNoaWxkcmVuKV0gOiBbeC5lbnRyeV0pO1xufVxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlVHJlZSh0cmVlLCBjaGFuZ2VkVHJlZSwgcGF0aCkge1xuICBjb25zdCBuZXdUcmVlID0gbmV3IE1hcCh0cmVlKTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgY2hhbmdlZFRyZWUpIHtcbiAgICBpZiAodmFsdWUgPT09ICdkZWxldGUnKSB7XG4gICAgICBuZXdUcmVlLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgIHZhciBfbmV3VHJlZSRnZXQkY2hpbGRyZW4sIF9uZXdUcmVlJGdldDtcbiAgICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRyZW4gPSAoX25ld1RyZWUkZ2V0JGNoaWxkcmVuID0gKF9uZXdUcmVlJGdldCA9IG5ld1RyZWUuZ2V0KGtleSkpID09PSBudWxsIHx8IF9uZXdUcmVlJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25ld1RyZWUkZ2V0LmNoaWxkcmVuKSAhPT0gbnVsbCAmJiBfbmV3VHJlZSRnZXQkY2hpbGRyZW4gIT09IHZvaWQgMCA/IF9uZXdUcmVlJGdldCRjaGlsZHJlbiA6IG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gYXdhaXQgdXBkYXRlVHJlZShleGlzdGluZ0NoaWxkcmVuLCB2YWx1ZSwgcGF0aC5jb25jYXQoa2V5KSk7XG4gICAgICBpZiAoY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdUcmVlLmRlbGV0ZShrZXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVudHJ5ID0gYXdhaXQgY3JlYXRlVHJlZU5vZGVFbnRyeShwYXRoLmNvbmNhdChrZXkpLmpvaW4oJy8nKSwgY2hpbGRyZW4pO1xuICAgICAgbmV3VHJlZS5zZXQoa2V5LCB7XG4gICAgICAgIGVudHJ5LFxuICAgICAgICBjaGlsZHJlblxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAnc2hhJyBpbiB2YWx1ZSkge1xuICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCBjcmVhdGVCbG9iTm9kZUVudHJ5KHBhdGguY29uY2F0KGtleSkuam9pbignLycpLCB2YWx1ZSk7XG4gICAgICBuZXdUcmVlLnNldChrZXksIHtcbiAgICAgICAgZW50cnlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAobmV3VHJlZS5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gbmV3VHJlZTtcbn1cbmZ1bmN0aW9uIHRyZWVFbnRyaWVzVG9UcmVlTm9kZXMoZW50cmllcykge1xuICBjb25zdCByb290ID0gbmV3IE1hcCgpO1xuICBjb25zdCBnZXRDaGlsZHJlbkF0UGF0aCA9IHBhcnRzID0+IHtcbiAgICB2YXIgX25vZGU7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIGxldCBub2RlID0gcm9vdC5nZXQocGFydHNbMF0pO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cy5zbGljZSgxKSkge1xuICAgICAgaWYgKCFub2RlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW4uZ2V0KHBhcnQpO1xuICAgIH1cbiAgICByZXR1cm4gKF9ub2RlID0gbm9kZSkgPT09IG51bGwgfHwgX25vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlLmNoaWxkcmVuO1xuICB9O1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICBjb25zdCBzcGxpdCA9IGVudHJ5LnBhdGguc3BsaXQoJy8nKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuQXRQYXRoKHNwbGl0LnNsaWNlKDAsIC0xKSk7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBjaGlsZHJlbi5zZXQoc3BsaXRbc3BsaXQubGVuZ3RoIC0gMV0sIHtcbiAgICAgICAgZW50cnksXG4gICAgICAgIGNoaWxkcmVuOiBlbnRyeS50eXBlID09PSAndHJlZScgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcm9vdDtcbn1cblxuZnVuY3Rpb24gY29sbGVjdERpcmVjdG9yaWVzVXNlZEluU2NoZW1hSW5uZXIoc2NoZW1hLCBkaXJlY3Rvcmllcywgc2VlblNjaGVtYXMpIHtcbiAgaWYgKHNlZW5TY2hlbWFzLmhhcyhzY2hlbWEpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNlZW5TY2hlbWFzLmFkZChzY2hlbWEpO1xuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdhcnJheScpIHtcbiAgICByZXR1cm4gY29sbGVjdERpcmVjdG9yaWVzVXNlZEluU2NoZW1hSW5uZXIoc2NoZW1hLmVsZW1lbnQsIGRpcmVjdG9yaWVzLCBzZWVuU2NoZW1hcyk7XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnY2hpbGQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ2Zvcm0nKSB7XG4gICAgaWYgKHNjaGVtYS5mb3JtS2luZCA9PT0gJ2Fzc2V0JyAmJiBzY2hlbWEuZGlyZWN0b3J5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRpcmVjdG9yaWVzLmFkZChmaXhQYXRoKHNjaGVtYS5kaXJlY3RvcnkpKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS5mb3JtS2luZCA9PT0gJ2NvbnRlbnQnICYmIHNjaGVtYS5kaXJlY3RvcmllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGNvbnN0IGRpcmVjdG9yeSBvZiBzY2hlbWEuZGlyZWN0b3JpZXMpIHtcbiAgICAgICAgZGlyZWN0b3JpZXMuYWRkKGZpeFBhdGgoZGlyZWN0b3J5KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBPYmplY3QudmFsdWVzKHNjaGVtYS5maWVsZHMpKSB7XG4gICAgICBjb2xsZWN0RGlyZWN0b3JpZXNVc2VkSW5TY2hlbWFJbm5lcihmaWVsZCwgZGlyZWN0b3JpZXMsIHNlZW5TY2hlbWFzKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ2NvbmRpdGlvbmFsJykge1xuICAgIGZvciAoY29uc3QgaW5uZXJTY2hlbWEgb2YgT2JqZWN0LnZhbHVlcyhzY2hlbWEudmFsdWVzKSkge1xuICAgICAgY29sbGVjdERpcmVjdG9yaWVzVXNlZEluU2NoZW1hSW5uZXIoaW5uZXJTY2hlbWEsIGRpcmVjdG9yaWVzLCBzZWVuU2NoZW1hcyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBhc3NlcnROZXZlcihzY2hlbWEpO1xufVxuZnVuY3Rpb24gY29sbGVjdERpcmVjdG9yaWVzVXNlZEluU2NoZW1hKHNjaGVtYSkge1xuICBjb25zdCBkaXJlY3RvcmllcyA9IG5ldyBTZXQoKTtcbiAgY29sbGVjdERpcmVjdG9yaWVzVXNlZEluU2NoZW1hSW5uZXIoc2NoZW1hLCBkaXJlY3RvcmllcywgbmV3IFNldCgpKTtcbiAgcmV0dXJuIGRpcmVjdG9yaWVzO1xufVxuZnVuY3Rpb24gZ2V0RGlyZWN0b3JpZXNGb3JUcmVlS2V5KHNjaGVtYSwgZGlyZWN0b3J5LCBzbHVnLCBmb3JtYXQpIHtcbiAgY29uc3QgZGlyZWN0b3JpZXMgPSBbZml4UGF0aChkaXJlY3RvcnkpXTtcbiAgaWYgKGZvcm1hdC5kYXRhTG9jYXRpb24gPT09ICdvdXRlcicpIHtcbiAgICBkaXJlY3Rvcmllcy5wdXNoKGZpeFBhdGgoZGlyZWN0b3J5KSArIGdldERhdGFGaWxlRXh0ZW5zaW9uKGZvcm1hdCkpO1xuICB9XG4gIGNvbnN0IHRvQWRkID0gc2x1ZyA9PT0gdW5kZWZpbmVkID8gJycgOiBgLyR7c2x1Z31gO1xuICBmb3IgKGNvbnN0IGRpcmVjdG9yeSBvZiBjb2xsZWN0RGlyZWN0b3JpZXNVc2VkSW5TY2hlbWEoc2NoZW1hKSkge1xuICAgIGRpcmVjdG9yaWVzLnB1c2goZGlyZWN0b3J5ICsgdG9BZGQpO1xuICB9XG4gIHJldHVybiBkaXJlY3Rvcmllcztcbn1cbmZ1bmN0aW9uIGdldFRyZWVLZXkoZGlyZWN0b3JpZXMsIHRyZWUpIHtcbiAgcmV0dXJuIGRpcmVjdG9yaWVzLm1hcChkID0+IHtcbiAgICB2YXIgX2dldFRyZWVOb2RlQXRQYXRoO1xuICAgIHJldHVybiAoX2dldFRyZWVOb2RlQXRQYXRoID0gZ2V0VHJlZU5vZGVBdFBhdGgodHJlZSwgZCkpID09PSBudWxsIHx8IF9nZXRUcmVlTm9kZUF0UGF0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldFRyZWVOb2RlQXRQYXRoLmVudHJ5LnNoYTtcbiAgfSkuam9pbignLScpO1xufVxuXG52YXIgcGtnSnNvbiA9IHtcblx0bmFtZTogXCJAa2V5c3RhdGljL2NvcmVcIixcblx0dmVyc2lvbjogXCIwLjMuMTJcIixcblx0bGljZW5zZTogXCJNSVRcIixcblx0cmVwb3NpdG9yeToge1xuXHRcdHR5cGU6IFwiZ2l0XCIsXG5cdFx0dXJsOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9UaGlua21pbGwva2V5c3RhdGljL1wiLFxuXHRcdGRpcmVjdG9yeTogXCJwYWNrYWdlcy9rZXlzdGF0aWNcIlxuXHR9LFxuXHR0eXBlOiBcIm1vZHVsZVwiLFxuXHRleHBvcnRzOiB7XG5cdFx0XCIuL3VpXCI6IHtcblx0XHRcdHR5cGVzOiBcIi4vZGlzdC9rZXlzdGF0aWMtY29yZS11aS5qc1wiLFxuXHRcdFx0bm9kZToge1xuXHRcdFx0XHRcInJlYWN0LXNlcnZlclwiOiBcIi4vZGlzdC9rZXlzdGF0aWMtY29yZS11aS5ub2RlLnJlYWN0LXNlcnZlci5qc1wiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtdWkubm9kZS5qc1wiXG5cdFx0XHR9LFxuXHRcdFx0XCJyZWFjdC1zZXJ2ZXJcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtdWkucmVhY3Qtc2VydmVyLmpzXCIsXG5cdFx0XHRcImRlZmF1bHRcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtdWkuanNcIlxuXHRcdH0sXG5cdFx0XCIuXCI6IHtcblx0XHRcdHR5cGVzOiBcIi4vZGlzdC9rZXlzdGF0aWMtY29yZS5qc1wiLFxuXHRcdFx0bm9kZToge1xuXHRcdFx0XHRcInJlYWN0LXNlcnZlclwiOiBcIi4vZGlzdC9rZXlzdGF0aWMtY29yZS5ub2RlLnJlYWN0LXNlcnZlci5qc1wiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUubm9kZS5qc1wiXG5cdFx0XHR9LFxuXHRcdFx0XCJyZWFjdC1zZXJ2ZXJcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUucmVhY3Qtc2VydmVyLmpzXCIsXG5cdFx0XHRcImRlZmF1bHRcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUuanNcIlxuXHRcdH0sXG5cdFx0XCIuL2FwaS91dGlsc1wiOiB7XG5cdFx0XHR0eXBlczogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtYXBpLXV0aWxzLmpzXCIsXG5cdFx0XHRub2RlOiB7XG5cdFx0XHRcdFwicmVhY3Qtc2VydmVyXCI6IFwiLi9kaXN0L2tleXN0YXRpYy1jb3JlLWFwaS11dGlscy5ub2RlLnJlYWN0LXNlcnZlci5qc1wiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtYXBpLXV0aWxzLm5vZGUuanNcIlxuXHRcdFx0fSxcblx0XHRcdFwicmVhY3Qtc2VydmVyXCI6IFwiLi9kaXN0L2tleXN0YXRpYy1jb3JlLWFwaS11dGlscy5yZWFjdC1zZXJ2ZXIuanNcIixcblx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vZGlzdC9rZXlzdGF0aWMtY29yZS1hcGktdXRpbHMuanNcIlxuXHRcdH0sXG5cdFx0XCIuL3JlbmRlcmVyXCI6IHtcblx0XHRcdHR5cGVzOiBcIi4vZGlzdC9rZXlzdGF0aWMtY29yZS1yZW5kZXJlci5qc1wiLFxuXHRcdFx0bm9kZToge1xuXHRcdFx0XHRcInJlYWN0LXNlcnZlclwiOiBcIi4vZGlzdC9rZXlzdGF0aWMtY29yZS1yZW5kZXJlci5ub2RlLnJlYWN0LXNlcnZlci5qc1wiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVuZGVyZXIubm9kZS5qc1wiXG5cdFx0XHR9LFxuXHRcdFx0XCJyZWFjdC1zZXJ2ZXJcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVuZGVyZXIucmVhY3Qtc2VydmVyLmpzXCIsXG5cdFx0XHRcImRlZmF1bHRcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVuZGVyZXIuanNcIlxuXHRcdH0sXG5cdFx0XCIuL2FwaS9nZW5lcmljXCI6IHtcblx0XHRcdHR5cGVzOiBcIi4vZGlzdC9rZXlzdGF0aWMtY29yZS1hcGktZ2VuZXJpYy5qc1wiLFxuXHRcdFx0bm9kZToge1xuXHRcdFx0XHRcInJlYWN0LXNlcnZlclwiOiBcIi4vZGlzdC9rZXlzdGF0aWMtY29yZS1hcGktZ2VuZXJpYy5ub2RlLnJlYWN0LXNlcnZlci5qc1wiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtYXBpLWdlbmVyaWMubm9kZS5qc1wiXG5cdFx0XHR9LFxuXHRcdFx0XCJyZWFjdC1zZXJ2ZXJcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtYXBpLWdlbmVyaWMucmVhY3Qtc2VydmVyLmpzXCIsXG5cdFx0XHRcImRlZmF1bHRcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtYXBpLWdlbmVyaWMuanNcIlxuXHRcdH0sXG5cdFx0XCIuL3JlYWRlclwiOiB7XG5cdFx0XHR0eXBlczogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVhZGVyLmpzXCIsXG5cdFx0XHRub2RlOiB7XG5cdFx0XHRcdFwicmVhY3Qtc2VydmVyXCI6IFwiLi9kaXN0L2tleXN0YXRpYy1jb3JlLXJlYWRlci5ub2RlLnJlYWN0LXNlcnZlci5qc1wiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVhZGVyLm5vZGUuanNcIlxuXHRcdFx0fSxcblx0XHRcdFwicmVhY3Qtc2VydmVyXCI6IFwiLi9kaXN0L2tleXN0YXRpYy1jb3JlLXJlYWRlci5yZWFjdC1zZXJ2ZXIuanNcIixcblx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vZGlzdC9rZXlzdGF0aWMtY29yZS1yZWFkZXIuanNcIlxuXHRcdH0sXG5cdFx0XCIuL3JlYWRlci9naXRodWJcIjoge1xuXHRcdFx0dHlwZXM6IFwiLi9kaXN0L2tleXN0YXRpYy1jb3JlLXJlYWRlci1naXRodWIuanNcIixcblx0XHRcdG5vZGU6IHtcblx0XHRcdFx0XCJyZWFjdC1zZXJ2ZXJcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVhZGVyLWdpdGh1Yi5ub2RlLnJlYWN0LXNlcnZlci5qc1wiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVhZGVyLWdpdGh1Yi5ub2RlLmpzXCJcblx0XHRcdH0sXG5cdFx0XHRcInJlYWN0LXNlcnZlclwiOiBcIi4vZGlzdC9rZXlzdGF0aWMtY29yZS1yZWFkZXItZ2l0aHViLnJlYWN0LXNlcnZlci5qc1wiLFxuXHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9kaXN0L2tleXN0YXRpYy1jb3JlLXJlYWRlci1naXRodWIuanNcIlxuXHRcdH0sXG5cdFx0XCIuL2NvbnRlbnQtY29tcG9uZW50c1wiOiB7XG5cdFx0XHR0eXBlczogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtY29udGVudC1jb21wb25lbnRzLmpzXCIsXG5cdFx0XHRub2RlOiB7XG5cdFx0XHRcdFwicmVhY3Qtc2VydmVyXCI6IFwiLi9kaXN0L2tleXN0YXRpYy1jb3JlLWNvbnRlbnQtY29tcG9uZW50cy5ub2RlLnJlYWN0LXNlcnZlci5qc1wiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtY29udGVudC1jb21wb25lbnRzLm5vZGUuanNcIlxuXHRcdFx0fSxcblx0XHRcdFwicmVhY3Qtc2VydmVyXCI6IFwiLi9kaXN0L2tleXN0YXRpYy1jb3JlLWNvbnRlbnQtY29tcG9uZW50cy5yZWFjdC1zZXJ2ZXIuanNcIixcblx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vZGlzdC9rZXlzdGF0aWMtY29yZS1jb250ZW50LWNvbXBvbmVudHMuanNcIlxuXHRcdH0sXG5cdFx0XCIuL2NvbXBvbmVudC1ibG9ja3NcIjoge1xuXHRcdFx0dHlwZXM6IFwiLi9kaXN0L2tleXN0YXRpYy1jb3JlLWNvbXBvbmVudC1ibG9ja3MuanNcIixcblx0XHRcdG5vZGU6IHtcblx0XHRcdFx0XCJyZWFjdC1zZXJ2ZXJcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtY29tcG9uZW50LWJsb2Nrcy5ub2RlLnJlYWN0LXNlcnZlci5qc1wiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtY29tcG9uZW50LWJsb2Nrcy5ub2RlLmpzXCJcblx0XHRcdH0sXG5cdFx0XHRcInJlYWN0LXNlcnZlclwiOiBcIi4vZGlzdC9rZXlzdGF0aWMtY29yZS1jb21wb25lbnQtYmxvY2tzLnJlYWN0LXNlcnZlci5qc1wiLFxuXHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9kaXN0L2tleXN0YXRpYy1jb3JlLWNvbXBvbmVudC1ibG9ja3MuanNcIlxuXHRcdH0sXG5cdFx0XCIuL2Zvcm0vZmllbGRzL21hcmtkb2NcIjoge1xuXHRcdFx0dHlwZXM6IFwiLi9kaXN0L2tleXN0YXRpYy1jb3JlLWZvcm0tZmllbGRzLW1hcmtkb2MuanNcIixcblx0XHRcdG5vZGU6IHtcblx0XHRcdFx0XCJyZWFjdC1zZXJ2ZXJcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtZm9ybS1maWVsZHMtbWFya2RvYy5ub2RlLnJlYWN0LXNlcnZlci5qc1wiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUtZm9ybS1maWVsZHMtbWFya2RvYy5ub2RlLmpzXCJcblx0XHRcdH0sXG5cdFx0XHRcInJlYWN0LXNlcnZlclwiOiBcIi4vZGlzdC9rZXlzdGF0aWMtY29yZS1mb3JtLWZpZWxkcy1tYXJrZG9jLnJlYWN0LXNlcnZlci5qc1wiLFxuXHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9kaXN0L2tleXN0YXRpYy1jb3JlLWZvcm0tZmllbGRzLW1hcmtkb2MuanNcIlxuXHRcdH0sXG5cdFx0XCIuL3BhY2thZ2UuanNvblwiOiBcIi4vcGFja2FnZS5qc29uXCJcblx0fSxcblx0ZmlsZXM6IFtcblx0XHRcImRpc3RcIlxuXHRdLFxuXHRzY3JpcHRzOiB7XG5cdFx0c2V0dXA6IFwidHMtZ3FsIGJ1aWxkICYmIHRzeCBzY3JpcHRzL2wxMG4uY3RzICYmIHRzeCBzY3JpcHRzL2J1aWxkLXByaXNtLmN0c1wiLFxuXHRcdGJ1aWxkOiBcInBucG0gcnVuIHNldHVwICYmIG5leHQgYnVpbGRcIixcblx0XHRkZXY6IFwibmV4dCBkZXZcIixcblx0XHRzdGFydDogXCJuZXh0IHN0YXJ0XCJcblx0fSxcblx0ZGVwZW5kZW5jaWVzOiB7XG5cdFx0XCJAYmFiZWwvcnVudGltZVwiOiBcIl43LjE4LjNcIixcblx0XHRcIkBicmFpbnRyZWUvc2FuaXRpemUtdXJsXCI6IFwiXjYuMC4yXCIsXG5cdFx0XCJAZW1vdGlvbi9jc3NcIjogXCJeMTEuOS4wXCIsXG5cdFx0XCJAZW1vdGlvbi93ZWFrLW1lbW9pemVcIjogXCJeMC4zLjBcIixcblx0XHRcIkBmbG9hdGluZy11aS9yZWFjdFwiOiBcIl4wLjI0LjBcIixcblx0XHRcIkBpbnRlcm5hdGlvbmFsaXplZC9zdHJpbmdcIjogXCJeMy4xLjFcIixcblx0XHRcIkBrZXlzdGFyL3VpXCI6IFwiXjAuNy4wXCIsXG5cdFx0XCJAbWFya2RvYy9tYXJrZG9jXCI6IFwiXjAuMy4wXCIsXG5cdFx0XCJAcmVhY3QtYXJpYS9mb2N1c1wiOiBcIl4zLjE0LjNcIixcblx0XHRcIkByZWFjdC1hcmlhL2kxOG5cIjogXCJeMy44LjBcIixcblx0XHRcIkByZWFjdC1hcmlhL2ludGVyYWN0aW9uc1wiOiBcIl4zLjE5LjFcIixcblx0XHRcIkByZWFjdC1hcmlhL292ZXJsYXlzXCI6IFwiXjMuMTguMVwiLFxuXHRcdFwiQHJlYWN0LWFyaWEvc2VsZWN0aW9uXCI6IFwiXjMuMTcuMVwiLFxuXHRcdFwiQHJlYWN0LWFyaWEvdXRpbHNcIjogXCJeMy4yMS4xXCIsXG5cdFx0XCJAcmVhY3QtYXJpYS92aXN1YWxseS1oaWRkZW5cIjogXCJeMy44LjZcIixcblx0XHRcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI6IFwiXjMuMTAuMlwiLFxuXHRcdFwiQHJlYWN0LXN0YXRlbHkvbGlzdFwiOiBcIl4zLjEwLjBcIixcblx0XHRcIkByZWFjdC1zdGF0ZWx5L292ZXJsYXlzXCI6IFwiXjMuNi4zXCIsXG5cdFx0XCJAcmVhY3Qtc3RhdGVseS91dGlsc1wiOiBcIl4zLjguMFwiLFxuXHRcdFwiQHJlYWN0LXR5cGVzL3NoYXJlZFwiOiBcIl4zLjIxLjBcIixcblx0XHRcIkBzaW5kcmVzb3JodXMvc2x1Z2lmeVwiOiBcIl4xLjEuMlwiLFxuXHRcdFwiQHRzLWdxbC90YWdcIjogXCJeMC43LjBcIixcblx0XHRcIkB0eXBlcy9tZGFzdFwiOiBcIl40LjAuM1wiLFxuXHRcdFwiQHR5cGVzL25vZGVcIjogXCIxNi4xMS4xM1wiLFxuXHRcdFwiQHR5cGVzL3JlYWN0XCI6IFwiXjE4LjIuOFwiLFxuXHRcdFwiQHR5cGVzL3JlYWN0LWRvbVwiOiBcIl4xOC4wLjExXCIsXG5cdFx0XCJAdXJxbC9jb3JlXCI6IFwiXjQuMS4zXCIsXG5cdFx0XCJAdXJxbC9leGNoYW5nZS1hdXRoXCI6IFwiXjIuMS42XCIsXG5cdFx0XCJAdXJxbC9leGNoYW5nZS1ncmFwaGNhY2hlXCI6IFwiXjYuMy4zXCIsXG5cdFx0XCJAdXJxbC9leGNoYW5nZS1wZXJzaXN0ZWRcIjogXCJeNC4xLjBcIixcblx0XHRjb29raWU6IFwiXjAuNS4wXCIsXG5cdFx0XCJkZWNpbWFsLmpzXCI6IFwiXjEwLjQuM1wiLFxuXHRcdGVtZXJ5OiBcIl4xLjQuMVwiLFxuXHRcdFwiZXNjYXBlLXN0cmluZy1yZWdleHBcIjogXCJeNC4wLjBcIixcblx0XHRcImZhc3QtZGVlcC1lcXVhbFwiOiBcIl4zLjEuM1wiLFxuXHRcdGdyYXBocWw6IFwiXjE2LjYuMFwiLFxuXHRcdFwiaWRiLWtleXZhbFwiOiBcIl42LjIuMVwiLFxuXHRcdGlnbm9yZTogXCJeNS4yLjRcIixcblx0XHRcImlyb24td2ViY3J5cHRvXCI6IFwiXjAuMTAuMVwiLFxuXHRcdFwiaXMtaG90a2V5XCI6IFwiXjAuMi4wXCIsXG5cdFx0XCJqcy1iYXNlNjRcIjogXCJeMy43LjVcIixcblx0XHRcImpzLXlhbWxcIjogXCJeNC4xLjBcIixcblx0XHRcImxydS1jYWNoZVwiOiBcIl43LjE0LjFcIixcblx0XHRcIm1hdGNoLXNvcnRlclwiOiBcIl42LjMuMVwiLFxuXHRcdFwibWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duXCI6IFwiXjIuMC4wXCIsXG5cdFx0XCJtZGFzdC11dGlsLWdmbVwiOiBcIl4zLjAuMFwiLFxuXHRcdFwibWRhc3QtdXRpbC1nZm0tYXV0b2xpbmstbGl0ZXJhbFwiOiBcIl4yLjAuMFwiLFxuXHRcdFwibWRhc3QtdXRpbC1nZm0tc3RyaWtldGhyb3VnaFwiOiBcIl4yLjAuMFwiLFxuXHRcdFwibWRhc3QtdXRpbC1tZHhcIjogXCJeMy4wLjBcIixcblx0XHRcIm1kYXN0LXV0aWwtdG8tbWFya2Rvd25cIjogXCJeMi4xLjBcIixcblx0XHRcIm1pY3JvbWFyay1leHRlbnNpb24tZ2ZtXCI6IFwiXjMuMC4wXCIsXG5cdFx0XCJtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS1hdXRvbGluay1saXRlcmFsXCI6IFwiXjIuMC4wXCIsXG5cdFx0XCJtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS1zdHJpa2V0aHJvdWdoXCI6IFwiXjIuMC4wXCIsXG5cdFx0XCJtaWNyb21hcmstZXh0ZW5zaW9uLW1keGpzXCI6IFwiXjMuMC4wXCIsXG5cdFx0bWluaW1hdGNoOiBcIl45LjAuM1wiLFxuXHRcdFwicHJvc2VtaXJyb3ItY29tbWFuZHNcIjogXCJeMS41LjFcIixcblx0XHRcInByb3NlbWlycm9yLWhpc3RvcnlcIjogXCJeMS4zLjBcIixcblx0XHRcInByb3NlbWlycm9yLWtleW1hcFwiOiBcIl4xLjIuMVwiLFxuXHRcdFwicHJvc2VtaXJyb3ItbW9kZWxcIjogXCJeMS4xOS4wXCIsXG5cdFx0XCJwcm9zZW1pcnJvci1zdGF0ZVwiOiBcIl4xLjQuMlwiLFxuXHRcdFwicHJvc2VtaXJyb3ItdGFibGVzXCI6IFwiXjEuMy40XCIsXG5cdFx0XCJwcm9zZW1pcnJvci10cmFuc2Zvcm1cIjogXCJeMS43LjFcIixcblx0XHRcInByb3NlbWlycm9yLXZpZXdcIjogXCJeMS4zMC4yXCIsXG5cdFx0XCJzY3JvbGwtaW50by12aWV3LWlmLW5lZWRlZFwiOiBcIl4zLjAuM1wiLFxuXHRcdHNsYXRlOiBcIl4wLjkxLjRcIixcblx0XHRcInNsYXRlLWhpc3RvcnlcIjogXCJeMC44Ni4wXCIsXG5cdFx0XCJzbGF0ZS1yZWFjdFwiOiBcIl4wLjkxLjlcIixcblx0XHRcInVuaXN0LXV0aWwtdmlzaXRcIjogXCJeNS4wLjBcIixcblx0XHR1cnFsOiBcIl40LjAuMFwiLFxuXHRcdHpvZDogXCJeMy4yMC4yXCJcblx0fSxcblx0ZGV2RGVwZW5kZW5jaWVzOiB7XG5cdFx0XCJAamVzdC9leHBlY3RcIjogXCJeMjkuNy4wXCIsXG5cdFx0XCJAamVzdC9nbG9iYWxzXCI6IFwiXjI5LjcuMFwiLFxuXHRcdFwiQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50XCI6IFwiXjE0LjQuM1wiLFxuXHRcdFwiQHRzLWdxbC9jb21waWxlclwiOiBcIl4wLjE2LjFcIixcblx0XHRcIkB0cy1ncWwvZXNsaW50LXBsdWdpblwiOiBcIl4wLjguNVwiLFxuXHRcdFwiQHRzLWdxbC9uZXh0XCI6IFwiXjE3LjAuMFwiLFxuXHRcdFwiQHR5cGVzL2Nvb2tpZVwiOiBcIl4wLjUuMVwiLFxuXHRcdFwiQHR5cGVzL2lzLWhvdGtleVwiOiBcIl4wLjEuN1wiLFxuXHRcdFwiQHR5cGVzL2pzLXlhbWxcIjogXCJeNC4wLjVcIixcblx0XHRcIkB0eXBlcy9wcmlzbWpzXCI6IFwiXjEuMjYuMFwiLFxuXHRcdFwiQHR5cGVzL3NpZ25hbC1leGl0XCI6IFwiXjMuMC4xXCIsXG5cdFx0ZXNsaW50OiBcIl44LjE4LjBcIixcblx0XHRcImZhc3QtZ2xvYlwiOiBcIl4zLjIuMTJcIixcblx0XHRcImplc3QtZGlmZlwiOiBcIl4yOS4wLjFcIixcblx0XHRvdXRkZW50OiBcIl4wLjguMFwiLFxuXHRcdFwicHJldHR5LWZvcm1hdFwiOiBcIl4yOS4wLjFcIixcblx0XHRwcmlzbWpzOiBcIl4xLjI5LjBcIixcblx0XHRyZWFjdDogXCJeMTguMi4wXCIsXG5cdFx0XCJyZWFjdC1kb21cIjogXCJeMTguMi4wXCIsXG5cdFx0XCJyZWFjdC1lbGVtZW50LXRvLWpzeC1zdHJpbmdcIjogXCJeMTUuMC4wXCIsXG5cdFx0XCJyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGxcIjogXCJeMS41LjFcIixcblx0XHRcInNpZ25hbC1leGl0XCI6IFwiXjMuMC43XCIsXG5cdFx0XCJzbGF0ZS1oeXBlcnNjcmlwdFwiOiBcIl4wLjc3LjBcIixcblx0XHR0c3g6IFwiXjMuOC4wXCIsXG5cdFx0dHlwZXNjcmlwdDogXCJeNS4yLjJcIlxuXHR9LFxuXHRwZWVyRGVwZW5kZW5jaWVzOiB7XG5cdFx0cmVhY3Q6IFwiXjE4LjIuMFwiLFxuXHRcdFwicmVhY3QtZG9tXCI6IFwiXjE4LjIuMFwiXG5cdH0sXG5cdHByZWNvbnN0cnVjdDoge1xuXHRcdGVudHJ5cG9pbnRzOiBbXG5cdFx0XHRcImluZGV4LnRzXCIsXG5cdFx0XHRcImFwaS9nZW5lcmljLnRzXCIsXG5cdFx0XHRcImFwaS91dGlscy50c1wiLFxuXHRcdFx0XCJyZWFkZXIvaW5kZXgudHNcIixcblx0XHRcdFwicmVhZGVyL2dpdGh1Yi50c1wiLFxuXHRcdFx0XCJyZW5kZXJlci50c3hcIixcblx0XHRcdFwidWkudHN4XCIsXG5cdFx0XHRcImZvcm0vZmllbGRzL21hcmtkb2MvaW5kZXgudHN4XCIsXG5cdFx0XHRcImNvbXBvbmVudC1ibG9ja3MvaW5kZXgudHN4XCIsXG5cdFx0XHRcImNvbnRlbnQtY29tcG9uZW50cy50c1wiXG5cdFx0XVxuXHR9LFxuXHRcInRzLWdxbFwiOiB7XG5cdFx0c2NoZW1hOiBcIi4vZ2l0aHViLmdyYXBocWxcIixcblx0XHRtb2RlOiBcIm5vLXRyYW5zZm9ybVwiLFxuXHRcdGFkZFR5cGVuYW1lOiBmYWxzZSxcblx0XHRzY2FsYXJzOiB7XG5cdFx0XHRHaXRPYmplY3RJRDogXCJzdHJpbmdcIlxuXHRcdH1cblx0fSxcblx0aW1wb3J0czoge1xuXHRcdFwiI3JlYWN0LWNhY2hlLWluLXJlYWN0LXNlcnZlclwiOiB7XG5cdFx0XHRcInJlYWN0LXNlcnZlclwiOiBcIi4vc3JjL3JlYWRlci9yZWFjdC1zZXJ2ZXItY2FjaGUudHNcIixcblx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vc3JjL3JlYWRlci9ub29wLWNhY2hlLnRzXCJcblx0XHR9LFxuXHRcdFwiI3NoYTFcIjoge1xuXHRcdFx0bm9kZTogXCIuL3NyYy9zaGExL25vZGUudHNcIixcblx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vc3JjL3NoYTEvd2ViY3J5cHRvLnRzXCJcblx0XHR9LFxuXHRcdFwiI3dlYmNyeXB0b1wiOiB7XG5cdFx0XHRub2RlOiBcIi4vc3JjL2FwaS93ZWJjcnlwdG8vbm9kZS50c1wiLFxuXHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9zcmMvYXBpL3dlYmNyeXB0by9kZWZhdWx0LnRzXCJcblx0XHR9LFxuXHRcdFwiI2FwaS1oYW5kbGVyXCI6IHtcblx0XHRcdG5vZGU6IFwiLi9zcmMvYXBpL2FwaS1ub2RlLnRzXCIsXG5cdFx0XHRcImRlZmF1bHRcIjogXCIuL3NyYy9hcGkvYXBpLW5vb3AudHNcIlxuXHRcdH0sXG5cdFx0XCIjZmllbGQtdWkvKlwiOiB7XG5cdFx0XHRcInJlYWN0LXNlcnZlclwiOiBcIi4vc3JjL2Zvcm0vZmllbGRzL2VtcHR5LWZpZWxkLXVpLnRzeFwiLFxuXHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9zcmMvZm9ybS9maWVsZHMvKi91aS50c3hcIlxuXHRcdH0sXG5cdFx0XCIjY29tcG9uZW50LWJsb2NrLXByaW1pdGl2ZXNcIjoge1xuXHRcdFx0XCJyZWFjdC1zZXJ2ZXJcIjogXCIuL3NyYy9mb3JtL2ZpZWxkcy9kb2N1bWVudC9Eb2N1bWVudEVkaXRvci9wcmltaXRpdmVzL2JsYW5rLWZvci1yZWFjdC1zZXJ2ZXIudHN4XCIsXG5cdFx0XHRcImRlZmF1bHRcIjogXCIuL3NyYy9mb3JtL2ZpZWxkcy9kb2N1bWVudC9Eb2N1bWVudEVkaXRvci9wcmltaXRpdmVzL2luZGV4LnRzeFwiXG5cdFx0fSxcblx0XHRcIiNjbG91ZC1pbWFnZS1wcmV2aWV3XCI6IHtcblx0XHRcdFwicmVhY3Qtc2VydmVyXCI6IFwiLi9zcmMvY29tcG9uZW50LWJsb2Nrcy9ibGFuay1mb3ItcmVhY3Qtc2VydmVyLnRzeFwiLFxuXHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9zcmMvY29tcG9uZW50LWJsb2Nrcy9jbG91ZC1pbWFnZS1wcmV2aWV3LnRzeFwiXG5cdFx0fVxuXHR9XG59O1xuXG5mdW5jdGlvbiBvYmplY3QoZmllbGRzLCBvcHRzKSB7XG4gIHJldHVybiB7XG4gICAgLi4ub3B0cyxcbiAgICBraW5kOiAnb2JqZWN0JyxcbiAgICBmaWVsZHNcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGx1cmFsaXplKGNvdW50LCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBzaW5ndWxhcixcbiAgICBwbHVyYWwgPSBzaW5ndWxhciArICdzJyxcbiAgICBpbmNsdXNpdmUgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB2YXJpYW50ID0gY291bnQgPT09IDEgPyBzaW5ndWxhciA6IHBsdXJhbDtcbiAgcmV0dXJuIGluY2x1c2l2ZSA/IGAke2NvdW50fSAke3ZhcmlhbnR9YCA6IHZhcmlhbnQ7XG59XG5mdW5jdGlvbiBnZXRCcmFuY2hQcmVmaXgoY29uZmlnKSB7XG4gIHJldHVybiBjb25maWcuc3RvcmFnZS5raW5kICE9PSAnbG9jYWwnID8gY29uZmlnLnN0b3JhZ2UuYnJhbmNoUHJlZml4IDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNHaXRIdWJDb25maWcoY29uZmlnKSB7XG4gIHJldHVybiBjb25maWcuc3RvcmFnZS5raW5kID09PSAnZ2l0aHViJztcbn1cbmZ1bmN0aW9uIGlzTG9jYWxDb25maWcoY29uZmlnKSB7XG4gIHJldHVybiBjb25maWcuc3RvcmFnZS5raW5kID09PSAnbG9jYWwnO1xufVxuZnVuY3Rpb24gaXNDbG91ZENvbmZpZyhjb25maWcpIHtcbiAgdmFyIF9jb25maWckY2xvdWQ7XG4gIGlmIChjb25maWcuc3RvcmFnZS5raW5kICE9PSAnY2xvdWQnKSByZXR1cm4gZmFsc2U7XG4gIGlmICghKChfY29uZmlnJGNsb3VkID0gY29uZmlnLmNsb3VkKSAhPT0gbnVsbCAmJiBfY29uZmlnJGNsb3VkICE9PSB2b2lkIDAgJiYgX2NvbmZpZyRjbG91ZC5wcm9qZWN0KSB8fCAhY29uZmlnLmNsb3VkLnByb2plY3QuaW5jbHVkZXMoJy8nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgS2V5c3RhdGljIGlzIHNldCB0byBcXGBzdG9yYWdlOiB7IGtpbmQ6ICdjbG91ZCcgfVxcYCBidXQgXFxgY2xvdWQucHJvamVjdFxcYCBpc24ndCBzZXQuXG5jb25maWcoe1xuICBzdG9yYWdlOiB7IGtpbmQ6ICdjbG91ZCcgfSxcbiAgY2xvdWQ6IHsgcHJvamVjdDogJ3RlYW0vcHJvamVjdCcgfSxcbn0pYCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRTcGxpdENsb3VkUHJvamVjdChjb25maWcpIHtcbiAgdmFyIF9jb25maWckY2xvdWQyO1xuICBpZiAoISgoX2NvbmZpZyRjbG91ZDIgPSBjb25maWcuY2xvdWQpICE9PSBudWxsICYmIF9jb25maWckY2xvdWQyICE9PSB2b2lkIDAgJiYgX2NvbmZpZyRjbG91ZDIucHJvamVjdCkpIHJldHVybiB1bmRlZmluZWQ7XG4gIGNvbnN0IFt0ZWFtLCBwcm9qZWN0XSA9IGNvbmZpZy5jbG91ZC5wcm9qZWN0LnNwbGl0KCcvJyk7XG4gIHJldHVybiB7XG4gICAgdGVhbSxcbiAgICBwcm9qZWN0XG4gIH07XG59XG5mdW5jdGlvbiBnZXRSZXBvUGF0aChjb25maWcpIHtcbiAgcmV0dXJuIGAke2NvbmZpZy5tYWluT3duZXJ9LyR7Y29uZmlnLm1haW5SZXBvfWA7XG59XG5mdW5jdGlvbiBnZXRSZXBvVXJsKGNvbmZpZykge1xuICByZXR1cm4gYGh0dHBzOi8vZ2l0aHViLmNvbS8ke2dldFJlcG9QYXRoKGNvbmZpZyl9YDtcbn1cbmZ1bmN0aW9uIGdldFNsdWdGcm9tU3RhdGUoY29sbGVjdGlvbkNvbmZpZywgc3RhdGUpIHtcbiAgY29uc3QgdmFsdWUgPSBzdGF0ZVtjb2xsZWN0aW9uQ29uZmlnLnNsdWdGaWVsZF07XG4gIGNvbnN0IGZpZWxkID0gY29sbGVjdGlvbkNvbmZpZy5zY2hlbWFbY29sbGVjdGlvbkNvbmZpZy5zbHVnRmllbGRdO1xuICBpZiAoZmllbGQua2luZCAhPT0gJ2Zvcm0nIHx8IGZpZWxkLmZvcm1LaW5kICE9PSAnc2x1ZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHNsdWdGaWVsZCBpcyBub3QgYSBzbHVnIGZpZWxkYCk7XG4gIH1cbiAgcmV0dXJuIGZpZWxkLnNlcmlhbGl6ZVdpdGhTbHVnKHZhbHVlKS5zbHVnO1xufVxuZnVuY3Rpb24gZ2V0RW50cmllc0luQ29sbGVjdGlvbldpdGhUcmVlS2V5KGNvbmZpZywgY29sbGVjdGlvbiwgcm9vdFRyZWUpIHtcbiAgdmFyIF9nZXRUcmVlTm9kZUF0UGF0aCRjaCwgX2dldFRyZWVOb2RlQXRQYXRoO1xuICBjb25zdCBjb2xsZWN0aW9uQ29uZmlnID0gY29uZmlnLmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25dO1xuICBjb25zdCBzY2hlbWEgPSBvYmplY3QoY29sbGVjdGlvbkNvbmZpZy5zY2hlbWEpO1xuICBjb25zdCBmb3JtYXRJbmZvID0gZ2V0Q29sbGVjdGlvbkZvcm1hdChjb25maWcsIGNvbGxlY3Rpb24pO1xuICBjb25zdCBleHRlbnNpb24gPSBnZXREYXRhRmlsZUV4dGVuc2lvbihmb3JtYXRJbmZvKTtcbiAgY29uc3QgZ2xvYiA9IGdldFNsdWdHbG9iRm9yQ29sbGVjdGlvbihjb25maWcsIGNvbGxlY3Rpb24pO1xuICBjb25zdCBjb2xsZWN0aW9uUGF0aCA9IGdldENvbGxlY3Rpb25QYXRoKGNvbmZpZywgY29sbGVjdGlvbik7XG4gIGNvbnN0IGRpcmVjdG9yeSA9IChfZ2V0VHJlZU5vZGVBdFBhdGgkY2ggPSAoX2dldFRyZWVOb2RlQXRQYXRoID0gZ2V0VHJlZU5vZGVBdFBhdGgocm9vdFRyZWUsIGNvbGxlY3Rpb25QYXRoKSkgPT09IG51bGwgfHwgX2dldFRyZWVOb2RlQXRQYXRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0VHJlZU5vZGVBdFBhdGguY2hpbGRyZW4pICE9PSBudWxsICYmIF9nZXRUcmVlTm9kZUF0UGF0aCRjaCAhPT0gdm9pZCAwID8gX2dldFRyZWVOb2RlQXRQYXRoJGNoIDogbmV3IE1hcCgpO1xuICBjb25zdCBlbnRyaWVzID0gW107XG4gIGNvbnN0IGRpcmVjdG9yaWVzVXNlZEluU2NoZW1hID0gWy4uLmNvbGxlY3REaXJlY3Rvcmllc1VzZWRJblNjaGVtYShzY2hlbWEpXTtcbiAgY29uc3Qgc3VmZml4ID0gZ2V0Q29sbGVjdGlvbkl0ZW1TbHVnU3VmZml4KGNvbmZpZywgY29sbGVjdGlvbik7XG4gIGNvbnN0IHBvc3NpYmxlRW50cmllcyA9IG5ldyBNYXAoZGlyZWN0b3J5KTtcbiAgaWYgKGdsb2IgPT09ICcqKicpIHtcbiAgICBjb25zdCBoYW5kbGVEaXJlY3RvcnkgPSAoZGlyLCBwcmVmaXgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIGRpcikge1xuICAgICAgICBpZiAoZW50cnkuY2hpbGRyZW4pIHtcbiAgICAgICAgICBwb3NzaWJsZUVudHJpZXMuc2V0KGAke3ByZWZpeH0ke2tleX1gLCBlbnRyeSk7XG4gICAgICAgICAgaGFuZGxlRGlyZWN0b3J5KGVudHJ5LmNoaWxkcmVuLCBgJHtwcmVmaXh9JHtrZXl9L2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvc3NpYmxlRW50cmllcy5zZXQoYCR7cHJlZml4fSR7a2V5fWAsIGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaGFuZGxlRGlyZWN0b3J5KGRpcmVjdG9yeSwgJycpO1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIHBvc3NpYmxlRW50cmllcykge1xuICAgIGlmIChmb3JtYXRJbmZvLmRhdGFMb2NhdGlvbiA9PT0gJ2luZGV4Jykge1xuICAgICAgdmFyIF9hY3R1YWxFbnRyeSRjaGlsZHJlbjtcbiAgICAgIGNvbnN0IGFjdHVhbEVudHJ5ID0gZ2V0VHJlZU5vZGVBdFBhdGgocm9vdFRyZWUsIGdldENvbGxlY3Rpb25JdGVtUGF0aChjb25maWcsIGNvbGxlY3Rpb24sIGtleSkpO1xuICAgICAgaWYgKCEoYWN0dWFsRW50cnkgIT09IG51bGwgJiYgYWN0dWFsRW50cnkgIT09IHZvaWQgMCAmJiAoX2FjdHVhbEVudHJ5JGNoaWxkcmVuID0gYWN0dWFsRW50cnkuY2hpbGRyZW4pICE9PSBudWxsICYmIF9hY3R1YWxFbnRyeSRjaGlsZHJlbiAhPT0gdm9pZCAwICYmIF9hY3R1YWxFbnRyeSRjaGlsZHJlbi5oYXMoJ2luZGV4JyArIGV4dGVuc2lvbikpKSBjb250aW51ZTtcbiAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgIGtleTogZ2V0VHJlZUtleShbYWN0dWFsRW50cnkuZW50cnkucGF0aCwgLi4uZGlyZWN0b3JpZXNVc2VkSW5TY2hlbWEubWFwKHggPT4gYCR7eH0vJHtrZXl9YCldLCByb290VHJlZSksXG4gICAgICAgIHNsdWc6IGtleSxcbiAgICAgICAgc2hhOiBhY3R1YWxFbnRyeS5jaGlsZHJlbi5nZXQoJ2luZGV4JyArIGV4dGVuc2lvbikuZW50cnkuc2hhXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN1ZmZpeCkge1xuICAgICAgICBjb25zdCBuZXdFbnRyeSA9IGdldFRyZWVOb2RlQXRQYXRoKHJvb3RUcmVlLCBnZXRDb2xsZWN0aW9uSXRlbVBhdGgoY29uZmlnLCBjb2xsZWN0aW9uLCBrZXkpICsgZXh0ZW5zaW9uKTtcbiAgICAgICAgaWYgKCFuZXdFbnRyeSB8fCBuZXdFbnRyeS5jaGlsZHJlbikgY29udGludWU7XG4gICAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgICAga2V5OiBnZXRUcmVlS2V5KFtlbnRyeS5lbnRyeS5wYXRoLCBnZXRDb2xsZWN0aW9uSXRlbVBhdGgoY29uZmlnLCBjb2xsZWN0aW9uLCBrZXkpLCAuLi5kaXJlY3Rvcmllc1VzZWRJblNjaGVtYS5tYXAoeCA9PiBgJHt4fS8ke2tleX1gKV0sIHJvb3RUcmVlKSxcbiAgICAgICAgICBzbHVnOiBrZXksXG4gICAgICAgICAgc2hhOiBuZXdFbnRyeS5lbnRyeS5zaGFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoZW50cnkuY2hpbGRyZW4gfHwgIWtleS5lbmRzV2l0aChleHRlbnNpb24pKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHNsdWcgPSBrZXkuc2xpY2UoMCwgLWV4dGVuc2lvbi5sZW5ndGgpO1xuICAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgICAga2V5OiBnZXRUcmVlS2V5KFtlbnRyeS5lbnRyeS5wYXRoLCBnZXRDb2xsZWN0aW9uSXRlbVBhdGgoY29uZmlnLCBjb2xsZWN0aW9uLCBzbHVnKSwgLi4uZGlyZWN0b3JpZXNVc2VkSW5TY2hlbWEubWFwKHggPT4gYCR7eH0vJHtzbHVnfWApXSwgcm9vdFRyZWUpLFxuICAgICAgICBzbHVnLFxuICAgICAgICBzaGE6IGVudHJ5LmVudHJ5LnNoYVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbnRyaWVzO1xufVxuY29uc3QgS0VZU1RBVElDX0NMT1VEX0FQSV9VUkwgPSAnaHR0cHM6Ly9hcGkua2V5c3RhdGljLmNsb3VkJztcbmNvbnN0IEtFWVNUQVRJQ19DTE9VRF9IRUFERVJTID0ge1xuICAneC1rZXlzdGF0aWMtdmVyc2lvbic6IHBrZ0pzb24udmVyc2lvblxufTtcbmNvbnN0IHRleHRFbmNvZGVyJDEgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmFzeW5jIGZ1bmN0aW9uIHJlZGlyZWN0VG9DbG91ZEF1dGgoZnJvbSwgY29uZmlnKSB7XG4gIHZhciBfY29uZmlnJGNsb3VkMztcbiAgaWYgKCEoKF9jb25maWckY2xvdWQzID0gY29uZmlnLmNsb3VkKSAhPT0gbnVsbCAmJiBfY29uZmlnJGNsb3VkMyAhPT0gdm9pZCAwICYmIF9jb25maWckY2xvdWQzLnByb2plY3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBjbG91ZCBjb25maWcnKTtcbiAgfVxuICBjb25zdCBjb2RlX3ZlcmlmaWVyID0gZnJvbVVpbnQ4QXJyYXkoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgzMikpLCB0cnVlKTtcbiAgY29uc3QgY29kZV9jaGFsbGVuZ2UgPSBmcm9tVWludDhBcnJheShuZXcgVWludDhBcnJheShhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIHRleHRFbmNvZGVyJDEuZW5jb2RlKGNvZGVfdmVyaWZpZXIpKSksIHRydWUpO1xuICBjb25zdCBzdGF0ZSA9IGZyb21VaW50OEFycmF5KGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMzIpKSwgdHJ1ZSk7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdrZXlzdGF0aWMtY2xvdWQtc3RhdGUnLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgc3RhdGUsXG4gICAgZnJvbSxcbiAgICBjb2RlX3ZlcmlmaWVyXG4gIH0pKTtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtLRVlTVEFUSUNfQ0xPVURfQVBJX1VSTH0vb2F1dGgvYXV0aG9yaXplYCk7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdzdGF0ZScsIHN0YXRlKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NsaWVudF9pZCcsIGNvbmZpZy5jbG91ZC5wcm9qZWN0KTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3JlZGlyZWN0X3VyaScsIGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59L2tleXN0YXRpYy9jbG91ZC9vYXV0aC9jYWxsYmFja2ApO1xuICB1cmwuc2VhcmNoUGFyYW1zLnNldCgncmVzcG9uc2VfdHlwZScsICdjb2RlJyk7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdjb2RlX2NoYWxsZW5nZV9tZXRob2QnLCAnUzI1NicpO1xuICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnY29kZV9jaGFsbGVuZ2UnLCBjb2RlX2NoYWxsZW5nZSk7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdrZXlzdGF0aWNfdmVyc2lvbicsIHBrZ0pzb24udmVyc2lvbik7XG4gIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbmNvbnN0IHRhYmxlQ2VsbENoaWxkcmVuID0gWydwYXJhZ3JhcGgnLCAnY29kZScsICdoZWFkaW5nJywgJ29yZGVyZWQtbGlzdCcsICd1bm9yZGVyZWQtbGlzdCcsICdkaXZpZGVyJywgJ2ltYWdlJ107XG5jb25zdCBibG9ja3F1b3RlQ2hpbGRyZW4gPSBbLi4udGFibGVDZWxsQ2hpbGRyZW4sICd0YWJsZSddO1xuY29uc3QgcGFyYWdyYXBoTGlrZSA9IFsuLi5ibG9ja3F1b3RlQ2hpbGRyZW4sICdibG9ja3F1b3RlJ107XG5jb25zdCBpbnNpZGVPZkxheW91dHMgPSBbLi4ucGFyYWdyYXBoTGlrZSwgJ2NvbXBvbmVudC1ibG9jayddO1xuZnVuY3Rpb24gYmxvY2tDb250YWluZXIoYXJncykge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6ICdibG9ja3MnLFxuICAgIGFsbG93ZWRDaGlsZHJlbjogbmV3IFNldChhcmdzLmFsbG93ZWRDaGlsZHJlbiksXG4gICAgYmxvY2tUb1dyYXBJbmxpbmVzSW46IGFyZ3MuYWxsb3dlZENoaWxkcmVuWzBdLFxuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6IGFyZ3MuaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZVxuICB9O1xufVxuZnVuY3Rpb24gaW5saW5lQ29udGFpbmVyKGFyZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiAnaW5saW5lcycsXG4gICAgaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZTogYXJncy5pbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlXG4gIH07XG59XG5jb25zdCBlZGl0b3JTY2hlbWEgPSB7XG4gIGVkaXRvcjogYmxvY2tDb250YWluZXIoe1xuICAgIGFsbG93ZWRDaGlsZHJlbjogWy4uLmluc2lkZU9mTGF5b3V0cywgJ2xheW91dCddLFxuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICdtb3ZlJ1xuICB9KSxcbiAgbGF5b3V0OiBibG9ja0NvbnRhaW5lcih7XG4gICAgYWxsb3dlZENoaWxkcmVuOiBbJ2xheW91dC1hcmVhJ10sXG4gICAgaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZTogJ21vdmUnXG4gIH0pLFxuICAnbGF5b3V0LWFyZWEnOiBibG9ja0NvbnRhaW5lcih7XG4gICAgYWxsb3dlZENoaWxkcmVuOiBpbnNpZGVPZkxheW91dHMsXG4gICAgaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZTogJ3Vud3JhcCdcbiAgfSksXG4gIGJsb2NrcXVvdGU6IGJsb2NrQ29udGFpbmVyKHtcbiAgICBhbGxvd2VkQ2hpbGRyZW46IGJsb2NrcXVvdGVDaGlsZHJlbixcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAnbW92ZSdcbiAgfSksXG4gIHBhcmFncmFwaDogaW5saW5lQ29udGFpbmVyKHtcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAndW53cmFwJ1xuICB9KSxcbiAgY29kZTogaW5saW5lQ29udGFpbmVyKHtcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAnbW92ZSdcbiAgfSksXG4gIGRpdmlkZXI6IGlubGluZUNvbnRhaW5lcih7XG4gICAgaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZTogJ21vdmUnXG4gIH0pLFxuICBoZWFkaW5nOiBpbmxpbmVDb250YWluZXIoe1xuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICd1bndyYXAnXG4gIH0pLFxuICAnY29tcG9uZW50LWJsb2NrJzogYmxvY2tDb250YWluZXIoe1xuICAgIGFsbG93ZWRDaGlsZHJlbjogWydjb21wb25lbnQtYmxvY2stcHJvcCcsICdjb21wb25lbnQtaW5saW5lLXByb3AnXSxcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAnbW92ZSdcbiAgfSksXG4gICdjb21wb25lbnQtaW5saW5lLXByb3AnOiBpbmxpbmVDb250YWluZXIoe1xuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICd1bndyYXAnXG4gIH0pLFxuICAnY29tcG9uZW50LWJsb2NrLXByb3AnOiBibG9ja0NvbnRhaW5lcih7XG4gICAgYWxsb3dlZENoaWxkcmVuOiBpbnNpZGVPZkxheW91dHMsXG4gICAgaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZTogJ3Vud3JhcCdcbiAgfSksXG4gICdvcmRlcmVkLWxpc3QnOiBibG9ja0NvbnRhaW5lcih7XG4gICAgYWxsb3dlZENoaWxkcmVuOiBbJ2xpc3QtaXRlbSddLFxuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICdtb3ZlJ1xuICB9KSxcbiAgJ3Vub3JkZXJlZC1saXN0JzogYmxvY2tDb250YWluZXIoe1xuICAgIGFsbG93ZWRDaGlsZHJlbjogWydsaXN0LWl0ZW0nXSxcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAnbW92ZSdcbiAgfSksXG4gICdsaXN0LWl0ZW0nOiBibG9ja0NvbnRhaW5lcih7XG4gICAgYWxsb3dlZENoaWxkcmVuOiBbJ2xpc3QtaXRlbS1jb250ZW50JywgJ29yZGVyZWQtbGlzdCcsICd1bm9yZGVyZWQtbGlzdCddLFxuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICd1bndyYXAnXG4gIH0pLFxuICAnbGlzdC1pdGVtLWNvbnRlbnQnOiBpbmxpbmVDb250YWluZXIoe1xuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICd1bndyYXAnXG4gIH0pLFxuICBpbWFnZTogaW5saW5lQ29udGFpbmVyKHtcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAnbW92ZSdcbiAgfSksXG4gIHRhYmxlOiBibG9ja0NvbnRhaW5lcih7XG4gICAgaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZTogJ21vdmUnLFxuICAgIGFsbG93ZWRDaGlsZHJlbjogWyd0YWJsZS1oZWFkJywgJ3RhYmxlLWJvZHknXVxuICB9KSxcbiAgJ3RhYmxlLWJvZHknOiBibG9ja0NvbnRhaW5lcih7XG4gICAgaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZTogJ21vdmUnLFxuICAgIGFsbG93ZWRDaGlsZHJlbjogWyd0YWJsZS1yb3cnXVxuICB9KSxcbiAgJ3RhYmxlLXJvdyc6IGJsb2NrQ29udGFpbmVyKHtcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAnbW92ZScsXG4gICAgYWxsb3dlZENoaWxkcmVuOiBbJ3RhYmxlLWNlbGwnXVxuICB9KSxcbiAgJ3RhYmxlLWNlbGwnOiBibG9ja0NvbnRhaW5lcih7XG4gICAgaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZTogJ21vdmUnLFxuICAgIGFsbG93ZWRDaGlsZHJlbjogdGFibGVDZWxsQ2hpbGRyZW5cbiAgfSksXG4gICd0YWJsZS1oZWFkJzogYmxvY2tDb250YWluZXIoe1xuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICdtb3ZlJyxcbiAgICBhbGxvd2VkQ2hpbGRyZW46IFsndGFibGUtcm93J11cbiAgfSlcbn07XG5jb25zdCBpbmxpbmVDb250YWluZXJUeXBlcyA9IG5ldyBTZXQoT2JqZWN0LmVudHJpZXMoZWRpdG9yU2NoZW1hKS5maWx0ZXIoKFssIHZhbHVlXSkgPT4gdmFsdWUua2luZCA9PT0gJ2lubGluZXMnKS5tYXAoKFt0eXBlXSkgPT4gdHlwZSkpO1xuZnVuY3Rpb24gaXNJbmxpbmVDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gbm9kZS50eXBlICE9PSB1bmRlZmluZWQgJiYgaW5saW5lQ29udGFpbmVyVHlwZXMuaGFzKG5vZGUudHlwZSk7XG59XG5jb25zdCBibG9ja1R5cGVzID0gbmV3IFNldChPYmplY3Qua2V5cyhlZGl0b3JTY2hlbWEpLmZpbHRlcih4ID0+IHggIT09ICdlZGl0b3InKSk7XG5mdW5jdGlvbiBpc0Jsb2NrKG5vZGUpIHtcbiAgcmV0dXJuIGJsb2NrVHlwZXMuaGFzKG5vZGUudHlwZSk7XG59XG5cbi8vIHRvIHByaW50IHRoZSBlZGl0b3Igc2NoZW1hIGluIEdyYXBodml6IGlmIHlvdSB3YW50IHRvIHZpc3VhbGl6ZSBpdFxuLy8gZnVuY3Rpb24gcHJpbnRFZGl0b3JTY2hlbWEoZWRpdG9yU2NoZW1hOiBFZGl0b3JTY2hlbWEpIHtcbi8vICAgcmV0dXJuIGBkaWdyYXBoIEcge1xuLy8gICBjb25jZW50cmF0ZT10cnVlO1xuLy8gICAke09iamVjdC5rZXlzKGVkaXRvclNjaGVtYSlcbi8vICAgICAubWFwKGtleSA9PiB7XG4vLyAgICAgICBsZXQgdmFsID0gZWRpdG9yU2NoZW1hW2tleV07XG4vLyAgICAgICBpZiAodmFsLmtpbmQgPT09ICdpbmxpbmVzJykge1xuLy8gICAgICAgICByZXR1cm4gYFwiJHtrZXl9XCIgLT4gaW5saW5lc2A7XG4vLyAgICAgICB9XG4vLyAgICAgICBpZiAodmFsLmtpbmQgPT09ICdibG9ja3MnKSB7XG4vLyAgICAgICAgIHJldHVybiBgXCIke2tleX1cIiAtPiB7JHtbLi4udmFsLmFsbG93ZWRDaGlsZHJlbl0ubWFwKHggPT4gSlNPTi5zdHJpbmdpZnkoeCkpLmpvaW4oJyAnKX19YDtcbi8vICAgICAgIH1cbi8vICAgICB9KVxuLy8gICAgIC5qb2luKCdcXG4gICcpfVxuLy8gfWA7XG4vLyB9XG5cbmZ1bmN0aW9uIGdldFdob2xlRG9jdW1lbnRGZWF0dXJlc0ZvckNoaWxkRmllbGQoZWRpdG9yRG9jdW1lbnRGZWF0dXJlcywgb3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkZm9ybWF0dGluZywgX29wdGlvbnMkZm9ybWF0dGluZzIsIF9vcHRpb25zJGZvcm1hdHRpbmczLCBfb3B0aW9ucyRmb3JtYXR0aW5nNCwgX29wdGlvbnMkZm9ybWF0dGluZzUsIF9vcHRpb25zJGZvcm1hdHRpbmc2LCBfb3B0aW9ucyRmb3JtYXR0aW5nNztcbiAgY29uc3QgaW5saW5lTWFya3NGcm9tT3B0aW9ucyA9IChfb3B0aW9ucyRmb3JtYXR0aW5nID0gb3B0aW9ucy5mb3JtYXR0aW5nKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRmb3JtYXR0aW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRmb3JtYXR0aW5nLmlubGluZU1hcmtzO1xuICBjb25zdCBpbmxpbmVNYXJrcyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3Qua2V5cyhlZGl0b3JEb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuaW5saW5lTWFya3MpLm1hcChfbWFyayA9PiB7XG4gICAgY29uc3QgbWFyayA9IF9tYXJrO1xuICAgIHJldHVybiBbbWFyaywgaW5saW5lTWFya3NGcm9tT3B0aW9ucyA9PT0gJ2luaGVyaXQnIHx8IChpbmxpbmVNYXJrc0Zyb21PcHRpb25zID09PSBudWxsIHx8IGlubGluZU1hcmtzRnJvbU9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlubGluZU1hcmtzRnJvbU9wdGlvbnNbbWFya10pID09PSAnaW5oZXJpdCcgPyBlZGl0b3JEb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuaW5saW5lTWFya3NbbWFya10gOiBmYWxzZV07XG4gIH0pKTtcbiAgY29uc3QgaGVhZGluZ0xldmVscyA9IChfb3B0aW9ucyRmb3JtYXR0aW5nMiA9IG9wdGlvbnMuZm9ybWF0dGluZykgPT09IG51bGwgfHwgX29wdGlvbnMkZm9ybWF0dGluZzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJGZvcm1hdHRpbmcyLmhlYWRpbmdMZXZlbHM7XG4gIHJldHVybiB7XG4gICAgZm9ybWF0dGluZzoge1xuICAgICAgaW5saW5lTWFya3MsXG4gICAgICBzb2Z0QnJlYWtzOiAoKF9vcHRpb25zJGZvcm1hdHRpbmczID0gb3B0aW9ucy5mb3JtYXR0aW5nKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRmb3JtYXR0aW5nMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkZm9ybWF0dGluZzMuc29mdEJyZWFrcykgPT09ICdpbmhlcml0JyAmJiBlZGl0b3JEb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuc29mdEJyZWFrcyxcbiAgICAgIGFsaWdubWVudDoge1xuICAgICAgICBjZW50ZXI6IGVkaXRvckRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5hbGlnbm1lbnQuY2VudGVyICYmICgoX29wdGlvbnMkZm9ybWF0dGluZzQgPSBvcHRpb25zLmZvcm1hdHRpbmcpID09PSBudWxsIHx8IF9vcHRpb25zJGZvcm1hdHRpbmc0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRmb3JtYXR0aW5nNC5hbGlnbm1lbnQpID09PSAnaW5oZXJpdCcsXG4gICAgICAgIGVuZDogZWRpdG9yRG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmFsaWdubWVudC5lbmQgJiYgKChfb3B0aW9ucyRmb3JtYXR0aW5nNSA9IG9wdGlvbnMuZm9ybWF0dGluZykgPT09IG51bGwgfHwgX29wdGlvbnMkZm9ybWF0dGluZzUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJGZvcm1hdHRpbmc1LmFsaWdubWVudCkgPT09ICdpbmhlcml0J1xuICAgICAgfSxcbiAgICAgIGJsb2NrVHlwZXM6ICgoX29wdGlvbnMkZm9ybWF0dGluZzYgPSBvcHRpb25zLmZvcm1hdHRpbmcpID09PSBudWxsIHx8IF9vcHRpb25zJGZvcm1hdHRpbmc2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRmb3JtYXR0aW5nNi5ibG9ja1R5cGVzKSA9PT0gJ2luaGVyaXQnID8gZWRpdG9yRG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmJsb2NrVHlwZXMgOiB7XG4gICAgICAgIGJsb2NrcXVvdGU6IGZhbHNlLFxuICAgICAgICBjb2RlOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGhlYWRpbmdzOiBoZWFkaW5nTGV2ZWxzID09PSAnaW5oZXJpdCcgPyBlZGl0b3JEb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuaGVhZGluZ3MgOiB7XG4gICAgICAgIGxldmVsczogaGVhZGluZ0xldmVscyA/IGVkaXRvckRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5oZWFkaW5ncy5sZXZlbHMuZmlsdGVyKGxldmVsID0+IGhlYWRpbmdMZXZlbHMuaW5jbHVkZXMobGV2ZWwpKSA6IFtdLFxuICAgICAgICBzY2hlbWE6IGVkaXRvckRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5oZWFkaW5ncy5zY2hlbWFcbiAgICAgIH0sXG4gICAgICBsaXN0VHlwZXM6ICgoX29wdGlvbnMkZm9ybWF0dGluZzcgPSBvcHRpb25zLmZvcm1hdHRpbmcpID09PSBudWxsIHx8IF9vcHRpb25zJGZvcm1hdHRpbmc3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRmb3JtYXR0aW5nNy5saXN0VHlwZXMpID09PSAnaW5oZXJpdCcgPyBlZGl0b3JEb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcubGlzdFR5cGVzIDoge1xuICAgICAgICBvcmRlcmVkOiBmYWxzZSxcbiAgICAgICAgdW5vcmRlcmVkOiBmYWxzZVxuICAgICAgfVxuICAgIH0sXG4gICAgZGl2aWRlcnM6IG9wdGlvbnMuZGl2aWRlcnMgPT09ICdpbmhlcml0JyA/IGVkaXRvckRvY3VtZW50RmVhdHVyZXMuZGl2aWRlcnMgOiBmYWxzZSxcbiAgICBpbWFnZXM6IG9wdGlvbnMuaW1hZ2VzID09PSAnaW5oZXJpdCcgJiYgZWRpdG9yRG9jdW1lbnRGZWF0dXJlcy5pbWFnZXMsXG4gICAgbGF5b3V0czogW10sXG4gICAgbGlua3M6IG9wdGlvbnMubGlua3MgPT09ICdpbmhlcml0JyAmJiBlZGl0b3JEb2N1bWVudEZlYXR1cmVzLmxpbmtzLFxuICAgIHRhYmxlczogb3B0aW9ucy50YWJsZXMgPT09ICdpbmhlcml0JyAmJiBlZGl0b3JEb2N1bWVudEZlYXR1cmVzLnRhYmxlc1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRGZWF0dXJlc0ZvckNoaWxkRmllbGQoZWRpdG9yRG9jdW1lbnRGZWF0dXJlcywgb3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkZm9ybWF0dGluZzgsIF9vcHRpb25zJGZvcm1hdHRpbmcxMCwgX29wdGlvbnMkZm9ybWF0dGluZzExLCBfb3B0aW9ucyRmb3JtYXR0aW5nMTIsIF9vcHRpb25zJGZvcm1hdHRpbmcxMywgX29wdGlvbnMkZm9ybWF0dGluZzE0O1xuICAvLyBhbiBpbXBvcnRhbnQgbm90ZSBmb3IgdGhpczogbm9ybWFsaXphdGlvbiBiYXNlZCBvbiBkb2N1bWVudCBmZWF0dXJlc1xuICAvLyBpcyBkb25lIGJhc2VkIG9uIHRoZSBkb2N1bWVudCBmZWF0dXJlcyByZXR1cm5lZCBoZXJlXG4gIC8vIGFuZCB0aGUgZWRpdG9yIGRvY3VtZW50IGZlYXR1cmVzXG4gIC8vIHNvIHRoZSByZXN1bHQgZm9yIGFueSBnaXZlbiBjaGlsZCBwcm9wIHdpbGwgYmUgdGhlIHRoaW5ncyB0aGF0IGFyZVxuICAvLyBhbGxvd2VkIGJ5IGJvdGggdGhlc2UgZG9jdW1lbnQgZmVhdHVyZXNcbiAgLy8gQU5EIHRoZSBlZGl0b3IgZG9jdW1lbnQgZmVhdHVyZXNcbiAgY29uc3QgaW5saW5lTWFya3NGcm9tT3B0aW9ucyA9IChfb3B0aW9ucyRmb3JtYXR0aW5nOCA9IG9wdGlvbnMuZm9ybWF0dGluZykgPT09IG51bGwgfHwgX29wdGlvbnMkZm9ybWF0dGluZzggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJGZvcm1hdHRpbmc4LmlubGluZU1hcmtzO1xuICBjb25zdCBpbmxpbmVNYXJrcyA9IGlubGluZU1hcmtzRnJvbU9wdGlvbnMgPT09ICdpbmhlcml0JyA/ICdpbmhlcml0JyA6IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3Qua2V5cyhlZGl0b3JEb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuaW5saW5lTWFya3MpLm1hcChtYXJrID0+IHtcbiAgICByZXR1cm4gW21hcmssICEhKGlubGluZU1hcmtzRnJvbU9wdGlvbnMgfHwge30pW21hcmtdXTtcbiAgfSkpO1xuICBpZiAob3B0aW9ucy5raW5kID09PSAnaW5saW5lJykge1xuICAgIHZhciBfb3B0aW9ucyRmb3JtYXR0aW5nOTtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogJ2lubGluZScsXG4gICAgICBpbmxpbmVNYXJrcyxcbiAgICAgIGRvY3VtZW50RmVhdHVyZXM6IHtcbiAgICAgICAgbGlua3M6IG9wdGlvbnMubGlua3MgPT09ICdpbmhlcml0J1xuICAgICAgfSxcbiAgICAgIHNvZnRCcmVha3M6ICgoX29wdGlvbnMkZm9ybWF0dGluZzkgPSBvcHRpb25zLmZvcm1hdHRpbmcpID09PSBudWxsIHx8IF9vcHRpb25zJGZvcm1hdHRpbmc5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRmb3JtYXR0aW5nOS5zb2Z0QnJlYWtzKSA9PT0gJ2luaGVyaXQnXG4gICAgfTtcbiAgfVxuICBjb25zdCBoZWFkaW5nTGV2ZWxzID0gKF9vcHRpb25zJGZvcm1hdHRpbmcxMCA9IG9wdGlvbnMuZm9ybWF0dGluZykgPT09IG51bGwgfHwgX29wdGlvbnMkZm9ybWF0dGluZzEwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRmb3JtYXR0aW5nMTAuaGVhZGluZ0xldmVscztcbiAgcmV0dXJuIHtcbiAgICBraW5kOiAnYmxvY2snLFxuICAgIGlubGluZU1hcmtzLFxuICAgIHNvZnRCcmVha3M6ICgoX29wdGlvbnMkZm9ybWF0dGluZzExID0gb3B0aW9ucy5mb3JtYXR0aW5nKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRmb3JtYXR0aW5nMTEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJGZvcm1hdHRpbmcxMS5zb2Z0QnJlYWtzKSA9PT0gJ2luaGVyaXQnLFxuICAgIGRvY3VtZW50RmVhdHVyZXM6IHtcbiAgICAgIGxheW91dHM6IFtdLFxuICAgICAgZGl2aWRlcnM6IG9wdGlvbnMuZGl2aWRlcnMgPT09ICdpbmhlcml0JyA/IGVkaXRvckRvY3VtZW50RmVhdHVyZXMuZGl2aWRlcnMgOiBmYWxzZSxcbiAgICAgIGZvcm1hdHRpbmc6IHtcbiAgICAgICAgYWxpZ25tZW50OiAoKF9vcHRpb25zJGZvcm1hdHRpbmcxMiA9IG9wdGlvbnMuZm9ybWF0dGluZykgPT09IG51bGwgfHwgX29wdGlvbnMkZm9ybWF0dGluZzEyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRmb3JtYXR0aW5nMTIuYWxpZ25tZW50KSA9PT0gJ2luaGVyaXQnID8gZWRpdG9yRG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmFsaWdubWVudCA6IHtcbiAgICAgICAgICBjZW50ZXI6IGZhbHNlLFxuICAgICAgICAgIGVuZDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgYmxvY2tUeXBlczogKChfb3B0aW9ucyRmb3JtYXR0aW5nMTMgPSBvcHRpb25zLmZvcm1hdHRpbmcpID09PSBudWxsIHx8IF9vcHRpb25zJGZvcm1hdHRpbmcxMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkZm9ybWF0dGluZzEzLmJsb2NrVHlwZXMpID09PSAnaW5oZXJpdCcgPyBlZGl0b3JEb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuYmxvY2tUeXBlcyA6IHtcbiAgICAgICAgICBibG9ja3F1b3RlOiBmYWxzZSxcbiAgICAgICAgICBjb2RlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBoZWFkaW5nczogaGVhZGluZ0xldmVscyA9PT0gJ2luaGVyaXQnID8gZWRpdG9yRG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmhlYWRpbmdzIDoge1xuICAgICAgICAgIGxldmVsczogaGVhZGluZ0xldmVscyA/IGVkaXRvckRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5oZWFkaW5ncy5sZXZlbHMuZmlsdGVyKGxldmVsID0+IGhlYWRpbmdMZXZlbHMuaW5jbHVkZXMobGV2ZWwpKSA6IFtdLFxuICAgICAgICAgIHNjaGVtYTogZWRpdG9yRG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmhlYWRpbmdzLnNjaGVtYVxuICAgICAgICB9LFxuICAgICAgICBsaXN0VHlwZXM6ICgoX29wdGlvbnMkZm9ybWF0dGluZzE0ID0gb3B0aW9ucy5mb3JtYXR0aW5nKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRmb3JtYXR0aW5nMTQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJGZvcm1hdHRpbmcxNC5saXN0VHlwZXMpID09PSAnaW5oZXJpdCcgPyBlZGl0b3JEb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcubGlzdFR5cGVzIDoge1xuICAgICAgICAgIG9yZGVyZWQ6IGZhbHNlLFxuICAgICAgICAgIHVub3JkZXJlZDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxpbmtzOiBvcHRpb25zLmxpbmtzID09PSAnaW5oZXJpdCcsXG4gICAgICBpbWFnZXM6IG9wdGlvbnMuaW1hZ2VzID09PSAnaW5oZXJpdCcgPyBlZGl0b3JEb2N1bWVudEZlYXR1cmVzLmltYWdlcyA6IGZhbHNlLFxuICAgICAgdGFibGVzOiBvcHRpb25zLnRhYmxlcyA9PT0gJ2luaGVyaXQnXG4gICAgfSxcbiAgICBjb21wb25lbnRCbG9ja3M6IG9wdGlvbnMuY29tcG9uZW50QmxvY2tzID09PSAnaW5oZXJpdCdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNjaGVtYUF0UHJvcFBhdGhJbm5lcihwYXRoLCB2YWx1ZSwgc2NoZW1hKSB7XG4gIC8vIGJlY2F1c2Ugd2UncmUgY2hlY2tpbmcgdGhlIGxlbmd0aCBoZXJlXG4gIC8vIHRoZSBub24tbnVsbCBhc3NlcnRzIG9uIHNoaWZ0IGJlbG93IGFyZSBmaW5lXG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnY2hpbGQnIHx8IHNjaGVtYS5raW5kID09PSAnZm9ybScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnY29uZGl0aW9uYWwnKSB7XG4gICAgY29uc3Qga2V5ID0gcGF0aC5zaGlmdCgpO1xuICAgIGlmIChrZXkgPT09ICdkaXNjcmltaW5hbnQnKSB7XG4gICAgICByZXR1cm4gZ2V0U2NoZW1hQXRQcm9wUGF0aElubmVyKHBhdGgsIHZhbHVlLmRpc2NyaW1pbmFudCwgc2NoZW1hLmRpc2NyaW1pbmFudCk7XG4gICAgfVxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIGNvbnN0IHByb3BWYWwgPSBzY2hlbWEudmFsdWVzW3ZhbHVlLmRpc2NyaW1pbmFudF07XG4gICAgICByZXR1cm4gZ2V0U2NoZW1hQXRQcm9wUGF0aElubmVyKHBhdGgsIHZhbHVlLnZhbHVlLCBwcm9wVmFsKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCBrZXkgPSBwYXRoLnNoaWZ0KCk7XG4gICAgcmV0dXJuIGdldFNjaGVtYUF0UHJvcFBhdGhJbm5lcihwYXRoLCB2YWx1ZVtrZXldLCBzY2hlbWEuZmllbGRzW2tleV0pO1xuICB9XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ2FycmF5Jykge1xuICAgIGNvbnN0IGluZGV4ID0gcGF0aC5zaGlmdCgpO1xuICAgIHJldHVybiBnZXRTY2hlbWFBdFByb3BQYXRoSW5uZXIocGF0aCwgdmFsdWVbaW5kZXhdLCBzY2hlbWEuZWxlbWVudCk7XG4gIH1cbiAgYXNzZXJ0TmV2ZXIoc2NoZW1hKTtcbn1cbmZ1bmN0aW9uIGdldFNjaGVtYUF0UHJvcFBhdGgocGF0aCwgdmFsdWUsIHByb3BzKSB7XG4gIHJldHVybiBnZXRTY2hlbWFBdFByb3BQYXRoSW5uZXIoWy4uLnBhdGhdLCB2YWx1ZSwge1xuICAgIGtpbmQ6ICdvYmplY3QnLFxuICAgIGZpZWxkczogcHJvcHNcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRBbmNlc3RvclNjaGVtYXMocm9vdFNjaGVtYSwgcGF0aCwgdmFsdWUpIHtcbiAgY29uc3QgYW5jZXN0b3JzID0gW107XG4gIGNvbnN0IGN1cnJlbnRQYXRoID0gWy4uLnBhdGhdO1xuICBsZXQgY3VycmVudFByb3AgPSByb290U2NoZW1hO1xuICBsZXQgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gIHdoaWxlIChjdXJyZW50UGF0aC5sZW5ndGgpIHtcbiAgICBhbmNlc3RvcnMucHVzaChjdXJyZW50UHJvcCk7XG4gICAgY29uc3Qga2V5ID0gY3VycmVudFBhdGguc2hpZnQoKTsgLy8gdGhpcyBjb2RlIG9ubHkgcnVucyB3aGVuIHBhdGgubGVuZ3RoIGlzIHRydXRoeSBzbyB0aGlzIG5vbi1udWxsIGFzc2VydGlvbiBpcyBmaW5lXG4gICAgaWYgKGN1cnJlbnRQcm9wLmtpbmQgPT09ICdhcnJheScpIHtcbiAgICAgIGN1cnJlbnRQcm9wID0gY3VycmVudFByb3AuZWxlbWVudDtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZVtrZXldO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFByb3Aua2luZCA9PT0gJ2NvbmRpdGlvbmFsJykge1xuICAgICAgY3VycmVudFByb3AgPSBjdXJyZW50UHJvcC52YWx1ZXNbdmFsdWUuZGlzY3JpbWluYW50XTtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZS52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRQcm9wLmtpbmQgPT09ICdvYmplY3QnKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSBjdXJyZW50VmFsdWVba2V5XTtcbiAgICAgIGN1cnJlbnRQcm9wID0gY3VycmVudFByb3AuZmllbGRzW2tleV07XG4gICAgfSBlbHNlIGlmIChjdXJyZW50UHJvcC5raW5kID09PSAnY2hpbGQnIHx8IGN1cnJlbnRQcm9wLmtpbmQgPT09ICdmb3JtJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIHByb3AgXCIke2tleX1cImApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnROZXZlcihjdXJyZW50UHJvcCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhbmNlc3RvcnM7XG59XG5mdW5jdGlvbiBnZXRQbGFjZWhvbGRlclRleHRGb3JQcm9wUGF0aChwcm9wUGF0aCwgZmllbGRzLCBmb3JtUHJvcHMpIHtcbiAgY29uc3QgZmllbGQgPSBnZXRTY2hlbWFBdFByb3BQYXRoKHByb3BQYXRoLCBmb3JtUHJvcHMsIGZpZWxkcyk7XG4gIGlmICgoZmllbGQgPT09IG51bGwgfHwgZmllbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkLmtpbmQpID09PSAnY2hpbGQnICYmIChmaWVsZC5vcHRpb25zLmtpbmQgPT09ICdibG9jaycgJiYgZmllbGQub3B0aW9ucy5lZGl0SW4gIT09ICdtb2RhbCcgfHwgZmllbGQub3B0aW9ucy5raW5kID09PSAnaW5saW5lJykpIHtcbiAgICByZXR1cm4gZmllbGQub3B0aW9ucy5wbGFjZWhvbGRlcjtcbiAgfVxuICByZXR1cm4gJyc7XG59XG5mdW5jdGlvbiBjbG9uZURlc2NlbmRlbnQobm9kZSkge1xuICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5ub2RlLFxuICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4ubWFwKGNsb25lRGVzY2VuZGVudClcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4ubm9kZVxuICB9O1xufVxuXG5jb25zdCBhbGxNYXJrcyA9IFsnYm9sZCcsICdpdGFsaWMnLCAndW5kZXJsaW5lJywgJ3N0cmlrZXRocm91Z2gnLCAnY29kZScsICdzdXBlcnNjcmlwdCcsICdzdWJzY3JpcHQnLCAna2V5Ym9hcmQnXTtcbmNvbnN0IGlzRWxlbWVudEFjdGl2ZSA9IChlZGl0b3IsIGZvcm1hdCkgPT4ge1xuICBjb25zdCBbbWF0Y2hdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIG1hdGNoOiBuID0+IG4udHlwZSA9PT0gZm9ybWF0XG4gIH0pO1xuICByZXR1cm4gISFtYXRjaDtcbn07XG5mdW5jdGlvbiBjbGVhckZvcm1hdHRpbmcoZWRpdG9yKSB7XG4gIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgbWF0Y2g6IG5vZGUgPT4gbm9kZS50eXBlID09PSAnaGVhZGluZycgfHwgbm9kZS50eXBlID09PSAnYmxvY2txdW90ZScgfHwgbm9kZS50eXBlID09PSAnY29kZSdcbiAgfSk7XG4gIFRyYW5zZm9ybXMudW5zZXROb2RlcyhlZGl0b3IsIGFsbE1hcmtzLCB7XG4gICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gIH0pO1xufVxuZnVuY3Rpb24gbW92ZUNoaWxkcmVuKGVkaXRvciwgcGFyZW50LCB0bywgc2hvdWxkTW92ZU5vZGUgPSAoKSA9PiB0cnVlKSB7XG4gIGNvbnN0IHBhcmVudFBhdGggPSBQYXRoLmlzUGF0aChwYXJlbnQpID8gcGFyZW50IDogcGFyZW50WzFdO1xuICBjb25zdCBwYXJlbnROb2RlID0gUGF0aC5pc1BhdGgocGFyZW50KSA/IE5vZGUuZ2V0KGVkaXRvciwgcGFyZW50UGF0aCkgOiBwYXJlbnRbMF07XG4gIGlmICghaXNCbG9jayhwYXJlbnROb2RlKSkgcmV0dXJuO1xuICBmb3IgKGxldCBpID0gcGFyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChzaG91bGRNb3ZlTm9kZShwYXJlbnROb2RlLmNoaWxkcmVuW2ldLCBpKSkge1xuICAgICAgY29uc3QgY2hpbGRQYXRoID0gWy4uLnBhcmVudFBhdGgsIGldO1xuICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBjaGlsZFBhdGgsXG4gICAgICAgIHRvXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gRWRpdG9yLmFmdGVyIGV4Y2VwdCB0aGF0IGl0IGlnbm9yZXMgcG9pbnRzIHRoYXQgaGF2ZSBubyBjb250ZW50XG4gKiBsaWtlIHRoZSBwb2ludCBpbiBhIHZvaWQgdGV4dCBub2RlLCBhbiBlbXB0eSB0ZXh0IG5vZGUgYW5kIHRoZSBsYXN0IHBvaW50IGluIGEgdGV4dCBub2RlXG4gKi9cbi8vIFRPRE86IHRoaXMgd291bGQgcHJvYmFibHkgYnJlYWsgaWYgeW91IHdlcmUgdHJ5aW5nIHRvIGdldCB0aGUgbGFzdCBwb2ludCBpbiB0aGUgZWRpdG9yP1xuZnVuY3Rpb24gRWRpdG9yQWZ0ZXJCdXRJZ25vcmluZ2luZ1BvaW50c1dpdGhOb0NvbnRlbnQoZWRpdG9yLCBhdCwge1xuICBkaXN0YW5jZSA9IDFcbn0gPSB7fSkge1xuICBjb25zdCBhbmNob3IgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgIGVkZ2U6ICdlbmQnXG4gIH0pO1xuICBjb25zdCBmb2N1cyA9IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gIGNvbnN0IHJhbmdlID0ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xuICBsZXQgZCA9IDA7XG4gIGxldCB0YXJnZXQ7XG4gIGZvciAoY29uc3QgcCBvZiBFZGl0b3IucG9zaXRpb25zKGVkaXRvciwge1xuICAgIGF0OiByYW5nZVxuICB9KSkge1xuICAgIGlmIChkID4gZGlzdGFuY2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIHRoaXMgaXMgdGhlIGltcG9ydGFudCBjaGFuZ2VcbiAgICBjb25zdCBub2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwLnBhdGgpO1xuICAgIGlmIChub2RlLnRleHQubGVuZ3RoID09PSBwLm9mZnNldCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChkICE9PSAwKSB7XG4gICAgICB0YXJnZXQgPSBwO1xuICAgIH1cbiAgICBkKys7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIG5vZGVUeXBlTWF0Y2hlciguLi5hcmdzKSB7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHR5cGUgPSBhcmdzWzBdO1xuICAgIHJldHVybiBub2RlID0+IG5vZGUudHlwZSA9PT0gdHlwZTtcbiAgfVxuICBjb25zdCBzZXQgPSBuZXcgU2V0KGFyZ3MpO1xuICByZXR1cm4gbm9kZSA9PiB0eXBlb2Ygbm9kZS50eXBlID09PSAnc3RyaW5nJyAmJiBzZXQuaGFzKG5vZGUudHlwZSk7XG59XG5mdW5jdGlvbiBnZXRBbmNlc3RvckNvbXBvbmVudENoaWxkRmllbGREb2N1bWVudEZlYXR1cmVzKGVkaXRvciwgZWRpdG9yRG9jdW1lbnRGZWF0dXJlcywgY29tcG9uZW50QmxvY2tzKSB7XG4gIGNvbnN0IGFuY2VzdG9yQ29tcG9uZW50UHJvcCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICBtYXRjaDogbm9kZVR5cGVNYXRjaGVyKCdjb21wb25lbnQtYmxvY2stcHJvcCcsICdjb21wb25lbnQtaW5saW5lLXByb3AnKVxuICB9KTtcbiAgaWYgKGFuY2VzdG9yQ29tcG9uZW50UHJvcCkge1xuICAgIGNvbnN0IHByb3BQYXRoID0gYW5jZXN0b3JDb21wb25lbnRQcm9wWzBdLnByb3BQYXRoO1xuICAgIGNvbnN0IGFuY2VzdG9yQ29tcG9uZW50ID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGFuY2VzdG9yQ29tcG9uZW50UHJvcFsxXSk7XG4gICAgaWYgKGFuY2VzdG9yQ29tcG9uZW50WzBdLnR5cGUgPT09ICdjb21wb25lbnQtYmxvY2snKSB7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSBhbmNlc3RvckNvbXBvbmVudFswXS5jb21wb25lbnQ7XG4gICAgICBjb25zdCBjb21wb25lbnRCbG9jayA9IGNvbXBvbmVudEJsb2Nrc1tjb21wb25lbnRdO1xuICAgICAgaWYgKGNvbXBvbmVudEJsb2NrICYmIHByb3BQYXRoKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkRmllbGQgPSBnZXRTY2hlbWFBdFByb3BQYXRoKHByb3BQYXRoLCBhbmNlc3RvckNvbXBvbmVudFswXS5wcm9wcywgY29tcG9uZW50QmxvY2suc2NoZW1hKTtcbiAgICAgICAgaWYgKChjaGlsZEZpZWxkID09PSBudWxsIHx8IGNoaWxkRmllbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoaWxkRmllbGQua2luZCkgPT09ICdjaGlsZCcpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RG9jdW1lbnRGZWF0dXJlc0ZvckNoaWxkRmllbGQoZWRpdG9yRG9jdW1lbnRGZWF0dXJlcywgY2hpbGRGaWVsZC5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyB0aGlzIGlzIHVzZWQgaW4gcmVhY3Qtc2VydmVyIGVudmlyb25tZW50cyB0byBhdm9pZCBidW5kbGluZyBVSSB3aGVuIHRoZSByZWFkZXIgQVBJIGlzIHVzZWRcbi8vIGlmIHlvdSBhZGRlZCBhIG5ldyBmaWVsZCBhbmQgZ2V0IGFuIGVycm9yIHRoYXQgdGhlcmUncyBtaXNzaW5nIGEgbWlzc2luZyBleHBvcnQgaGVyZSxcbi8vIHlvdSBwcm9iYWJseSBqdXN0IG5lZWQgdG8gYWRkIGFub3RoZXIgZW1wdHkgZXhwb3J0IGhlcmVcblxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgY2FsbCB0byBmdW5jdGlvbiB0aGF0IHNob3VsZG4ndCBiZSBjYWxsZWQgaW4gUmVhY3Qgc2VydmVyIGNvbXBvbmVudCBlbnZpcm9ubWVudFwiKTtcbn1cbmxldCBTbHVnRmllbGRJbnB1dCA9IGVtcHR5LFxuICBUZXh0RmllbGRJbnB1dCA9IGVtcHR5LFxuICBVcmxGaWVsZElucHV0ID0gZW1wdHksXG4gIFNlbGVjdEZpZWxkSW5wdXQgPSBlbXB0eSxcbiAgUmVsYXRpb25zaGlwSW5wdXQgPSBlbXB0eSxcbiAgUGF0aFJlZmVyZW5jZUlucHV0ID0gZW1wdHksXG4gIE11bHRpc2VsZWN0RmllbGRJbnB1dCA9IGVtcHR5LFxuICBJbnRlZ2VyRmllbGRJbnB1dCA9IGVtcHR5LFxuICBOdW1iZXJGaWVsZElucHV0ID0gZW1wdHksXG4gIEltYWdlRmllbGRJbnB1dCA9IGVtcHR5LFxuICBGaWxlRmllbGRJbnB1dCA9IGVtcHR5LFxuICBEYXRldGltZUZpZWxkSW5wdXQgPSBlbXB0eSxcbiAgRGF0ZUZpZWxkSW5wdXQgPSBlbXB0eSxcbiAgQ2xvdWRJbWFnZUZpZWxkSW5wdXQgPSBlbXB0eSxcbiAgQmxvY2tzRmllbGRJbnB1dCA9IGVtcHR5LFxuICBEb2N1bWVudEZpZWxkSW5wdXQgPSBlbXB0eSxcbiAgQ2hlY2tib3hGaWVsZElucHV0ID0gZW1wdHksXG4gIGNyZWF0ZUVkaXRvclNjaGVtYSA9IGVtcHR5LFxuICBnZXREZWZhdWx0VmFsdWUgPSBlbXB0eSxcbiAgcGFyc2VUb0VkaXRvclN0YXRlID0gZW1wdHksXG4gIHNlcmlhbGl6ZUZyb21FZGl0b3JTdGF0ZSA9IGVtcHR5LFxuICBwYXJzZVRvRWRpdG9yU3RhdGVNRFggPSBlbXB0eSxcbiAgc2VyaWFsaXplRnJvbUVkaXRvclN0YXRlTURYID0gZW1wdHk7XG5cbmNsYXNzIEZpZWxkRGF0YUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ0ZpZWxkRGF0YUVycm9yJztcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRSZXF1aXJlZCh2YWx1ZSwgdmFsaWRhdGlvbiwgbGFiZWwpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsICYmIHZhbGlkYXRpb24gIT09IG51bGwgJiYgdmFsaWRhdGlvbiAhPT0gdm9pZCAwICYmIHZhbGlkYXRpb24uaXNSZXF1aXJlZCkge1xuICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcihgJHtsYWJlbH0gaXMgcmVxdWlyZWRgKTtcbiAgfVxufVxuZnVuY3Rpb24gYmFzaWNGb3JtRmllbGRXaXRoU2ltcGxlUmVhZGVyUGFyc2UoY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogJ2Zvcm0nLFxuICAgIElucHV0OiBjb25maWcuSW5wdXQsXG4gICAgZGVmYXVsdFZhbHVlOiBjb25maWcuZGVmYXVsdFZhbHVlLFxuICAgIHBhcnNlOiBjb25maWcucGFyc2UsXG4gICAgc2VyaWFsaXplOiBjb25maWcuc2VyaWFsaXplLFxuICAgIHZhbGlkYXRlOiBjb25maWcudmFsaWRhdGUsXG4gICAgcmVhZGVyOiB7XG4gICAgICBwYXJzZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY29uZmlnLnZhbGlkYXRlKGNvbmZpZy5wYXJzZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGFiZWw6IGNvbmZpZy5sYWJlbFxuICB9O1xufVxuXG5jb25zdCBhcnJheVZhbHVlc1RvRWxlbWVudEtleXMgPSBuZXcgV2Vha01hcCgpO1xubGV0IGNvdW50ZXIgPSAwO1xuZnVuY3Rpb24gZ2V0S2V5c0ZvckFycmF5VmFsdWUodmFsdWUpIHtcbiAgaWYgKCFhcnJheVZhbHVlc1RvRWxlbWVudEtleXMuaGFzKHZhbHVlKSkge1xuICAgIGFycmF5VmFsdWVzVG9FbGVtZW50S2V5cy5zZXQodmFsdWUsIEFycmF5LmZyb20oe1xuICAgICAgbGVuZ3RoOiB2YWx1ZS5sZW5ndGhcbiAgICB9LCBnZXROZXdBcnJheUVsZW1lbnRLZXkpKTtcbiAgfVxuICByZXR1cm4gYXJyYXlWYWx1ZXNUb0VsZW1lbnRLZXlzLmdldCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRLZXlzRm9yQXJyYXlWYWx1ZSh2YWx1ZSwgZWxlbWVudElkcykge1xuICBhcnJheVZhbHVlc1RvRWxlbWVudEtleXMuc2V0KHZhbHVlLCBlbGVtZW50SWRzKTtcbn1cbmZ1bmN0aW9uIGdldE5ld0FycmF5RWxlbWVudEtleSgpIHtcbiAgcmV0dXJuIChjb3VudGVyKyspLnRvU3RyaW5nKCk7XG59XG5jb25zdCBnZXRJbml0aWFsUHJvcHNWYWx1ZSA9IF9nZXRJbml0aWFsUHJvcHNWYWx1ZTtcbmZ1bmN0aW9uIF9nZXRJbml0aWFsUHJvcHNWYWx1ZShzY2hlbWEpIHtcbiAgc3dpdGNoIChzY2hlbWEua2luZCkge1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgcmV0dXJuIHNjaGVtYS5kZWZhdWx0VmFsdWUoKTtcbiAgICBjYXNlICdjaGlsZCc6XG4gICAgICByZXR1cm4gc2NoZW1hLm9wdGlvbnMua2luZCA9PT0gJ2Jsb2NrJyA/IFt7XG4gICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICB9XVxuICAgICAgfV0gOiBudWxsO1xuICAgIGNhc2UgJ2NvbmRpdGlvbmFsJzpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gc2NoZW1hLmRpc2NyaW1pbmFudC5kZWZhdWx0VmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXNjcmltaW5hbnQ6IGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICB2YWx1ZTogZ2V0SW5pdGlhbFByb3BzVmFsdWUoc2NoZW1hLnZhbHVlc1tkZWZhdWx0VmFsdWUudG9TdHJpbmcoKV0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYS5maWVsZHMpKSB7XG4gICAgICAgICAgb2JqW2tleV0gPSBnZXRJbml0aWFsUHJvcHNWYWx1ZShzY2hlbWEuZmllbGRzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gIH1cbiAgYXNzZXJ0TmV2ZXIoc2NoZW1hKTtcbn1cbmZ1bmN0aW9uIGdldEluaXRpYWxQcm9wc1ZhbHVlRnJvbUluaXRpYWxpemVyKHNjaGVtYSwgaW5pdGlhbGl6ZXIpIHtcbiAgc3dpdGNoIChzY2hlbWEua2luZCkge1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgcmV0dXJuIGluaXRpYWxpemVyID09PSB1bmRlZmluZWQgPyBzY2hlbWEuZGVmYXVsdFZhbHVlKCkgOiBpbml0aWFsaXplcjtcbiAgICBjYXNlICdjaGlsZCc6XG4gICAgICByZXR1cm4gaW5pdGlhbGl6ZXIgIT09IG51bGwgJiYgaW5pdGlhbGl6ZXIgIT09IHZvaWQgMCA/IGluaXRpYWxpemVyIDogc2NoZW1hLm9wdGlvbnMua2luZCA9PT0gJ2Jsb2NrJyA/IFt7XG4gICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICB9XVxuICAgICAgfV0gOiBudWxsO1xuICAgIGNhc2UgJ2NvbmRpdGlvbmFsJzpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gaW5pdGlhbGl6ZXIgPT09IHVuZGVmaW5lZCA/IHNjaGVtYS5kaXNjcmltaW5hbnQuZGVmYXVsdFZhbHVlKCkgOiBpbml0aWFsaXplci5kaXNjcmltaW5hbnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlzY3JpbWluYW50OiBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgdmFsdWU6IGdldEluaXRpYWxQcm9wc1ZhbHVlRnJvbUluaXRpYWxpemVyKHNjaGVtYS52YWx1ZXNbZGVmYXVsdFZhbHVlLnRvU3RyaW5nKCldLCBpbml0aWFsaXplciA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogaW5pdGlhbGl6ZXIudmFsdWUpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYS5maWVsZHMpKSB7XG4gICAgICAgICAgb2JqW2tleV0gPSBnZXRJbml0aWFsUHJvcHNWYWx1ZUZyb21Jbml0aWFsaXplcihzY2hlbWEuZmllbGRzW2tleV0sIGluaXRpYWxpemVyID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBpbml0aWFsaXplcltrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIChpbml0aWFsaXplciAhPT0gbnVsbCAmJiBpbml0aWFsaXplciAhPT0gdm9pZCAwID8gaW5pdGlhbGl6ZXIgOiBbXSkubWFwKHggPT4gZ2V0SW5pdGlhbFByb3BzVmFsdWVGcm9tSW5pdGlhbGl6ZXIoc2NoZW1hLmVsZW1lbnQsIHgudmFsdWUpKTtcbiAgICAgIH1cbiAgfVxuICBhc3NlcnROZXZlcihzY2hlbWEpO1xufVxuZnVuY3Rpb24gdXBkYXRlVmFsdWUoc2NoZW1hLCBjdXJyZW50VmFsdWUsIHVwZGF0ZXIpIHtcbiAgaWYgKHVwZGF0ZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgc3dpdGNoIChzY2hlbWEua2luZCkge1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgcmV0dXJuIHVwZGF0ZXI7XG4gICAgY2FzZSAnY2hpbGQnOlxuICAgICAgcmV0dXJuIHVwZGF0ZXI7XG4gICAgY2FzZSAnY29uZGl0aW9uYWwnOlxuICAgICAge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpc2NyaW1pbmFudDogdXBkYXRlci5kaXNjcmltaW5hbnQsXG4gICAgICAgICAgdmFsdWU6IHVwZGF0ZXIuZGlzY3JpbWluYW50ID09PSBjdXJyZW50VmFsdWUuZGlzY3JpbWluYW50ID8gdXBkYXRlVmFsdWUoc2NoZW1hLnZhbHVlc1t1cGRhdGVyLmRpc2NyaW1pbmFudC50b1N0cmluZygpXSwgY3VycmVudFZhbHVlLnZhbHVlLCB1cGRhdGVyLnZhbHVlKSA6IGdldEluaXRpYWxQcm9wc1ZhbHVlRnJvbUluaXRpYWxpemVyKHNjaGVtYS52YWx1ZXNbdXBkYXRlci5kaXNjcmltaW5hbnQudG9TdHJpbmcoKV0sIHVwZGF0ZXIudmFsdWUpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYS5maWVsZHMpKSB7XG4gICAgICAgICAgb2JqW2tleV0gPSB1cGRhdGVWYWx1ZShzY2hlbWEuZmllbGRzW2tleV0sIGN1cnJlbnRWYWx1ZVtrZXldLCB1cGRhdGVyW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAge1xuICAgICAgICBjb25zdCBjdXJyZW50QXJyVmFsID0gY3VycmVudFZhbHVlO1xuICAgICAgICBjb25zdCBuZXdWYWwgPSB1cGRhdGVyO1xuICAgICAgICBjb25zdCB1bmlxdWVLZXlzID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHggb2YgbmV3VmFsKSB7XG4gICAgICAgICAgaWYgKHgua2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh1bmlxdWVLZXlzLmhhcyh4LmtleSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheSBlbGVtZW50cyBtdXN0IGhhdmUgdW5pcXVlIGtleXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVuaXF1ZUtleXMuYWRkKHgua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IG5ld1ZhbC5tYXAoeCA9PiB7XG4gICAgICAgICAgaWYgKHgua2V5ICE9PSB1bmRlZmluZWQpIHJldHVybiB4LmtleTtcbiAgICAgICAgICBsZXQgZWxlbWVudEtleSA9IGdldE5ld0FycmF5RWxlbWVudEtleSgpO1xuICAgICAgICAgIC8vIGp1c3QgaW4gY2FzZSBzb21lb25lIGdpdmVzIGEga2V5IHRoYXQgaXMgYWJvdmUgb3VyIGNvdW50ZXJcbiAgICAgICAgICB3aGlsZSAodW5pcXVlS2V5cy5oYXMoZWxlbWVudEtleSkpIHtcbiAgICAgICAgICAgIGVsZW1lbnRLZXkgPSBnZXROZXdBcnJheUVsZW1lbnRLZXkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5pcXVlS2V5cy5hZGQoZWxlbWVudEtleSk7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRLZXk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcmV2S2V5cyA9IGdldEtleXNGb3JBcnJheVZhbHVlKGN1cnJlbnRBcnJWYWwpO1xuICAgICAgICBjb25zdCBwcmV2VmFsdWVzQnlLZXkgPSBuZXcgTWFwKGN1cnJlbnRBcnJWYWwubWFwKCh2YWx1ZSwgaSkgPT4ge1xuICAgICAgICAgIHJldHVybiBbcHJldktleXNbaV0sIHZhbHVlXTtcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB2YWwgPSBuZXdWYWwubWFwKCh4LCBpKSA9PiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChwcmV2VmFsdWVzQnlLZXkuaGFzKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVZhbHVlKHNjaGVtYS5lbGVtZW50LCBwcmV2VmFsdWVzQnlLZXkuZ2V0KGlkKSwgeC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnZXRJbml0aWFsUHJvcHNWYWx1ZUZyb21Jbml0aWFsaXplcihzY2hlbWEuZWxlbWVudCwgeC52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXRLZXlzRm9yQXJyYXlWYWx1ZSh2YWwsIGtleXMpO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICB9XG4gIGFzc2VydE5ldmVyKHNjaGVtYSk7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlQXRQcm9wUGF0aCh2YWx1ZSwgaW5wdXRQYXRoKSB7XG4gIGNvbnN0IHBhdGggPSBbLi4uaW5wdXRQYXRoXTtcbiAgd2hpbGUgKHBhdGgubGVuZ3RoKSB7XG4gICAgY29uc3Qga2V5ID0gcGF0aC5zaGlmdCgpO1xuICAgIHZhbHVlID0gdmFsdWVba2V5XTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVByb3BzKHNjaGVtYSwgdmFsdWUsIHZpc2l0b3IsIHBhdGggPSBbXSkge1xuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdmb3JtJyB8fCBzY2hlbWEua2luZCA9PT0gJ2NoaWxkJykge1xuICAgIHZpc2l0b3Ioc2NoZW1hLCB2YWx1ZSwgcGF0aCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGNoaWxkUHJvcF0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLmZpZWxkcykpIHtcbiAgICAgIHRyYXZlcnNlUHJvcHMoY2hpbGRQcm9wLCB2YWx1ZVtrZXldLCB2aXNpdG9yLCBbLi4ucGF0aCwga2V5XSk7XG4gICAgfVxuICAgIHZpc2l0b3Ioc2NoZW1hLCB2YWx1ZSwgcGF0aCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ2FycmF5Jykge1xuICAgIGZvciAoY29uc3QgW2lkeCwgdmFsXSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgIHRyYXZlcnNlUHJvcHMoc2NoZW1hLmVsZW1lbnQsIHZhbCwgdmlzaXRvciwgcGF0aC5jb25jYXQoaWR4KSk7XG4gICAgfVxuICAgIHJldHVybiB2aXNpdG9yKHNjaGVtYSwgdmFsdWUsIHBhdGgpO1xuICB9XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ2NvbmRpdGlvbmFsJykge1xuICAgIGNvbnN0IGRpc2NyaW1pbmFudCA9IHZhbHVlLmRpc2NyaW1pbmFudDtcbiAgICB2aXNpdG9yKHNjaGVtYSwgZGlzY3JpbWluYW50LCBwYXRoLmNvbmNhdCgnZGlzY3JpbWluYW50JykpO1xuICAgIHRyYXZlcnNlUHJvcHMoc2NoZW1hLnZhbHVlc1tkaXNjcmltaW5hbnQudG9TdHJpbmcoKV0sIHZhbHVlLnZhbHVlLCB2aXNpdG9yLCBwYXRoLmNvbmNhdCgndmFsdWUnKSk7XG4gICAgdmlzaXRvcihzY2hlbWEsIHZhbHVlLCBwYXRoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0TmV2ZXIkMShzY2hlbWEpO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtUHJvcHMoc2NoZW1hLCB2YWx1ZSwgdmlzaXRvcnMsIHBhdGggPSBbXSkge1xuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdmb3JtJyB8fCBzY2hlbWEua2luZCA9PT0gJ2NoaWxkJykge1xuICAgIGlmICh2aXNpdG9yc1tzY2hlbWEua2luZF0pIHtcbiAgICAgIHJldHVybiB2aXNpdG9yc1tzY2hlbWEua2luZF0oc2NoZW1hLCB2YWx1ZSwgcGF0aCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgdmFsID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHNjaGVtYS5maWVsZHMpLm1hcCgoW2tleSwgdmFsXSkgPT4ge1xuICAgICAgcmV0dXJuIFtrZXksIHRyYW5zZm9ybVByb3BzKHZhbCwgdmFsdWVba2V5XSwgdmlzaXRvcnMsIFsuLi5wYXRoLCBrZXldKV07XG4gICAgfSkpO1xuICAgIGlmICh2aXNpdG9ycy5vYmplY3QpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yc1tzY2hlbWEua2luZF0oc2NoZW1hLCB2YWwsIHBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ2FycmF5Jykge1xuICAgIGNvbnN0IHZhbCA9IHZhbHVlLm1hcCgodmFsLCBpZHgpID0+IHRyYW5zZm9ybVByb3BzKHNjaGVtYS5lbGVtZW50LCB2YWwsIHZpc2l0b3JzLCBwYXRoLmNvbmNhdChpZHgpKSk7XG4gICAgaWYgKHZpc2l0b3JzLmFycmF5KSB7XG4gICAgICByZXR1cm4gdmlzaXRvcnNbc2NoZW1hLmtpbmRdKHNjaGVtYSwgdmFsLCBwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdjb25kaXRpb25hbCcpIHtcbiAgICBjb25zdCBkaXNjcmltaW5hbnQgPSB0cmFuc2Zvcm1Qcm9wcyhzY2hlbWEuZGlzY3JpbWluYW50LCB2YWx1ZS5kaXNjcmltaW5hbnQsIHZpc2l0b3JzLCBwYXRoLmNvbmNhdCgnZGlzY3JpbWluYW50JykpO1xuICAgIGNvbnN0IGNvbmRpdGlvbmFsVmFsID0gdHJhbnNmb3JtUHJvcHMoc2NoZW1hLnZhbHVlc1tkaXNjcmltaW5hbnQudG9TdHJpbmcoKV0sIHZhbHVlLnZhbHVlLCB2aXNpdG9ycywgcGF0aC5jb25jYXQoJ3ZhbHVlJykpO1xuICAgIGNvbnN0IHZhbCA9IHtcbiAgICAgIGRpc2NyaW1pbmFudCxcbiAgICAgIHZhbHVlOiBjb25kaXRpb25hbFZhbFxuICAgIH07XG4gICAgaWYgKHZpc2l0b3JzLmNvbmRpdGlvbmFsKSB7XG4gICAgICByZXR1cm4gdmlzaXRvcnNbc2NoZW1hLmtpbmRdKHNjaGVtYSwgdmFsLCBwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBhc3NlcnROZXZlciQxKHNjaGVtYSk7XG59XG5mdW5jdGlvbiByZXBsYWNlVmFsdWVBdFByb3BQYXRoKHNjaGVtYSwgdmFsdWUsIG5ld1ZhbHVlLCBwYXRoKSB7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgfVxuICBjb25zdCBba2V5LCAuLi5uZXdQYXRoXSA9IHBhdGg7XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udmFsdWUsXG4gICAgICBba2V5XTogcmVwbGFjZVZhbHVlQXRQcm9wUGF0aChzY2hlbWEuZmllbGRzW2tleV0sIHZhbHVlW2tleV0sIG5ld1ZhbHVlLCBuZXdQYXRoKVxuICAgIH07XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnY29uZGl0aW9uYWwnKSB7XG4gICAgY29uc3QgY29uZGl0aW9uYWxWYWx1ZSA9IHZhbHVlO1xuICAgIC8vIHJlcGxhY2VWYWx1ZUF0UHJvcFBhdGggc2hvdWxkIG5vdCBiZSB1c2VkIHRvIG9ubHkgdXBkYXRlIHRoZSBkaXNjcmltaW5hbnQgb2YgYSBjb25kaXRpb25hbCBmaWVsZFxuICAgIC8vIGlmIHlvdSB3YW50IHRvIHVwZGF0ZSB0aGUgZGlzY3JpbWluYW50IG9mIGEgY29uZGl0aW9uYWwgZmllbGQsIHJlcGxhY2UgdGhlIHZhbHVlIG9mIHRoZSB3aG9sZSBjb25kaXRpb25hbCBmaWVsZFxuICAgIGFzc2VydCQxKGtleSA9PT0gJ3ZhbHVlJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc2NyaW1pbmFudDogY29uZGl0aW9uYWxWYWx1ZS5kaXNjcmltaW5hbnQsXG4gICAgICB2YWx1ZTogcmVwbGFjZVZhbHVlQXRQcm9wUGF0aChzY2hlbWEudmFsdWVzW2tleV0sIGNvbmRpdGlvbmFsVmFsdWUudmFsdWUsIG5ld1ZhbHVlLCBuZXdQYXRoKVxuICAgIH07XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnYXJyYXknKSB7XG4gICAgY29uc3QgcHJldlZhbCA9IHZhbHVlO1xuICAgIGNvbnN0IG5ld1ZhbCA9IFsuLi5wcmV2VmFsXTtcbiAgICBzZXRLZXlzRm9yQXJyYXlWYWx1ZShuZXdWYWwsIGdldEtleXNGb3JBcnJheVZhbHVlKHByZXZWYWwpKTtcbiAgICBuZXdWYWxba2V5XSA9IHJlcGxhY2VWYWx1ZUF0UHJvcFBhdGgoc2NoZW1hLmVsZW1lbnQsIG5ld1ZhbFtrZXldLCBuZXdWYWx1ZSwgbmV3UGF0aCk7XG4gICAgcmV0dXJuIG5ld1ZhbDtcbiAgfVxuXG4gIC8vIHdlIHNob3VsZCBuZXZlciByZWFjaCBoZXJlIHNpbmNlIGZvcm0gb3IgY2hpbGQgZmllbGRzIGRvbid0IGNvbnRhaW4gb3RoZXIgZmllbGRzXG4gIC8vIHNvIHRoZSBvbmx5IHRoaW5nIHRoYXQgY2FuIGhhcHBlbiB0byB0aGVtIGlzIHRvIGJlIHJlcGxhY2VkIHdoaWNoIGhhcHBlbnMgYXQgdGhlIHN0YXJ0IG9mIHRoaXMgZnVuY3Rpb24gd2hlbiBwYXRoLmxlbmd0aCA9PT0gMFxuICBhc3NlcnQkMShzY2hlbWEua2luZCAhPT0gJ2Zvcm0nICYmIHNjaGVtYS5raW5kICE9PSAnY2hpbGQnKTtcbiAgYXNzZXJ0TmV2ZXIkMShzY2hlbWEpO1xufVxuXG4vLyBhIHYgaW1wb3J0YW50IG5vdGVcbi8vIG1hcmtzIGluIHRoZSBtYXJrZG93biBhc3QvaHRtbCBhcmUgcmVwcmVzZW50ZWQgcXVpdGUgZGlmZmVyZW50bHkgdG8gaG93IHRoZXkgYXJlIGluIHNsYXRlXG4vLyBpZiB5b3UgaGFkIHRoZSBtYXJrZG93biAqKnNvbWV0aGluZyBodHRwczovL2tleXN0b25lanMuY29tIHNvbWV0aGluZyoqXG4vLyB0aGUgYm9sZCBub2RlIGlzIHRoZSBwYXJlbnQgb2YgdGhlIGxpbmsgbm9kZVxuLy8gYnV0IGluIHNsYXRlLCBtYXJrcyBhcmUgb25seSByZXByZXNlbnRlZCBvbiB0ZXh0IG5vZGVzXG5cbmNvbnN0IGN1cnJlbnRseUFjdGl2ZU1hcmtzID0gbmV3IFNldCgpO1xuY29uc3QgY3VycmVudGx5RGlzYWJsZWRNYXJrcyA9IG5ldyBTZXQoKTtcbmxldCBjdXJyZW50TGluayA9IG51bGw7XG5mdW5jdGlvbiBhZGRNYXJrVG9DaGlsZHJlbihtYXJrLCBjYikge1xuICBjb25zdCB3YXNQcmV2aW91c2x5QWN0aXZlID0gY3VycmVudGx5QWN0aXZlTWFya3MuaGFzKG1hcmspO1xuICBjdXJyZW50bHlBY3RpdmVNYXJrcy5hZGQobWFyayk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNiKCk7XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKCF3YXNQcmV2aW91c2x5QWN0aXZlKSB7XG4gICAgICBjdXJyZW50bHlBY3RpdmVNYXJrcy5kZWxldGUobWFyayk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRMaW5rRm9yQ2hpbGRyZW4oaHJlZiwgY2IpIHtcbiAgLy8gd2UnbGwgb25seSB1c2UgdGhlIG91dGVyIGxpbmtcbiAgaWYgKGN1cnJlbnRMaW5rICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNiKCk7XG4gIH1cbiAgY3VycmVudExpbmsgPSBocmVmO1xuICB0cnkge1xuICAgIHJldHVybiBjYigpO1xuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRMaW5rID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gYWRkTWFya3NUb0NoaWxkcmVuKG1hcmtzLCBjYikge1xuICBjb25zdCBtYXJrc1RvUmVtb3ZlID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IG1hcmsgb2YgbWFya3MpIHtcbiAgICBpZiAoIWN1cnJlbnRseUFjdGl2ZU1hcmtzLmhhcyhtYXJrKSkge1xuICAgICAgbWFya3NUb1JlbW92ZS5hZGQobWFyayk7XG4gICAgfVxuICAgIGN1cnJlbnRseUFjdGl2ZU1hcmtzLmFkZChtYXJrKTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBjYigpO1xuICB9IGZpbmFsbHkge1xuICAgIGZvciAoY29uc3QgbWFyayBvZiBtYXJrc1RvUmVtb3ZlKSB7XG4gICAgICBjdXJyZW50bHlBY3RpdmVNYXJrcy5kZWxldGUobWFyayk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmb3JjZURpc2FibGVNYXJrRm9yQ2hpbGRyZW4obWFyaywgY2IpIHtcbiAgY29uc3Qgd2FzUHJldmlvdXNseURpc2FibGVkID0gY3VycmVudGx5RGlzYWJsZWRNYXJrcy5oYXMobWFyayk7XG4gIGN1cnJlbnRseURpc2FibGVkTWFya3MuYWRkKG1hcmspO1xuICB0cnkge1xuICAgIHJldHVybiBjYigpO1xuICB9IGZpbmFsbHkge1xuICAgIGlmICghd2FzUHJldmlvdXNseURpc2FibGVkKSB7XG4gICAgICBjdXJyZW50bHlEaXNhYmxlZE1hcmtzLmRlbGV0ZShtYXJrKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHR5cGUgaXMgbW9yZSBzdHJpY3QgdGhhbiBgRWxlbWVudCAmIHsgdHlwZTogJ2xpbmsnOyB9YCBiZWNhdXNlIGBjaGlsZHJlbmBcbiAqIGlzIGNvbnN0cmFpbmVkIHRvIG9ubHkgY29udGFpbiBUZXh0IG5vZGVzLiBUaGlzIGNhbid0IGJlIGFzc3VtZWQgZ2VuZXJhbGx5IGFyb3VuZCB0aGUgZWRpdG9yXG4gKiAoYmVjYXVzZSBvZiBwb3RlbnRpYWxseSBmdXR1cmUgaW5saW5lIGNvbXBvbmVudHMgb3IgbmVzdGVkIGxpbmtzKHdoaWNoIGFyZSBub3JtYWxpemVkIGF3YXkgYnV0IHRoZSBlZGl0b3IgbmVlZHMgdG8gbm90IGJyZWFrIGlmIGl0IGhhcHBlbnMpKVxuICogYnV0IHdoZXJlIHRoaXMgdHlwZSBpcyB1c2VkLCB3ZSdyZSBvbmx5IGdvaW5nIHRvIGFsbG93IGxpbmtzIHRvIGNvbnRhaW4gVGV4dCBhbmQgdGhhdCdzIGltcG9ydGFudFxuICogc28gdGhhdCB3ZSBrbm93IGEgYmxvY2sgd2lsbCBuZXZlciBiZSBpbnNpZGUgYW4gaW5saW5lIGJlY2F1c2UgU2xhdGUgZ2V0cyB1bmhhcHB5IHdoZW4gdGhhdCBoYXBwZW5zXG4gKiAocmVhbGx5IHRoZSBsaW5rIGlubGluZSBzaG91bGQgcHJvYmFibHkgYmUgYSBtYXJrIHJhdGhlciB0aGFuIGFuIGlubGluZSxcbiAqIG5vbi12b2lkIGlubGluZXMgYXJlIHByb2JhYmx5IGFsd2F5cyBiYWQgYnV0IHRoYXQgd291bGQgaW1wbHkgY2hhbmdpbmcgdGhlIGRvY3VtZW50XG4gKiBzdHJ1Y3R1cmUgd2hpY2ggd291bGQgYmUgc3VjaCB1bm5lY2Vzc2FyeSBicmVha2FnZSlcbiAqL1xuXG5mdW5jdGlvbiBnZXRJbmxpbmVOb2Rlcyh0ZXh0KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdGV4dFxuICB9O1xuICBmb3IgKGNvbnN0IG1hcmsgb2YgY3VycmVudGx5QWN0aXZlTWFya3MpIHtcbiAgICBpZiAoIWN1cnJlbnRseURpc2FibGVkTWFya3MuaGFzKG1hcmspKSB7XG4gICAgICBub2RlW21hcmtdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGN1cnJlbnRMaW5rICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIFt7XG4gICAgICB0ZXh0OiAnJ1xuICAgIH0sIHtcbiAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgIGhyZWY6IGN1cnJlbnRMaW5rLFxuICAgICAgY2hpbGRyZW46IFtub2RlXVxuICAgIH0sIHtcbiAgICAgIHRleHQ6ICcnXG4gICAgfV07XG4gIH1cbiAgcmV0dXJuIFtub2RlXTtcbn1cblxuY2xhc3MgVmFyaWFibGVDaGlsZEZpZWxkcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ1RoZXJlIGFyZSBhIHZhcmlhYmxlIG51bWJlciBvZiBjaGlsZCBmaWVsZHMnKTtcbiAgfVxufVxuZnVuY3Rpb24gZmluZFNpbmdsZUNoaWxkRmllbGQoc2NoZW1hKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gX2ZpbmRDb25zdGFudENoaWxkRmllbGRzKHNjaGVtYSwgW10sIG5ldyBTZXQoKSk7XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgfVxuICAgIHJldHVybjtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFZhcmlhYmxlQ2hpbGRGaWVsZHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5mdW5jdGlvbiBfZmluZENvbnN0YW50Q2hpbGRGaWVsZHMoc2NoZW1hLCBwYXRoLCBzZWVuU2NoZW1hcykge1xuICBpZiAoc2VlblNjaGVtYXMuaGFzKHNjaGVtYSkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgc2VlblNjaGVtYXMuYWRkKHNjaGVtYSk7XG4gIHN3aXRjaCAoc2NoZW1hLmtpbmQpIHtcbiAgICBjYXNlICdmb3JtJzpcbiAgICAgIHJldHVybiBbXTtcbiAgICBjYXNlICdjaGlsZCc6XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgcmVsYXRpdmVQYXRoOiBwYXRoLFxuICAgICAgICBvcHRpb25zOiBzY2hlbWEub3B0aW9ucyxcbiAgICAgICAga2luZDogJ2NoaWxkJ1xuICAgICAgfV07XG4gICAgY2FzZSAnY29uZGl0aW9uYWwnOlxuICAgICAge1xuICAgICAgICBpZiAoY291bGRDb250YWluQ2hpbGRGaWVsZChzY2hlbWEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhcmlhYmxlQ2hpbGRGaWVsZHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAge1xuICAgICAgICBpZiAoc2NoZW1hLmFzQ2hpbGRUYWcpIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IF9maW5kQ29uc3RhbnRDaGlsZEZpZWxkcyhzY2hlbWEuZWxlbWVudCwgW10sIHNlZW5TY2hlbWFzKTtcbiAgICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgIGtpbmQ6ICdhcnJheScsXG4gICAgICAgICAgICBhc0NoaWxkVGFnOiBzY2hlbWEuYXNDaGlsZFRhZyxcbiAgICAgICAgICAgIGZpZWxkOiBzY2hlbWEsXG4gICAgICAgICAgICByZWxhdGl2ZVBhdGg6IHBhdGgsXG4gICAgICAgICAgICBjaGlsZDogY2hpbGRbMF1cbiAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bGRDb250YWluQ2hpbGRGaWVsZChzY2hlbWEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhcmlhYmxlQ2hpbGRGaWVsZHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLmZpZWxkcykpIHtcbiAgICAgICAgICBwYXRocy5wdXNoKC4uLl9maW5kQ29uc3RhbnRDaGlsZEZpZWxkcyh2YWx1ZSwgcGF0aC5jb25jYXQoa2V5KSwgc2VlblNjaGVtYXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aHM7XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvdWxkQ29udGFpbkNoaWxkRmllbGQoc2NoZW1hLCBzZWVuID0gbmV3IFNldCgpKSB7XG4gIGlmIChzZWVuLmhhcyhzY2hlbWEpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHNlZW4uYWRkKHNjaGVtYSk7XG4gIHN3aXRjaCAoc2NoZW1hLmtpbmQpIHtcbiAgICBjYXNlICdmb3JtJzpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXNlICdjaGlsZCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdjb25kaXRpb25hbCc6XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhzY2hlbWEudmFsdWVzKS5zb21lKHZhbHVlID0+IGNvdWxkQ29udGFpbkNoaWxkRmllbGQodmFsdWUsIHNlZW4pKTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHNjaGVtYS5maWVsZHMpLnNvbWUoa2V5ID0+IGNvdWxkQ29udGFpbkNoaWxkRmllbGQoc2NoZW1hLmZpZWxkc1trZXldLCBzZWVuKSk7XG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgcmV0dXJuIGNvdWxkQ29udGFpbkNoaWxkRmllbGQoc2NoZW1hLmVsZW1lbnQsIHNlZW4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlubGluZU5vZGVGcm9tTWFya2RvYyhub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09ICdpbmxpbmUnKSB7XG4gICAgcmV0dXJuIGlubGluZUNoaWxkcmVuRnJvbU1hcmtkb2Mobm9kZS5jaGlsZHJlbik7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgcmV0dXJuIHNldExpbmtGb3JDaGlsZHJlbihub2RlLmF0dHJpYnV0ZXMuaHJlZiwgKCkgPT4gaW5saW5lQ2hpbGRyZW5Gcm9tTWFya2RvYyhub2RlLmNoaWxkcmVuKSk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgcmV0dXJuIGdldElubGluZU5vZGVzKG5vZGUuYXR0cmlidXRlcy5jb250ZW50KTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAnc3Ryb25nJykge1xuICAgIHJldHVybiBhZGRNYXJrVG9DaGlsZHJlbignYm9sZCcsICgpID0+IGlubGluZUNoaWxkcmVuRnJvbU1hcmtkb2Mobm9kZS5jaGlsZHJlbikpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICdjb2RlJykge1xuICAgIHJldHVybiBhZGRNYXJrVG9DaGlsZHJlbignY29kZScsICgpID0+IGdldElubGluZU5vZGVzKG5vZGUuYXR0cmlidXRlcy5jb250ZW50KSk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2VtJykge1xuICAgIHJldHVybiBhZGRNYXJrVG9DaGlsZHJlbignaXRhbGljJywgKCkgPT4gaW5saW5lQ2hpbGRyZW5Gcm9tTWFya2RvYyhub2RlLmNoaWxkcmVuKSk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3MnKSB7XG4gICAgcmV0dXJuIGFkZE1hcmtUb0NoaWxkcmVuKCdzdHJpa2V0aHJvdWdoJywgKCkgPT4gaW5saW5lQ2hpbGRyZW5Gcm9tTWFya2RvYyhub2RlLmNoaWxkcmVuKSk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3RhZycpIHtcbiAgICBpZiAobm9kZS50YWcgPT09ICd1Jykge1xuICAgICAgcmV0dXJuIGFkZE1hcmtUb0NoaWxkcmVuKCd1bmRlcmxpbmUnLCAoKSA9PiBpbmxpbmVDaGlsZHJlbkZyb21NYXJrZG9jKG5vZGUuY2hpbGRyZW4pKTtcbiAgICB9XG4gICAgaWYgKG5vZGUudGFnID09PSAna2JkJykge1xuICAgICAgcmV0dXJuIGFkZE1hcmtUb0NoaWxkcmVuKCdrZXlib2FyZCcsICgpID0+IGlubGluZUNoaWxkcmVuRnJvbU1hcmtkb2Mobm9kZS5jaGlsZHJlbikpO1xuICAgIH1cbiAgICBpZiAobm9kZS50YWcgPT09ICdzdWInKSB7XG4gICAgICByZXR1cm4gYWRkTWFya1RvQ2hpbGRyZW4oJ3N1YnNjcmlwdCcsICgpID0+IGlubGluZUNoaWxkcmVuRnJvbU1hcmtkb2Mobm9kZS5jaGlsZHJlbikpO1xuICAgIH1cbiAgICBpZiAobm9kZS50YWcgPT09ICdzdXAnKSB7XG4gICAgICByZXR1cm4gYWRkTWFya1RvQ2hpbGRyZW4oJ3N1cGVyc2NyaXB0JywgKCkgPT4gaW5saW5lQ2hpbGRyZW5Gcm9tTWFya2RvYyhub2RlLmNoaWxkcmVuKSk7XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICdzb2Z0YnJlYWsnKSB7XG4gICAgcmV0dXJuIGdldElubGluZU5vZGVzKCcgJyk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2hhcmRicmVhaycpIHtcbiAgICByZXR1cm4gZ2V0SW5saW5lTm9kZXMoJ1xcbicpO1xuICB9XG4gIGlmIChub2RlLnRhZyA9PT0gJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCcgJiYgQXJyYXkuaXNBcnJheShub2RlLmF0dHJpYnV0ZXMucHJvcFBhdGgpICYmIG5vZGUuYXR0cmlidXRlcy5wcm9wUGF0aC5ldmVyeSh4ID0+IHR5cGVvZiB4ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgeCA9PT0gJ251bWJlcicpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdjb21wb25lbnQtaW5saW5lLXByb3AnLFxuICAgICAgY2hpbGRyZW46IGlubGluZUZyb21NYXJrZG9jKG5vZGUuY2hpbGRyZW4pLFxuICAgICAgcHJvcFBhdGg6IG5vZGUuYXR0cmlidXRlcy5wcm9wUGF0aFxuICAgIH07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGlubGluZSBub2RlIHR5cGU6ICR7bm9kZS50eXBlfWApO1xufVxuZnVuY3Rpb24gaW5saW5lQ2hpbGRyZW5Gcm9tTWFya2RvYyhub2Rlcykge1xuICByZXR1cm4gbm9kZXMuZmxhdE1hcChpbmxpbmVOb2RlRnJvbU1hcmtkb2MpO1xufVxuZnVuY3Rpb24gaW5saW5lRnJvbU1hcmtkb2Mobm9kZXMpIHtcbiAgY29uc3QgdHJhbnNmb3JtZWROb2RlcyA9IG5vZGVzLmZsYXRNYXAoaW5saW5lTm9kZUZyb21NYXJrZG9jKTtcbiAgY29uc3QgbmV4dE5vZGVzID0gW107XG4gIGxldCBsYXN0Tm9kZTtcbiAgZm9yIChjb25zdCBbaWR4LCBub2RlXSBvZiB0cmFuc2Zvcm1lZE5vZGVzLmVudHJpZXMoKSkge1xuICAgIHZhciBfbGFzdE5vZGU7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gdW5kZWZpbmVkICYmIG5vZGUudGV4dCA9PT0gJycgJiYgKChfbGFzdE5vZGUgPSBsYXN0Tm9kZSkgPT09IG51bGwgfHwgX2xhc3ROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGFzdE5vZGUudHlwZSkgPT09IHVuZGVmaW5lZCAmJiBpZHggIT09IHRyYW5zZm9ybWVkTm9kZXMubGVuZ3RoIC0gMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG5leHROb2Rlcy5wdXNoKG5vZGUpO1xuICAgIGxhc3ROb2RlID0gbm9kZTtcbiAgfVxuICBpZiAoIW5leHROb2Rlcy5sZW5ndGgpIHtcbiAgICBuZXh0Tm9kZXMucHVzaCh7XG4gICAgICB0ZXh0OiAnJ1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXh0Tm9kZXM7XG59XG5mdW5jdGlvbiBmcm9tTWFya2RvYyhub2RlLCBjb21wb25lbnRCbG9ja3MpIHtcbiAgY29uc3Qgbm9kZXMgPSBub2RlLmNoaWxkcmVuLmZsYXRNYXAoeCA9PiBmcm9tTWFya2RvY05vZGUoeCwgY29tcG9uZW50QmxvY2tzKSk7XG4gIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW3tcbiAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHRleHQ6ICcnXG4gICAgICB9XVxuICAgIH1dO1xuICB9XG4gIGlmIChub2Rlc1tub2Rlcy5sZW5ndGggLSAxXS50eXBlICE9PSAncGFyYWdyYXBoJykge1xuICAgIG5vZGVzLnB1c2goe1xuICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdGV4dDogJydcbiAgICAgIH1dXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuZnVuY3Rpb24gZnJvbU1hcmtkb2NOb2RlKG5vZGUsIGNvbXBvbmVudEJsb2Nrcykge1xuICBpZiAobm9kZS50eXBlID09PSAnYmxvY2txdW90ZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2Jsb2NrcXVvdGUnLFxuICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4uZmxhdE1hcCh4ID0+IGZyb21NYXJrZG9jTm9kZSh4LCBjb21wb25lbnRCbG9ja3MpKVxuICAgIH07XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2ZlbmNlJykge1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgY29udGVudCxcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnY29kZScsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdGV4dDogY29udGVudC5yZXBsYWNlKC9cXG4kLywgJycpXG4gICAgICB9XSxcbiAgICAgIC4uLih0eXBlb2YgbGFuZ3VhZ2UgPT09ICdzdHJpbmcnID8ge1xuICAgICAgICBsYW5ndWFnZVxuICAgICAgfSA6IHt9KSxcbiAgICAgIC4uLnJlc3RcbiAgICB9O1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICdoZWFkaW5nJykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5ub2RlLmF0dHJpYnV0ZXMsXG4gICAgICBsZXZlbDogbm9kZS5hdHRyaWJ1dGVzLmxldmVsLFxuICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgY2hpbGRyZW46IGlubGluZUZyb21NYXJrZG9jKG5vZGUuY2hpbGRyZW4pXG4gICAgfTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAnbGlzdCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogbm9kZS5hdHRyaWJ1dGVzLm9yZGVyZWQgPyAnb3JkZXJlZC1saXN0JyA6ICd1bm9yZGVyZWQtbGlzdCcsXG4gICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5mbGF0TWFwKHggPT4gZnJvbU1hcmtkb2NOb2RlKHgsIGNvbXBvbmVudEJsb2NrcykpXG4gICAgfTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAnaXRlbScpIHtcbiAgICB2YXIgX25vZGUkY2hpbGRyZW4kO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gW3tcbiAgICAgIHR5cGU6ICdsaXN0LWl0ZW0tY29udGVudCcsXG4gICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5sZW5ndGggPyBpbmxpbmVGcm9tTWFya2RvYyhbbm9kZS5jaGlsZHJlblswXV0pIDogW3tcbiAgICAgICAgdGV4dDogJydcbiAgICAgIH1dXG4gICAgfV07XG4gICAgaWYgKCgoX25vZGUkY2hpbGRyZW4kID0gbm9kZS5jaGlsZHJlblsxXSkgPT09IG51bGwgfHwgX25vZGUkY2hpbGRyZW4kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRjaGlsZHJlbiQudHlwZSkgPT09ICdsaXN0Jykge1xuICAgICAgY29uc3QgbGlzdCA9IG5vZGUuY2hpbGRyZW5bMV07XG4gICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgdHlwZTogbGlzdC5hdHRyaWJ1dGVzLm9yZGVyZWQgPyAnb3JkZXJlZC1saXN0JyA6ICd1bm9yZGVyZWQtbGlzdCcsXG4gICAgICAgIGNoaWxkcmVuOiBsaXN0LmNoaWxkcmVuLmZsYXRNYXAoeCA9PiBmcm9tTWFya2RvY05vZGUoeCwgY29tcG9uZW50QmxvY2tzKSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2xpc3QtaXRlbScsXG4gICAgICBjaGlsZHJlblxuICAgIH07XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAnaW5saW5lJyAmJiBub2RlLmNoaWxkcmVuWzBdLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBub2RlLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLnR5cGUgPT09ICdpbWFnZScpIHtcbiAgICAgIHZhciBfaW1hZ2UkYXR0cmlidXRlcyR0aXQ7XG4gICAgICBjb25zdCBpbWFnZSA9IG5vZGUuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICBzcmM6IGRlY29kZVVSSShpbWFnZS5hdHRyaWJ1dGVzLnNyYyksXG4gICAgICAgIGFsdDogaW1hZ2UuYXR0cmlidXRlcy5hbHQsXG4gICAgICAgIHRpdGxlOiAoX2ltYWdlJGF0dHJpYnV0ZXMkdGl0ID0gaW1hZ2UuYXR0cmlidXRlcy50aXRsZSkgIT09IG51bGwgJiYgX2ltYWdlJGF0dHJpYnV0ZXMkdGl0ICE9PSB2b2lkIDAgPyBfaW1hZ2UkYXR0cmlidXRlcyR0aXQgOiAnJyxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdGV4dDogJydcbiAgICAgICAgfV1cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gaW5saW5lRnJvbU1hcmtkb2Mobm9kZS5jaGlsZHJlbik7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXS50eXBlID09PSAnY29tcG9uZW50LWlubGluZS1wcm9wJykge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHRleHRBbGlnbjogbm9kZS5hdHRyaWJ1dGVzLnRleHRBbGlnblxuICAgIH07XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2hyJykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnZGl2aWRlcicsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdGV4dDogJydcbiAgICAgIH1dXG4gICAgfTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAndGFibGUnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5mbGF0TWFwKHggPT4gZnJvbU1hcmtkb2NOb2RlKHgsIGNvbXBvbmVudEJsb2NrcykpXG4gICAgfTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAndGJvZHknKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0YWJsZS1ib2R5JyxcbiAgICAgIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuLmZsYXRNYXAoeCA9PiBmcm9tTWFya2RvY05vZGUoeCwgY29tcG9uZW50QmxvY2tzKSlcbiAgICB9O1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICd0aGVhZCcpIHtcbiAgICBpZiAoIW5vZGUuY2hpbGRyZW4ubGVuZ3RoKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0YWJsZS1oZWFkJyxcbiAgICAgIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuLmZsYXRNYXAoeCA9PiBmcm9tTWFya2RvY05vZGUoeCwgY29tcG9uZW50QmxvY2tzKSlcbiAgICB9O1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICd0cicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3RhYmxlLXJvdycsXG4gICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5mbGF0TWFwKHggPT4gZnJvbU1hcmtkb2NOb2RlKHgsIGNvbXBvbmVudEJsb2NrcykpXG4gICAgfTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAndGQnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0YWJsZS1jZWxsJyxcbiAgICAgIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuLmZsYXRNYXAoeCA9PiBmcm9tTWFya2RvY05vZGUoeCwgY29tcG9uZW50QmxvY2tzKSlcbiAgICB9O1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICd0aCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3RhYmxlLWNlbGwnLFxuICAgICAgaGVhZGVyOiB0cnVlLFxuICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4uZmxhdE1hcCh4ID0+IGZyb21NYXJrZG9jTm9kZSh4LCBjb21wb25lbnRCbG9ja3MpKVxuICAgIH07XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3RhZycpIHtcbiAgICBpZiAobm9kZS50YWcgPT09ICd0YWJsZScpIHtcbiAgICAgIHJldHVybiBmcm9tTWFya2RvY05vZGUobm9kZS5jaGlsZHJlblswXSwgY29tcG9uZW50QmxvY2tzKTtcbiAgICB9XG4gICAgaWYgKG5vZGUudGFnID09PSAnbGF5b3V0Jykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2xheW91dCcsXG4gICAgICAgIGxheW91dDogbm9kZS5hdHRyaWJ1dGVzLmxheW91dCxcbiAgICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4uZmxhdE1hcCh4ID0+IGZyb21NYXJrZG9jTm9kZSh4LCBjb21wb25lbnRCbG9ja3MpKVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG5vZGUudGFnID09PSAnbGF5b3V0LWFyZWEnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnbGF5b3V0LWFyZWEnLFxuICAgICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5mbGF0TWFwKHggPT4gZnJvbU1hcmtkb2NOb2RlKHgsIGNvbXBvbmVudEJsb2NrcykpXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobm9kZS50YWcgPT09ICdjb21wb25lbnQtYmxvY2snKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnY29tcG9uZW50LWJsb2NrJyxcbiAgICAgICAgY29tcG9uZW50OiBub2RlLmF0dHJpYnV0ZXMuY29tcG9uZW50LFxuICAgICAgICBwcm9wczogbm9kZS5hdHRyaWJ1dGVzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyBbe1xuICAgICAgICAgIHR5cGU6ICdjb21wb25lbnQtaW5saW5lLXByb3AnLFxuICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICB9XVxuICAgICAgICB9XSA6IG5vZGUuY2hpbGRyZW4uZmxhdE1hcCh4ID0+IGZyb21NYXJrZG9jTm9kZSh4LCBjb21wb25lbnRCbG9ja3MpKVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG5vZGUudGFnID09PSAnY29tcG9uZW50LWJsb2NrLXByb3AnICYmIEFycmF5LmlzQXJyYXkobm9kZS5hdHRyaWJ1dGVzLnByb3BQYXRoKSAmJiBub2RlLmF0dHJpYnV0ZXMucHJvcFBhdGguZXZlcnkoeCA9PiB0eXBlb2YgeCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHggPT09ICdudW1iZXInKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2NvbXBvbmVudC1ibG9jay1wcm9wJyxcbiAgICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4uZmxhdE1hcCh4ID0+IGZyb21NYXJrZG9jTm9kZSh4LCBjb21wb25lbnRCbG9ja3MpKSxcbiAgICAgICAgcHJvcFBhdGg6IG5vZGUuYXR0cmlidXRlcy5wcm9wUGF0aFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG5vZGUudGFnKSB7XG4gICAgICBjb25zdCBjb21wb25lbnRCbG9jayA9IGNvbXBvbmVudEJsb2Nrc1tub2RlLnRhZ107XG4gICAgICBpZiAoY29tcG9uZW50QmxvY2spIHtcbiAgICAgICAgY29uc3Qgc2luZ2xlQ2hpbGRGaWVsZCA9IGZpbmRTaW5nbGVDaGlsZEZpZWxkKHtcbiAgICAgICAgICBraW5kOiAnb2JqZWN0JyxcbiAgICAgICAgICBmaWVsZHM6IGNvbXBvbmVudEJsb2NrLnNjaGVtYVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNpbmdsZUNoaWxkRmllbGQpIHtcbiAgICAgICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShub2RlLmF0dHJpYnV0ZXMpKTtcbiAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgIHRvQ2hpbGRyZW5BbmRQcm9wcyQxKG5vZGUuY2hpbGRyZW4sIGNoaWxkcmVuLCBuZXdBdHRyaWJ1dGVzLCBzaW5nbGVDaGlsZEZpZWxkLCBbXSwgY29tcG9uZW50QmxvY2tzKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2NvbXBvbmVudC1ibG9jaycsXG4gICAgICAgICAgICBjb21wb25lbnQ6IG5vZGUudGFnLFxuICAgICAgICAgICAgcHJvcHM6IG5ld0F0dHJpYnV0ZXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnY29tcG9uZW50LWJsb2NrJyxcbiAgICAgICAgICBjb21wb25lbnQ6IG5vZGUudGFnLFxuICAgICAgICAgIHByb3BzOiBub2RlLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gW3tcbiAgICAgICAgICAgIHR5cGU6ICdjb21wb25lbnQtaW5saW5lLXByb3AnLFxuICAgICAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH1dIDogbm9kZS5jaGlsZHJlbi5mbGF0TWFwKHggPT4gZnJvbU1hcmtkb2NOb2RlKHgsIGNvbXBvbmVudEJsb2NrcykpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0YWc6ICR7bm9kZS50YWd9YCk7XG4gIH1cbiAgcmV0dXJuIGlubGluZU5vZGVGcm9tTWFya2RvYyhub2RlKTtcbn1cbmZ1bmN0aW9uIHRvQ2hpbGRyZW5BbmRQcm9wcyQxKGZyb21NYXJrZG9jLCByZXN1bHRpbmdDaGlsZHJlbiwgdmFsdWUsIHNpbmdsZUNoaWxkRmllbGQsIHBhcmVudFByb3BQYXRoLCBjb21wb25lbnRCbG9ja3MpIHtcbiAgaWYgKHNpbmdsZUNoaWxkRmllbGQua2luZCA9PT0gJ2NoaWxkJykge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gZnJvbU1hcmtkb2MuZmxhdE1hcCh4ID0+IGZyb21NYXJrZG9jTm9kZSh4LCBjb21wb25lbnRCbG9ja3MpKTtcbiAgICByZXN1bHRpbmdDaGlsZHJlbi5wdXNoKHtcbiAgICAgIHR5cGU6IGBjb21wb25lbnQtJHtzaW5nbGVDaGlsZEZpZWxkLm9wdGlvbnMua2luZH0tcHJvcGAsXG4gICAgICBwcm9wUGF0aDogWy4uLnBhcmVudFByb3BQYXRoLCAuLi5zaW5nbGVDaGlsZEZpZWxkLnJlbGF0aXZlUGF0aF0sXG4gICAgICBjaGlsZHJlblxuICAgIH0pO1xuICB9XG4gIGlmIChzaW5nbGVDaGlsZEZpZWxkLmtpbmQgPT09ICdhcnJheScpIHtcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBmb3IgKGxldCBbaWR4LCBjaGlsZF0gb2YgZnJvbU1hcmtkb2MuZW50cmllcygpKSB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5jaGlsZHJlblswXS5jaGlsZHJlblswXTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC50eXBlICE9PSAndGFnJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIHRhZyAke3NpbmdsZUNoaWxkRmllbGQuYXNDaGlsZFRhZ30sIGZvdW5kIHR5cGU6ICR7Y2hpbGQudHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC50YWcgIT09IHNpbmdsZUNoaWxkRmllbGQuYXNDaGlsZFRhZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIHRhZyAke3NpbmdsZUNoaWxkRmllbGQuYXNDaGlsZFRhZ30sIGZvdW5kIHRhZzogJHtjaGlsZC50YWd9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjaGlsZC5hdHRyaWJ1dGVzKSk7XG4gICAgICBpZiAoc2luZ2xlQ2hpbGRGaWVsZC5jaGlsZCkge1xuICAgICAgICB0b0NoaWxkcmVuQW5kUHJvcHMkMShjaGlsZC5jaGlsZHJlbiwgcmVzdWx0aW5nQ2hpbGRyZW4sIGF0dHJpYnV0ZXMsIHNpbmdsZUNoaWxkRmllbGQuY2hpbGQsIFsuLi5wYXJlbnRQcm9wUGF0aCwgLi4uc2luZ2xlQ2hpbGRGaWVsZC5yZWxhdGl2ZVBhdGgsIGlkeF0sIGNvbXBvbmVudEJsb2Nrcyk7XG4gICAgICB9XG4gICAgICBhcnIucHVzaChhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gc2luZ2xlQ2hpbGRGaWVsZC5yZWxhdGl2ZVBhdGhbc2luZ2xlQ2hpbGRGaWVsZC5yZWxhdGl2ZVBhdGgubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgcGFyZW50ID0gZ2V0VmFsdWVBdFByb3BQYXRoKHZhbHVlLCBzaW5nbGVDaGlsZEZpZWxkLnJlbGF0aXZlUGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIHBhcmVudFtrZXldID0gYXJyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KCh4LCBpKSA9PiB4ID09PSBiW2ldKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRleHRCYXNlZE9uSW5saW5lTWFya3NBbmRTb2Z0QnJlYWtzKFtub2RlLCBwYXRoXSwgZWRpdG9yLCBpbmxpbmVNYXJrcywgc29mdEJyZWFrcykge1xuICBjb25zdCBtYXJrc1RvUmVtb3ZlID0gT2JqZWN0LmtleXMobm9kZSkuZmlsdGVyKHggPT4geCAhPT0gJ3RleHQnICYmIHggIT09ICdpbnNlcnRNZW51JyAmJiBpbmxpbmVNYXJrc1t4XSAhPT0gdHJ1ZSk7XG4gIGlmIChtYXJrc1RvUmVtb3ZlLmxlbmd0aCkge1xuICAgIFRyYW5zZm9ybXMudW5zZXROb2RlcyhlZGl0b3IsIG1hcmtzVG9SZW1vdmUsIHtcbiAgICAgIGF0OiBwYXRoXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFzb2Z0QnJlYWtzKSB7XG4gICAgY29uc3QgaGFzU29mdEJyZWFrcyA9IG5vZGUudGV4dC5pbmNsdWRlcygnXFxuJyk7XG4gICAgaWYgKGhhc1NvZnRCcmVha3MpIHtcbiAgICAgIGNvbnN0IFtwYXJlbnROb2RlXSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgIGlmIChwYXJlbnROb2RlLnR5cGUgIT09ICdjb2RlJykge1xuICAgICAgICBmb3IgKGNvbnN0IHBvc2l0aW9uIG9mIEVkaXRvci5wb3NpdGlvbnMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBjb25zdCBjaGFyYWN0ZXIgPSBOb2RlLmdldChlZGl0b3IsIHBvc2l0aW9uLnBhdGgpLnRleHRbcG9zaXRpb24ub2Zmc2V0XTtcbiAgICAgICAgICBpZiAoY2hhcmFjdGVyID09PSAnXFxuJykge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBwb3NpdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSW5saW5lQmFzZWRPbkxpbmtzKFtub2RlLCBwYXRoXSwgZWRpdG9yLCBsaW5rcykge1xuICBpZiAobm9kZS50eXBlID09PSAnbGluaycgJiYgIWxpbmtzKSB7XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KGVkaXRvciwgYCAoJHtub2RlLmhyZWZ9KWAsIHtcbiAgICAgIGF0OiBFZGl0b3IuZW5kKGVkaXRvciwgcGF0aClcbiAgICB9KTtcbiAgICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGhcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBub3JtYWxpemVFbGVtZW50QmFzZWRPbkRvY3VtZW50RmVhdHVyZXMoW25vZGUsIHBhdGhdLCBlZGl0b3IsIHtcbiAgZm9ybWF0dGluZyxcbiAgZGl2aWRlcnMsXG4gIGxheW91dHMsXG4gIGxpbmtzLFxuICBpbWFnZXMsXG4gIHRhYmxlc1xufSkge1xuICBpZiAobm9kZS50eXBlID09PSAnaGVhZGluZycgJiYgKCFmb3JtYXR0aW5nLmhlYWRpbmdzLmxldmVscy5sZW5ndGggfHwgIWZvcm1hdHRpbmcuaGVhZGluZ3MubGV2ZWxzLmluY2x1ZGVzKG5vZGUubGV2ZWwpKSB8fCBub2RlLnR5cGUgPT09ICdvcmRlcmVkLWxpc3QnICYmICFmb3JtYXR0aW5nLmxpc3RUeXBlcy5vcmRlcmVkIHx8IG5vZGUudHlwZSA9PT0gJ3Vub3JkZXJlZC1saXN0JyAmJiAhZm9ybWF0dGluZy5saXN0VHlwZXMudW5vcmRlcmVkIHx8IG5vZGUudHlwZSA9PT0gJ2NvZGUnICYmICFmb3JtYXR0aW5nLmJsb2NrVHlwZXMuY29kZSB8fCBub2RlLnR5cGUgPT09ICdibG9ja3F1b3RlJyAmJiAhZm9ybWF0dGluZy5ibG9ja1R5cGVzLmJsb2NrcXVvdGUgfHwgbm9kZS50eXBlID09PSAnaW1hZ2UnICYmICFpbWFnZXMgfHwgbm9kZS50eXBlID09PSAndGFibGUnICYmICF0YWJsZXMgfHwgbm9kZS50eXBlID09PSAnbGF5b3V0JyAmJiAobGF5b3V0cy5sZW5ndGggPT09IDAgfHwgIWxheW91dHMuc29tZShsYXlvdXQgPT4gYXJlQXJyYXlzRXF1YWwobGF5b3V0LCBub2RlLmxheW91dCkpKSkge1xuICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aFxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICgobm9kZS50eXBlID09PSAncGFyYWdyYXBoJyB8fCBub2RlLnR5cGUgPT09ICdoZWFkaW5nJykgJiYgKCFmb3JtYXR0aW5nLmFsaWdubWVudC5jZW50ZXIgJiYgbm9kZS50ZXh0QWxpZ24gPT09ICdjZW50ZXInIHx8ICFmb3JtYXR0aW5nLmFsaWdubWVudC5lbmQgJiYgbm9kZS50ZXh0QWxpZ24gPT09ICdlbmQnIHx8ICd0ZXh0QWxpZ24nIGluIG5vZGUgJiYgbm9kZS50ZXh0QWxpZ24gIT09ICdjZW50ZXInICYmIG5vZGUudGV4dEFsaWduICE9PSAnZW5kJykpIHtcbiAgICBUcmFuc2Zvcm1zLnVuc2V0Tm9kZXMoZWRpdG9yLCAndGV4dEFsaWduJywge1xuICAgICAgYXQ6IHBhdGhcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAnZGl2aWRlcicgJiYgIWRpdmlkZXJzKSB7XG4gICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZUlubGluZUJhc2VkT25MaW5rcyhbbm9kZSwgcGF0aF0sIGVkaXRvciwgbGlua3MpO1xufVxuZnVuY3Rpb24gd2l0aERvY3VtZW50RmVhdHVyZXNOb3JtYWxpemF0aW9uKGRvY3VtZW50RmVhdHVyZXMsIGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgbm9ybWFsaXplTm9kZVxuICB9ID0gZWRpdG9yO1xuICBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIG5vcm1hbGl6ZVRleHRCYXNlZE9uSW5saW5lTWFya3NBbmRTb2Z0QnJlYWtzKFtub2RlLCBwYXRoXSwgZWRpdG9yLCBkb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuaW5saW5lTWFya3MsIGRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5zb2Z0QnJlYWtzKTtcbiAgICB9IGVsc2UgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgIG5vcm1hbGl6ZUVsZW1lbnRCYXNlZE9uRG9jdW1lbnRGZWF0dXJlcyhbbm9kZSwgcGF0aF0sIGVkaXRvciwgZG9jdW1lbnRGZWF0dXJlcyk7XG4gICAgfVxuICAgIG5vcm1hbGl6ZU5vZGUoW25vZGUsIHBhdGhdKTtcbiAgfTtcbiAgcmV0dXJuIGVkaXRvcjtcbn1cblxuZnVuY3Rpb24gZ2V0U3JjUHJlZml4KHB1YmxpY1BhdGgsIHNsdWcpIHtcbiAgcmV0dXJuIHR5cGVvZiBwdWJsaWNQYXRoID09PSAnc3RyaW5nJyA/IGAke3B1YmxpY1BhdGgucmVwbGFjZSgvXFwvKiQvLCAnJyl9LyR7c2x1ZyA9PT0gdW5kZWZpbmVkID8gJycgOiBzbHVnICsgJy8nfWAgOiAnJztcbn1cblxuZnVuY3Rpb24gZGVzZXJpYWxpemVGaWxlcyhub2RlcywgY29tcG9uZW50QmxvY2tzLCBmaWxlcywgb3RoZXJGaWxlcywgbW9kZSwgZG9jdW1lbnRGZWF0dXJlcywgc2x1Zykge1xuICByZXR1cm4gbm9kZXMubWFwKG5vZGUgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgPT09ICdjb21wb25lbnQtYmxvY2snKSB7XG4gICAgICBjb25zdCBjb21wb25lbnRCbG9jayA9IGNvbXBvbmVudEJsb2Nrc1tub2RlLmNvbXBvbmVudF07XG4gICAgICBpZiAoIWNvbXBvbmVudEJsb2NrKSByZXR1cm4gbm9kZTtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IG9iamVjdChjb21wb25lbnRCbG9jay5zY2hlbWEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgcHJvcHM6IGRlc2VyaWFsaXplUHJvcHMoc2NoZW1hLCBub2RlLnByb3BzLCBmaWxlcywgb3RoZXJGaWxlcywgbW9kZSwgc2x1ZylcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChub2RlLnR5cGUgPT09ICdpbWFnZScgJiYgdHlwZW9mIG5vZGUuc3JjID09PSAnc3RyaW5nJyAmJiBtb2RlID09PSAnZWRpdCcpIHtcbiAgICAgIHZhciBfcmVmO1xuICAgICAgY29uc3QgcHJlZml4ID0gZ2V0U3JjUHJlZml4Rm9ySW1hZ2VCbG9jayhkb2N1bWVudEZlYXR1cmVzLCBzbHVnKTtcbiAgICAgIGNvbnN0IGZpbGVuYW1lID0gbm9kZS5zcmMuc2xpY2UocHJlZml4Lmxlbmd0aCk7XG4gICAgICBjb25zdCBjb250ZW50ID0gKF9yZWYgPSB0eXBlb2YgZG9jdW1lbnRGZWF0dXJlcy5pbWFnZXMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkb2N1bWVudEZlYXR1cmVzLmltYWdlcy5kaXJlY3RvcnkgPT09ICdzdHJpbmcnID8gb3RoZXJGaWxlcy5nZXQoZml4UGF0aChkb2N1bWVudEZlYXR1cmVzLmltYWdlcy5kaXJlY3RvcnkpKSA6IGZpbGVzKSA9PT0gbnVsbCB8fCBfcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVmLmdldChmaWxlbmFtZSk7XG4gICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICAgIHRleHQ6IGBNaXNzaW5nIGltYWdlICR7ZmlsZW5hbWV9YFxuICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICBzcmM6IHtcbiAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICBjb250ZW50XG4gICAgICAgIH0sXG4gICAgICAgIGFsdDogbm9kZS5hbHQsXG4gICAgICAgIHRpdGxlOiBub2RlLnRpdGxlLFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICB9XVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBub2RlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGRlc2VyaWFsaXplRmlsZXMobm9kZS5jaGlsZHJlbiwgY29tcG9uZW50QmxvY2tzLCBmaWxlcywgb3RoZXJGaWxlcywgbW9kZSwgZG9jdW1lbnRGZWF0dXJlcywgc2x1Zyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5ub2RlLFxuICAgICAgICBjaGlsZHJlblxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0pO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVQcm9wcyhzY2hlbWEsIHZhbHVlLCBmaWxlcywgb3RoZXJGaWxlcywgbW9kZSwgc2x1Zykge1xuICByZXR1cm4gdHJhbnNmb3JtUHJvcHMoc2NoZW1hLCB2YWx1ZSwge1xuICAgIGZvcm06IChzY2hlbWEsIHZhbHVlKSA9PiB7XG4gICAgICBpZiAoc2NoZW1hLmZvcm1LaW5kID09PSAnYXNzZXQnKSB7XG4gICAgICAgIHZhciBfb3RoZXJGaWxlcyRnZXQ7XG4gICAgICAgIGlmIChtb2RlID09PSAncmVhZCcpIHtcbiAgICAgICAgICByZXR1cm4gc2NoZW1hLnJlYWRlci5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBzY2hlbWEuZmlsZW5hbWUodmFsdWUsIHtcbiAgICAgICAgICBzbHVnLFxuICAgICAgICAgIHN1Z2dlc3RlZEZpbGVuYW1lUHJlZml4OiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzY2hlbWEucGFyc2UodmFsdWUsIHtcbiAgICAgICAgICBhc3NldDogZmlsZW5hbWUgPyBzY2hlbWEuZGlyZWN0b3J5ID8gKF9vdGhlckZpbGVzJGdldCA9IG90aGVyRmlsZXMuZ2V0KHNjaGVtYS5kaXJlY3RvcnkpKSA9PT0gbnVsbCB8fCBfb3RoZXJGaWxlcyRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vdGhlckZpbGVzJGdldC5nZXQoZmlsZW5hbWUpIDogZmlsZXMuZ2V0KGZpbGVuYW1lKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBzbHVnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHNjaGVtYS5mb3JtS2luZCA9PT0gJ2NvbnRlbnQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAobW9kZSA9PT0gJ3JlYWQnKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEucmVhZGVyLnBhcnNlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWEucGFyc2UodmFsdWUsIHVuZGVmaW5lZCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNyY1ByZWZpeEZvckltYWdlQmxvY2soZG9jdW1lbnRGZWF0dXJlcywgc2x1Zykge1xuICByZXR1cm4gZ2V0U3JjUHJlZml4KHR5cGVvZiBkb2N1bWVudEZlYXR1cmVzLmltYWdlcyA9PT0gJ29iamVjdCcgPyBkb2N1bWVudEZlYXR1cmVzLmltYWdlcy5wdWJsaWNQYXRoIDogdW5kZWZpbmVkLCBzbHVnKTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplUHJvcHMocm9vdFZhbHVlLCByb290U2NoZW1hLFxuLy8gbm90ZSB5b3UgbWlnaHQgaGF2ZSBhIHNsdWcgd2l0aG91dCBhIHNsdWcgZmllbGQgd2hlbiBzZXJpYWxpemluZyBwcm9wcyBpbnNpZGUgYSBjb21wb25lbnQgYmxvY2sgb3IgZXRjLiBpbiB0aGUgZWRpdG9yXG5zbHVnRmllbGQsIHNsdWcsIHNob3VsZFN1Z2dlc3RGaWxlbmFtZVByZWZpeCkge1xuICBjb25zdCBleHRyYUZpbGVzID0gW107XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHRyYW5zZm9ybVByb3BzKHJvb3RTY2hlbWEsIHJvb3RWYWx1ZSwge1xuICAgICAgZm9ybShzY2hlbWEsIHZhbHVlLCBwcm9wUGF0aCkge1xuICAgICAgICBpZiAocHJvcFBhdGgubGVuZ3RoID09PSAxICYmIHNsdWdGaWVsZCA9PT0gcHJvcFBhdGhbMF0pIHtcbiAgICAgICAgICBpZiAoc2NoZW1hLmZvcm1LaW5kICE9PSAnc2x1ZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2x1Z0ZpZWxkIGlzIGEgbm90IGEgc2x1ZyBmaWVsZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2NoZW1hLnNlcmlhbGl6ZVdpdGhTbHVnKHZhbHVlKS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmZvcm1LaW5kID09PSAnYXNzZXQnKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYXNzZXQsXG4gICAgICAgICAgICB2YWx1ZTogZm9yWWFtbFxuICAgICAgICAgIH0gPSBzY2hlbWEuc2VyaWFsaXplKHZhbHVlLCB7XG4gICAgICAgICAgICBzdWdnZXN0ZWRGaWxlbmFtZVByZWZpeDogc2hvdWxkU3VnZ2VzdEZpbGVuYW1lUHJlZml4ID8gZ2V0UHJvcFBhdGhQb3J0aW9uKHByb3BQYXRoLCByb290U2NoZW1hLCByb290VmFsdWUpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2x1Z1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChhc3NldCkge1xuICAgICAgICAgICAgZXh0cmFGaWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgcGF0aDogYXNzZXQuZmlsZW5hbWUsXG4gICAgICAgICAgICAgIGNvbnRlbnRzOiBhc3NldC5jb250ZW50LFxuICAgICAgICAgICAgICBwYXJlbnQ6IHNjaGVtYS5kaXJlY3RvcnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZm9yWWFtbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmZvcm1LaW5kID09PSAnY29udGVudCcpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBvdGhlcixcbiAgICAgICAgICAgIGV4dGVybmFsLFxuICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgIHZhbHVlOiBmb3JZYW1sXG4gICAgICAgICAgfSA9IHNjaGVtYS5zZXJpYWxpemUodmFsdWUsIHtcbiAgICAgICAgICAgIHNsdWdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgZXh0cmFGaWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgcGF0aDogZ2V0UHJvcFBhdGhQb3J0aW9uKHByb3BQYXRoLCByb290U2NoZW1hLCByb290VmFsdWUpICsgc2NoZW1hLmNvbnRlbnRFeHRlbnNpb24sXG4gICAgICAgICAgICAgIGNvbnRlbnRzOiBjb250ZW50LFxuICAgICAgICAgICAgICBwYXJlbnQ6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgY29udGVudHNdIG9mIG90aGVyKSB7XG4gICAgICAgICAgICBleHRyYUZpbGVzLnB1c2goe1xuICAgICAgICAgICAgICBwYXRoOiBnZXRQcm9wUGF0aFBvcnRpb24ocHJvcFBhdGgsIHJvb3RTY2hlbWEsIHJvb3RWYWx1ZSkgKyAnLycgKyBrZXksXG4gICAgICAgICAgICAgIGNvbnRlbnRzLFxuICAgICAgICAgICAgICBwYXJlbnQ6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFsbG93ZWREaXJlY3RvcmllcyA9IG5ldyBTZXQoc2NoZW1hLmRpcmVjdG9yaWVzKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtkaXJlY3RvcnksIGNvbnRlbnRzXSBvZiBleHRlcm5hbCkge1xuICAgICAgICAgICAgaWYgKCFhbGxvd2VkRGlyZWN0b3JpZXMuaGFzKGRpcmVjdG9yeSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRpcmVjdG9yeSAke2RpcmVjdG9yeX0gaW4gY29udGVudCBmaWVsZCBzZXJpYWxpemF0aW9uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWxlbmFtZSwgZmlsZUNvbnRlbnRzXSBvZiBjb250ZW50cykge1xuICAgICAgICAgICAgICBleHRyYUZpbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhdGg6IGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRzOiBmaWxlQ29udGVudHMsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBkaXJlY3RvcnlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmb3JZYW1sO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWEuc2VyaWFsaXplKHZhbHVlKS52YWx1ZTtcbiAgICAgIH0sXG4gICAgICBvYmplY3QoX3NjaGVtYSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh2YWx1ZSkuZmlsdGVyKChbXywgdmFsXSkgPT4gdmFsICE9PSB1bmRlZmluZWQpKTtcbiAgICAgIH0sXG4gICAgICBhcnJheShfc2NoZW1hLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKHZhbCA9PiB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2YWwpO1xuICAgICAgfSxcbiAgICAgIGNoaWxkKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGV4dHJhRmlsZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFByb3BQYXRoUG9ydGlvbihwYXRoLCBzY2hlbWEsIHZhbHVlKSB7XG4gIGNvbnN0IGVuZCA9IFtdO1xuICBmb3IgKGNvbnN0IHBvcnRpb24gb2YgcGF0aCkge1xuICAgIGlmIChzY2hlbWEua2luZCA9PT0gJ2FycmF5Jykge1xuICAgICAgdmFsdWUgPSB2YWx1ZVtwb3J0aW9uXTtcbiAgICAgIGlmIChzY2hlbWEuc2x1Z0ZpZWxkICYmIHNjaGVtYS5lbGVtZW50LmtpbmQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IHNsdWcgPSBnZXRTbHVnRnJvbVN0YXRlKHtcbiAgICAgICAgICBzY2hlbWE6IHNjaGVtYS5lbGVtZW50LmZpZWxkcyxcbiAgICAgICAgICBzbHVnRmllbGQ6IHNjaGVtYS5zbHVnRmllbGRcbiAgICAgICAgfSwgdmFsdWUpO1xuICAgICAgICBlbmQucHVzaChzbHVnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZC5wdXNoKHBvcnRpb24pO1xuICAgICAgfVxuICAgICAgc2NoZW1hID0gc2NoZW1hLmVsZW1lbnQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZW5kLnB1c2gocG9ydGlvbik7XG4gICAgaWYgKHNjaGVtYS5raW5kID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsdWUgPSB2YWx1ZVtwb3J0aW9uXTtcbiAgICAgIHNjaGVtYSA9IHNjaGVtYS5maWVsZHNbcG9ydGlvbl07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS5raW5kID09PSAnY29uZGl0aW9uYWwnKSB7XG4gICAgICBpZiAocG9ydGlvbiA9PT0gJ2Rpc2NyaW1pbmFudCcpIHtcbiAgICAgICAgc2NoZW1hID0gc2NoZW1hLmRpc2NyaW1pbmFudDtcbiAgICAgIH0gZWxzZSBpZiAocG9ydGlvbiA9PT0gJ3ZhbHVlJykge1xuICAgICAgICBzY2hlbWEgPSBzY2hlbWEudmFsdWVzW3ZhbHVlLmRpc2NyaW1pbmFudF07XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlW3BvcnRpb25dO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCAke3NjaGVtYS5raW5kfWApO1xuICB9XG4gIHJldHVybiBlbmQuam9pbignLycpO1xufVxuXG5jb25zdCB7XG4gIEFzdFxufSA9IE1hcmtkb2M7XG5mdW5jdGlvbiB0b0lubGluZShub2Rlcykge1xuICByZXR1cm4gbmV3IEFzdC5Ob2RlKCdpbmxpbmUnLCB7fSwgbm9kZXMuZmxhdE1hcCh0b01hcmtkb2NJbmxpbmUpKTtcbn1cbmNvbnN0IG1hcmtUb01hcmtkb2MgPSB7XG4gIGJvbGQ6IHtcbiAgICB0eXBlOiAnc3Ryb25nJ1xuICB9LFxuICBjb2RlOiB7XG4gICAgdHlwZTogJ2NvZGUnXG4gIH0sXG4gIGl0YWxpYzoge1xuICAgIHR5cGU6ICdlbSdcbiAgfSxcbiAgdW5kZXJsaW5lOiB7XG4gICAgdHlwZTogJ3RhZycsXG4gICAgdGFnOiAndSdcbiAgfSxcbiAga2V5Ym9hcmQ6IHtcbiAgICB0eXBlOiAndGFnJyxcbiAgICB0YWc6ICdrYmQnXG4gIH0sXG4gIHN0cmlrZXRocm91Z2g6IHtcbiAgICB0eXBlOiAncydcbiAgfSxcbiAgc3Vic2NyaXB0OiB7XG4gICAgdHlwZTogJ3RhZycsXG4gICAgdGFnOiAnc3ViJ1xuICB9LFxuICBzdXBlcnNjcmlwdDoge1xuICAgIHR5cGU6ICd0YWcnLFxuICAgIHRhZzogJ3N1cCdcbiAgfVxufTtcbmZ1bmN0aW9uIHRvTWFya2RvY0lubGluZShub2RlKSB7XG4gIHZhciBfZXhlYywgX2V4ZWMyO1xuICBpZiAobm9kZS50eXBlID09PSAnbGluaycpIHtcbiAgICByZXR1cm4gbmV3IEFzdC5Ob2RlKCdsaW5rJywge1xuICAgICAgaHJlZjogbm9kZS5ocmVmXG4gICAgfSwgbm9kZS5jaGlsZHJlbi5mbGF0TWFwKHRvTWFya2RvY0lubGluZSkpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBpbmxpbmUgbm9kZSB0eXBlOiAke25vZGUudHlwZX1gKTtcbiAgfVxuICBjb25zdCBtYXJrcyA9IE9iamVjdC5rZXlzKG5vZGUpLmZpbHRlcihtYXJrID0+IG1hcmsgIT09ICd0ZXh0JyAmJiBtYXJrICE9PSAnY29kZScpLnNvcnQoKTtcbiAgY29uc3Qgc3BsaXRCeU5ld0xpbmVzID0gbm9kZS50ZXh0LnNwbGl0KC9cXG4vKTtcbiAgaWYgKHNwbGl0QnlOZXdMaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIHNwbGl0QnlOZXdMaW5lcy5mbGF0TWFwKCh4LCBpKSA9PiB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdG9NYXJrZG9jSW5saW5lKHtcbiAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgIHRleHQ6IHhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbm5lciA9IHRvTWFya2RvY0lubGluZSh7XG4gICAgICAgIC4uLm5vZGUsXG4gICAgICAgIHRleHQ6IHhcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtuZXcgQXN0Lk5vZGUoJ2hhcmRicmVhaycpLCAuLi4oQXJyYXkuaXNBcnJheShpbm5lcikgPyBpbm5lciA6IFtpbm5lcl0pXTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBsZWFkaW5nV2hpdGVzcGFjZSA9IChfZXhlYyA9IC9eXFxzKy8uZXhlYyhub2RlLnRleHQpKSA9PT0gbnVsbCB8fCBfZXhlYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V4ZWNbMF07XG4gIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZSA9IChfZXhlYzIgPSAvXFxzKyQvLmV4ZWMobm9kZS50ZXh0KSkgPT09IG51bGwgfHwgX2V4ZWMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXhlYzJbMF07XG4gIGxldCBjaGlsZHJlbiA9IG5vZGUuY29kZSA/IFtuZXcgQXN0Lk5vZGUoJ2NvZGUnLCB7XG4gICAgY29udGVudDogbm9kZS50ZXh0LnRyaW0oKVxuICB9LCBbXSldIDogW25ldyBBc3QuTm9kZSgndGV4dCcsIHtcbiAgICBjb250ZW50OiBub2RlLnRleHQudHJpbSgpXG4gIH0pXTtcbiAgZm9yIChjb25zdCBtYXJrIG9mIG1hcmtzKSB7XG4gICAgY29uc3QgY29uZmlnID0gbWFya1RvTWFya2RvY1ttYXJrXTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICBjaGlsZHJlbiA9IFtuZXcgQXN0Lk5vZGUoY29uZmlnLnR5cGUsIHt9LCBjaGlsZHJlbiwgY29uZmlnLnRhZyldO1xuICAgIH1cbiAgfVxuICBpZiAoL15cXHMrJC8udGVzdChub2RlLnRleHQpKSB7XG4gICAgY2hpbGRyZW4udW5zaGlmdChuZXcgQXN0Lk5vZGUoJ3RleHQnLCB7XG4gICAgICBjb250ZW50OiBsZWFkaW5nV2hpdGVzcGFjZVxuICAgIH0sIFtdKSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlICE9PSBudWxsICYmIGxlYWRpbmdXaGl0ZXNwYWNlICE9PSB2b2lkIDAgJiYgbGVhZGluZ1doaXRlc3BhY2UubGVuZ3RoKSB7XG4gICAgICBjaGlsZHJlbi51bnNoaWZ0KG5ldyBBc3QuTm9kZSgndGV4dCcsIHtcbiAgICAgICAgY29udGVudDogbGVhZGluZ1doaXRlc3BhY2VcbiAgICAgIH0sIFtdKSk7XG4gICAgfVxuICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2UgIT09IG51bGwgJiYgdHJhaWxpbmdXaGl0ZXNwYWNlICE9PSB2b2lkIDAgJiYgdHJhaWxpbmdXaGl0ZXNwYWNlLmxlbmd0aCkge1xuICAgICAgY2hpbGRyZW4ucHVzaChuZXcgQXN0Lk5vZGUoJ3RleHQnLCB7XG4gICAgICAgIGNvbnRlbnQ6IHRyYWlsaW5nV2hpdGVzcGFjZVxuICAgICAgfSwgW10pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gdG9NYXJrZG9jRG9jdW1lbnQobm9kZXMsIF9jb25maWcpIHtcbiAgY29uc3QgZXh0cmFGaWxlcyA9IFtdO1xuICBjb25zdCBjb25maWcgPSB7XG4gICAgLi4uX2NvbmZpZyxcbiAgICBleHRyYUZpbGVzXG4gIH07XG4gIGNvbnN0IG5vZGUgPSBuZXcgQXN0Lk5vZGUoJ2RvY3VtZW50Jywge30sIG5vZGVzLmZsYXRNYXAoeCA9PiB0b01hcmtkb2MoeCwgY29uZmlnKSkpO1xuICByZXR1cm4ge1xuICAgIG5vZGUsXG4gICAgZXh0cmFGaWxlc1xuICB9O1xufVxuZnVuY3Rpb24gdG9DaGlsZHJlbkFuZFByb3BzKGNoaWxkcmVuQXNNYXJrZG9jLCByZXN1bHRpbmdDaGlsZHJlbiwgdmFsdWUsIHNpbmdsZUNoaWxkRmllbGQpIHtcbiAgaWYgKHNpbmdsZUNoaWxkRmllbGQua2luZCA9PT0gJ2NoaWxkJykge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5Bc01hcmtkb2MuZmluZCh4ID0+IGFyZUFycmF5c0VxdWFsKHgucHJvcFBhdGgsIHNpbmdsZUNoaWxkRmllbGQucmVsYXRpdmVQYXRoKSk7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICByZXN1bHRpbmdDaGlsZHJlbi5wdXNoKC4uLmNoaWxkLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzaW5nbGVDaGlsZEZpZWxkLmtpbmQgPT09ICdhcnJheScpIHtcbiAgICBjb25zdCBrZXkgPSBzaW5nbGVDaGlsZEZpZWxkLnJlbGF0aXZlUGF0aFtzaW5nbGVDaGlsZEZpZWxkLnJlbGF0aXZlUGF0aC5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBwYXJlbnQgPSBnZXRWYWx1ZUF0UHJvcFBhdGgodmFsdWUsIHNpbmdsZUNoaWxkRmllbGQucmVsYXRpdmVQYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgY29uc3QgdmFsdWVBdFByb3BQYXRoID0gcGFyZW50W2tleV07XG4gICAgZGVsZXRlIHBhcmVudFtrZXldO1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbkFzTWFya2RvYykge1xuICAgICAgY29uc3QgaW5uZXJQcm9wUGF0aCA9IGNoaWxkLnByb3BQYXRoLnNsaWNlKHNpbmdsZUNoaWxkRmllbGQucmVsYXRpdmVQYXRoLmxlbmd0aCArIDEpO1xuICAgICAgY29uc3QgbnVtID0gY2hpbGQucHJvcFBhdGhbc2luZ2xlQ2hpbGRGaWVsZC5yZWxhdGl2ZVBhdGgubGVuZ3RoXTtcbiAgICAgIGlmIChjaGlsZE5vZGVzLmdldChudW0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2hpbGROb2Rlcy5zZXQobnVtLCBbXSk7XG4gICAgICB9XG4gICAgICBjaGlsZE5vZGVzLmdldChudW0pLnB1c2goe1xuICAgICAgICBjaGlsZHJlbjogY2hpbGQuY2hpbGRyZW4sXG4gICAgICAgIHByb3BQYXRoOiBpbm5lclByb3BQYXRoXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVzdWx0aW5nQ2hpbGRyZW4ucHVzaCguLi52YWx1ZUF0UHJvcFBhdGgubWFwKCh4LCBpKSA9PiB7XG4gICAgICB2YXIgX2NoaWxkTm9kZXMkZ2V0O1xuICAgICAgY29uc3QgbmV3Q2hpbGRyZW5Bc01hcmtkb2MgPSAoX2NoaWxkTm9kZXMkZ2V0ID0gY2hpbGROb2Rlcy5nZXQoaSkpICE9PSBudWxsICYmIF9jaGlsZE5vZGVzJGdldCAhPT0gdm9pZCAwID8gX2NoaWxkTm9kZXMkZ2V0IDogW107XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgdG9DaGlsZHJlbkFuZFByb3BzKG5ld0NoaWxkcmVuQXNNYXJrZG9jLCBjaGlsZHJlbiwgeCwgc2luZ2xlQ2hpbGRGaWVsZC5jaGlsZCk7XG4gICAgICByZXR1cm4gbmV3IEFzdC5Ob2RlKCd0YWcnLCB4LCBjaGlsZHJlbiwgc2luZ2xlQ2hpbGRGaWVsZC5hc0NoaWxkVGFnKTtcbiAgICB9KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvTWFya2RvYyhub2RlLCBjb25maWcpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICBjb25zdCBtYXJrZG9jTm9kZSA9IG5ldyBBc3QuTm9kZSgncGFyYWdyYXBoJywgbm9kZS50ZXh0QWxpZ24gPyB7XG4gICAgICB0ZXh0QWxpZ246IG5vZGUudGV4dEFsaWduXG4gICAgfSA6IHt9LCBbdG9JbmxpbmUobm9kZS5jaGlsZHJlbildKTtcbiAgICBpZiAobm9kZS50ZXh0QWxpZ24pIHtcbiAgICAgIG1hcmtkb2NOb2RlLmFubm90YXRpb25zLnB1c2goe1xuICAgICAgICBuYW1lOiAndGV4dEFsaWduJyxcbiAgICAgICAgdmFsdWU6IG5vZGUudGV4dEFsaWduLFxuICAgICAgICB0eXBlOiAnYXR0cmlidXRlJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZG9jTm9kZTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAnaW1hZ2UnKSB7XG4gICAgY29uZmlnLmV4dHJhRmlsZXMucHVzaCh7XG4gICAgICBjb250ZW50czogbm9kZS5zcmMuY29udGVudCxcbiAgICAgIHBhdGg6IG5vZGUuc3JjLmZpbGVuYW1lLFxuICAgICAgcGFyZW50OiB0eXBlb2YgY29uZmlnLmRvY3VtZW50RmVhdHVyZXMuaW1hZ2VzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY29uZmlnLmRvY3VtZW50RmVhdHVyZXMuaW1hZ2VzLmRpcmVjdG9yeSA9PT0gJ3N0cmluZycgPyBmaXhQYXRoKGNvbmZpZy5kb2N1bWVudEZlYXR1cmVzLmltYWdlcy5kaXJlY3RvcnkpIDogdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBBc3QuTm9kZSgncGFyYWdyYXBoJywge30sIFtuZXcgQXN0Lk5vZGUoJ2lubGluZScsIHt9LCBbbmV3IEFzdC5Ob2RlKCdpbWFnZScsIHtcbiAgICAgIHNyYzogZW5jb2RlVVJJKGAke2dldFNyY1ByZWZpeEZvckltYWdlQmxvY2soY29uZmlnLmRvY3VtZW50RmVhdHVyZXMsIGNvbmZpZy5zbHVnKX0ke25vZGUuc3JjLmZpbGVuYW1lfWApLFxuICAgICAgYWx0OiBub2RlLmFsdCxcbiAgICAgIHRpdGxlOiBub2RlLnRpdGxlXG4gICAgfSldKV0pO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICdjb2RlJykge1xuICAgIGNvbnN0IGV4dHJhQXR0cmlidXRlcyA9IHt9O1xuICAgIGNvbnN0IHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgbGFuZ3VhZ2UsXG4gICAgICB0eXBlLFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSBub2RlO1xuICAgIGNvbnN0IHNjaGVtYSA9IHR5cGVvZiBjb25maWcuZG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmJsb2NrVHlwZXMuY29kZSA9PT0gJ29iamVjdCcgPyBjb25maWcuZG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmJsb2NrVHlwZXMuY29kZS5zY2hlbWEgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHNjaGVtYSAmJiBPYmplY3Qua2V5cyhzY2hlbWEuZmllbGRzKS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gc2VyaWFsaXplUHJvcHMoZ2V0SW5pdGlhbFByb3BzVmFsdWVGcm9tSW5pdGlhbGl6ZXIoc2NoZW1hLCByZXN0KSwgc2NoZW1hLCB1bmRlZmluZWQsIGNvbmZpZy5zbHVnLCBmYWxzZSk7XG4gICAgICBPYmplY3QuYXNzaWduKGV4dHJhQXR0cmlidXRlcywgc2VyaWFsaXplZC52YWx1ZSk7XG4gICAgICBjb25maWcuZXh0cmFGaWxlcy5wdXNoKC4uLnNlcmlhbGl6ZWQuZXh0cmFGaWxlcyk7XG4gICAgfVxuICAgIGxldCBjb250ZW50ID0gY2hpbGRyZW5bMF0udGV4dCArICdcXG4nO1xuICAgIGNvbnN0IG1hcmtkb2NOb2RlID0gbmV3IEFzdC5Ob2RlKCdmZW5jZScsIHtcbiAgICAgIGNvbnRlbnQsXG4gICAgICBsYW5ndWFnZSxcbiAgICAgIC4uLmV4dHJhQXR0cmlidXRlc1xuICAgIH0sIFtuZXcgQXN0Lk5vZGUoJ3RleHQnLCB7XG4gICAgICBjb250ZW50XG4gICAgfSldKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhleHRyYUF0dHJpYnV0ZXMpKSB7XG4gICAgICBtYXJrZG9jTm9kZS5hbm5vdGF0aW9ucy5wdXNoKHtcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdHlwZTogJ2F0dHJpYnV0ZSdcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2RvY05vZGU7XG4gIH1cbiAgY29uc3QgX3RvTWFya2RvYyA9IG5vZGUgPT4gdG9NYXJrZG9jKG5vZGUsIGNvbmZpZyk7XG4gIGlmIChub2RlLnR5cGUgPT09ICdibG9ja3F1b3RlJykge1xuICAgIHJldHVybiBuZXcgQXN0Lk5vZGUoJ2Jsb2NrcXVvdGUnLCB7fSwgbm9kZS5jaGlsZHJlbi5tYXAoX3RvTWFya2RvYykpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICdkaXZpZGVyJykge1xuICAgIHJldHVybiBuZXcgQXN0Lk5vZGUoJ2hyJyk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3RhYmxlJykge1xuICAgIGNvbnN0IGhlYWQgPSBub2RlLmNoaWxkcmVuLmZpbmQoeCA9PiB4LnR5cGUgPT09ICd0YWJsZS1oZWFkJyk7XG4gICAgcmV0dXJuIG5ldyBBc3QuTm9kZSgndGFnJywge30sIFtuZXcgQXN0Lk5vZGUoJ3RhYmxlJywge30sIFtuZXcgQXN0Lk5vZGUoJ3RoZWFkJywge30sIGhlYWQgPyBoZWFkLmNoaWxkcmVuLm1hcChfdG9NYXJrZG9jKSA6IFtdKSwgX3RvTWFya2RvYyhub2RlLmNoaWxkcmVuLmZpbmQoeCA9PiB4LnR5cGUgPT09ICd0YWJsZS1ib2R5JykpXSldLCAndGFibGUnKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAndGFibGUtYm9keScpIHtcbiAgICByZXR1cm4gbmV3IEFzdC5Ob2RlKCd0Ym9keScsIHt9LCBub2RlLmNoaWxkcmVuLm1hcChfdG9NYXJrZG9jKSk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3RhYmxlLXJvdycpIHtcbiAgICByZXR1cm4gbmV3IEFzdC5Ob2RlKCd0cicsIHt9LCBub2RlLmNoaWxkcmVuLm1hcChfdG9NYXJrZG9jKSk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3RhYmxlLWNlbGwnKSB7XG4gICAgcmV0dXJuIG5ldyBBc3QuTm9kZShub2RlLmhlYWRlciA/ICd0aCcgOiAndGQnLCB7fSwgbm9kZS5jaGlsZHJlbi5tYXAoX3RvTWFya2RvYykpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICdoZWFkaW5nJykge1xuICAgIGNvbnN0IGV4dHJhQXR0cmlidXRlcyA9IHt9O1xuICAgIGlmIChub2RlLnRleHRBbGlnbikge1xuICAgICAgZXh0cmFBdHRyaWJ1dGVzLnRleHRBbGlnbiA9IG5vZGUudGV4dEFsaWduO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjaGlsZHJlbixcbiAgICAgIGxldmVsLFxuICAgICAgdGV4dEFsaWduLFxuICAgICAgdHlwZSxcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gbm9kZTtcbiAgICBjb25zdCBzY2hlbWEgPSBjb25maWcuZG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmhlYWRpbmdzLnNjaGVtYTtcbiAgICBpZiAoT2JqZWN0LmtleXMoc2NoZW1hLmZpZWxkcykubGVuZ3RoID4gMCkge1xuICAgICAgT2JqZWN0LmFzc2lnbihleHRyYUF0dHJpYnV0ZXMsIHNlcmlhbGl6ZVByb3BzKGdldEluaXRpYWxQcm9wc1ZhbHVlRnJvbUluaXRpYWxpemVyKHNjaGVtYSwgcmVzdCksIHNjaGVtYSwgdW5kZWZpbmVkLCBjb25maWcuc2x1ZywgZmFsc2UpLnZhbHVlKTtcbiAgICB9XG4gICAgY29uc3QgbWFya2RvY05vZGUgPSBuZXcgQXN0Lk5vZGUoJ2hlYWRpbmcnLCB7XG4gICAgICBsZXZlbDogbm9kZS5sZXZlbCxcbiAgICAgIC4uLmV4dHJhQXR0cmlidXRlc1xuICAgIH0sIFt0b0lubGluZShub2RlLmNoaWxkcmVuKV0pO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGV4dHJhQXR0cmlidXRlcykpIHtcbiAgICAgIG1hcmtkb2NOb2RlLmFubm90YXRpb25zLnB1c2goe1xuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlOiAnYXR0cmlidXRlJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZG9jTm9kZTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAnb3JkZXJlZC1saXN0Jykge1xuICAgIHJldHVybiBuZXcgQXN0Lk5vZGUoJ2xpc3QnLCB7XG4gICAgICBvcmRlcmVkOiB0cnVlXG4gICAgfSwgbm9kZS5jaGlsZHJlbi5tYXAoX3RvTWFya2RvYykpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICd1bm9yZGVyZWQtbGlzdCcpIHtcbiAgICByZXR1cm4gbmV3IEFzdC5Ob2RlKCdsaXN0Jywge1xuICAgICAgb3JkZXJlZDogZmFsc2VcbiAgICB9LCBub2RlLmNoaWxkcmVuLm1hcChfdG9NYXJrZG9jKSk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2xheW91dCcpIHtcbiAgICByZXR1cm4gbmV3IEFzdC5Ob2RlKCd0YWcnLCB7XG4gICAgICBsYXlvdXQ6IG5vZGUubGF5b3V0XG4gICAgfSwgbm9kZS5jaGlsZHJlbi5tYXAoX3RvTWFya2RvYyksICdsYXlvdXQnKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAnbGF5b3V0LWFyZWEnKSB7XG4gICAgcmV0dXJuIG5ldyBBc3QuTm9kZSgndGFnJywge30sIG5vZGUuY2hpbGRyZW4uZmxhdE1hcChfdG9NYXJrZG9jKSwgJ2xheW91dC1hcmVhJyk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2NvbXBvbmVudC1ibG9jaycpIHtcbiAgICBjb25zdCBpc1ZvaWQgPSBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09ICdjb21wb25lbnQtaW5saW5lLXByb3AnICYmIG5vZGUuY2hpbGRyZW5bMF0ucHJvcFBhdGggPT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBjb21wb25lbnRCbG9jayA9IGNvbmZpZy5jb21wb25lbnRCbG9ja3Nbbm9kZS5jb21wb25lbnRdO1xuICAgIGNvbnN0IGNoaWxkcmVuQXNNYXJrZG9jID0gW107XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICBpZiAoKGNoaWxkLnR5cGUgPT09ICdjb21wb25lbnQtYmxvY2stcHJvcCcgfHwgY2hpbGQudHlwZSA9PT0gJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCcpICYmIGNoaWxkLnByb3BQYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2hpbGRyZW5Bc01hcmtkb2MucHVzaCh7XG4gICAgICAgICAgdHlwZTogY2hpbGQudHlwZSxcbiAgICAgICAgICBwcm9wUGF0aDogY2hpbGQucHJvcFBhdGgsXG4gICAgICAgICAgY2hpbGRyZW46IGNoaWxkLnR5cGUgPT09ICdjb21wb25lbnQtYmxvY2stcHJvcCcgPyBjaGlsZC5jaGlsZHJlbi5mbGF0TWFwKF90b01hcmtkb2MpIDogW3RvSW5saW5lKGNoaWxkLmNoaWxkcmVuKV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBhdHRyaWJ1dGVzID0gbm9kZS5wcm9wcztcbiAgICBpZiAoY29tcG9uZW50QmxvY2spIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBzZXJpYWxpemVQcm9wcyhub2RlLnByb3BzLCB7XG4gICAgICAgIGtpbmQ6ICdvYmplY3QnLFxuICAgICAgICBmaWVsZHM6IGNvbXBvbmVudEJsb2NrLnNjaGVtYVxuICAgICAgfSwgdW5kZWZpbmVkLCBjb25maWcuc2x1ZywgZmFsc2UpO1xuICAgICAgYXR0cmlidXRlcyA9IHNlcmlhbGl6ZWQudmFsdWU7XG4gICAgICBjb25maWcuZXh0cmFGaWxlcy5wdXNoKC4uLnNlcmlhbGl6ZWQuZXh0cmFGaWxlcyk7XG4gICAgICBjb25zdCBzaW5nbGVDaGlsZEZpZWxkID0gZmluZFNpbmdsZUNoaWxkRmllbGQoe1xuICAgICAgICBraW5kOiAnb2JqZWN0JyxcbiAgICAgICAgZmllbGRzOiBjb21wb25lbnRCbG9jay5zY2hlbWFcbiAgICAgIH0pO1xuICAgICAgaWYgKHNpbmdsZUNoaWxkRmllbGQpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdG9DaGlsZHJlbkFuZFByb3BzKGNoaWxkcmVuQXNNYXJrZG9jLCBjaGlsZHJlbiwgYXR0cmlidXRlcywgc2luZ2xlQ2hpbGRGaWVsZCk7XG4gICAgICAgIHJldHVybiBuZXcgQXN0Lk5vZGUoJ3RhZycsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuLCBub2RlLmNvbXBvbmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gaXNWb2lkID8gW10gOiBjaGlsZHJlbkFzTWFya2RvYy5tYXAoeCA9PiBuZXcgQXN0Lk5vZGUoJ3RhZycsIHtcbiAgICAgIHByb3BQYXRoOiB4LnByb3BQYXRoXG4gICAgfSwgeC5jaGlsZHJlbiwgeC50eXBlKSk7XG4gICAgcmV0dXJuIG5ldyBBc3QuTm9kZSgndGFnJywgYXR0cmlidXRlcywgY2hpbGRyZW4sIG5vZGUuY29tcG9uZW50KTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAnY29tcG9uZW50LWJsb2NrLXByb3AnIHx8IG5vZGUudHlwZSA9PT0gJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCcpIHtcbiAgICByZXR1cm4gbmV3IEFzdC5Ob2RlKCd0YWcnLCB7XG4gICAgICBwcm9wUGF0aDogbm9kZS5wcm9wUGF0aFxuICAgIH0sIG5vZGUudHlwZSA9PT0gJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCcgPyBbdG9JbmxpbmUobm9kZS5jaGlsZHJlbildIDogbm9kZS5jaGlsZHJlbi5mbGF0TWFwKF90b01hcmtkb2MpLCBub2RlLnR5cGUpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICdsaXN0LWl0ZW0nKSB7XG4gICAgY29uc3QgbGlzdEl0ZW1Db250ZW50ID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICBpZiAobGlzdEl0ZW1Db250ZW50LnR5cGUgIT09ICdsaXN0LWl0ZW0tY29udGVudCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGlzdCBpdGVtIGNvbnRlbnQgbXVzdCBjb250YWluIGEgbGlzdC1pdGVtLWNvbnRlbnQnKTtcbiAgICB9XG4gICAgY29uc3QgaW5saW5lID0gdG9JbmxpbmUobGlzdEl0ZW1Db250ZW50LmNoaWxkcmVuKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IFtpbmxpbmVdO1xuICAgIGNvbnN0IG5lc3RlZExpc3QgPSBub2RlLmNoaWxkcmVuWzFdO1xuICAgIGlmIChuZXN0ZWRMaXN0KSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKHRvTWFya2RvYyhuZXN0ZWRMaXN0LCBjb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBc3QuTm9kZSgnaXRlbScsIHt9LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2xpc3QtaXRlbS1jb250ZW50Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignbGlzdC1pdGVtLWNvbnRlbnQgaW4gdW5leHBlY3RlZCBwb3NpdGlvbicpO1xuICB9XG4gIGRlYnVnZ2VyO1xuICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgbm9kZSB0eXBlOiAke25vZGUudHlwZX1gKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUZXh0KHZhbCwgbWluLCBtYXgsIGZpZWxkTGFiZWwsIHNsdWdJbmZvKSB7XG4gIGlmICh2YWwubGVuZ3RoIDwgbWluKSB7XG4gICAgaWYgKG1pbiA9PT0gMSkge1xuICAgICAgcmV0dXJuIGAke2ZpZWxkTGFiZWx9IG11c3Qgbm90IGJlIGVtcHR5YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGAke2ZpZWxkTGFiZWx9IG11c3QgYmUgYXQgbGVhc3QgJHttaW59IGNoYXJhY3RlcnMgbG9uZ2A7XG4gICAgfVxuICB9XG4gIGlmICh2YWwubGVuZ3RoID4gbWF4KSB7XG4gICAgcmV0dXJuIGAke2ZpZWxkTGFiZWx9IG11c3QgYmUgbm8gbG9uZ2VyIHRoYW4gJHttYXh9IGNoYXJhY3RlcnNgO1xuICB9XG4gIGlmIChzbHVnSW5mbykge1xuICAgIGlmICh2YWwgPT09ICcnKSB7XG4gICAgICByZXR1cm4gYCR7ZmllbGRMYWJlbH0gbXVzdCBub3QgYmUgZW1wdHlgO1xuICAgIH1cbiAgICBpZiAodmFsID09PSAnLi4nKSB7XG4gICAgICByZXR1cm4gYCR7ZmllbGRMYWJlbH0gbXVzdCBub3QgYmUgLi5gO1xuICAgIH1cbiAgICBpZiAodmFsID09PSAnLicpIHtcbiAgICAgIHJldHVybiBgJHtmaWVsZExhYmVsfSBtdXN0IG5vdCBiZSAuYDtcbiAgICB9XG4gICAgaWYgKHNsdWdJbmZvLmdsb2IgPT09ICcqKicpIHtcbiAgICAgIGNvbnN0IHNwbGl0ID0gdmFsLnNwbGl0KCcvJyk7XG4gICAgICBpZiAoc3BsaXQuc29tZShzID0+IHMgPT09ICcuLicpKSB7XG4gICAgICAgIHJldHVybiBgJHtmaWVsZExhYmVsfSBtdXN0IG5vdCBjb250YWluIC4uYDtcbiAgICAgIH1cbiAgICAgIGlmIChzcGxpdC5zb21lKHMgPT4gcyA9PT0gJy4nKSkge1xuICAgICAgICByZXR1cm4gYCR7ZmllbGRMYWJlbH0gbXVzdCBub3QgYmUgLmA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgoc2x1Z0luZm8uZ2xvYiA9PT0gJyonID8gL1tcXFxcL10vIDogL1tcXFxcXS8pLnRlc3QodmFsKSkge1xuICAgICAgcmV0dXJuIGAke2ZpZWxkTGFiZWx9IG11c3Qgbm90IGNvbnRhaW4gc2xhc2hlc2A7XG4gICAgfVxuICAgIGlmICgvXlxcc3xcXHMkLy50ZXN0KHZhbCkpIHtcbiAgICAgIHJldHVybiBgJHtmaWVsZExhYmVsfSBtdXN0IG5vdCBzdGFydCBvciBlbmQgd2l0aCBzcGFjZXNgO1xuICAgIH1cbiAgICBpZiAoc2x1Z0luZm8uc2x1Z3MuaGFzKHZhbCkpIHtcbiAgICAgIHJldHVybiBgJHtmaWVsZExhYmVsfSBtdXN0IGJlIHVuaXF1ZWA7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlQXNOb3JtYWxGaWVsZCh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcignTXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IGVtcHR5U2V0ID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gdGV4dCh7XG4gIGxhYmVsLFxuICBkZWZhdWx0VmFsdWUgPSAnJyxcbiAgdmFsaWRhdGlvbjoge1xuICAgIGxlbmd0aDoge1xuICAgICAgbWF4ID0gSW5maW5pdHksXG4gICAgICBtaW4gPSAwXG4gICAgfSA9IHt9XG4gIH0gPSB7fSxcbiAgZGVzY3JpcHRpb24sXG4gIG11bHRpbGluZSA9IGZhbHNlXG59KSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBzbHVnRmllbGQpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdmFsaWRhdGVUZXh0KHZhbHVlLCBtaW4sIG1heCwgbGFiZWwsIHNsdWdGaWVsZCk7XG4gICAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBraW5kOiAnZm9ybScsXG4gICAgZm9ybUtpbmQ6ICdzbHVnJyxcbiAgICBsYWJlbCxcbiAgICBJbnB1dChwcm9wcykge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goVGV4dEZpZWxkSW5wdXQsIHtcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgIG1pbjogbWluLFxuICAgICAgICBtYXg6IG1heCxcbiAgICAgICAgbXVsdGlsaW5lOiBtdWx0aWxpbmUsXG4gICAgICAgIC4uLnByb3BzXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFZhbHVlID09PSAnc3RyaW5nJyA/IGRlZmF1bHRWYWx1ZSA6IGRlZmF1bHRWYWx1ZSgpO1xuICAgIH0sXG4gICAgcGFyc2UodmFsdWUsIGFyZ3MpIHtcbiAgICAgIGlmICgoYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLnNsdWcpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3Muc2x1ZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZUFzTm9ybWFsRmllbGQodmFsdWUpO1xuICAgIH0sXG4gICAgc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUgPT09ICcnID8gdW5kZWZpbmVkIDogdmFsdWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBzZXJpYWxpemVXaXRoU2x1Zyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2x1ZzogdmFsdWUsXG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfSxcbiAgICByZWFkZXI6IHtcbiAgICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQXNOb3JtYWxGaWVsZCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwYXJzZWQsIHVuZGVmaW5lZCk7XG4gICAgICB9LFxuICAgICAgcGFyc2VXaXRoU2x1ZyhfdmFsdWUsIGFyZ3MpIHtcbiAgICAgICAgdmFsaWRhdGUocGFyc2VBc05vcm1hbEZpZWxkKGFyZ3Muc2x1ZyksIHtcbiAgICAgICAgICBnbG9iOiBhcmdzLmdsb2IsXG4gICAgICAgICAgc2x1Z3M6IGVtcHR5U2V0XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlKHZhbHVlLCBhcmdzKSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGUodmFsdWUsIGFyZ3MgPT09IG51bGwgfHwgYXJncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXJncy5zbHVnRmllbGQpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmdsb2JhbFRoaXMuUHJpc20gPSB7XG4gIG1hbnVhbDogdHJ1ZVxufTtcblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jb3JlLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8vLyA8cmVmZXJlbmNlIGxpYj1cIldlYldvcmtlclwiLz5cblxudmFyIF9zZWxmID0gZ2xvYmFsVGhpcztcblxuLyoqXG4gKiBQcmlzbTogTGlnaHR3ZWlnaHQsIHJvYnVzdCwgZWxlZ2FudCBzeW50YXggaGlnaGxpZ2h0aW5nXG4gKlxuICogQGxpY2Vuc2UgTUlUIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD5cbiAqIEBhdXRob3IgTGVhIFZlcm91IDxodHRwczovL2xlYS52ZXJvdS5tZT5cbiAqIEBuYW1lc3BhY2VcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFByaXNtID0gZnVuY3Rpb24gKF9zZWxmKSB7XG4gIC8vIFByaXZhdGUgaGVscGVyIHZhcnNcbiAgdmFyIGxhbmcgPSAvKD86XnxcXHMpbGFuZyg/OnVhZ2UpPy0oW1xcdy1dKykoPz1cXHN8JCkvaTtcbiAgdmFyIHVuaXF1ZUlkID0gMDtcblxuICAvLyBUaGUgZ3JhbW1hciBvYmplY3QgZm9yIHBsYWludGV4dFxuICB2YXIgcGxhaW5UZXh0R3JhbW1hciA9IHt9O1xuICB2YXIgXyA9IHtcbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCBQcmlzbSB3aWxsIGF0dGVtcHQgdG8gaGlnaGxpZ2h0IGFsbCBjb2RlIGVsZW1lbnRzIChieSBjYWxsaW5nIHtAbGluayBQcmlzbS5oaWdobGlnaHRBbGx9KSBvbiB0aGVcbiAgICAgKiBjdXJyZW50IHBhZ2UgYWZ0ZXIgdGhlIHBhZ2UgZmluaXNoZWQgbG9hZGluZy4gVGhpcyBtaWdodCBiZSBhIHByb2JsZW0gaWYgZS5nLiB5b3Ugd2FudGVkIHRvIGFzeW5jaHJvbm91c2x5IGxvYWRcbiAgICAgKiBhZGRpdGlvbmFsIGxhbmd1YWdlcyBvciBwbHVnaW5zIHlvdXJzZWxmLlxuICAgICAqXG4gICAgICogQnkgc2V0dGluZyB0aGlzIHZhbHVlIHRvIGB0cnVlYCwgUHJpc20gd2lsbCBub3QgYXV0b21hdGljYWxseSBoaWdobGlnaHQgYWxsIGNvZGUgZWxlbWVudHMgb24gdGhlIHBhZ2UuXG4gICAgICpcbiAgICAgKiBZb3Ugb2J2aW91c2x5IGhhdmUgdG8gY2hhbmdlIHRoaXMgdmFsdWUgYmVmb3JlIHRoZSBhdXRvbWF0aWMgaGlnaGxpZ2h0aW5nIHN0YXJ0ZWQuIFRvIGRvIHRoaXMsIHlvdSBjYW4gYWRkIGFuXG4gICAgICogZW1wdHkgUHJpc20gb2JqZWN0IGludG8gdGhlIGdsb2JhbCBzY29wZSBiZWZvcmUgbG9hZGluZyB0aGUgUHJpc20gc2NyaXB0IGxpa2UgdGhpczpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogd2luZG93LlByaXNtID0gd2luZG93LlByaXNtIHx8IHt9O1xuICAgICAqIFByaXNtLm1hbnVhbCA9IHRydWU7XG4gICAgICogLy8gYWRkIGEgbmV3IDxzY3JpcHQ+IHRvIGxvYWQgUHJpc20ncyBzY3JpcHRcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlcm9mIFByaXNtXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIG1hbnVhbDogX3NlbGYuUHJpc20gJiYgX3NlbGYuUHJpc20ubWFudWFsLFxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIGlmIFByaXNtIGlzIGluIGEgd2ViIHdvcmtlciwgaXQgYXNzdW1lcyB0aGF0IGl0IGlzIGluIGEgd29ya2VyIGl0IGNyZWF0ZWQgaXRzZWxmLCBzbyBpdCB1c2VzXG4gICAgICogYGFkZEV2ZW50TGlzdGVuZXJgIHRvIGNvbW11bmljYXRlIHdpdGggaXRzIHBhcmVudCBpbnN0YW5jZS4gSG93ZXZlciwgaWYgeW91J3JlIHVzaW5nIFByaXNtIG1hbnVhbGx5IGluIHlvdXJcbiAgICAgKiBvd24gd29ya2VyLCB5b3UgZG9uJ3Qgd2FudCBpdCB0byBkbyB0aGlzLlxuICAgICAqXG4gICAgICogQnkgc2V0dGluZyB0aGlzIHZhbHVlIHRvIGB0cnVlYCwgUHJpc20gd2lsbCBub3QgYWRkIGl0cyBvd24gbGlzdGVuZXJzIHRvIHRoZSB3b3JrZXIuXG4gICAgICpcbiAgICAgKiBZb3Ugb2J2aW91c2x5IGhhdmUgdG8gY2hhbmdlIHRoaXMgdmFsdWUgYmVmb3JlIFByaXNtIGV4ZWN1dGVzLiBUbyBkbyB0aGlzLCB5b3UgY2FuIGFkZCBhblxuICAgICAqIGVtcHR5IFByaXNtIG9iamVjdCBpbnRvIHRoZSBnbG9iYWwgc2NvcGUgYmVmb3JlIGxvYWRpbmcgdGhlIFByaXNtIHNjcmlwdCBsaWtlIHRoaXM6XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIHdpbmRvdy5QcmlzbSA9IHdpbmRvdy5QcmlzbSB8fCB7fTtcbiAgICAgKiBQcmlzbS5kaXNhYmxlV29ya2VyTWVzc2FnZUhhbmRsZXIgPSB0cnVlO1xuICAgICAqIC8vIExvYWQgUHJpc20ncyBzY3JpcHRcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlcm9mIFByaXNtXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlcjogX3NlbGYuUHJpc20gJiYgX3NlbGYuUHJpc20uZGlzYWJsZVdvcmtlck1lc3NhZ2VIYW5kbGVyLFxuICAgIC8qKlxuICAgICAqIEEgbmFtZXNwYWNlIGZvciB1dGlsaXR5IG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBBbGwgZnVuY3Rpb24gaW4gdGhpcyBuYW1lc3BhY2UgdGhhdCBhcmUgbm90IGV4cGxpY2l0bHkgbWFya2VkIGFzIF9wdWJsaWNfIGFyZSBmb3IgX19pbnRlcm5hbCB1c2Ugb25seV9fIGFuZCBtYXlcbiAgICAgKiBjaGFuZ2Ugb3IgZGlzYXBwZWFyIGF0IGFueSB0aW1lLlxuICAgICAqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQcmlzbVxuICAgICAqL1xuICAgIHV0aWw6IHtcbiAgICAgIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlKHRva2Vucykge1xuICAgICAgICBpZiAodG9rZW5zIGluc3RhbmNlb2YgVG9rZW4pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFRva2VuKHRva2Vucy50eXBlLCBlbmNvZGUodG9rZW5zLmNvbnRlbnQpLCB0b2tlbnMuYWxpYXMpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodG9rZW5zKSkge1xuICAgICAgICAgIHJldHVybiB0b2tlbnMubWFwKGVuY29kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRva2Vucy5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC9cXHUwMGEwL2csICcgJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHR5cGUgb2YgdGhlIGdpdmVuIHZhbHVlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7YW55fSBvXG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIHR5cGUobnVsbCkgICAgICA9PT0gJ051bGwnXG4gICAgICAgKiB0eXBlKHVuZGVmaW5lZCkgPT09ICdVbmRlZmluZWQnXG4gICAgICAgKiB0eXBlKDEyMykgICAgICAgPT09ICdOdW1iZXInXG4gICAgICAgKiB0eXBlKCdmb28nKSAgICAgPT09ICdTdHJpbmcnXG4gICAgICAgKiB0eXBlKHRydWUpICAgICAgPT09ICdCb29sZWFuJ1xuICAgICAgICogdHlwZShbMSwgMl0pICAgID09PSAnQXJyYXknXG4gICAgICAgKiB0eXBlKHt9KSAgICAgICAgPT09ICdPYmplY3QnXG4gICAgICAgKiB0eXBlKFN0cmluZykgICAgPT09ICdGdW5jdGlvbidcbiAgICAgICAqIHR5cGUoL2FiYysvKSAgICA9PT0gJ1JlZ0V4cCdcbiAgICAgICAqL1xuICAgICAgdHlwZTogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgdW5pcXVlIG51bWJlciBmb3IgdGhlIGdpdmVuIG9iamVjdC4gTGF0ZXIgY2FsbHMgd2lsbCBzdGlsbCByZXR1cm4gdGhlIHNhbWUgbnVtYmVyLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIG9iaklkOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmICghb2JqWydfX2lkJ10pIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCAnX19pZCcsIHtcbiAgICAgICAgICAgIHZhbHVlOiArK3VuaXF1ZUlkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9ialsnX19pZCddO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgbWFpbiBpbnRlbmRlZCB1c2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBjbG9uZSBsYW5ndWFnZSBkZWZpbml0aW9ucy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1R9IG9cbiAgICAgICAqIEBwYXJhbSB7UmVjb3JkPG51bWJlciwgYW55Pn0gW3Zpc2l0ZWRdXG4gICAgICAgKiBAcmV0dXJucyB7VH1cbiAgICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICAgKi9cbiAgICAgIGNsb25lOiBmdW5jdGlvbiBkZWVwQ2xvbmUobywgdmlzaXRlZCkge1xuICAgICAgICB2aXNpdGVkID0gdmlzaXRlZCB8fCB7fTtcbiAgICAgICAgdmFyIGNsb25lO1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIHN3aXRjaCAoXy51dGlsLnR5cGUobykpIHtcbiAgICAgICAgICBjYXNlICdPYmplY3QnOlxuICAgICAgICAgICAgaWQgPSBfLnV0aWwub2JqSWQobyk7XG4gICAgICAgICAgICBpZiAodmlzaXRlZFtpZF0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0ZWRbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xvbmUgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGFueT59ICove307XG4gICAgICAgICAgICB2aXNpdGVkW2lkXSA9IGNsb25lO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG8pIHtcbiAgICAgICAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNsb25lW2tleV0gPSBkZWVwQ2xvbmUob1trZXldLCB2aXNpdGVkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqL2Nsb25lO1xuICAgICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgICAgIGlkID0gXy51dGlsLm9iaklkKG8pO1xuICAgICAgICAgICAgaWYgKHZpc2l0ZWRbaWRdKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2aXNpdGVkW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsb25lID0gW107XG4gICAgICAgICAgICB2aXNpdGVkW2lkXSA9IGNsb25lO1xuICAgICAgICAgICAgKCAvKiogQHR5cGUge0FycmF5fSAqLyAvKiogQHR5cGUge2FueX0gKi9vKS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICAgIGNsb25lW2ldID0gZGVlcENsb25lKHYsIHZpc2l0ZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovY2xvbmU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBQcmlzbSBsYW5ndWFnZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBzZXQgYnkgYSBgbGFuZ3VhZ2UteHh4eGAgb3IgYGxhbmcteHh4eGAgY2xhc3MuXG4gICAgICAgKlxuICAgICAgICogSWYgbm8gbGFuZ3VhZ2UgaXMgc2V0IGZvciB0aGUgZWxlbWVudCBvciB0aGUgZWxlbWVudCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIGBub25lYCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAqL1xuICAgICAgZ2V0TGFuZ3VhZ2U6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICAgICAgdmFyIG0gPSBsYW5nLmV4ZWMoZWxlbWVudC5jbGFzc05hbWUpO1xuICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gbVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIHRoZSBQcmlzbSBgbGFuZ3VhZ2UteHh4eGAgY2xhc3Mgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2VcbiAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAgICovXG4gICAgICBzZXRMYW5ndWFnZTogZnVuY3Rpb24gKGVsZW1lbnQsIGxhbmd1YWdlKSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgYGxhbmd1YWdlLXh4eHhgIGNsYXNzZXNcbiAgICAgICAgLy8gKHRoaXMgbWlnaHQgbGVhdmUgYmVoaW5kIGEgbGVhZGluZyBzcGFjZSlcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKFJlZ0V4cChsYW5nLCAnZ2knKSwgJycpO1xuXG4gICAgICAgIC8vIGFkZCB0aGUgbmV3IGBsYW5ndWFnZS14eHh4YCBjbGFzc1xuICAgICAgICAvLyAodXNpbmcgYGNsYXNzTGlzdGAgd2lsbCBhdXRvbWF0aWNhbGx5IGNsZWFuIHVwIHNwYWNlcyBmb3IgdXMpXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbGFuZ3VhZ2UtJyArIGxhbmd1YWdlKTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIHNjcmlwdCBlbGVtZW50IHRoYXQgaXMgY3VycmVudGx5IGV4ZWN1dGluZy5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGRvZXMgX19ub3RfXyB3b3JrIGZvciBsaW5lIHNjcmlwdCBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtIVE1MU2NyaXB0RWxlbWVudCB8IG51bGx9XG4gICAgICAgKi9cbiAgICAgIGN1cnJlbnRTY3JpcHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2N1cnJlbnRTY3JpcHQnIGluIGRvY3VtZW50ICYmIDEgPCAyIC8qIGhhY2sgdG8gdHJpcCBUUycgZmxvdyBhbmFseXNpcyAqLykge1xuICAgICAgICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi9kb2N1bWVudC5jdXJyZW50U2NyaXB0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSUUxMSB3b3JrYXJvdW5kXG4gICAgICAgIC8vIHdlJ2xsIGdldCB0aGUgc3JjIG9mIHRoZSBjdXJyZW50IHNjcmlwdCBieSBwYXJzaW5nIElFMTEncyBlcnJvciBzdGFjayB0cmFjZVxuICAgICAgICAvLyB0aGlzIHdpbGwgbm90IHdvcmsgZm9yIGlubGluZSBzY3JpcHRzXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gR2V0IGZpbGUgc3JjIHVybCBmcm9tIHN0YWNrLiBTcGVjaWZpY2FsbHkgd29ya3Mgd2l0aCB0aGUgZm9ybWF0IG9mIHN0YWNrIHRyYWNlcyBpbiBJRS5cbiAgICAgICAgICAvLyBBIHN0YWNrIHdpbGwgbG9vayBsaWtlIHRoaXM6XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBFcnJvclxuICAgICAgICAgIC8vICAgIGF0IF8udXRpbC5jdXJyZW50U2NyaXB0IChodHRwOi8vbG9jYWxob3N0L2NvbXBvbmVudHMvcHJpc20tY29yZS5qczoxMTk6NSlcbiAgICAgICAgICAvLyAgICBhdCBHbG9iYWwgY29kZSAoaHR0cDovL2xvY2FsaG9zdC9jb21wb25lbnRzL3ByaXNtLWNvcmUuanM6NjA2OjEpXG5cbiAgICAgICAgICB2YXIgc3JjID0gKC9hdCBbXihcXHJcXG5dKlxcKCguKik6W146XSs6W146XStcXCkkL2kuZXhlYyhlcnIuc3RhY2spIHx8IFtdKVsxXTtcbiAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gc2NyaXB0cykge1xuICAgICAgICAgICAgICBpZiAoc2NyaXB0c1tpXS5zcmMgPT0gc3JjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdHNbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgd2hldGhlciBhIGdpdmVuIGNsYXNzIGlzIGFjdGl2ZSBmb3IgYGVsZW1lbnRgLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBjbGFzcyBjYW4gYmUgYWN0aXZhdGVkIGlmIGBlbGVtZW50YCBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgdGhlIGdpdmVuIGNsYXNzIGFuZCBpdCBjYW4gYmUgZGVhY3RpdmF0ZWRcbiAgICAgICAqIGlmIGBlbGVtZW50YCBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgdGhlIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gY2xhc3MuIFRoZSBfbmVnYXRlZCB2ZXJzaW9uXyBvZiB0aGVcbiAgICAgICAqIGdpdmVuIGNsYXNzIGlzIGp1c3QgdGhlIGdpdmVuIGNsYXNzIHdpdGggYSBgbm8tYCBwcmVmaXguXG4gICAgICAgKlxuICAgICAgICogV2hldGhlciB0aGUgY2xhc3MgaXMgYWN0aXZlIGlzIGRldGVybWluZWQgYnkgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgYGVsZW1lbnRgICh3aGVyZSBgZWxlbWVudGAgaXRzZWxmIGlzXG4gICAgICAgKiBjbG9zZXN0IGFuY2VzdG9yKSB0aGF0IGhhcyB0aGUgZ2l2ZW4gY2xhc3Mgb3IgdGhlIG5lZ2F0ZWQgdmVyc2lvbiBvZiBpdC4gSWYgbmVpdGhlciBgZWxlbWVudGAgbm9yIGFueSBvZiBpdHNcbiAgICAgICAqIGFuY2VzdG9ycyBoYXZlIHRoZSBnaXZlbiBjbGFzcyBvciB0aGUgbmVnYXRlZCB2ZXJzaW9uIG9mIGl0LCB0aGVuIHRoZSBkZWZhdWx0IGFjdGl2YXRpb24gd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgICAqXG4gICAgICAgKiBJbiB0aGUgcGFyYWRveGljYWwgc2l0dWF0aW9uIHdoZXJlIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGNvbnRhaW5zIF9fYm90aF9fIHRoZSBnaXZlbiBjbGFzcyBhbmQgdGhlIG5lZ2F0ZWRcbiAgICAgICAqIHZlcnNpb24gb2YgaXQsIHRoZSBjbGFzcyBpcyBjb25zaWRlcmVkIGFjdGl2ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZmF1bHRBY3RpdmF0aW9uPWZhbHNlXVxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGlzQWN0aXZlOiBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lLCBkZWZhdWx0QWN0aXZhdGlvbikge1xuICAgICAgICB2YXIgbm8gPSAnbm8tJyArIGNsYXNzTmFtZTtcbiAgICAgICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgY2xhc3NMaXN0ID0gZWxlbWVudC5jbGFzc0xpc3Q7XG4gICAgICAgICAgaWYgKGNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNsYXNzTGlzdC5jb250YWlucyhubykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISFkZWZhdWx0QWN0aXZhdGlvbjtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoaXMgbmFtZXNwYWNlIGNvbnRhaW5zIGFsbCBjdXJyZW50bHkgbG9hZGVkIGxhbmd1YWdlcyBhbmQgdGhlIHNvbWUgaGVscGVyIGZ1bmN0aW9ucyB0byBjcmVhdGUgYW5kIG1vZGlmeSBsYW5ndWFnZXMuXG4gICAgICpcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFByaXNtXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGxhbmd1YWdlczoge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZ3JhbW1hciBmb3IgcGxhaW4sIHVuZm9ybWF0dGVkIHRleHQuXG4gICAgICAgKi9cbiAgICAgIHBsYWluOiBwbGFpblRleHRHcmFtbWFyLFxuICAgICAgcGxhaW50ZXh0OiBwbGFpblRleHRHcmFtbWFyLFxuICAgICAgdGV4dDogcGxhaW5UZXh0R3JhbW1hcixcbiAgICAgIHR4dDogcGxhaW5UZXh0R3JhbW1hcixcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIGRlZXAgY29weSBvZiB0aGUgbGFuZ3VhZ2Ugd2l0aCB0aGUgZ2l2ZW4gaWQgYW5kIGFwcGVuZHMgdGhlIGdpdmVuIHRva2Vucy5cbiAgICAgICAqXG4gICAgICAgKiBJZiBhIHRva2VuIGluIGByZWRlZmAgYWxzbyBhcHBlYXJzIGluIHRoZSBjb3BpZWQgbGFuZ3VhZ2UsIHRoZW4gdGhlIGV4aXN0aW5nIHRva2VuIGluIHRoZSBjb3BpZWQgbGFuZ3VhZ2VcbiAgICAgICAqIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYXQgaXRzIG9yaWdpbmFsIHBvc2l0aW9uLlxuICAgICAgICpcbiAgICAgICAqICMjIEJlc3QgcHJhY3RpY2VzXG4gICAgICAgKlxuICAgICAgICogU2luY2UgdGhlIHBvc2l0aW9uIG9mIG92ZXJ3cml0aW5nIHRva2VucyAodG9rZW4gaW4gYHJlZGVmYCB0aGF0IG92ZXJ3cml0ZSB0b2tlbnMgaW4gdGhlIGNvcGllZCBsYW5ndWFnZSlcbiAgICAgICAqIGRvZXNuJ3QgbWF0dGVyLCB0aGV5IGNhbiB0ZWNobmljYWxseSBiZSBpbiBhbnkgb3JkZXIuIEhvd2V2ZXIsIHRoaXMgY2FuIGJlIGNvbmZ1c2luZyB0byBvdGhlcnMgdGhhdCB0cnlpbmcgdG9cbiAgICAgICAqIHVuZGVyc3RhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb24gYmVjYXVzZSwgbm9ybWFsbHksIHRoZSBvcmRlciBvZiB0b2tlbnMgbWF0dGVycyBpbiBQcmlzbSBncmFtbWFycy5cbiAgICAgICAqXG4gICAgICAgKiBUaGVyZWZvcmUsIGl0IGlzIGVuY291cmFnZWQgdG8gb3JkZXIgb3ZlcndyaXRpbmcgdG9rZW5zIGFjY29yZGluZyB0byB0aGUgcG9zaXRpb25zIG9mIHRoZSBvdmVyd3JpdHRlbiB0b2tlbnMuXG4gICAgICAgKiBGdXJ0aGVybW9yZSwgYWxsIG5vbi1vdmVyd3JpdGluZyB0b2tlbnMgc2hvdWxkIGJlIHBsYWNlZCBhZnRlciB0aGUgb3ZlcndyaXRpbmcgb25lcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBsYW5ndWFnZSB0byBleHRlbmQuIFRoaXMgaGFzIHRvIGJlIGEga2V5IGluIGBQcmlzbS5sYW5ndWFnZXNgLlxuICAgICAgICogQHBhcmFtIHtHcmFtbWFyfSByZWRlZiBUaGUgbmV3IHRva2VucyB0byBhcHBlbmQuXG4gICAgICAgKiBAcmV0dXJucyB7R3JhbW1hcn0gVGhlIG5ldyBsYW5ndWFnZSBjcmVhdGVkLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIFByaXNtLmxhbmd1YWdlc1snY3NzLXdpdGgtY29sb3JzJ10gPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjc3MnLCB7XG4gICAgICAgKiAgICAgLy8gUHJpc20ubGFuZ3VhZ2VzLmNzcyBhbHJlYWR5IGhhcyBhICdjb21tZW50JyB0b2tlbiwgc28gdGhpcyB0b2tlbiB3aWxsIG92ZXJ3cml0ZSBDU1MnICdjb21tZW50JyB0b2tlblxuICAgICAgICogICAgIC8vIGF0IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuICAgICAgICogICAgICdjb21tZW50JzogeyAuLi4gfSxcbiAgICAgICAqICAgICAvLyBDU1MgZG9lc24ndCBoYXZlIGEgJ2NvbG9yJyB0b2tlbiwgc28gdGhpcyB0b2tlbiB3aWxsIGJlIGFwcGVuZGVkXG4gICAgICAgKiAgICAgJ2NvbG9yJzogL1xcYig/OnJlZHxncmVlbnxibHVlKVxcYi9cbiAgICAgICAqIH0pO1xuICAgICAgICovXG4gICAgICBleHRlbmQ6IGZ1bmN0aW9uIChpZCwgcmVkZWYpIHtcbiAgICAgICAgdmFyIGxhbmcgPSBfLnV0aWwuY2xvbmUoXy5sYW5ndWFnZXNbaWRdKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHJlZGVmKSB7XG4gICAgICAgICAgbGFuZ1trZXldID0gcmVkZWZba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFuZztcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEluc2VydHMgdG9rZW5zIF9iZWZvcmVfIGFub3RoZXIgdG9rZW4gaW4gYSBsYW5ndWFnZSBkZWZpbml0aW9uIG9yIGFueSBvdGhlciBncmFtbWFyLlxuICAgICAgICpcbiAgICAgICAqICMjIFVzYWdlXG4gICAgICAgKlxuICAgICAgICogVGhpcyBoZWxwZXIgbWV0aG9kIG1ha2VzIGl0IGVhc3kgdG8gbW9kaWZ5IGV4aXN0aW5nIGxhbmd1YWdlcy4gRm9yIGV4YW1wbGUsIHRoZSBDU1MgbGFuZ3VhZ2UgZGVmaW5pdGlvblxuICAgICAgICogbm90IG9ubHkgZGVmaW5lcyBDU1MgaGlnaGxpZ2h0aW5nIGZvciBDU1MgZG9jdW1lbnRzLCBidXQgYWxzbyBuZWVkcyB0byBkZWZpbmUgaGlnaGxpZ2h0aW5nIGZvciBDU1MgZW1iZWRkZWRcbiAgICAgICAqIGluIEhUTUwgdGhyb3VnaCBgPHN0eWxlPmAgZWxlbWVudHMuIFRvIGRvIHRoaXMsIGl0IG5lZWRzIHRvIG1vZGlmeSBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAgYW5kIGFkZCB0aGVcbiAgICAgICAqIGFwcHJvcHJpYXRlIHRva2Vucy4gSG93ZXZlciwgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgIGlzIGEgcmVndWxhciBKYXZhU2NyaXB0IG9iamVjdCBsaXRlcmFsLCBzbyBpZiB5b3UgZG9cbiAgICAgICAqIHRoaXM6XG4gICAgICAgKlxuICAgICAgICogYGBganNcbiAgICAgICAqIFByaXNtLmxhbmd1YWdlcy5tYXJrdXAuc3R5bGUgPSB7XG4gICAgICAgKiAgICAgLy8gdG9rZW5cbiAgICAgICAqIH07XG4gICAgICAgKiBgYGBcbiAgICAgICAqXG4gICAgICAgKiB0aGVuIHRoZSBgc3R5bGVgIHRva2VuIHdpbGwgYmUgYWRkZWQgKGFuZCBwcm9jZXNzZWQpIGF0IHRoZSBlbmQuIGBpbnNlcnRCZWZvcmVgIGFsbG93cyB5b3UgdG8gaW5zZXJ0IHRva2Vuc1xuICAgICAgICogYmVmb3JlIGV4aXN0aW5nIHRva2Vucy4gRm9yIHRoZSBDU1MgZXhhbXBsZSBhYm92ZSwgeW91IHdvdWxkIHVzZSBpdCBsaWtlIHRoaXM6XG4gICAgICAgKlxuICAgICAgICogYGBganNcbiAgICAgICAqIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjZGF0YScsIHtcbiAgICAgICAqICAgICAnc3R5bGUnOiB7XG4gICAgICAgKiAgICAgICAgIC8vIHRva2VuXG4gICAgICAgKiAgICAgfVxuICAgICAgICogfSk7XG4gICAgICAgKiBgYGBcbiAgICAgICAqXG4gICAgICAgKiAjIyBTcGVjaWFsIGNhc2VzXG4gICAgICAgKlxuICAgICAgICogSWYgdGhlIGdyYW1tYXJzIG9mIGBpbnNpZGVgIGFuZCBgaW5zZXJ0YCBoYXZlIHRva2VucyB3aXRoIHRoZSBzYW1lIG5hbWUsIHRoZSB0b2tlbnMgaW4gYGluc2lkZWAncyBncmFtbWFyXG4gICAgICAgKiB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBiZWhhdmlvciBjYW4gYmUgdXNlZCB0byBpbnNlcnQgdG9rZW5zIGFmdGVyIGBiZWZvcmVgOlxuICAgICAgICpcbiAgICAgICAqIGBgYGpzXG4gICAgICAgKiBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrdXAnLCAnY29tbWVudCcsIHtcbiAgICAgICAqICAgICAnY29tbWVudCc6IFByaXNtLmxhbmd1YWdlcy5tYXJrdXAuY29tbWVudCxcbiAgICAgICAqICAgICAvLyB0b2tlbnMgYWZ0ZXIgJ2NvbW1lbnQnXG4gICAgICAgKiB9KTtcbiAgICAgICAqIGBgYFxuICAgICAgICpcbiAgICAgICAqICMjIExpbWl0YXRpb25zXG4gICAgICAgKlxuICAgICAgICogVGhlIG1haW4gcHJvYmxlbSBgaW5zZXJ0QmVmb3JlYCBoYXMgdG8gc29sdmUgaXMgaXRlcmF0aW9uIG9yZGVyLiBTaW5jZSBFUzIwMTUsIHRoZSBpdGVyYXRpb24gb3JkZXIgZm9yIG9iamVjdFxuICAgICAgICogcHJvcGVydGllcyBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSBpbnNlcnRpb24gb3JkZXIgKGV4Y2VwdCBmb3IgaW50ZWdlciBrZXlzKSBidXQgc29tZSBicm93c2VycyBiZWhhdmVcbiAgICAgICAqIGRpZmZlcmVudGx5IHdoZW4ga2V5cyBhcmUgZGVsZXRlZCBhbmQgcmUtaW5zZXJ0ZWQuIFNvIGBpbnNlcnRCZWZvcmVgIGNhbid0IGJlIGltcGxlbWVudGVkIGJ5IHRlbXBvcmFyaWx5XG4gICAgICAgKiBkZWxldGluZyBwcm9wZXJ0aWVzIHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBpbnNlcnQgYXQgYXJiaXRyYXJ5IHBvc2l0aW9ucy5cbiAgICAgICAqXG4gICAgICAgKiBUbyBzb2x2ZSB0aGlzIHByb2JsZW0sIGBpbnNlcnRCZWZvcmVgIGRvZXNuJ3QgYWN0dWFsbHkgaW5zZXJ0IHRoZSBnaXZlbiB0b2tlbnMgaW50byB0aGUgdGFyZ2V0IG9iamVjdC5cbiAgICAgICAqIEluc3RlYWQsIGl0IHdpbGwgY3JlYXRlIGEgbmV3IG9iamVjdCBhbmQgcmVwbGFjZSBhbGwgcmVmZXJlbmNlcyB0byB0aGUgdGFyZ2V0IG9iamVjdCB3aXRoIHRoZSBuZXcgb25lLiBUaGlzXG4gICAgICAgKiBjYW4gYmUgZG9uZSB3aXRob3V0IHRlbXBvcmFyaWx5IGRlbGV0aW5nIHByb3BlcnRpZXMsIHNvIHRoZSBpdGVyYXRpb24gb3JkZXIgaXMgd2VsbC1kZWZpbmVkLlxuICAgICAgICpcbiAgICAgICAqIEhvd2V2ZXIsIG9ubHkgcmVmZXJlbmNlcyB0aGF0IGNhbiBiZSByZWFjaGVkIGZyb20gYFByaXNtLmxhbmd1YWdlc2Agb3IgYGluc2VydGAgd2lsbCBiZSByZXBsYWNlZC4gSS5lLiBpZlxuICAgICAgICogeW91IGhvbGQgdGhlIHRhcmdldCBvYmplY3QgaW4gYSB2YXJpYWJsZSwgdGhlbiB0aGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlIHdpbGwgbm90IGNoYW5nZS5cbiAgICAgICAqXG4gICAgICAgKiBgYGBqc1xuICAgICAgICogdmFyIG9sZE1hcmt1cCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG4gICAgICAgKiB2YXIgbmV3TWFya3VwID0gUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NvbW1lbnQnLCB7IC4uLiB9KTtcbiAgICAgICAqXG4gICAgICAgKiBhc3NlcnQob2xkTWFya3VwICE9PSBQcmlzbS5sYW5ndWFnZXMubWFya3VwKTtcbiAgICAgICAqIGFzc2VydChuZXdNYXJrdXAgPT09IFByaXNtLmxhbmd1YWdlcy5tYXJrdXApO1xuICAgICAgICogYGBgXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGluc2lkZSBUaGUgcHJvcGVydHkgb2YgYHJvb3RgIChlLmcuIGEgbGFuZ3VhZ2UgaWQgaW4gYFByaXNtLmxhbmd1YWdlc2ApIHRoYXQgY29udGFpbnMgdGhlXG4gICAgICAgKiBvYmplY3QgdG8gYmUgbW9kaWZpZWQuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmVmb3JlIFRoZSBrZXkgdG8gaW5zZXJ0IGJlZm9yZS5cbiAgICAgICAqIEBwYXJhbSB7R3JhbW1hcn0gaW5zZXJ0IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBrZXktdmFsdWUgcGFpcnMgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtyb290XSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgYGluc2lkZWAsIGkuZS4gdGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuICAgICAgICogb2JqZWN0IHRvIGJlIG1vZGlmaWVkLlxuICAgICAgICpcbiAgICAgICAqIERlZmF1bHRzIHRvIGBQcmlzbS5sYW5ndWFnZXNgLlxuICAgICAgICogQHJldHVybnMge0dyYW1tYXJ9IFRoZSBuZXcgZ3JhbW1hciBvYmplY3QuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24gKGluc2lkZSwgYmVmb3JlLCBpbnNlcnQsIHJvb3QpIHtcbiAgICAgICAgcm9vdCA9IHJvb3QgfHwgKCAvKiogQHR5cGUge2FueX0gKi9fLmxhbmd1YWdlcyk7XG4gICAgICAgIHZhciBncmFtbWFyID0gcm9vdFtpbnNpZGVdO1xuICAgICAgICAvKiogQHR5cGUge0dyYW1tYXJ9ICovXG4gICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgdG9rZW4gaW4gZ3JhbW1hcikge1xuICAgICAgICAgIGlmIChncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSkge1xuICAgICAgICAgICAgaWYgKHRva2VuID09IGJlZm9yZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBuZXdUb2tlbiBpbiBpbnNlcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lmhhc093blByb3BlcnR5KG5ld1Rva2VuKSkge1xuICAgICAgICAgICAgICAgICAgcmV0W25ld1Rva2VuXSA9IGluc2VydFtuZXdUb2tlbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERvIG5vdCBpbnNlcnQgdG9rZW4gd2hpY2ggYWxzbyBvY2N1ciBpbiBpbnNlcnQuIFNlZSAjMTUyNVxuICAgICAgICAgICAgaWYgKCFpbnNlcnQuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG4gICAgICAgICAgICAgIHJldFt0b2tlbl0gPSBncmFtbWFyW3Rva2VuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9sZCA9IHJvb3RbaW5zaWRlXTtcbiAgICAgICAgcm9vdFtpbnNpZGVdID0gcmV0O1xuXG4gICAgICAgIC8vIFVwZGF0ZSByZWZlcmVuY2VzIGluIG90aGVyIGxhbmd1YWdlIGRlZmluaXRpb25zXG4gICAgICAgIF8ubGFuZ3VhZ2VzLkRGUyhfLmxhbmd1YWdlcywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IG9sZCAmJiBrZXkgIT0gaW5zaWRlKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSByZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sXG4gICAgICAvLyBUcmF2ZXJzZSBhIGxhbmd1YWdlIGRlZmluaXRpb24gd2l0aCBEZXB0aCBGaXJzdCBTZWFyY2hcbiAgICAgIERGUzogZnVuY3Rpb24gREZTKG8sIGNhbGxiYWNrLCB0eXBlLCB2aXNpdGVkKSB7XG4gICAgICAgIHZpc2l0ZWQgPSB2aXNpdGVkIHx8IHt9O1xuICAgICAgICB2YXIgb2JqSWQgPSBfLnV0aWwub2JqSWQ7XG4gICAgICAgIGZvciAodmFyIGkgaW4gbykge1xuICAgICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKG8sIGksIG9baV0sIHR5cGUgfHwgaSk7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBvW2ldO1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5VHlwZSA9IF8udXRpbC50eXBlKHByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eVR5cGUgPT09ICdPYmplY3QnICYmICF2aXNpdGVkW29iaklkKHByb3BlcnR5KV0pIHtcbiAgICAgICAgICAgICAgdmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgREZTKHByb3BlcnR5LCBjYWxsYmFjaywgbnVsbCwgdmlzaXRlZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5VHlwZSA9PT0gJ0FycmF5JyAmJiAhdmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldKSB7XG4gICAgICAgICAgICAgIHZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSA9IHRydWU7XG4gICAgICAgICAgICAgIERGUyhwcm9wZXJ0eSwgY2FsbGJhY2ssIGksIHZpc2l0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcGx1Z2luczoge30sXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgbW9zdCBoaWdoLWxldmVsIGZ1bmN0aW9uIGluIFByaXNt4oCZcyBBUEkuXG4gICAgICogSXQgZmV0Y2hlcyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIGAubGFuZ3VhZ2UteHh4eGAgY2xhc3MgYW5kIHRoZW4gY2FsbHMge0BsaW5rIFByaXNtLmhpZ2hsaWdodEVsZW1lbnR9IG9uXG4gICAgICogZWFjaCBvbmUgb2YgdGhlbS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byBgUHJpc20uaGlnaGxpZ2h0QWxsVW5kZXIoZG9jdW1lbnQsIGFzeW5jLCBjYWxsYmFjaylgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYXN5bmM9ZmFsc2VdIFNhbWUgYXMgaW4ge0BsaW5rIFByaXNtLmhpZ2hsaWdodEFsbFVuZGVyfS5cbiAgICAgKiBAcGFyYW0ge0hpZ2hsaWdodENhbGxiYWNrfSBbY2FsbGJhY2tdIFNhbWUgYXMgaW4ge0BsaW5rIFByaXNtLmhpZ2hsaWdodEFsbFVuZGVyfS5cbiAgICAgKiBAbWVtYmVyb2YgUHJpc21cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaGlnaGxpZ2h0QWxsOiBmdW5jdGlvbiAoYXN5bmMsIGNhbGxiYWNrKSB7XG4gICAgICBfLmhpZ2hsaWdodEFsbFVuZGVyKGRvY3VtZW50LCBhc3luYywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhbGwgdGhlIGRlc2NlbmRhbnRzIG9mIGBjb250YWluZXJgIHRoYXQgaGF2ZSBhIGAubGFuZ3VhZ2UteHh4eGAgY2xhc3MgYW5kIHRoZW4gY2FsbHNcbiAgICAgKiB7QGxpbmsgUHJpc20uaGlnaGxpZ2h0RWxlbWVudH0gb24gZWFjaCBvbmUgb2YgdGhlbS5cbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgaG9va3Mgd2lsbCBiZSBydW46XG4gICAgICogMS4gYGJlZm9yZS1oaWdobGlnaHRhbGxgXG4gICAgICogMi4gYGJlZm9yZS1hbGwtZWxlbWVudHMtaGlnaGxpZ2h0YFxuICAgICAqIDMuIEFsbCBob29rcyBvZiB7QGxpbmsgUHJpc20uaGlnaGxpZ2h0RWxlbWVudH0gZm9yIGVhY2ggZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyZW50Tm9kZX0gY29udGFpbmVyIFRoZSByb290IGVsZW1lbnQsIHdob3NlIGRlc2NlbmRhbnRzIHRoYXQgaGF2ZSBhIGAubGFuZ3VhZ2UteHh4eGAgY2xhc3Mgd2lsbCBiZSBoaWdobGlnaHRlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthc3luYz1mYWxzZV0gV2hldGhlciBlYWNoIGVsZW1lbnQgaXMgdG8gYmUgaGlnaGxpZ2h0ZWQgYXN5bmNocm9ub3VzbHkgdXNpbmcgV2ViIFdvcmtlcnMuXG4gICAgICogQHBhcmFtIHtIaWdobGlnaHRDYWxsYmFja30gW2NhbGxiYWNrXSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGVhY2ggZWxlbWVudCBhZnRlciBpdHMgaGlnaGxpZ2h0aW5nIGlzIGRvbmUuXG4gICAgICogQG1lbWJlcm9mIFByaXNtXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGhpZ2hsaWdodEFsbFVuZGVyOiBmdW5jdGlvbiAoY29udGFpbmVyLCBhc3luYywgY2FsbGJhY2spIHtcbiAgICAgIHZhciBlbnYgPSB7XG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIHNlbGVjdG9yOiAnY29kZVtjbGFzcyo9XCJsYW5ndWFnZS1cIl0sIFtjbGFzcyo9XCJsYW5ndWFnZS1cIl0gY29kZSwgY29kZVtjbGFzcyo9XCJsYW5nLVwiXSwgW2NsYXNzKj1cImxhbmctXCJdIGNvZGUnXG4gICAgICB9O1xuICAgICAgXy5ob29rcy5ydW4oJ2JlZm9yZS1oaWdobGlnaHRhbGwnLCBlbnYpO1xuICAgICAgZW52LmVsZW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGVudi5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChlbnYuc2VsZWN0b3IpKTtcbiAgICAgIF8uaG9va3MucnVuKCdiZWZvcmUtYWxsLWVsZW1lbnRzLWhpZ2hsaWdodCcsIGVudik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgZWxlbWVudDsgZWxlbWVudCA9IGVudi5lbGVtZW50c1tpKytdOykge1xuICAgICAgICBfLmhpZ2hsaWdodEVsZW1lbnQoZWxlbWVudCwgYXN5bmMgPT09IHRydWUsIGVudi5jYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBIaWdobGlnaHRzIHRoZSBjb2RlIGluc2lkZSBhIHNpbmdsZSBlbGVtZW50LlxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBob29rcyB3aWxsIGJlIHJ1bjpcbiAgICAgKiAxLiBgYmVmb3JlLXNhbml0eS1jaGVja2BcbiAgICAgKiAyLiBgYmVmb3JlLWhpZ2hsaWdodGBcbiAgICAgKiAzLiBBbGwgaG9va3Mgb2Yge0BsaW5rIFByaXNtLmhpZ2hsaWdodH0uIFRoZXNlIGhvb2tzIHdpbGwgYmUgcnVuIGJ5IGFuIGFzeW5jaHJvbm91cyB3b3JrZXIgaWYgYGFzeW5jYCBpcyBgdHJ1ZWAuXG4gICAgICogNC4gYGJlZm9yZS1pbnNlcnRgXG4gICAgICogNS4gYGFmdGVyLWhpZ2hsaWdodGBcbiAgICAgKiA2LiBgY29tcGxldGVgXG4gICAgICpcbiAgICAgKiBTb21lIHRoZSBhYm92ZSBob29rcyB3aWxsIGJlIHNraXBwZWQgaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBjb250YWluIGFueSB0ZXh0IG9yIHRoZXJlIGlzIG5vIGdyYW1tYXIgbG9hZGVkIGZvclxuICAgICAqIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgY29kZS5cbiAgICAgKiBJdCBtdXN0IGhhdmUgYSBjbGFzcyBvZiBgbGFuZ3VhZ2UteHh4eGAgdG8gYmUgcHJvY2Vzc2VkLCB3aGVyZSBgeHh4eGAgaXMgYSB2YWxpZCBsYW5ndWFnZSBpZGVudGlmaWVyLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzeW5jPWZhbHNlXSBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIHRvIGJlIGhpZ2hsaWdodGVkIGFzeW5jaHJvbm91c2x5IHVzaW5nIFdlYiBXb3JrZXJzXG4gICAgICogdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSBhbmQgYXZvaWQgYmxvY2tpbmcgdGhlIFVJIHdoZW4gaGlnaGxpZ2h0aW5nIHZlcnkgbGFyZ2UgY2h1bmtzIG9mIGNvZGUuIFRoaXMgb3B0aW9uIGlzXG4gICAgICogW2Rpc2FibGVkIGJ5IGRlZmF1bHRdKGh0dHBzOi8vcHJpc21qcy5jb20vZmFxLmh0bWwjd2h5LWlzLWFzeW5jaHJvbm91cy1oaWdobGlnaHRpbmctZGlzYWJsZWQtYnktZGVmYXVsdCkuXG4gICAgICpcbiAgICAgKiBOb3RlOiBBbGwgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgcmVxdWlyZWQgdG8gaGlnaGxpZ2h0IHRoZSBjb2RlIG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlIG1haW4gYHByaXNtLmpzYCBmaWxlIGZvclxuICAgICAqIGFzeW5jaHJvbm91cyBoaWdobGlnaHRpbmcgdG8gd29yay4gWW91IGNhbiBidWlsZCB5b3VyIG93biBidW5kbGUgb24gdGhlXG4gICAgICogW0Rvd25sb2FkIHBhZ2VdKGh0dHBzOi8vcHJpc21qcy5jb20vZG93bmxvYWQuaHRtbCkuXG4gICAgICogQHBhcmFtIHtIaWdobGlnaHRDYWxsYmFja30gW2NhbGxiYWNrXSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBoaWdobGlnaHRpbmcgaXMgZG9uZS5cbiAgICAgKiBNb3N0bHkgdXNlZnVsIHdoZW4gYGFzeW5jYCBpcyBgdHJ1ZWAsIHNpbmNlIGluIHRoYXQgY2FzZSwgdGhlIGhpZ2hsaWdodGluZyBpcyBkb25lIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIEBtZW1iZXJvZiBQcmlzbVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBoaWdobGlnaHRFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCwgYXN5bmMsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBGaW5kIGxhbmd1YWdlXG4gICAgICB2YXIgbGFuZ3VhZ2UgPSBfLnV0aWwuZ2V0TGFuZ3VhZ2UoZWxlbWVudCk7XG4gICAgICB2YXIgZ3JhbW1hciA9IF8ubGFuZ3VhZ2VzW2xhbmd1YWdlXTtcblxuICAgICAgLy8gU2V0IGxhbmd1YWdlIG9uIHRoZSBlbGVtZW50LCBpZiBub3QgcHJlc2VudFxuICAgICAgXy51dGlsLnNldExhbmd1YWdlKGVsZW1lbnQsIGxhbmd1YWdlKTtcblxuICAgICAgLy8gU2V0IGxhbmd1YWdlIG9uIHRoZSBwYXJlbnQsIGZvciBzdHlsaW5nXG4gICAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3ByZScpIHtcbiAgICAgICAgXy51dGlsLnNldExhbmd1YWdlKHBhcmVudCwgbGFuZ3VhZ2UpO1xuICAgICAgfVxuICAgICAgdmFyIGNvZGUgPSBlbGVtZW50LnRleHRDb250ZW50O1xuICAgICAgdmFyIGVudiA9IHtcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlLFxuICAgICAgICBncmFtbWFyOiBncmFtbWFyLFxuICAgICAgICBjb2RlOiBjb2RlXG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gaW5zZXJ0SGlnaGxpZ2h0ZWRDb2RlKGhpZ2hsaWdodGVkQ29kZSkge1xuICAgICAgICBlbnYuaGlnaGxpZ2h0ZWRDb2RlID0gaGlnaGxpZ2h0ZWRDb2RlO1xuICAgICAgICBfLmhvb2tzLnJ1bignYmVmb3JlLWluc2VydCcsIGVudik7XG4gICAgICAgIGVudi5lbGVtZW50LmlubmVySFRNTCA9IGVudi5oaWdobGlnaHRlZENvZGU7XG4gICAgICAgIF8uaG9va3MucnVuKCdhZnRlci1oaWdobGlnaHQnLCBlbnYpO1xuICAgICAgICBfLmhvb2tzLnJ1bignY29tcGxldGUnLCBlbnYpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGVudi5lbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIF8uaG9va3MucnVuKCdiZWZvcmUtc2FuaXR5LWNoZWNrJywgZW52KTtcblxuICAgICAgLy8gcGx1Z2lucyBtYXkgY2hhbmdlL2FkZCB0aGUgcGFyZW50L2VsZW1lbnRcbiAgICAgIHBhcmVudCA9IGVudi5lbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAncHJlJyAmJiAhcGFyZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICBwYXJlbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICcwJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWVudi5jb2RlKSB7XG4gICAgICAgIF8uaG9va3MucnVuKCdjb21wbGV0ZScsIGVudik7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoZW52LmVsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfLmhvb2tzLnJ1bignYmVmb3JlLWhpZ2hsaWdodCcsIGVudik7XG4gICAgICBpZiAoIWVudi5ncmFtbWFyKSB7XG4gICAgICAgIGluc2VydEhpZ2hsaWdodGVkQ29kZShfLnV0aWwuZW5jb2RlKGVudi5jb2RlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhc3luYyAmJiBfc2VsZi5Xb3JrZXIpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoXy5maWxlbmFtZSk7XG4gICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgaW5zZXJ0SGlnaGxpZ2h0ZWRDb2RlKGV2dC5kYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBsYW5ndWFnZTogZW52Lmxhbmd1YWdlLFxuICAgICAgICAgIGNvZGU6IGVudi5jb2RlLFxuICAgICAgICAgIGltbWVkaWF0ZUNsb3NlOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc2VydEhpZ2hsaWdodGVkQ29kZShfLmhpZ2hsaWdodChlbnYuY29kZSwgZW52LmdyYW1tYXIsIGVudi5sYW5ndWFnZSkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogTG93LWxldmVsIGZ1bmN0aW9uLCBvbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdeKAmXJlIGRvaW5nLiBJdCBhY2NlcHRzIGEgc3RyaW5nIG9mIHRleHQgYXMgaW5wdXRcbiAgICAgKiBhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb25zIHRvIHVzZSwgYW5kIHJldHVybnMgYSBzdHJpbmcgd2l0aCB0aGUgSFRNTCBwcm9kdWNlZC5cbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgaG9va3Mgd2lsbCBiZSBydW46XG4gICAgICogMS4gYGJlZm9yZS10b2tlbml6ZWBcbiAgICAgKiAyLiBgYWZ0ZXItdG9rZW5pemVgXG4gICAgICogMy4gYHdyYXBgOiBPbiBlYWNoIHtAbGluayBUb2tlbn0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBBIHN0cmluZyB3aXRoIHRoZSBjb2RlIHRvIGJlIGhpZ2hsaWdodGVkLlxuICAgICAqIEBwYXJhbSB7R3JhbW1hcn0gZ3JhbW1hciBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdG9rZW5zIHRvIHVzZS5cbiAgICAgKlxuICAgICAqIFVzdWFsbHkgYSBsYW5ndWFnZSBkZWZpbml0aW9uIGxpa2UgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBUaGUgbmFtZSBvZiB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBwYXNzZWQgdG8gYGdyYW1tYXJgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBoaWdobGlnaHRlZCBIVE1MLlxuICAgICAqIEBtZW1iZXJvZiBQcmlzbVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFByaXNtLmhpZ2hsaWdodCgndmFyIGZvbyA9IHRydWU7JywgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQsICdqYXZhc2NyaXB0Jyk7XG4gICAgICovXG4gICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAodGV4dCwgZ3JhbW1hciwgbGFuZ3VhZ2UpIHtcbiAgICAgIHZhciBlbnYgPSB7XG4gICAgICAgIGNvZGU6IHRleHQsXG4gICAgICAgIGdyYW1tYXI6IGdyYW1tYXIsXG4gICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZVxuICAgICAgfTtcbiAgICAgIF8uaG9va3MucnVuKCdiZWZvcmUtdG9rZW5pemUnLCBlbnYpO1xuICAgICAgaWYgKCFlbnYuZ3JhbW1hcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBsYW5ndWFnZSBcIicgKyBlbnYubGFuZ3VhZ2UgKyAnXCIgaGFzIG5vIGdyYW1tYXIuJyk7XG4gICAgICB9XG4gICAgICBlbnYudG9rZW5zID0gXy50b2tlbml6ZShlbnYuY29kZSwgZW52LmdyYW1tYXIpO1xuICAgICAgXy5ob29rcy5ydW4oJ2FmdGVyLXRva2VuaXplJywgZW52KTtcbiAgICAgIHJldHVybiBUb2tlbi5zdHJpbmdpZnkoXy51dGlsLmVuY29kZShlbnYudG9rZW5zKSwgZW52Lmxhbmd1YWdlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGhlYXJ0IG9mIFByaXNtLCBhbmQgdGhlIG1vc3QgbG93LWxldmVsIGZ1bmN0aW9uIHlvdSBjYW4gdXNlLiBJdCBhY2NlcHRzIGEgc3RyaW5nIG9mIHRleHQgYXMgaW5wdXRcbiAgICAgKiBhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb25zIHRvIHVzZSwgYW5kIHJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgdG9rZW5pemVkIGNvZGUuXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9uIGluY2x1ZGVzIG5lc3RlZCB0b2tlbnMsIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgcmVjdXJzaXZlbHkgb24gZWFjaCBvZiB0aGVzZSB0b2tlbnMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjb3VsZCBiZSB1c2VmdWwgaW4gb3RoZXIgY29udGV4dHMgYXMgd2VsbCwgYXMgYSB2ZXJ5IGNydWRlIHBhcnNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IEEgc3RyaW5nIHdpdGggdGhlIGNvZGUgdG8gYmUgaGlnaGxpZ2h0ZWQuXG4gICAgICogQHBhcmFtIHtHcmFtbWFyfSBncmFtbWFyIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0b2tlbnMgdG8gdXNlLlxuICAgICAqXG4gICAgICogVXN1YWxseSBhIGxhbmd1YWdlIGRlZmluaXRpb24gbGlrZSBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAuXG4gICAgICogQHJldHVybnMge1Rva2VuU3RyZWFtfSBBbiBhcnJheSBvZiBzdHJpbmdzIGFuZCB0b2tlbnMsIGEgdG9rZW4gc3RyZWFtLlxuICAgICAqIEBtZW1iZXJvZiBQcmlzbVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGxldCBjb2RlID0gYHZhciBmb28gPSAwO2A7XG4gICAgICogbGV0IHRva2VucyA9IFByaXNtLnRva2VuaXplKGNvZGUsIFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0KTtcbiAgICAgKiB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB7XG4gICAgICogICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIFByaXNtLlRva2VuICYmIHRva2VuLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgbnVtZXJpYyBsaXRlcmFsOiAke3Rva2VuLmNvbnRlbnR9YCk7XG4gICAgICogICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB0b2tlbml6ZTogZnVuY3Rpb24gKHRleHQsIGdyYW1tYXIpIHtcbiAgICAgIHZhciByZXN0ID0gZ3JhbW1hci5yZXN0O1xuICAgICAgaWYgKHJlc3QpIHtcbiAgICAgICAgZm9yICh2YXIgdG9rZW4gaW4gcmVzdCkge1xuICAgICAgICAgIGdyYW1tYXJbdG9rZW5dID0gcmVzdFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGdyYW1tYXIucmVzdDtcbiAgICAgIH1cbiAgICAgIHZhciB0b2tlbkxpc3QgPSBuZXcgTGlua2VkTGlzdCgpO1xuICAgICAgYWRkQWZ0ZXIodG9rZW5MaXN0LCB0b2tlbkxpc3QuaGVhZCwgdGV4dCk7XG4gICAgICBtYXRjaEdyYW1tYXIodGV4dCwgdG9rZW5MaXN0LCBncmFtbWFyLCB0b2tlbkxpc3QuaGVhZCwgMCk7XG4gICAgICByZXR1cm4gdG9BcnJheSh0b2tlbkxpc3QpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQcmlzbVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBob29rczoge1xuICAgICAgYWxsOiB7fSxcbiAgICAgIC8qKlxuICAgICAgICogQWRkcyB0aGUgZ2l2ZW4gY2FsbGJhY2sgdG8gdGhlIGxpc3Qgb2YgY2FsbGJhY2tzIGZvciB0aGUgZ2l2ZW4gaG9vay5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIGhvb2sgaXQgaXMgcmVnaXN0ZXJlZCBmb3IgaXMgcnVuLlxuICAgICAgICogSG9va3MgYXJlIHVzdWFsbHkgZGlyZWN0bHkgcnVuIGJ5IGEgaGlnaGxpZ2h0IGZ1bmN0aW9uIGJ1dCB5b3UgY2FuIGFsc28gcnVuIGhvb2tzIHlvdXJzZWxmLlxuICAgICAgICpcbiAgICAgICAqIE9uZSBjYWxsYmFjayBmdW5jdGlvbiBjYW4gYmUgcmVnaXN0ZXJlZCB0byBtdWx0aXBsZSBob29rcyBhbmQgdGhlIHNhbWUgaG9vayBtdWx0aXBsZSB0aW1lcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9vay5cbiAgICAgICAqIEBwYXJhbSB7SG9va0NhbGxiYWNrfSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaXMgZ2l2ZW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBhZGQ6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaG9va3MgPSBfLmhvb2tzLmFsbDtcbiAgICAgICAgaG9va3NbbmFtZV0gPSBob29rc1tuYW1lXSB8fCBbXTtcbiAgICAgICAgaG9va3NbbmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBSdW5zIGEgaG9vayBpbnZva2luZyBhbGwgcmVnaXN0ZXJlZCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgICAgICpcbiAgICAgICAqIENhbGxiYWNrcyB3aWxsIGJlIGludm9rZWQgc3luY2hyb25vdXNseSBhbmQgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSByZWdpc3RlcmVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBob29rLlxuICAgICAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBlbnYgVGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyBvZiB0aGUgaG9vayBwYXNzZWQgdG8gYWxsIGNhbGxiYWNrcyByZWdpc3RlcmVkLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBydW46IGZ1bmN0aW9uIChuYW1lLCBlbnYpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IF8uaG9va3MuYWxsW25hbWVdO1xuICAgICAgICBpZiAoIWNhbGxiYWNrcyB8fCAhY2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgY2FsbGJhY2s7IGNhbGxiYWNrID0gY2FsbGJhY2tzW2krK107KSB7XG4gICAgICAgICAgY2FsbGJhY2soZW52KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgVG9rZW46IFRva2VuXG4gIH07XG4gIF9zZWxmLlByaXNtID0gXztcblxuICAvLyBUeXBlc2NyaXB0IG5vdGU6XG4gIC8vIFRoZSBmb2xsb3dpbmcgY2FuIGJlIHVzZWQgdG8gaW1wb3J0IHRoZSBUb2tlbiB0eXBlIGluIEpTRG9jOlxuICAvL1xuICAvLyAgIEB0eXBlZGVmIHtJbnN0YW5jZVR5cGU8aW1wb3J0KFwiLi9wcmlzbS1jb3JlXCIpW1wiVG9rZW5cIl0+fSBUb2tlblxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHRva2VuLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBTZWUge0BsaW5rIFRva2VuI3R5cGUgdHlwZX1cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBUb2tlblN0cmVhbX0gY29udGVudCBTZWUge0BsaW5rIFRva2VuI2NvbnRlbnQgY29udGVudH1cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFthbGlhc10gVGhlIGFsaWFzKGVzKSBvZiB0aGUgdG9rZW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbWF0Y2hlZFN0cj1cIlwiXSBBIGNvcHkgb2YgdGhlIGZ1bGwgc3RyaW5nIHRoaXMgdG9rZW4gd2FzIGNyZWF0ZWQgZnJvbS5cbiAgICogQGNsYXNzXG4gICAqIEBnbG9iYWxcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZnVuY3Rpb24gVG9rZW4odHlwZSwgY29udGVudCwgYWxpYXMsIG1hdGNoZWRTdHIpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9rZW4uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzdWFsbHkgdGhlIGtleSBvZiBhIHBhdHRlcm4gaW4gYSB7QGxpbmsgR3JhbW1hcn0uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBzZWUgR3JhbW1hclRva2VuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZ3Mgb3IgdG9rZW5zIGNvbnRhaW5lZCBieSB0aGlzIHRva2VuLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGJlIGEgdG9rZW4gc3RyZWFtIGlmIHRoZSBwYXR0ZXJuIG1hdGNoZWQgYWxzbyBkZWZpbmVkIGFuIGBpbnNpZGVgIGdyYW1tYXIuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nIHwgVG9rZW5TdHJlYW19XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgLyoqXG4gICAgICogVGhlIGFsaWFzKGVzKSBvZiB0aGUgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfHN0cmluZ1tdfVxuICAgICAqIEBzZWUgR3JhbW1hclRva2VuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAvLyBDb3B5IG9mIHRoZSBmdWxsIHN0cmluZyB0aGlzIHRva2VuIHdhcyBjcmVhdGVkIGZyb21cbiAgICB0aGlzLmxlbmd0aCA9IChtYXRjaGVkU3RyIHx8ICcnKS5sZW5ndGggfCAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdG9rZW4gc3RyZWFtIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIHtAbGluayBUb2tlbiBUb2tlbn0gb2JqZWN0cy5cbiAgICpcbiAgICogVG9rZW4gc3RyZWFtcyBoYXZlIHRvIGZ1bGZpbGwgYSBmZXcgcHJvcGVydGllcyB0aGF0IGFyZSBhc3N1bWVkIGJ5IG1vc3QgZnVuY3Rpb25zIChtb3N0bHkgaW50ZXJuYWwgb25lcykgdGhhdCBwcm9jZXNzXG4gICAqIHRoZW0uXG4gICAqXG4gICAqIDEuIE5vIGFkamFjZW50IHN0cmluZ3MuXG4gICAqIDIuIE5vIGVtcHR5IHN0cmluZ3MuXG4gICAqXG4gICAqICAgIFRoZSBvbmx5IGV4Y2VwdGlvbiBoZXJlIGlzIHRoZSB0b2tlbiBzdHJlYW0gdGhhdCBvbmx5IGNvbnRhaW5zIHRoZSBlbXB0eSBzdHJpbmcgYW5kIG5vdGhpbmcgZWxzZS5cbiAgICpcbiAgICogQHR5cGVkZWYge0FycmF5PHN0cmluZyB8IFRva2VuPn0gVG9rZW5TdHJlYW1cbiAgICogQGdsb2JhbFxuICAgKiBAcHVibGljXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdG9rZW4gb3IgdG9rZW4gc3RyZWFtIHRvIGFuIEhUTUwgcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgaG9va3Mgd2lsbCBiZSBydW46XG4gICAqIDEuIGB3cmFwYDogT24gZWFjaCB7QGxpbmsgVG9rZW59LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFRva2VuIHwgVG9rZW5TdHJlYW19IG8gVGhlIHRva2VuIG9yIHRva2VuIHN0cmVhbSB0byBiZSBjb252ZXJ0ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBUaGUgbmFtZSBvZiBjdXJyZW50IGxhbmd1YWdlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgSFRNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdG9rZW4gb3IgdG9rZW4gc3RyZWFtLlxuICAgKiBAbWVtYmVyb2YgVG9rZW5cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgVG9rZW4uc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KG8sIGxhbmd1YWdlKSB7XG4gICAgaWYgKHR5cGVvZiBvID09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgIHZhciBzID0gJyc7XG4gICAgICBvLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcyArPSBzdHJpbmdpZnkoZSwgbGFuZ3VhZ2UpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgdmFyIGVudiA9IHtcbiAgICAgIHR5cGU6IG8udHlwZSxcbiAgICAgIGNvbnRlbnQ6IHN0cmluZ2lmeShvLmNvbnRlbnQsIGxhbmd1YWdlKSxcbiAgICAgIHRhZzogJ3NwYW4nLFxuICAgICAgY2xhc3NlczogWyd0b2tlbicsIG8udHlwZV0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZVxuICAgIH07XG4gICAgdmFyIGFsaWFzZXMgPSBvLmFsaWFzO1xuICAgIGlmIChhbGlhc2VzKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhbGlhc2VzKSkge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbnYuY2xhc3NlcywgYWxpYXNlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnYuY2xhc3Nlcy5wdXNoKGFsaWFzZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBfLmhvb2tzLnJ1bignd3JhcCcsIGVudik7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSAnJztcbiAgICBmb3IgKHZhciBuYW1lIGluIGVudi5hdHRyaWJ1dGVzKSB7XG4gICAgICBhdHRyaWJ1dGVzICs9ICcgJyArIG5hbWUgKyAnPVwiJyArIChlbnYuYXR0cmlidXRlc1tuYW1lXSB8fCAnJykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpICsgJ1wiJztcbiAgICB9XG4gICAgcmV0dXJuICc8JyArIGVudi50YWcgKyAnIGNsYXNzPVwiJyArIGVudi5jbGFzc2VzLmpvaW4oJyAnKSArICdcIicgKyBhdHRyaWJ1dGVzICsgJz4nICsgZW52LmNvbnRlbnQgKyAnPC8nICsgZW52LnRhZyArICc+JztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtSZWdFeHB9IHBhdHRlcm5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb2tiZWhpbmRcbiAgICogQHJldHVybnMge1JlZ0V4cEV4ZWNBcnJheSB8IG51bGx9XG4gICAqL1xuICBmdW5jdGlvbiBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcG9zLCB0ZXh0LCBsb29rYmVoaW5kKSB7XG4gICAgcGF0dGVybi5sYXN0SW5kZXggPSBwb3M7XG4gICAgdmFyIG1hdGNoID0gcGF0dGVybi5leGVjKHRleHQpO1xuICAgIGlmIChtYXRjaCAmJiBsb29rYmVoaW5kICYmIG1hdGNoWzFdKSB7XG4gICAgICAvLyBjaGFuZ2UgdGhlIG1hdGNoIHRvIHJlbW92ZSB0aGUgdGV4dCBtYXRjaGVkIGJ5IHRoZSBQcmlzbSBsb29rYmVoaW5kIGdyb3VwXG4gICAgICB2YXIgbG9va2JlaGluZExlbmd0aCA9IG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgIG1hdGNoLmluZGV4ICs9IGxvb2tiZWhpbmRMZW5ndGg7XG4gICAgICBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKGxvb2tiZWhpbmRMZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtMaW5rZWRMaXN0PHN0cmluZyB8IFRva2VuPn0gdG9rZW5MaXN0XG4gICAqIEBwYXJhbSB7YW55fSBncmFtbWFyXG4gICAqIEBwYXJhbSB7TGlua2VkTGlzdE5vZGU8c3RyaW5nIHwgVG9rZW4+fSBzdGFydE5vZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0UG9zXG4gICAqIEBwYXJhbSB7UmVtYXRjaE9wdGlvbnN9IFtyZW1hdGNoXVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHR5cGVkZWYgUmVtYXRjaE9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNhdXNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWFjaFxuICAgKi9cbiAgZnVuY3Rpb24gbWF0Y2hHcmFtbWFyKHRleHQsIHRva2VuTGlzdCwgZ3JhbW1hciwgc3RhcnROb2RlLCBzdGFydFBvcywgcmVtYXRjaCkge1xuICAgIGZvciAodmFyIHRva2VuIGluIGdyYW1tYXIpIHtcbiAgICAgIGlmICghZ3JhbW1hci5oYXNPd25Qcm9wZXJ0eSh0b2tlbikgfHwgIWdyYW1tYXJbdG9rZW5dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHBhdHRlcm5zID0gZ3JhbW1hclt0b2tlbl07XG4gICAgICBwYXR0ZXJucyA9IEFycmF5LmlzQXJyYXkocGF0dGVybnMpID8gcGF0dGVybnMgOiBbcGF0dGVybnNdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXR0ZXJucy5sZW5ndGg7ICsraikge1xuICAgICAgICBpZiAocmVtYXRjaCAmJiByZW1hdGNoLmNhdXNlID09IHRva2VuICsgJywnICsgaikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0dGVybk9iaiA9IHBhdHRlcm5zW2pdO1xuICAgICAgICB2YXIgaW5zaWRlID0gcGF0dGVybk9iai5pbnNpZGU7XG4gICAgICAgIHZhciBsb29rYmVoaW5kID0gISFwYXR0ZXJuT2JqLmxvb2tiZWhpbmQ7XG4gICAgICAgIHZhciBncmVlZHkgPSAhIXBhdHRlcm5PYmouZ3JlZWR5O1xuICAgICAgICB2YXIgYWxpYXMgPSBwYXR0ZXJuT2JqLmFsaWFzO1xuICAgICAgICBpZiAoZ3JlZWR5ICYmICFwYXR0ZXJuT2JqLnBhdHRlcm4uZ2xvYmFsKSB7XG4gICAgICAgICAgLy8gV2l0aG91dCB0aGUgZ2xvYmFsIGZsYWcsIGxhc3RJbmRleCB3b24ndCB3b3JrXG4gICAgICAgICAgdmFyIGZsYWdzID0gcGF0dGVybk9iai5wYXR0ZXJuLnRvU3RyaW5nKCkubWF0Y2goL1tpbXN1eV0qJC8pWzBdO1xuICAgICAgICAgIHBhdHRlcm5PYmoucGF0dGVybiA9IFJlZ0V4cChwYXR0ZXJuT2JqLnBhdHRlcm4uc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHR5cGUge1JlZ0V4cH0gKi9cbiAgICAgICAgdmFyIHBhdHRlcm4gPSBwYXR0ZXJuT2JqLnBhdHRlcm4gfHwgcGF0dGVybk9iajtcbiAgICAgICAgZm9yIChcbiAgICAgICAgLy8gaXRlcmF0ZSB0aGUgdG9rZW4gbGlzdCBhbmQga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCB0b2tlbi9zdHJpbmcgcG9zaXRpb25cbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gc3RhcnROb2RlLm5leHQsIHBvcyA9IHN0YXJ0UG9zOyBjdXJyZW50Tm9kZSAhPT0gdG9rZW5MaXN0LnRhaWw7IHBvcyArPSBjdXJyZW50Tm9kZS52YWx1ZS5sZW5ndGgsIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUubmV4dCkge1xuICAgICAgICAgIGlmIChyZW1hdGNoICYmIHBvcyA+PSByZW1hdGNoLnJlYWNoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0ciA9IGN1cnJlbnROb2RlLnZhbHVlO1xuICAgICAgICAgIGlmICh0b2tlbkxpc3QubGVuZ3RoID4gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHRlcnJpYmx5IHdyb25nLCBBQk9SVCwgQUJPUlQhXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHIgaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZW1vdmVDb3VudCA9IDE7IC8vIHRoaXMgaXMgdGhlIHRvIHBhcmFtZXRlciBvZiByZW1vdmVCZXR3ZWVuXG4gICAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICAgIGlmIChncmVlZHkpIHtcbiAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hQYXR0ZXJuKHBhdHRlcm4sIHBvcywgdGV4dCwgbG9va2JlaGluZCk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ID49IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZyb20gPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICAgIHZhciB0byA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHAgPSBwb3M7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIG5vZGUgdGhhdCBjb250YWlucyB0aGUgbWF0Y2hcbiAgICAgICAgICAgIHAgKz0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGZyb20gPj0gcCkge1xuICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHQ7XG4gICAgICAgICAgICAgIHAgKz0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRqdXN0IHBvcyAoYW5kIHApXG4gICAgICAgICAgICBwIC09IGN1cnJlbnROb2RlLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIHBvcyA9IHA7XG5cbiAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IG5vZGUgaXMgYSBUb2tlbiwgdGhlbiB0aGUgbWF0Y2ggc3RhcnRzIGluc2lkZSBhbm90aGVyIFRva2VuLCB3aGljaCBpcyBpbnZhbGlkXG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUudmFsdWUgaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmluZCB0aGUgbGFzdCBub2RlIHdoaWNoIGlzIGFmZmVjdGVkIGJ5IHRoaXMgbWF0Y2hcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSBjdXJyZW50Tm9kZTsgayAhPT0gdG9rZW5MaXN0LnRhaWwgJiYgKHAgPCB0byB8fCB0eXBlb2Ygay52YWx1ZSA9PT0gJ3N0cmluZycpOyBrID0gay5uZXh0KSB7XG4gICAgICAgICAgICAgIHJlbW92ZUNvdW50Kys7XG4gICAgICAgICAgICAgIHAgKz0gay52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVDb3VudC0tO1xuXG4gICAgICAgICAgICAvLyByZXBsYWNlIHdpdGggdGhlIG5ldyBtYXRjaFxuICAgICAgICAgICAgc3RyID0gdGV4dC5zbGljZShwb3MsIHApO1xuICAgICAgICAgICAgbWF0Y2guaW5kZXggLT0gcG9zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaCA9IG1hdGNoUGF0dGVybihwYXR0ZXJuLCAwLCBzdHIsIGxvb2tiZWhpbmQpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG4gICAgICAgICAgdmFyIGZyb20gPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICB2YXIgbWF0Y2hTdHIgPSBtYXRjaFswXTtcbiAgICAgICAgICB2YXIgYmVmb3JlID0gc3RyLnNsaWNlKDAsIGZyb20pO1xuICAgICAgICAgIHZhciBhZnRlciA9IHN0ci5zbGljZShmcm9tICsgbWF0Y2hTdHIubGVuZ3RoKTtcbiAgICAgICAgICB2YXIgcmVhY2ggPSBwb3MgKyBzdHIubGVuZ3RoO1xuICAgICAgICAgIGlmIChyZW1hdGNoICYmIHJlYWNoID4gcmVtYXRjaC5yZWFjaCkge1xuICAgICAgICAgICAgcmVtYXRjaC5yZWFjaCA9IHJlYWNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVtb3ZlRnJvbSA9IGN1cnJlbnROb2RlLnByZXY7XG4gICAgICAgICAgaWYgKGJlZm9yZSkge1xuICAgICAgICAgICAgcmVtb3ZlRnJvbSA9IGFkZEFmdGVyKHRva2VuTGlzdCwgcmVtb3ZlRnJvbSwgYmVmb3JlKTtcbiAgICAgICAgICAgIHBvcyArPSBiZWZvcmUubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZW1vdmVSYW5nZSh0b2tlbkxpc3QsIHJlbW92ZUZyb20sIHJlbW92ZUNvdW50KTtcbiAgICAgICAgICB2YXIgd3JhcHBlZCA9IG5ldyBUb2tlbih0b2tlbiwgaW5zaWRlID8gXy50b2tlbml6ZShtYXRjaFN0ciwgaW5zaWRlKSA6IG1hdGNoU3RyLCBhbGlhcywgbWF0Y2hTdHIpO1xuICAgICAgICAgIGN1cnJlbnROb2RlID0gYWRkQWZ0ZXIodG9rZW5MaXN0LCByZW1vdmVGcm9tLCB3cmFwcGVkKTtcbiAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgIGFkZEFmdGVyKHRva2VuTGlzdCwgY3VycmVudE5vZGUsIGFmdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlbW92ZUNvdW50ID4gMSkge1xuICAgICAgICAgICAgLy8gYXQgbGVhc3Qgb25lIFRva2VuIG9iamVjdCB3YXMgcmVtb3ZlZCwgc28gd2UgaGF2ZSB0byBkbyBzb21lIHJlbWF0Y2hpbmdcbiAgICAgICAgICAgIC8vIHRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBjdXJyZW50IHBhdHRlcm4gaXMgZ3JlZWR5XG5cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UmVtYXRjaE9wdGlvbnN9ICovXG4gICAgICAgICAgICB2YXIgbmVzdGVkUmVtYXRjaCA9IHtcbiAgICAgICAgICAgICAgY2F1c2U6IHRva2VuICsgJywnICsgaixcbiAgICAgICAgICAgICAgcmVhY2g6IHJlYWNoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWF0Y2hHcmFtbWFyKHRleHQsIHRva2VuTGlzdCwgZ3JhbW1hciwgY3VycmVudE5vZGUucHJldiwgcG9zLCBuZXN0ZWRSZW1hdGNoKTtcblxuICAgICAgICAgICAgLy8gdGhlIHJlYWNoIG1pZ2h0IGhhdmUgYmVlbiBleHRlbmRlZCBiZWNhdXNlIG9mIHRoZSByZW1hdGNoaW5nXG4gICAgICAgICAgICBpZiAocmVtYXRjaCAmJiBuZXN0ZWRSZW1hdGNoLnJlYWNoID4gcmVtYXRjaC5yZWFjaCkge1xuICAgICAgICAgICAgICByZW1hdGNoLnJlYWNoID0gbmVzdGVkUmVtYXRjaC5yZWFjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYgTGlua2VkTGlzdE5vZGVcbiAgICogQHByb3BlcnR5IHtUfSB2YWx1ZVxuICAgKiBAcHJvcGVydHkge0xpbmtlZExpc3ROb2RlPFQ+IHwgbnVsbH0gcHJldiBUaGUgcHJldmlvdXMgbm9kZS5cbiAgICogQHByb3BlcnR5IHtMaW5rZWRMaXN0Tm9kZTxUPiB8IG51bGx9IG5leHQgVGhlIG5leHQgbm9kZS5cbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBMaW5rZWRMaXN0KCkge1xuICAgIC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG4gICAgdmFyIGhlYWQgPSB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIHByZXY6IG51bGwsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICAvKiogQHR5cGUge0xpbmtlZExpc3ROb2RlPFQ+fSAqL1xuICAgIHZhciB0YWlsID0ge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBwcmV2OiBoZWFkLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaGVhZC5uZXh0ID0gdGFpbDtcblxuICAgIC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG4gICAgdGhpcy5oZWFkID0gaGVhZDtcbiAgICAvKiogQHR5cGUge0xpbmtlZExpc3ROb2RlPFQ+fSAqL1xuICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgbm9kZSB3aXRoIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtMaW5rZWRMaXN0PFQ+fSBsaXN0XG4gICAqIEBwYXJhbSB7TGlua2VkTGlzdE5vZGU8VD59IG5vZGVcbiAgICogQHBhcmFtIHtUfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7TGlua2VkTGlzdE5vZGU8VD59IFRoZSBhZGRlZCBub2RlLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgZnVuY3Rpb24gYWRkQWZ0ZXIobGlzdCwgbm9kZSwgdmFsdWUpIHtcbiAgICAvLyBhc3N1bWVzIHRoYXQgbm9kZSAhPSBsaXN0LnRhaWwgJiYgdmFsdWVzLmxlbmd0aCA+PSAwXG4gICAgdmFyIG5leHQgPSBub2RlLm5leHQ7XG4gICAgdmFyIG5ld05vZGUgPSB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBwcmV2OiBub2RlLFxuICAgICAgbmV4dDogbmV4dFxuICAgIH07XG4gICAgbm9kZS5uZXh0ID0gbmV3Tm9kZTtcbiAgICBuZXh0LnByZXYgPSBuZXdOb2RlO1xuICAgIGxpc3QubGVuZ3RoKys7XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYGNvdW50YCBub2RlcyBhZnRlciB0aGUgZ2l2ZW4gbm9kZS4gVGhlIGdpdmVuIG5vZGUgd2lsbCBub3QgYmUgcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtIHtMaW5rZWRMaXN0PFQ+fSBsaXN0XG4gICAqIEBwYXJhbSB7TGlua2VkTGlzdE5vZGU8VD59IG5vZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmVSYW5nZShsaXN0LCBub2RlLCBjb3VudCkge1xuICAgIHZhciBuZXh0ID0gbm9kZS5uZXh0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgJiYgbmV4dCAhPT0gbGlzdC50YWlsOyBpKyspIHtcbiAgICAgIG5leHQgPSBuZXh0Lm5leHQ7XG4gICAgfVxuICAgIG5vZGUubmV4dCA9IG5leHQ7XG4gICAgbmV4dC5wcmV2ID0gbm9kZTtcbiAgICBsaXN0Lmxlbmd0aCAtPSBpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0xpbmtlZExpc3Q8VD59IGxpc3RcbiAgICogQHJldHVybnMge1RbXX1cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIGZ1bmN0aW9uIHRvQXJyYXkobGlzdCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHZhciBub2RlID0gbGlzdC5oZWFkLm5leHQ7XG4gICAgd2hpbGUgKG5vZGUgIT09IGxpc3QudGFpbCkge1xuICAgICAgYXJyYXkucHVzaChub2RlLnZhbHVlKTtcbiAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICBpZiAoIV9zZWxmLmRvY3VtZW50KSB7XG4gICAgaWYgKCFfc2VsZi5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAvLyBpbiBOb2RlLmpzXG4gICAgICByZXR1cm4gXztcbiAgICB9XG4gICAgaWYgKCFfLmRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlcikge1xuICAgICAgLy8gSW4gd29ya2VyXG4gICAgICBfc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZ0LmRhdGEpO1xuICAgICAgICB2YXIgbGFuZyA9IG1lc3NhZ2UubGFuZ3VhZ2U7XG4gICAgICAgIHZhciBjb2RlID0gbWVzc2FnZS5jb2RlO1xuICAgICAgICB2YXIgaW1tZWRpYXRlQ2xvc2UgPSBtZXNzYWdlLmltbWVkaWF0ZUNsb3NlO1xuICAgICAgICBfc2VsZi5wb3N0TWVzc2FnZShfLmhpZ2hsaWdodChjb2RlLCBfLmxhbmd1YWdlc1tsYW5nXSwgbGFuZykpO1xuICAgICAgICBpZiAoaW1tZWRpYXRlQ2xvc2UpIHtcbiAgICAgICAgICBfc2VsZi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9LCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiBfO1xuICB9XG5cbiAgLy8gR2V0IGN1cnJlbnQgc2NyaXB0IGFuZCBoaWdobGlnaHRcbiAgdmFyIHNjcmlwdCA9IF8udXRpbC5jdXJyZW50U2NyaXB0KCk7XG4gIGlmIChzY3JpcHQpIHtcbiAgICBfLmZpbGVuYW1lID0gc2NyaXB0LnNyYztcbiAgICBpZiAoc2NyaXB0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1tYW51YWwnKSkge1xuICAgICAgXy5tYW51YWwgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoaWdobGlnaHRBdXRvbWF0aWNhbGx5Q2FsbGJhY2soKSB7XG4gICAgaWYgKCFfLm1hbnVhbCkge1xuICAgICAgXy5oaWdobGlnaHRBbGwoKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFfLm1hbnVhbCkge1xuICAgIC8vIElmIHRoZSBkb2N1bWVudCBzdGF0ZSBpcyBcImxvYWRpbmdcIiwgdGhlbiB3ZSdsbCB1c2UgRE9NQ29udGVudExvYWRlZC5cbiAgICAvLyBJZiB0aGUgZG9jdW1lbnQgc3RhdGUgaXMgXCJpbnRlcmFjdGl2ZVwiIGFuZCB0aGUgcHJpc20uanMgc2NyaXB0IGlzIGRlZmVycmVkLCB0aGVuIHdlJ2xsIGFsc28gdXNlIHRoZVxuICAgIC8vIERPTUNvbnRlbnRMb2FkZWQgZXZlbnQgYmVjYXVzZSB0aGVyZSBtaWdodCBiZSBzb21lIHBsdWdpbnMgb3IgbGFuZ3VhZ2VzIHdoaWNoIGhhdmUgYWxzbyBiZWVuIGRlZmVycmVkIGFuZCB0aGV5XG4gICAgLy8gbWlnaHQgdGFrZSBsb25nZXIgb25lIGFuaW1hdGlvbiBmcmFtZSB0byBleGVjdXRlIHdoaWNoIGNhbiBjcmVhdGUgYSByYWNlIGNvbmRpdGlvbiB3aGVyZSBvbmx5IHNvbWUgcGx1Z2lucyBoYXZlXG4gICAgLy8gYmVlbiBsb2FkZWQgd2hlbiBQcmlzbS5oaWdobGlnaHRBbGwoKSBpcyBleGVjdXRlZCwgZGVwZW5kaW5nIG9uIGhvdyBmYXN0IHJlc291cmNlcyBhcmUgbG9hZGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUHJpc21KUy9wcmlzbS9pc3N1ZXMvMjEwMlxuICAgIHZhciByZWFkeVN0YXRlID0gZG9jdW1lbnQucmVhZHlTdGF0ZTtcbiAgICBpZiAocmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnIHx8IHJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScgJiYgc2NyaXB0ICYmIHNjcmlwdC5kZWZlcikge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGhpZ2hsaWdodEF1dG9tYXRpY2FsbHlDYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaGlnaGxpZ2h0QXV0b21hdGljYWxseUNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGhpZ2hsaWdodEF1dG9tYXRpY2FsbHlDYWxsYmFjaywgMTYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gXztcbn0oX3NlbGYpO1xuXG4vLyBzb21lIGFkZGl0aW9uYWwgZG9jdW1lbnRhdGlvbi90eXBlc1xuXG4vKipcbiAqIFRoZSBleHBhbnNpb24gb2YgYSBzaW1wbGUgYFJlZ0V4cGAgbGl0ZXJhbCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgcHJvcGVydGllcy5cbiAqXG4gKiBAdHlwZWRlZiBHcmFtbWFyVG9rZW5cbiAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBwYXR0ZXJuIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gb2YgdGhlIHRva2VuLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbG9va2JlaGluZD1mYWxzZV0gSWYgYHRydWVgLCB0aGVuIHRoZSBmaXJzdCBjYXB0dXJpbmcgZ3JvdXAgb2YgYHBhdHRlcm5gIHdpbGwgKGVmZmVjdGl2ZWx5KVxuICogYmVoYXZlIGFzIGEgbG9va2JlaGluZCBncm91cCBtZWFuaW5nIHRoYXQgdGhlIGNhcHR1cmVkIHRleHQgd2lsbCBub3QgYmUgcGFydCBvZiB0aGUgbWF0Y2hlZCB0ZXh0IG9mIHRoZSBuZXcgdG9rZW4uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtncmVlZHk9ZmFsc2VdIFdoZXRoZXIgdGhlIHRva2VuIGlzIGdyZWVkeS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfHN0cmluZ1tdfSBbYWxpYXNdIEFuIG9wdGlvbmFsIGFsaWFzIG9yIGxpc3Qgb2YgYWxpYXNlcy5cbiAqIEBwcm9wZXJ0eSB7R3JhbW1hcn0gW2luc2lkZV0gVGhlIG5lc3RlZCBncmFtbWFyIG9mIHRoaXMgdG9rZW4uXG4gKlxuICogVGhlIGBpbnNpZGVgIGdyYW1tYXIgd2lsbCBiZSB1c2VkIHRvIHRva2VuaXplIHRoZSB0ZXh0IHZhbHVlIG9mIGVhY2ggdG9rZW4gb2YgdGhpcyBraW5kLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbWFrZSBuZXN0ZWQgYW5kIGV2ZW4gcmVjdXJzaXZlIGxhbmd1YWdlIGRlZmluaXRpb25zLlxuICpcbiAqIE5vdGU6IFRoaXMgY2FuIGNhdXNlIGluZmluaXRlIHJlY3Vyc2lvbi4gQmUgY2FyZWZ1bCB3aGVuIHlvdSBlbWJlZCBkaWZmZXJlbnQgbGFuZ3VhZ2VzIG9yIGV2ZW4gdGhlIHNhbWUgbGFuZ3VhZ2UgaW50b1xuICogZWFjaCBhbm90aGVyLlxuICogQGdsb2JhbFxuICogQHB1YmxpY1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYgR3JhbW1hclxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIFJlZ0V4cCB8IEdyYW1tYXJUb2tlbiB8IEFycmF5PFJlZ0V4cCB8IEdyYW1tYXJUb2tlbj4+fVxuICogQHByb3BlcnR5IHtHcmFtbWFyfSBbcmVzdF0gQW4gb3B0aW9uYWwgZ3JhbW1hciBvYmplY3QgdGhhdCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoaXMgZ3JhbW1hci5cbiAqIEBnbG9iYWxcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gd2hpY2ggd2lsbCBpbnZva2VkIGFmdGVyIGFuIGVsZW1lbnQgd2FzIHN1Y2Nlc3NmdWxseSBoaWdobGlnaHRlZC5cbiAqXG4gKiBAY2FsbGJhY2sgSGlnaGxpZ2h0Q2FsbGJhY2tcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCBzdWNjZXNzZnVsbHkgaGlnaGxpZ2h0ZWQuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBnbG9iYWxcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBIb29rQ2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gZW52IFRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgb2YgdGhlIGhvb2suXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBnbG9iYWxcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLW1hcmt1cC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMubWFya3VwID0ge1xuICAnY29tbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvPCEtLSg/Oig/ITwhLS0pW1xcc1xcU10pKj8tLT4vLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAncHJvbG9nJzoge1xuICAgIHBhdHRlcm46IC88XFw/W1xcc1xcU10rP1xcPz4vLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnZG9jdHlwZSc6IHtcbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIveG1sLyNOVC1kb2N0eXBlZGVjbFxuICAgIHBhdHRlcm46IC88IURPQ1RZUEUoPzpbXj5cIidbXFxdXXxcIlteXCJdKlwifCdbXiddKicpKyg/OlxcWyg/OltePFwiJ1xcXV18XCJbXlwiXSpcInwnW14nXSonfDwoPyEhLS0pfDwhLS0oPzpbXi1dfC0oPyEtPikpKi0tPikqXFxdXFxzKik/Pi9pLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdpbnRlcm5hbC1zdWJzZXQnOiB7XG4gICAgICAgIHBhdHRlcm46IC8oXlteXFxbXSpcXFspW1xcc1xcU10rKD89XFxdPiQpLyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICBpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG4gICAgICB9LFxuICAgICAgJ3N0cmluZyc6IHtcbiAgICAgICAgcGF0dGVybjogL1wiW15cIl0qXCJ8J1teJ10qJy8sXG4gICAgICAgIGdyZWVkeTogdHJ1ZVxuICAgICAgfSxcbiAgICAgICdwdW5jdHVhdGlvbic6IC9ePCF8PiR8W1tcXF1dLyxcbiAgICAgICdkb2N0eXBlLXRhZyc6IC9eRE9DVFlQRS9pLFxuICAgICAgJ25hbWUnOiAvW15cXHM8PidcIl0rL1xuICAgIH1cbiAgfSxcbiAgJ2NkYXRhJzoge1xuICAgIHBhdHRlcm46IC88IVxcW0NEQVRBXFxbW1xcc1xcU10qP1xcXVxcXT4vaSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ3RhZyc6IHtcbiAgICBwYXR0ZXJuOiAvPFxcLz8oPyFcXGQpW15cXHM+XFwvPSQ8JV0rKD86XFxzKD86XFxzKlteXFxzPlxcLz1dKyg/Olxccyo9XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSsoPz1bXFxzPl0pKXwoPz1bXFxzLz5dKSkpKyk/XFxzKlxcLz8+LyxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAndGFnJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXjxcXC8/W15cXHM+XFwvXSsvLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAncHVuY3R1YXRpb24nOiAvXjxcXC8/LyxcbiAgICAgICAgICAnbmFtZXNwYWNlJzogL15bXlxccz5cXC86XSs6L1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ3NwZWNpYWwtYXR0cic6IFtdLFxuICAgICAgJ2F0dHItdmFsdWUnOiB7XG4gICAgICAgIHBhdHRlcm46IC89XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSspLyxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ3B1bmN0dWF0aW9uJzogW3tcbiAgICAgICAgICAgIHBhdHRlcm46IC9ePS8sXG4gICAgICAgICAgICBhbGlhczogJ2F0dHItZXF1YWxzJ1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHBhdHRlcm46IC9eKFxccyopW1wiJ118W1wiJ10kLyxcbiAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgICB9XVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcLz8+LyxcbiAgICAgICdhdHRyLW5hbWUnOiB7XG4gICAgICAgIHBhdHRlcm46IC9bXlxccz5cXC9dKy8sXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICduYW1lc3BhY2UnOiAvXlteXFxzPlxcLzpdKzovXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICdlbnRpdHknOiBbe1xuICAgIHBhdHRlcm46IC8mW1xcZGEtel17MSw4fTsvaSxcbiAgICBhbGlhczogJ25hbWVkLWVudGl0eSdcbiAgfSwgLyYjeD9bXFxkYS1mXXsxLDh9Oy9pXVxufTtcblByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ3RhZyddLmluc2lkZVsnYXR0ci12YWx1ZSddLmluc2lkZVsnZW50aXR5J10gPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwWydlbnRpdHknXTtcblByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ2RvY3R5cGUnXS5pbnNpZGVbJ2ludGVybmFsLXN1YnNldCddLmluc2lkZSA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5cbi8vIFBsdWdpbiB0byBtYWtlIGVudGl0eSB0aXRsZSBzaG93IHRoZSByZWFsIGVudGl0eSwgaWRlYSBieSBSb21hbiBLb21hcm92XG5QcmlzbS5ob29rcy5hZGQoJ3dyYXAnLCBmdW5jdGlvbiAoZW52KSB7XG4gIGlmIChlbnYudHlwZSA9PT0gJ2VudGl0eScpIHtcbiAgICBlbnYuYXR0cmlidXRlc1sndGl0bGUnXSA9IGVudi5jb250ZW50LnJlcGxhY2UoLyZhbXA7LywgJyYnKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcsICdhZGRJbmxpbmVkJywge1xuICAvKipcbiAgICogQWRkcyBhbiBpbmxpbmVkIGxhbmd1YWdlIHRvIG1hcmt1cC5cbiAgICpcbiAgICogQW4gZXhhbXBsZSBvZiBhbiBpbmxpbmVkIGxhbmd1YWdlIGlzIENTUyB3aXRoIGA8c3R5bGU+YCB0YWdzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFnIHRoYXQgY29udGFpbnMgdGhlIGlubGluZWQgbGFuZ3VhZ2UuIFRoaXMgbmFtZSB3aWxsIGJlIHRyZWF0ZWQgYXNcbiAgICogY2FzZSBpbnNlbnNpdGl2ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmcgVGhlIGxhbmd1YWdlIGtleS5cbiAgICogQGV4YW1wbGVcbiAgICogYWRkSW5saW5lZCgnc3R5bGUnLCAnY3NzJyk7XG4gICAqL1xuICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5saW5lZCh0YWdOYW1lLCBsYW5nKSB7XG4gICAgdmFyIGluY2x1ZGVkQ2RhdGFJbnNpZGUgPSB7fTtcbiAgICBpbmNsdWRlZENkYXRhSW5zaWRlWydsYW5ndWFnZS0nICsgbGFuZ10gPSB7XG4gICAgICBwYXR0ZXJuOiAvKF48IVxcW0NEQVRBXFxbKVtcXHNcXFNdKz8oPz1cXF1cXF0+JCkvaSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlc1tsYW5nXVxuICAgIH07XG4gICAgaW5jbHVkZWRDZGF0YUluc2lkZVsnY2RhdGEnXSA9IC9ePCFcXFtDREFUQVxcW3xcXF1cXF0+JC9pO1xuICAgIHZhciBpbnNpZGUgPSB7XG4gICAgICAnaW5jbHVkZWQtY2RhdGEnOiB7XG4gICAgICAgIHBhdHRlcm46IC88IVxcW0NEQVRBXFxbW1xcc1xcU10qP1xcXVxcXT4vaSxcbiAgICAgICAgaW5zaWRlOiBpbmNsdWRlZENkYXRhSW5zaWRlXG4gICAgICB9XG4gICAgfTtcbiAgICBpbnNpZGVbJ2xhbmd1YWdlLScgKyBsYW5nXSA9IHtcbiAgICAgIHBhdHRlcm46IC9bXFxzXFxTXSsvLFxuICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXNbbGFuZ11cbiAgICB9O1xuICAgIHZhciBkZWYgPSB7fTtcbiAgICBkZWZbdGFnTmFtZV0gPSB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyg8X19bXj5dKj4pKD86PCFcXFtDREFUQVxcWyg/OlteXFxdXXxcXF0oPyFcXF0+KSkqXFxdXFxdPnwoPyE8IVxcW0NEQVRBXFxbKVtcXHNcXFNdKSo/KD89PFxcL19fPikvLnNvdXJjZS5yZXBsYWNlKC9fXy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lO1xuICAgICAgfSksICdpJyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiBpbnNpZGVcbiAgICB9O1xuICAgIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjZGF0YScsIGRlZik7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLCAnYWRkQXR0cmlidXRlJywge1xuICAvKipcbiAgICogQWRkcyBhbiBwYXR0ZXJuIHRvIGhpZ2hsaWdodCBsYW5ndWFnZXMgZW1iZWRkZWQgaW4gSFRNTCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBBbiBleGFtcGxlIG9mIGFuIGlubGluZWQgbGFuZ3VhZ2UgaXMgQ1NTIHdpdGggYHN0eWxlYCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ck5hbWUgVGhlIG5hbWUgb2YgdGhlIHRhZyB0aGF0IGNvbnRhaW5zIHRoZSBpbmxpbmVkIGxhbmd1YWdlLiBUaGlzIG5hbWUgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAqIGNhc2UgaW5zZW5zaXRpdmUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5nIFRoZSBsYW5ndWFnZSBrZXkuXG4gICAqIEBleGFtcGxlXG4gICAqIGFkZEF0dHJpYnV0ZSgnc3R5bGUnLCAnY3NzJyk7XG4gICAqL1xuICB2YWx1ZTogZnVuY3Rpb24gKGF0dHJOYW1lLCBsYW5nKSB7XG4gICAgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuaW5zaWRlWydzcGVjaWFsLWF0dHInXS5wdXNoKHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKF58W1wiJ1xcc10pLy5zb3VyY2UgKyAnKD86JyArIGF0dHJOYW1lICsgJyknICsgL1xccyo9XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSsoPz1bXFxzPl0pKS8uc291cmNlLCAnaScpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnYXR0ci1uYW1lJzogL15bXlxccz1dKy8sXG4gICAgICAgICdhdHRyLXZhbHVlJzoge1xuICAgICAgICAgIHBhdHRlcm46IC89W1xcc1xcU10rLyxcbiAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgICd2YWx1ZSc6IHtcbiAgICAgICAgICAgICAgcGF0dGVybjogLyhePVxccyooW1wiJ118KD8hW1wiJ10pKSlcXFNbXFxzXFxTXSooPz1cXDIkKS8sXG4gICAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgICAgIGFsaWFzOiBbbGFuZywgJ2xhbmd1YWdlLScgKyBsYW5nXSxcbiAgICAgICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXNbbGFuZ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncHVuY3R1YXRpb24nOiBbe1xuICAgICAgICAgICAgICBwYXR0ZXJuOiAvXj0vLFxuICAgICAgICAgICAgICBhbGlhczogJ2F0dHItZXF1YWxzJ1xuICAgICAgICAgICAgfSwgL1wifCcvXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59KTtcblByaXNtLmxhbmd1YWdlcy5odG1sID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblByaXNtLmxhbmd1YWdlcy5tYXRobWwgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuUHJpc20ubGFuZ3VhZ2VzLnN2ZyA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5QcmlzbS5sYW5ndWFnZXMueG1sID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnbWFya3VwJywge30pO1xuUHJpc20ubGFuZ3VhZ2VzLnNzbWwgPSBQcmlzbS5sYW5ndWFnZXMueG1sO1xuUHJpc20ubGFuZ3VhZ2VzLmF0b20gPSBQcmlzbS5sYW5ndWFnZXMueG1sO1xuUHJpc20ubGFuZ3VhZ2VzLnJzcyA9IFByaXNtLmxhbmd1YWdlcy54bWw7XG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tY3NzLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgdmFyIHN0cmluZyA9IC8oPzpcIig/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteXCJcXFxcXFxyXFxuXSkqXCJ8Jyg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteJ1xcXFxcXHJcXG5dKSonKS87XG4gIFByaXNtLmxhbmd1YWdlcy5jc3MgPSB7XG4gICAgJ2NvbW1lbnQnOiAvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy8sXG4gICAgJ2F0cnVsZSc6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnQFtcXFxcdy1dKD86JyArIC9bXjt7XFxzXCInXXxcXHMrKD8hXFxzKS8uc291cmNlICsgJ3wnICsgc3RyaW5nLnNvdXJjZSArICcpKj8nICsgLyg/Ojt8KD89XFxzKlxceykpLy5zb3VyY2UpLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdydWxlJzogL15AW1xcdy1dKy8sXG4gICAgICAgICdzZWxlY3Rvci1mdW5jdGlvbi1hcmd1bWVudCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKFxcYnNlbGVjdG9yXFxzKlxcKFxccyooPyFbXFxzKV0pKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpKSsoPz1cXHMqXFwpKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBhbGlhczogJ3NlbGVjdG9yJ1xuICAgICAgICB9LFxuICAgICAgICAna2V5d29yZCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF58W15cXHctXSkoPzphbmR8bm90fG9ubHl8b3IpKD8hW1xcdy1dKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSByZXN0IGJlbG93XG4gICAgICB9XG4gICAgfSxcbiAgICAndXJsJzoge1xuICAgICAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuICAgICAgcGF0dGVybjogUmVnRXhwKCdcXFxcYnVybFxcXFwoKD86JyArIHN0cmluZy5zb3VyY2UgKyAnfCcgKyAvKD86W15cXFxcXFxyXFxuKClcIiddfFxcXFxbXFxzXFxTXSkqLy5zb3VyY2UgKyAnKVxcXFwpJywgJ2knKSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZnVuY3Rpb24nOiAvXnVybC9pLFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvXlxcKHxcXCkkLyxcbiAgICAgICAgJ3N0cmluZyc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoJ14nICsgc3RyaW5nLnNvdXJjZSArICckJyksXG4gICAgICAgICAgYWxpYXM6ICd1cmwnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdzZWxlY3Rvcic6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnKF58W3t9XFxcXHNdKVtee31cXFxcc10oPzpbXnt9O1wiXFwnXFxcXHNdfFxcXFxzKyg/IVtcXFxcc3tdKXwnICsgc3RyaW5nLnNvdXJjZSArICcpKig/PVxcXFxzKlxcXFx7KScpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ3N0cmluZyc6IHtcbiAgICAgIHBhdHRlcm46IHN0cmluZyxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH0sXG4gICAgJ3Byb3BlcnR5Jzoge1xuICAgICAgcGF0dGVybjogLyhefFteLVxcd1xceEEwLVxcdUZGRkZdKSg/IVxccylbLV9hLXpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbLVxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqOikvaSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdpbXBvcnRhbnQnOiAvIWltcG9ydGFudFxcYi9pLFxuICAgICdmdW5jdGlvbic6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXi1hLXowLTldKVstYS16MC05XSsoPz1cXCgpL2ksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAncHVuY3R1YXRpb24nOiAvWygpe307OixdL1xuICB9O1xuICBQcmlzbS5sYW5ndWFnZXMuY3NzWydhdHJ1bGUnXS5pbnNpZGUucmVzdCA9IFByaXNtLmxhbmd1YWdlcy5jc3M7XG4gIHZhciBtYXJrdXAgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuICBpZiAobWFya3VwKSB7XG4gICAgbWFya3VwLnRhZy5hZGRJbmxpbmVkKCdzdHlsZScsICdjc3MnKTtcbiAgICBtYXJrdXAudGFnLmFkZEF0dHJpYnV0ZSgnc3R5bGUnLCAnY3NzJyk7XG4gIH1cbn0pKFByaXNtKTtcblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jbGlrZS5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMuY2xpa2UgPSB7XG4gICdjb21tZW50JzogW3tcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSlcXC9cXCpbXFxzXFxTXSo/KD86XFwqXFwvfCQpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LCB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXDpdKVxcL1xcLy4qLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9XSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKFtcIiddKSg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnY2xhc3MtbmFtZSc6IHtcbiAgICBwYXR0ZXJuOiAvKFxcYig/OmNsYXNzfGV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfGludGVyZmFjZXxuZXd8dHJhaXQpXFxzK3xcXGJjYXRjaFxccytcXCgpW1xcdy5cXFxcXSsvaSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ3B1bmN0dWF0aW9uJzogL1suXFxcXF0vXG4gICAgfVxuICB9LFxuICAna2V5d29yZCc6IC9cXGIoPzpicmVha3xjYXRjaHxjb250aW51ZXxkb3xlbHNlfGZpbmFsbHl8Zm9yfGZ1bmN0aW9ufGlmfGlufGluc3RhbmNlb2Z8bmV3fG51bGx8cmV0dXJufHRocm93fHRyeXx3aGlsZSlcXGIvLFxuICAnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi8sXG4gICdmdW5jdGlvbic6IC9cXGJcXHcrKD89XFwoKS8sXG4gICdudW1iZXInOiAvXFxiMHhbXFxkYS1mXStcXGJ8KD86XFxiXFxkKyg/OlxcLlxcZCopP3xcXEJcXC5cXGQrKSg/OmVbKy1dP1xcZCspPy9pLFxuICAnb3BlcmF0b3InOiAvWzw+XT0/fFshPV09Pz0/fC0tP3xcXCtcXCs/fCYmP3xcXHxcXHw/fFs/Ki9+XiVdLyxcbiAgJ3B1bmN0dWF0aW9uJzogL1t7fVtcXF07KCksLjpdL1xufTtcblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1qYXZhc2NyaXB0LmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cblByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY2xpa2UnLCB7XG4gICdjbGFzcy1uYW1lJzogW1ByaXNtLmxhbmd1YWdlcy5jbGlrZVsnY2xhc3MtbmFtZSddLCB7XG4gICAgcGF0dGVybjogLyhefFteJFxcd1xceEEwLVxcdUZGRkZdKSg/IVxccylbXyRBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXC4oPzpjb25zdHJ1Y3Rvcnxwcm90b3R5cGUpKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9XSxcbiAgJ2tleXdvcmQnOiBbe1xuICAgIHBhdHRlcm46IC8oKD86XnxcXH0pXFxzKiljYXRjaFxcYi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9LCB7XG4gICAgcGF0dGVybjogLyhefFteLl18XFwuXFwuXFwuXFxzKilcXGIoPzphc3xhc3NlcnQoPz1cXHMqXFx7KXxhc3luYyg/PVxccyooPzpmdW5jdGlvblxcYnxcXCh8WyRcXHdcXHhBMC1cXHVGRkZGXXwkKSl8YXdhaXR8YnJlYWt8Y2FzZXxjbGFzc3xjb25zdHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmluYWxseSg/PVxccyooPzpcXHt8JCkpfGZvcnxmcm9tKD89XFxzKig/OlsnXCJdfCQpKXxmdW5jdGlvbnwoPzpnZXR8c2V0KSg/PVxccyooPzpbI1xcWyRcXHdcXHhBMC1cXHVGRkZGXXwkKSl8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfG9mfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzdGF0aWN8c3VwZXJ8c3dpdGNofHRoaXN8dGhyb3d8dHJ5fHR5cGVvZnx1bmRlZmluZWR8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZClcXGIvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfV0sXG4gIC8vIEFsbG93IGZvciBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMgKFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMDA4NDQ0KVxuICAnZnVuY3Rpb24nOiAvIz8oPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKig/OlxcLlxccyooPzphcHBseXxiaW5kfGNhbGwpXFxzKik/XFwoKS8sXG4gICdudW1iZXInOiB7XG4gICAgcGF0dGVybjogUmVnRXhwKC8oXnxbXlxcdyRdKS8uc291cmNlICsgJyg/OicgKyAoXG4gICAgLy8gY29uc3RhbnRcbiAgICAvTmFOfEluZmluaXR5Ly5zb3VyY2UgKyAnfCcgK1xuICAgIC8vIGJpbmFyeSBpbnRlZ2VyXG4gICAgLzBbYkJdWzAxXSsoPzpfWzAxXSspKm4/Ly5zb3VyY2UgKyAnfCcgK1xuICAgIC8vIG9jdGFsIGludGVnZXJcbiAgICAvMFtvT11bMC03XSsoPzpfWzAtN10rKSpuPy8uc291cmNlICsgJ3wnICtcbiAgICAvLyBoZXhhZGVjaW1hbCBpbnRlZ2VyXG4gICAgLzBbeFhdW1xcZEEtRmEtZl0rKD86X1tcXGRBLUZhLWZdKykqbj8vLnNvdXJjZSArICd8JyArXG4gICAgLy8gZGVjaW1hbCBiaWdpbnRcbiAgICAvXFxkKyg/Ol9cXGQrKSpuLy5zb3VyY2UgKyAnfCcgK1xuICAgIC8vIGRlY2ltYWwgbnVtYmVyIChpbnRlZ2VyIG9yIGZsb2F0KSBidXQgbm8gYmlnaW50XG4gICAgLyg/OlxcZCsoPzpfXFxkKykqKD86XFwuKD86XFxkKyg/Ol9cXGQrKSopPyk/fFxcLlxcZCsoPzpfXFxkKykqKSg/OltFZV1bKy1dP1xcZCsoPzpfXFxkKykqKT8vLnNvdXJjZSkgKyAnKScgKyAvKD8hW1xcdyRdKS8uc291cmNlKSxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdvcGVyYXRvcic6IC8tLXxcXCtcXCt8XFwqXFwqPT98PT58JiY9P3xcXHxcXHw9P3xbIT1dPT18PDw9P3w+Pj4/PT98Wy0rKi8lJnxeIT08Pl09P3xcXC57M318XFw/XFw/PT98XFw/XFwuP3xbfjpdL1xufSk7XG5QcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFsnY2xhc3MtbmFtZSddWzBdLnBhdHRlcm4gPSAvKFxcYig/OmNsYXNzfGV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfGludGVyZmFjZXxuZXcpXFxzKylbXFx3LlxcXFxdKy87XG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ2tleXdvcmQnLCB7XG4gICdyZWdleCc6IHtcbiAgICBwYXR0ZXJuOiBSZWdFeHAoXG4gICAgLy8gbG9va2JlaGluZFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tZHVwZS1jaGFyYWN0ZXJzLWNoYXJhY3Rlci1jbGFzc1xuICAgIC8oKD86XnxbXiRcXHdcXHhBMC1cXHVGRkZGLlwiJ1xcXSlcXHNdfFxcYig/OnJldHVybnx5aWVsZCkpXFxzKikvLnNvdXJjZSArXG4gICAgLy8gUmVnZXggcGF0dGVybjpcbiAgICAvLyBUaGVyZSBhcmUgMiByZWdleCBwYXR0ZXJucyBoZXJlLiBUaGUgUmVnRXhwIHNldCBub3RhdGlvbiBwcm9wb3NhbCBhZGRlZCBzdXBwb3J0IGZvciBuZXN0ZWQgY2hhcmFjdGVyXG4gICAgLy8gY2xhc3NlcyBpZiB0aGUgYHZgIGZsYWcgaXMgcHJlc2VudC4gVW5mb3J0dW5hdGVseSwgbmVzdGVkIENDcyBhcmUgYm90aCBjb250ZXh0LWZyZWUgYW5kIGluY29tcGF0aWJsZVxuICAgIC8vIHdpdGggdGhlIG9ubHkgc3ludGF4LCBzbyB3ZSBoYXZlIHRvIGRlZmluZSAyIGRpZmZlcmVudCByZWdleCBwYXR0ZXJucy5cbiAgICAvXFwvLy5zb3VyY2UgKyAnKD86JyArIC8oPzpcXFsoPzpbXlxcXVxcXFxcXHJcXG5dfFxcXFwuKSpcXF18XFxcXC58W14vXFxcXFxcW1xcclxcbl0pK1xcL1tkZ2lteXVzXXswLDd9Ly5zb3VyY2UgKyAnfCcgK1xuICAgIC8vIGB2YCBmbGFnIHN5bnRheC4gVGhpcyBzdXBwb3J0cyAzIGxldmVscyBvZiBuZXN0ZWQgY2hhcmFjdGVyIGNsYXNzZXMuXG4gICAgLyg/OlxcWyg/OlteW1xcXVxcXFxcXHJcXG5dfFxcXFwufFxcWyg/OlteW1xcXVxcXFxcXHJcXG5dfFxcXFwufFxcWyg/OlteW1xcXVxcXFxcXHJcXG5dfFxcXFwuKSpcXF0pKlxcXSkqXFxdfFxcXFwufFteL1xcXFxcXFtcXHJcXG5dKStcXC9bZGdpbXl1c117MCw3fXZbZGdpbXl1c117MCw3fS8uc291cmNlICsgJyknICtcbiAgICAvLyBsb29rYWhlYWRcbiAgICAvKD89KD86XFxzfFxcL1xcKig/OlteKl18XFwqKD8hXFwvKSkqXFwqXFwvKSooPzokfFtcXHJcXG4sLjs6fSlcXF1dfFxcL1xcLykpLy5zb3VyY2UpLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ3JlZ2V4LXNvdXJjZSc6IHtcbiAgICAgICAgcGF0dGVybjogL14oXFwvKVtcXHNcXFNdKyg/PVxcL1thLXpdKiQpLyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgYWxpYXM6ICdsYW5ndWFnZS1yZWdleCcsXG4gICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLnJlZ2V4XG4gICAgICB9LFxuICAgICAgJ3JlZ2V4LWRlbGltaXRlcic6IC9eXFwvfFxcLyQvLFxuICAgICAgJ3JlZ2V4LWZsYWdzJzogL15bYS16XSskL1xuICAgIH1cbiAgfSxcbiAgLy8gVGhpcyBtdXN0IGJlIGRlY2xhcmVkIGJlZm9yZSBrZXl3b3JkIGJlY2F1c2Ugd2UgdXNlIFwiZnVuY3Rpb25cIiBpbnNpZGUgdGhlIGxvb2stZm9yd2FyZFxuICAnZnVuY3Rpb24tdmFyaWFibGUnOiB7XG4gICAgcGF0dGVybjogLyM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccypbPTpdXFxzKig/OmFzeW5jXFxzKik/KD86XFxiZnVuY3Rpb25cXGJ8KD86XFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCl8KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKilcXHMqPT4pKS8sXG4gICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgfSxcbiAgJ3BhcmFtZXRlcic6IFt7XG4gICAgcGF0dGVybjogLyhmdW5jdGlvbig/OlxccysoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKT9cXHMqXFwoXFxzKikoPyFcXHMpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoW14oKV0qXFwpKSsoPz1cXHMqXFwpKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKF58W14kXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVtfJGEtelxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyo9PikvaSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgfSwge1xuICAgIHBhdHRlcm46IC8oXFwoXFxzKikoPyFcXHMpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoW14oKV0qXFwpKSsoPz1cXHMqXFwpXFxzKj0+KS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKCg/OlxcYnxcXHN8XikoPyEoPzphc3xhc3luY3xhd2FpdHxicmVha3xjYXNlfGNhdGNofGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmaW5hbGx5fGZvcnxmcm9tfGZ1bmN0aW9ufGdldHxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxsZXR8bmV3fG51bGx8b2Z8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmV0dXJufHNldHxzdGF0aWN8c3VwZXJ8c3dpdGNofHRoaXN8dGhyb3d8dHJ5fHR5cGVvZnx1bmRlZmluZWR8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZCkoPyFbJFxcd1xceEEwLVxcdUZGRkZdKSkoPzooPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqXFxzKilcXChcXHMqfFxcXVxccypcXChcXHMqKSg/IVxccykoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXChbXigpXSpcXCkpKyg/PVxccypcXClcXHMqXFx7KS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gIH1dLFxuICAnY29uc3RhbnQnOiAvXFxiW0EtWl0oPzpbQS1aX118XFxkeD8pKlxcYi9cbn0pO1xuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdzdHJpbmcnLCB7XG4gICdoYXNoYmFuZyc6IHtcbiAgICBwYXR0ZXJuOiAvXiMhLiovLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBhbGlhczogJ2NvbW1lbnQnXG4gIH0sXG4gICd0ZW1wbGF0ZS1zdHJpbmcnOiB7XG4gICAgcGF0dGVybjogL2AoPzpcXFxcW1xcc1xcU118XFwkXFx7KD86W157fV18XFx7KD86W157fV18XFx7W159XSpcXH0pKlxcfSkrXFx9fCg/IVxcJFxceylbXlxcXFxgXSkqYC8sXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ3RlbXBsYXRlLXB1bmN0dWF0aW9uJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXmB8YCQvLFxuICAgICAgICBhbGlhczogJ3N0cmluZydcbiAgICAgIH0sXG4gICAgICAnaW50ZXJwb2xhdGlvbic6IHtcbiAgICAgICAgcGF0dGVybjogLygoPzpefFteXFxcXF0pKD86XFxcXHsyfSkqKVxcJFxceyg/Oltee31dfFxceyg/Oltee31dfFxce1tefV0qXFx9KSpcXH0pK1xcfS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uJzoge1xuICAgICAgICAgICAgcGF0dGVybjogL15cXCRcXHt8XFx9JC8sXG4gICAgICAgICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzdDogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdzdHJpbmcnOiAvW1xcc1xcU10rL1xuICAgIH1cbiAgfSxcbiAgJ3N0cmluZy1wcm9wZXJ0eSc6IHtcbiAgICBwYXR0ZXJuOiAvKCg/Ol58Wyx7XSlbIFxcdF0qKShbXCInXSkoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDIpW15cXFxcXFxyXFxuXSkqXFwyKD89XFxzKjopL20sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgYWxpYXM6ICdwcm9wZXJ0eSdcbiAgfVxufSk7XG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ29wZXJhdG9yJywge1xuICAnbGl0ZXJhbC1wcm9wZXJ0eSc6IHtcbiAgICBwYXR0ZXJuOiAvKCg/Ol58Wyx7XSlbIFxcdF0qKSg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqOikvbSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiAncHJvcGVydHknXG4gIH1cbn0pO1xuaWYgKFByaXNtLmxhbmd1YWdlcy5tYXJrdXApIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuYWRkSW5saW5lZCgnc2NyaXB0JywgJ2phdmFzY3JpcHQnKTtcblxuICAvLyBhZGQgYXR0cmlidXRlIHN1cHBvcnQgZm9yIGFsbCBET00gZXZlbnRzLlxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMjU3RhbmRhcmRfZXZlbnRzXG4gIFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmFkZEF0dHJpYnV0ZSgvb24oPzphYm9ydHxibHVyfGNoYW5nZXxjbGlja3xjb21wb3NpdGlvbig/OmVuZHxzdGFydHx1cGRhdGUpfGRibGNsaWNrfGVycm9yfGZvY3VzKD86aW58b3V0KT98a2V5KD86ZG93bnx1cCl8bG9hZHxtb3VzZSg/OmRvd258ZW50ZXJ8bGVhdmV8bW92ZXxvdXR8b3Zlcnx1cCl8cmVzZXR8cmVzaXplfHNjcm9sbHxzZWxlY3R8c2xvdGNoYW5nZXxzdWJtaXR8dW5sb2FkfHdoZWVsKS8uc291cmNlLCAnamF2YXNjcmlwdCcpO1xufVxuUHJpc20ubGFuZ3VhZ2VzLmpzID0gUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQ7XG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tZmlsZS1oaWdobGlnaHQuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBQcmlzbSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L21hdGNoZXMjUG9seWZpbGxcbiAgaWYgKCFFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKSB7XG4gICAgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcbiAgfVxuICB2YXIgTE9BRElOR19NRVNTQUdFID0gJ0xvYWRpbmfigKYnO1xuICB2YXIgRkFJTFVSRV9NRVNTQUdFID0gZnVuY3Rpb24gKHN0YXR1cywgbWVzc2FnZSkge1xuICAgIHJldHVybiAn4pyWIEVycm9yICcgKyBzdGF0dXMgKyAnIHdoaWxlIGZldGNoaW5nIGZpbGU6ICcgKyBtZXNzYWdlO1xuICB9O1xuICB2YXIgRkFJTFVSRV9FTVBUWV9NRVNTQUdFID0gJ+KcliBFcnJvcjogRmlsZSBkb2VzIG5vdCBleGlzdCBvciBpcyBlbXB0eSc7XG4gIHZhciBFWFRFTlNJT05TID0ge1xuICAgICdqcyc6ICdqYXZhc2NyaXB0JyxcbiAgICAncHknOiAncHl0aG9uJyxcbiAgICAncmInOiAncnVieScsXG4gICAgJ3BzMSc6ICdwb3dlcnNoZWxsJyxcbiAgICAncHNtMSc6ICdwb3dlcnNoZWxsJyxcbiAgICAnc2gnOiAnYmFzaCcsXG4gICAgJ2JhdCc6ICdiYXRjaCcsXG4gICAgJ2gnOiAnYycsXG4gICAgJ3RleCc6ICdsYXRleCdcbiAgfTtcbiAgdmFyIFNUQVRVU19BVFRSID0gJ2RhdGEtc3JjLXN0YXR1cyc7XG4gIHZhciBTVEFUVVNfTE9BRElORyA9ICdsb2FkaW5nJztcbiAgdmFyIFNUQVRVU19MT0FERUQgPSAnbG9hZGVkJztcbiAgdmFyIFNUQVRVU19GQUlMRUQgPSAnZmFpbGVkJztcbiAgdmFyIFNFTEVDVE9SID0gJ3ByZVtkYXRhLXNyY106bm90KFsnICsgU1RBVFVTX0FUVFIgKyAnPVwiJyArIFNUQVRVU19MT0FERUQgKyAnXCJdKScgKyAnOm5vdChbJyArIFNUQVRVU19BVFRSICsgJz1cIicgKyBTVEFUVVNfTE9BRElORyArICdcIl0pJztcblxuICAvKipcbiAgICogTG9hZHMgdGhlIGdpdmVuIGZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgVGhlIFVSTCBvciBwYXRoIG9mIHRoZSBzb3VyY2UgZmlsZSB0byBsb2FkLlxuICAgKiBAcGFyYW0geyhyZXN1bHQ6IHN0cmluZykgPT4gdm9pZH0gc3VjY2Vzc1xuICAgKiBAcGFyYW0geyhyZWFzb246IHN0cmluZykgPT4gdm9pZH0gZXJyb3JcbiAgICovXG4gIGZ1bmN0aW9uIGxvYWRGaWxlKHNyYywgc3VjY2VzcywgZXJyb3IpIHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4oJ0dFVCcsIHNyYywgdHJ1ZSk7XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzIDwgNDAwICYmIHhoci5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgICBzdWNjZXNzKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDQwMCkge1xuICAgICAgICAgICAgZXJyb3IoRkFJTFVSRV9NRVNTQUdFKHhoci5zdGF0dXMsIHhoci5zdGF0dXNUZXh0KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKEZBSUxVUkVfRU1QVFlfTUVTU0FHRSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZChudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGdpdmVuIHJhbmdlLlxuICAgKlxuICAgKiBUaGlzIHJldHVybnMgYSByYW5nZSB3aXRoIGluY2x1c2l2ZSBlbmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IHJhbmdlXG4gICAqIEByZXR1cm5zIHtbbnVtYmVyLCBudW1iZXIgfCB1bmRlZmluZWRdIHwgdW5kZWZpbmVkfVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VSYW5nZShyYW5nZSkge1xuICAgIHZhciBtID0gL15cXHMqKFxcZCspXFxzKig/OigsKVxccyooPzooXFxkKylcXHMqKT8pPyQvLmV4ZWMocmFuZ2UgfHwgJycpO1xuICAgIGlmIChtKSB7XG4gICAgICB2YXIgc3RhcnQgPSBOdW1iZXIobVsxXSk7XG4gICAgICB2YXIgY29tbWEgPSBtWzJdO1xuICAgICAgdmFyIGVuZCA9IG1bM107XG4gICAgICBpZiAoIWNvbW1hKSB7XG4gICAgICAgIHJldHVybiBbc3RhcnQsIHN0YXJ0XTtcbiAgICAgIH1cbiAgICAgIGlmICghZW5kKSB7XG4gICAgICAgIHJldHVybiBbc3RhcnQsIHVuZGVmaW5lZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gW3N0YXJ0LCBOdW1iZXIoZW5kKV07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgUHJpc20uaG9va3MuYWRkKCdiZWZvcmUtaGlnaGxpZ2h0YWxsJywgZnVuY3Rpb24gKGVudikge1xuICAgIGVudi5zZWxlY3RvciArPSAnLCAnICsgU0VMRUNUT1I7XG4gIH0pO1xuICBQcmlzbS5ob29rcy5hZGQoJ2JlZm9yZS1zYW5pdHktY2hlY2snLCBmdW5jdGlvbiAoZW52KSB7XG4gICAgdmFyIHByZSA9IC8qKiBAdHlwZSB7SFRNTFByZUVsZW1lbnR9ICovZW52LmVsZW1lbnQ7XG4gICAgaWYgKHByZS5tYXRjaGVzKFNFTEVDVE9SKSkge1xuICAgICAgZW52LmNvZGUgPSAnJzsgLy8gZmFzdC1wYXRoIHRoZSB3aG9sZSB0aGluZyBhbmQgZ28gdG8gY29tcGxldGVcblxuICAgICAgcHJlLnNldEF0dHJpYnV0ZShTVEFUVVNfQVRUUiwgU1RBVFVTX0xPQURJTkcpOyAvLyBtYXJrIGFzIGxvYWRpbmdcblxuICAgICAgLy8gYWRkIGNvZGUgZWxlbWVudCB3aXRoIGxvYWRpbmcgbWVzc2FnZVxuICAgICAgdmFyIGNvZGUgPSBwcmUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQ09ERScpKTtcbiAgICAgIGNvZGUudGV4dENvbnRlbnQgPSBMT0FESU5HX01FU1NBR0U7XG4gICAgICB2YXIgc3JjID0gcHJlLmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKTtcbiAgICAgIHZhciBsYW5ndWFnZSA9IGVudi5sYW5ndWFnZTtcbiAgICAgIGlmIChsYW5ndWFnZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIC8vIHRoZSBsYW5ndWFnZSBtaWdodCBiZSAnbm9uZScgYmVjYXVzZSB0aGVyZSBpcyBubyBsYW5ndWFnZSBzZXQ7XG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSwgd2Ugd2FudCB0byB1c2UgdGhlIGV4dGVuc2lvbiBhcyB0aGUgbGFuZ3VhZ2VcbiAgICAgICAgdmFyIGV4dGVuc2lvbiA9ICgvXFwuKFxcdyspJC8uZXhlYyhzcmMpIHx8IFssICdub25lJ10pWzFdO1xuICAgICAgICBsYW5ndWFnZSA9IEVYVEVOU0lPTlNbZXh0ZW5zaW9uXSB8fCBleHRlbnNpb247XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBsYW5ndWFnZSBjbGFzc2VzXG4gICAgICBQcmlzbS51dGlsLnNldExhbmd1YWdlKGNvZGUsIGxhbmd1YWdlKTtcbiAgICAgIFByaXNtLnV0aWwuc2V0TGFuZ3VhZ2UocHJlLCBsYW5ndWFnZSk7XG5cbiAgICAgIC8vIHByZWxvYWQgdGhlIGxhbmd1YWdlXG4gICAgICB2YXIgYXV0b2xvYWRlciA9IFByaXNtLnBsdWdpbnMuYXV0b2xvYWRlcjtcbiAgICAgIGlmIChhdXRvbG9hZGVyKSB7XG4gICAgICAgIGF1dG9sb2FkZXIubG9hZExhbmd1YWdlcyhsYW5ndWFnZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvYWQgZmlsZVxuICAgICAgbG9hZEZpbGUoc3JjLCBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAvLyBtYXJrIGFzIGxvYWRlZFxuICAgICAgICBwcmUuc2V0QXR0cmlidXRlKFNUQVRVU19BVFRSLCBTVEFUVVNfTE9BREVEKTtcblxuICAgICAgICAvLyBoYW5kbGUgZGF0YS1yYW5nZVxuICAgICAgICB2YXIgcmFuZ2UgPSBwYXJzZVJhbmdlKHByZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmFuZ2UnKSk7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoL1xcclxcbj98XFxuL2cpO1xuXG4gICAgICAgICAgLy8gdGhlIHJhbmdlIGlzIG9uZS1iYXNlZCBhbmQgaW5jbHVzaXZlIG9uIGJvdGggZW5kc1xuICAgICAgICAgIHZhciBzdGFydCA9IHJhbmdlWzBdO1xuICAgICAgICAgIHZhciBlbmQgPSByYW5nZVsxXSA9PSBudWxsID8gbGluZXMubGVuZ3RoIDogcmFuZ2VbMV07XG4gICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHN0YXJ0IC0gMSwgbGluZXMubGVuZ3RoKSk7XG4gICAgICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgICAgIGVuZCArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVuZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGVuZCwgbGluZXMubGVuZ3RoKSk7XG4gICAgICAgICAgdGV4dCA9IGxpbmVzLnNsaWNlKHN0YXJ0LCBlbmQpLmpvaW4oJ1xcbicpO1xuXG4gICAgICAgICAgLy8gYWRkIGRhdGEtc3RhcnQgZm9yIGxpbmUgbnVtYmVyc1xuICAgICAgICAgIGlmICghcHJlLmhhc0F0dHJpYnV0ZSgnZGF0YS1zdGFydCcpKSB7XG4gICAgICAgICAgICBwcmUuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXJ0JywgU3RyaW5nKHN0YXJ0ICsgMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhpZ2hsaWdodCBjb2RlXG4gICAgICAgIGNvZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICBQcmlzbS5oaWdobGlnaHRFbGVtZW50KGNvZGUpO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIC8vIG1hcmsgYXMgZmFpbGVkXG4gICAgICAgIHByZS5zZXRBdHRyaWJ1dGUoU1RBVFVTX0FUVFIsIFNUQVRVU19GQUlMRUQpO1xuICAgICAgICBjb2RlLnRleHRDb250ZW50ID0gZXJyb3I7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5wbHVnaW5zLmZpbGVIaWdobGlnaHQgPSB7XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIEZpbGUgSGlnaGxpZ2h0IHBsdWdpbiBmb3IgYWxsIG1hdGNoaW5nIGBwcmVgIGVsZW1lbnRzIHVuZGVyIHRoZSBnaXZlbiBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBFbGVtZW50cyB3aGljaCBhcmUgYWxyZWFkeSBsb2FkZWQgb3IgY3VycmVudGx5IGxvYWRpbmcgd2lsbCBub3QgYmUgdG91Y2hlZCBieSB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyZW50Tm9kZX0gW2NvbnRhaW5lcj1kb2N1bWVudF1cbiAgICAgKi9cbiAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uIGhpZ2hsaWdodChjb250YWluZXIpIHtcbiAgICAgIHZhciBlbGVtZW50cyA9IChjb250YWluZXIgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1IpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGVsZW1lbnQ7IGVsZW1lbnQgPSBlbGVtZW50c1tpKytdOykge1xuICAgICAgICBQcmlzbS5oaWdobGlnaHRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIGxvZ2dlZCA9IGZhbHNlO1xuICAvKiogQGRlcHJlY2F0ZWQgVXNlIGBQcmlzbS5wbHVnaW5zLmZpbGVIaWdobGlnaHQuaGlnaGxpZ2h0YCBpbnN0ZWFkLiAqL1xuICBQcmlzbS5maWxlSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghbG9nZ2VkKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1ByaXNtLmZpbGVIaWdobGlnaHQgaXMgZGVwcmVjYXRlZC4gVXNlIGBQcmlzbS5wbHVnaW5zLmZpbGVIaWdobGlnaHQuaGlnaGxpZ2h0YCBpbnN0ZWFkLicpO1xuICAgICAgbG9nZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgUHJpc20ucGx1Z2lucy5maWxlSGlnaGxpZ2h0LmhpZ2hsaWdodC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSkoKTtcblByaXNtLmxhbmd1YWdlcy5jbGlrZSA9IHtcbiAgJ2NvbW1lbnQnOiBbe1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKVxcL1xcKltcXHNcXFNdKj8oPzpcXCpcXC98JCkvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcOl0pXFwvXFwvLiovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH1dLFxuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oW1wiJ10pKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdjbGFzcy1uYW1lJzoge1xuICAgIHBhdHRlcm46IC8oXFxiKD86Y2xhc3N8ZXh0ZW5kc3xpbXBsZW1lbnRzfGluc3RhbmNlb2Z8aW50ZXJmYWNlfG5ld3x0cmFpdClcXHMrfFxcYmNhdGNoXFxzK1xcKClbXFx3LlxcXFxdKy9pLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAncHVuY3R1YXRpb24nOiAvWy5cXFxcXS9cbiAgICB9XG4gIH0sXG4gICdrZXl3b3JkJzogL1xcYig/OmJyZWFrfGNhdGNofGNvbnRpbnVlfGRvfGVsc2V8ZmluYWxseXxmb3J8ZnVuY3Rpb258aWZ8aW58aW5zdGFuY2VvZnxuZXd8bnVsbHxyZXR1cm58dGhyb3d8dHJ5fHdoaWxlKVxcYi8sXG4gICdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcbiAgJ2Z1bmN0aW9uJzogL1xcYlxcdysoPz1cXCgpLyxcbiAgJ251bWJlcic6IC9cXGIweFtcXGRhLWZdK1xcYnwoPzpcXGJcXGQrKD86XFwuXFxkKik/fFxcQlxcLlxcZCspKD86ZVsrLV0/XFxkKyk/L2ksXG4gICdvcGVyYXRvcic6IC9bPD5dPT98WyE9XT0/PT98LS0/fFxcK1xcKz98JiY/fFxcfFxcfD98Wz8qL35eJV0vLFxuICAncHVuY3R1YXRpb24nOiAvW3t9W1xcXTsoKSwuOl0vXG59O1xuUHJpc20ubGFuZ3VhZ2VzLmMgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcbiAgJ2NvbW1lbnQnOiB7XG4gICAgcGF0dGVybjogL1xcL1xcLyg/OlteXFxyXFxuXFxcXF18XFxcXCg/Olxcclxcbj98XFxufCg/IVtcXHJcXG5dKSkpKnxcXC9cXCpbXFxzXFxTXSo/KD86XFwqXFwvfCQpLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ3N0cmluZyc6IHtcbiAgICAvLyBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jL2xhbmd1YWdlL3N0cmluZ19saXRlcmFsXG4gICAgcGF0dGVybjogL1wiKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W15cIlxcXFxcXHJcXG5dKSpcIi8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdjbGFzcy1uYW1lJzoge1xuICAgIHBhdHRlcm46IC8oXFxiKD86ZW51bXxzdHJ1Y3QpXFxzKyg/Ol9fYXR0cmlidXRlX19cXHMqXFwoXFwoW1xcc1xcU10qP1xcKVxcKVxccyopPylcXHcrfFxcYlthLXpdXFx3Kl90XFxiLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdrZXl3b3JkJzogL1xcYig/Ol9BbGlnbmFzfF9BbGlnbm9mfF9BdG9taWN8X0Jvb2x8X0NvbXBsZXh8X0dlbmVyaWN8X0ltYWdpbmFyeXxfTm9yZXR1cm58X1N0YXRpY19hc3NlcnR8X1RocmVhZF9sb2NhbHxfX2F0dHJpYnV0ZV9ffGFzbXxhdXRvfGJyZWFrfGNhc2V8Y2hhcnxjb25zdHxjb250aW51ZXxkZWZhdWx0fGRvfGRvdWJsZXxlbHNlfGVudW18ZXh0ZXJufGZsb2F0fGZvcnxnb3RvfGlmfGlubGluZXxpbnR8bG9uZ3xyZWdpc3RlcnxyZXR1cm58c2hvcnR8c2lnbmVkfHNpemVvZnxzdGF0aWN8c3RydWN0fHN3aXRjaHx0eXBlZGVmfHR5cGVvZnx1bmlvbnx1bnNpZ25lZHx2b2lkfHZvbGF0aWxlfHdoaWxlKVxcYi8sXG4gICdmdW5jdGlvbic6IC9cXGJbYS16X11cXHcqKD89XFxzKlxcKCkvaSxcbiAgJ251bWJlcic6IC8oPzpcXGIweCg/OltcXGRhLWZdKyg/OlxcLltcXGRhLWZdKik/fFxcLltcXGRhLWZdKykoPzpwWystXT9cXGQrKT98KD86XFxiXFxkKyg/OlxcLlxcZCopP3xcXEJcXC5cXGQrKSg/OmVbKy1dP1xcZCspPylbZnVsXXswLDR9L2ksXG4gICdvcGVyYXRvcic6IC8+Pj0/fDw8PT98LT58KFstKyZ8Ol0pXFwxfFs/On5dfFstKyovJSZ8XiE9PD5dPT8vXG59KTtcblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2MnLCAnc3RyaW5nJywge1xuICAnY2hhcic6IHtcbiAgICAvLyBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jL2xhbmd1YWdlL2NoYXJhY3Rlcl9jb25zdGFudFxuICAgIHBhdHRlcm46IC8nKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W14nXFxcXFxcclxcbl0pezAsMzJ9Jy8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH1cbn0pO1xuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnYycsICdzdHJpbmcnLCB7XG4gICdtYWNybyc6IHtcbiAgICAvLyBhbGxvdyBmb3IgbXVsdGlsaW5lIG1hY3JvIGRlZmluaXRpb25zXG4gICAgLy8gc3BhY2VzIGFmdGVyIHRoZSAjIGNoYXJhY3RlciBjb21waWxlIGZpbmUgd2l0aCBnY2NcbiAgICBwYXR0ZXJuOiAvKF5bXFx0IF0qKSNcXHMqW2Etel0oPzpbXlxcclxcblxcXFwvXXxcXC8oPyFcXCopfFxcL1xcKig/OlteKl18XFwqKD8hXFwvKSkqXFwqXFwvfFxcXFwoPzpcXHJcXG58W1xcc1xcU10pKSovaW0sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgYWxpYXM6ICdwcm9wZXJ0eScsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnc3RyaW5nJzogW3tcbiAgICAgICAgLy8gaGlnaGxpZ2h0IHRoZSBwYXRoIG9mIHRoZSBpbmNsdWRlIHN0YXRlbWVudCBhcyBhIHN0cmluZ1xuICAgICAgICBwYXR0ZXJuOiAvXigjXFxzKmluY2x1ZGVcXHMqKTxbXj5dKz4vLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICB9LCBQcmlzbS5sYW5ndWFnZXMuY1snc3RyaW5nJ11dLFxuICAgICAgJ2NoYXInOiBQcmlzbS5sYW5ndWFnZXMuY1snY2hhciddLFxuICAgICAgJ2NvbW1lbnQnOiBQcmlzbS5sYW5ndWFnZXMuY1snY29tbWVudCddLFxuICAgICAgJ21hY3JvLW5hbWUnOiBbe1xuICAgICAgICBwYXR0ZXJuOiAvKF4jXFxzKmRlZmluZVxccyspXFx3K1xcYig/IVxcKCkvaSxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwYXR0ZXJuOiAvKF4jXFxzKmRlZmluZVxccyspXFx3K1xcYig/PVxcKCkvaSxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgICAgIH1dLFxuICAgICAgLy8gaGlnaGxpZ2h0IG1hY3JvIGRpcmVjdGl2ZXMgYXMga2V5d29yZHNcbiAgICAgICdkaXJlY3RpdmUnOiB7XG4gICAgICAgIHBhdHRlcm46IC9eKCNcXHMqKVthLXpdKy8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGFsaWFzOiAna2V5d29yZCdcbiAgICAgIH0sXG4gICAgICAnZGlyZWN0aXZlLWhhc2gnOiAvXiMvLFxuICAgICAgJ3B1bmN0dWF0aW9uJzogLyMjfFxcXFwoPz1bXFxyXFxuXSkvLFxuICAgICAgJ2V4cHJlc3Npb24nOiB7XG4gICAgICAgIHBhdHRlcm46IC9cXFNbXFxzXFxTXSovLFxuICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5jXG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2MnLCAnZnVuY3Rpb24nLCB7XG4gIC8vIGhpZ2hsaWdodCBwcmVkZWZpbmVkIG1hY3JvcyBhcyBjb25zdGFudHNcbiAgJ2NvbnN0YW50JzogL1xcYig/OkVPRnxOVUxMfFNFRUtfQ1VSfFNFRUtfRU5EfFNFRUtfU0VUfF9fREFURV9ffF9fRklMRV9ffF9fTElORV9ffF9fVElNRVNUQU1QX198X19USU1FX198X19mdW5jX198c3RkZXJyfHN0ZGlufHN0ZG91dClcXGIvXG59KTtcbmRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMuY1snYm9vbGVhbiddO1xuKGZ1bmN0aW9uIChQcmlzbSkge1xuICB2YXIga2V5d29yZCA9IC9cXGIoPzphbGlnbmFzfGFsaWdub2Z8YXNtfGF1dG98Ym9vbHxicmVha3xjYXNlfGNhdGNofGNoYXJ8Y2hhcjE2X3R8Y2hhcjMyX3R8Y2hhcjhfdHxjbGFzc3xjb19hd2FpdHxjb19yZXR1cm58Y29feWllbGR8Y29tcGx8Y29uY2VwdHxjb25zdHxjb25zdF9jYXN0fGNvbnN0ZXZhbHxjb25zdGV4cHJ8Y29uc3Rpbml0fGNvbnRpbnVlfGRlY2x0eXBlfGRlZmF1bHR8ZGVsZXRlfGRvfGRvdWJsZXxkeW5hbWljX2Nhc3R8ZWxzZXxlbnVtfGV4cGxpY2l0fGV4cG9ydHxleHRlcm58ZmluYWx8ZmxvYXR8Zm9yfGZyaWVuZHxnb3RvfGlmfGltcG9ydHxpbmxpbmV8aW50fGludDE2X3R8aW50MzJfdHxpbnQ2NF90fGludDhfdHxsb25nfG1vZHVsZXxtdXRhYmxlfG5hbWVzcGFjZXxuZXd8bm9leGNlcHR8bnVsbHB0cnxvcGVyYXRvcnxvdmVycmlkZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmVnaXN0ZXJ8cmVpbnRlcnByZXRfY2FzdHxyZXF1aXJlc3xyZXR1cm58c2hvcnR8c2lnbmVkfHNpemVvZnxzdGF0aWN8c3RhdGljX2Fzc2VydHxzdGF0aWNfY2FzdHxzdHJ1Y3R8c3dpdGNofHRlbXBsYXRlfHRoaXN8dGhyZWFkX2xvY2FsfHRocm93fHRyeXx0eXBlZGVmfHR5cGVpZHx0eXBlbmFtZXx1aW50MTZfdHx1aW50MzJfdHx1aW50NjRfdHx1aW50OF90fHVuaW9ufHVuc2lnbmVkfHVzaW5nfHZpcnR1YWx8dm9pZHx2b2xhdGlsZXx3Y2hhcl90fHdoaWxlKVxcYi87XG4gIHZhciBtb2ROYW1lID0gL1xcYig/ITxrZXl3b3JkPilcXHcrKD86XFxzKlxcLlxccypcXHcrKSpcXGIvLnNvdXJjZS5yZXBsYWNlKC88a2V5d29yZD4vZywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBrZXl3b3JkLnNvdXJjZTtcbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5jcHAgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjJywge1xuICAgICdjbGFzcy1uYW1lJzogW3tcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKFxcYig/OmNsYXNzfGNvbmNlcHR8ZW51bXxzdHJ1Y3R8dHlwZW5hbWUpXFxzKykoPyE8a2V5d29yZD4pXFx3Ky8uc291cmNlLnJlcGxhY2UoLzxrZXl3b3JkPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBrZXl3b3JkLnNvdXJjZTtcbiAgICAgIH0pKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgIC8vIFRoaXMgaXMgaW50ZW5kZWQgdG8gY2FwdHVyZSB0aGUgY2xhc3MgbmFtZSBvZiBtZXRob2QgaW1wbGVtZW50YXRpb25zIGxpa2U6XG4gICAgLy8gICB2b2lkIGZvbzo6YmFyKCkgY29uc3Qge31cbiAgICAvLyBIb3dldmVyISBUaGUgYGZvb2AgaW4gdGhlIGFib3ZlIGV4YW1wbGUgY291bGQgYWxzbyBiZSBhIG5hbWVzcGFjZSwgc28gd2Ugb25seSBjYXB0dXJlIHRoZSBjbGFzcyBuYW1lIGlmXG4gICAgLy8gaXQgc3RhcnRzIHdpdGggYW4gdXBwZXJjYXNlIGxldHRlci4gVGhpcyBhcHByb3hpbWF0aW9uIHNob3VsZCBnaXZlIGRlY2VudCByZXN1bHRzLlxuICAgIC9cXGJbQS1aXVxcdyooPz1cXHMqOjpcXHMqXFx3K1xccypcXCgpLyxcbiAgICAvLyBUaGlzIHdpbGwgY2FwdHVyZSB0aGUgY2xhc3MgbmFtZSBiZWZvcmUgZGVzdHJ1Y3RvcnMgbGlrZTpcbiAgICAvLyAgIEZvbzo6fkZvbygpIHt9XG4gICAgL1xcYltBLVpfXVxcdyooPz1cXHMqOjpcXHMqflxcdytcXHMqXFwoKS9pLFxuICAgIC8vIFRoaXMgYWxzbyBpbnRlbmRzIHRvIGNhcHR1cmUgdGhlIGNsYXNzIG5hbWUgb2YgbWV0aG9kIGltcGxlbWVudGF0aW9ucyBidXQgaGVyZSB0aGUgY2xhc3MgaGFzIHRlbXBsYXRlXG4gICAgLy8gcGFyYW1ldGVycywgc28gaXQgY2FuJ3QgYmUgYSBuYW1lc3BhY2UgKHVudGlsIEMrKyBhZGRzIGdlbmVyaWMgbmFtZXNwYWNlcykuXG4gICAgL1xcYlxcdysoPz1cXHMqPCg/OltePD5dfDwoPzpbXjw+XXw8W148Pl0qPikqPikqPlxccyo6OlxccypcXHcrXFxzKlxcKCkvXSxcbiAgICAna2V5d29yZCc6IGtleXdvcmQsXG4gICAgJ251bWJlcic6IHtcbiAgICAgIHBhdHRlcm46IC8oPzpcXGIwYlswMSddK3xcXGIweCg/OltcXGRhLWYnXSsoPzpcXC5bXFxkYS1mJ10qKT98XFwuW1xcZGEtZiddKykoPzpwWystXT9bXFxkJ10rKT98KD86XFxiW1xcZCddKyg/OlxcLltcXGQnXSopP3xcXEJcXC5bXFxkJ10rKSg/OmVbKy1dP1tcXGQnXSspPylbZnVsXXswLDR9L2ksXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdvcGVyYXRvcic6IC8+Pj0/fDw8PT98LT58LS18XFwrXFwrfCYmfFxcfFxcfHxbPzp+XXw8PT58Wy0rKi8lJnxeIT08Pl09P3xcXGIoPzphbmR8YW5kX2VxfGJpdGFuZHxiaXRvcnxub3R8bm90X2VxfG9yfG9yX2VxfHhvcnx4b3JfZXEpXFxiLyxcbiAgICAnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi9cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NwcCcsICdzdHJpbmcnLCB7XG4gICAgJ21vZHVsZSc6IHtcbiAgICAgIC8vIGh0dHBzOi8vZW4uY3BwcmVmZXJlbmNlLmNvbS93L2NwcC9sYW5ndWFnZS9tb2R1bGVzXG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyhcXGIoPzppbXBvcnR8bW9kdWxlKVxccyspLy5zb3VyY2UgKyAnKD86JyArXG4gICAgICAvLyBoZWFkZXItbmFtZVxuICAgICAgL1wiKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W15cIlxcXFxcXHJcXG5dKSpcInw8W148Plxcclxcbl0qPi8uc291cmNlICsgJ3wnICtcbiAgICAgIC8vIG1vZHVsZSBuYW1lIG9yIHBhcnRpdGlvbiBvciBib3RoXG4gICAgICAvPG1vZC1uYW1lPig/Olxccyo6XFxzKjxtb2QtbmFtZT4pP3w6XFxzKjxtb2QtbmFtZT4vLnNvdXJjZS5yZXBsYWNlKC88bW9kLW5hbWU+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1vZE5hbWU7XG4gICAgICB9KSArICcpJyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdzdHJpbmcnOiAvXls8XCJdW1xcc1xcU10rLyxcbiAgICAgICAgJ29wZXJhdG9yJzogLzovLFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFwuL1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3Jhdy1zdHJpbmcnOiB7XG4gICAgICBwYXR0ZXJuOiAvUlwiKFteKClcXFxcIF17MCwxNn0pXFwoW1xcc1xcU10qP1xcKVxcMVwiLyxcbiAgICAgIGFsaWFzOiAnc3RyaW5nJyxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NwcCcsICdrZXl3b3JkJywge1xuICAgICdnZW5lcmljLWZ1bmN0aW9uJzoge1xuICAgICAgcGF0dGVybjogL1xcYig/IW9wZXJhdG9yXFxiKVthLXpfXVxcdypcXHMqPCg/OltePD5dfDxbXjw+XSo+KSo+KD89XFxzKlxcKCkvaSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZnVuY3Rpb24nOiAvXlxcdysvLFxuICAgICAgICAnZ2VuZXJpYyc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvPFtcXHNcXFNdKy8sXG4gICAgICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lJyxcbiAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5jcHBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NwcCcsICdvcGVyYXRvcicsIHtcbiAgICAnZG91YmxlLWNvbG9uJzoge1xuICAgICAgcGF0dGVybjogLzo6LyxcbiAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3BwJywgJ2NsYXNzLW5hbWUnLCB7XG4gICAgLy8gdGhlIGJhc2UgY2xhdXNlIGlzIGFuIG9wdGlvbmFsIGxpc3Qgb2YgcGFyZW50IGNsYXNzZXNcbiAgICAvLyBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jcHAvbGFuZ3VhZ2UvY2xhc3NcbiAgICAnYmFzZS1jbGF1c2UnOiB7XG4gICAgICBwYXR0ZXJuOiAvKFxcYig/OmNsYXNzfHN0cnVjdClcXHMrXFx3K1xccyo6XFxzKilbXjt7fVwiJ1xcc10rKD86XFxzK1teO3t9XCInXFxzXSspKig/PVxccypbO3tdKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjcHAnLCB7fSlcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdpbnNpZGUnLCAnZG91YmxlLWNvbG9uJywge1xuICAgIC8vIEFsbCB1bnRva2VuaXplZCB3b3JkcyB0aGF0IGFyZSBub3QgbmFtZXNwYWNlcyBzaG91bGQgYmUgY2xhc3MgbmFtZXNcbiAgICAnY2xhc3MtbmFtZSc6IC9cXGJbYS16X11cXHcqXFxiKD8hXFxzKjo6KS9pXG4gIH0sIFByaXNtLmxhbmd1YWdlcy5jcHBbJ2Jhc2UtY2xhdXNlJ10pO1xufSkoUHJpc20pO1xuUHJpc20ubGFuZ3VhZ2VzLmFyZHVpbm8gPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjcHAnLCB7XG4gICdrZXl3b3JkJzogL1xcYig/OlN0cmluZ3xhcnJheXxib29sfGJvb2xlYW58YnJlYWt8Ynl0ZXxjYXNlfGNhdGNofGNvbnRpbnVlfGRlZmF1bHR8ZG98ZG91YmxlfGVsc2V8ZmluYWxseXxmb3J8ZnVuY3Rpb258Z290b3xpZnxpbnxpbnN0YW5jZW9mfGludHxpbnRlZ2VyfGxvbmd8bG9vcHxuZXd8bnVsbHxyZXR1cm58c2V0dXB8c3RyaW5nfHN3aXRjaHx0aHJvd3x0cnl8dm9pZHx3aGlsZXx3b3JkKVxcYi8sXG4gICdjb25zdGFudCc6IC9cXGIoPzpBTkFMT0dfTUVTU0FHRXxERUZBVUxUfERJR0lUQUxfTUVTU0FHRXxFWFRFUk5BTHxGSVJNQVRBX1NUUklOR3xISUdIfElOUFVUfElOUFVUX1BVTExVUHxJTlRFUk5BTHxJTlRFUk5BTDFWMXxJTlRFUk5BTDJWNTZ8TEVEX0JVSUxUSU58TE9XfE9VVFBVVHxSRVBPUlRfQU5BTE9HfFJFUE9SVF9ESUdJVEFMfFNFVF9QSU5fTU9ERXxTWVNFWF9TVEFSVHxTWVNURU1fUkVTRVQpXFxiLyxcbiAgJ2J1aWx0aW4nOiAvXFxiKD86QXVkaW98QlNTSUR8QnJpZGdlfENsaWVudHxDb25zb2xlfEVFUFJPTXxFc3Bsb3JhfEVzcGxvcmFURlR8RXRoZXJuZXR8RXRoZXJuZXRDbGllbnR8RXRoZXJuZXRTZXJ2ZXJ8RXRoZXJuZXRVRFB8RmlsZXxGaWxlSU98RmlsZVN5c3RlbXxGaXJtYXRhfEdQUlN8R1NNfEdTTUJhbmR8R1NNQ2xpZW50fEdTTU1vZGVtfEdTTVBJTnxHU01TY2FubmVyfEdTTVNlcnZlcnxHU01Wb2ljZUNhbGx8R1NNX1NNU3xIdHRwQ2xpZW50fElQQWRkcmVzc3xJUnJlYWR8S2V5Ym9hcmR8S2V5Ym9hcmRDb250cm9sbGVyfExpcXVpZENyeXN0YWx8TGlxdWlkQ3J5c3RhbF9JMkN8TWFpbGJveHxNb3VzZXxNb3VzZUNvbnRyb2xsZXJ8UEltYWdlfFByb2Nlc3N8UlNTSXxSb2JvdENvbnRyb2x8Um9ib3RNb3RvcnxTRHxTUEl8U1NJRHxTY2hlZHVsZXJ8U2VyaWFsfFNlcnZlcnxTZXJ2b3xTb2Z0d2FyZVNlcmlhbHxTdGVwcGVyfFN0cmVhbXxURlR8VGFza3xVU0JIb3N0fFdpRml8V2lGaUNsaWVudHxXaUZpU2VydmVyfFdpRmlVRFB8V2lyZXxZdW5DbGllbnR8WXVuU2VydmVyfGFic3xhZGRQYXJhbWV0ZXJ8YW5hbG9nUmVhZHxhbmFsb2dSZWFkUmVzb2x1dGlvbnxhbmFsb2dSZWZlcmVuY2V8YW5hbG9nV3JpdGV8YW5hbG9nV3JpdGVSZXNvbHV0aW9ufGFuc3dlckNhbGx8YXR0YWNofGF0dGFjaEdQUlN8YXR0YWNoSW50ZXJydXB0fGF0dGFjaGVkfGF1dG9zY3JvbGx8YXZhaWxhYmxlfGJhY2tncm91bmR8YmVlcHxiZWdpbnxiZWdpblBhY2tldHxiZWdpblNEfGJlZ2luU01TfGJlZ2luU3BlYWtlcnxiZWdpblRGVHxiZWdpblRyYW5zbWlzc2lvbnxiZWdpbldyaXRlfGJpdHxiaXRDbGVhcnxiaXRSZWFkfGJpdFNldHxiaXRXcml0ZXxibGlua3xibGlua1ZlcnNpb258YnVmZmVyfGNoYW5nZVBJTnxjaGVja1BJTnxjaGVja1BVS3xjaGVja1JlZ3xjaXJjbGV8Y2l0eU5hbWVSZWFkfGNpdHlOYW1lV3JpdGV8Y2xlYXJ8Y2xlYXJTY3JlZW58Y2xpY2t8Y2xvc2V8Y29tcGFzc1JlYWR8Y29uZmlnfGNvbm5lY3R8Y29ubmVjdGVkfGNvbnN0cmFpbnxjb3N8Y291bnRyeU5hbWVSZWFkfGNvdW50cnlOYW1lV3JpdGV8Y3JlYXRlQ2hhcnxjdXJzb3J8ZGVidWdQcmludHxkZWxheXxkZWxheU1pY3Jvc2Vjb25kc3xkZXRhY2h8ZGV0YWNoSW50ZXJydXB0fGRpZ2l0YWxSZWFkfGRpZ2l0YWxXcml0ZXxkaXNjb25uZWN0fGRpc3BsYXl8ZGlzcGxheUxvZ29zfGRyYXdCTVB8ZHJhd0NvbXBhc3N8ZW5jcnlwdGlvblR5cGV8ZW5kfGVuZFBhY2tldHxlbmRTTVN8ZW5kVHJhbnNtaXNzaW9ufGVuZFdyaXRlfGV4aXN0c3xleGl0VmFsdWV8ZmlsbHxmaW5kfGZpbmRVbnRpbHxmbHVzaHxnYXRld2F5SVB8Z2V0fGdldEFzeW5jaHJvbm91c2x5fGdldEJhbmR8Z2V0QnV0dG9ufGdldEN1cnJlbnRDYXJyaWVyfGdldElNRUl8Z2V0S2V5fGdldE1vZGlmaWVyc3xnZXRPZW1LZXl8Z2V0UElOVXNlZHxnZXRSZXN1bHR8Z2V0U2lnbmFsU3RyZW5ndGh8Z2V0U29ja2V0fGdldFZvaWNlQ2FsbFN0YXR1c3xnZXRYQ2hhbmdlfGdldFlDaGFuZ2V8aGFuZ0NhbGx8aGVpZ2h0fGhpZ2hCeXRlfGhvbWV8aW1hZ2V8aW50ZXJydXB0c3xpc0FjdGlvbkRvbmV8aXNEaXJlY3Rvcnl8aXNMaXN0ZW5pbmd8aXNQSU58aXNQcmVzc2VkfGlzVmFsaWR8a2V5UHJlc3NlZHxrZXlSZWxlYXNlZHxrZXlib2FyZFJlYWR8a25vYlJlYWR8bGVmdFRvUmlnaHR8bGluZXxsaW5lRm9sbG93Q29uZmlnfGxpc3RlbnxsaXN0ZW5PbkxvY2FsaG9zdHxsb2FkSW1hZ2V8bG9jYWxJUHxsb3dCeXRlfG1hY0FkZHJlc3N8bWFpbnRhaW58bWFwfG1heHxtZXNzYWdlQXZhaWxhYmxlfG1pY3Jvc3xtaWxsaXN8bWlufG1rZGlyfG1vdG9yc1N0b3B8bW90b3JzV3JpdGV8bW91c2VEcmFnZ2VkfG1vdXNlTW92ZWR8bW91c2VQcmVzc2VkfG1vdXNlUmVsZWFzZWR8bW92ZXxub0F1dG9zY3JvbGx8bm9CbGlua3xub0J1ZmZlcnxub0N1cnNvcnxub0Rpc3BsYXl8bm9GaWxsfG5vSW50ZXJydXB0c3xub0xpc3Rlbk9uTG9jYWxob3N0fG5vU3Ryb2tlfG5vVG9uZXxvblJlY2VpdmV8b25SZXF1ZXN0fG9wZW58b3Blbk5leHRGaWxlfG92ZXJmbG93fHBhcnNlQ29tbWFuZHxwYXJzZUZsb2F0fHBhcnNlSW50fHBhcnNlUGFja2V0fHBhdXNlTW9kZXxwZWVrfHBpbk1vZGV8cGxheUZpbGV8cGxheU1lbG9keXxwb2ludHxwb2ludFRvfHBvc2l0aW9ufHBvd3xwcmVwYXJlfHByZXNzfHByaW50fHByaW50RmlybXdhcmVWZXJzaW9ufHByaW50VmVyc2lvbnxwcmludGxufHByb2Nlc3N8cHJvY2Vzc0lucHV0fHB1bHNlSW58cHV0fHJhbmRvbXxyYW5kb21TZWVkfHJlYWR8cmVhZEFjY2VsZXJvbWV0ZXJ8cmVhZEJsdWV8cmVhZEJ1dHRvbnxyZWFkQnl0ZXN8cmVhZEJ5dGVzVW50aWx8cmVhZEdyZWVufHJlYWRKb3lzdGlja0J1dHRvbnxyZWFkSm95c3RpY2tTd2l0Y2h8cmVhZEpveXN0aWNrWHxyZWFkSm95c3RpY2tZfHJlYWRMaWdodFNlbnNvcnxyZWFkTWVzc2FnZXxyZWFkTWljcm9waG9uZXxyZWFkTmV0d29ya3N8cmVhZFJlZHxyZWFkU2xpZGVyfHJlYWRTdHJpbmd8cmVhZFN0cmluZ1VudGlsfHJlYWRUZW1wZXJhdHVyZXxyZWFkeXxyZWN0fHJlbGVhc2V8cmVsZWFzZUFsbHxyZW1vdGVJUHxyZW1vdGVOdW1iZXJ8cmVtb3RlUG9ydHxyZW1vdmV8cmVxdWVzdEZyb218cmV0cmlldmVDYWxsaW5nTnVtYmVyfHJld2luZERpcmVjdG9yeXxyaWdodFRvTGVmdHxybWRpcnxyb2JvdE5hbWVSZWFkfHJvYm90TmFtZVdyaXRlfHJ1bnxydW5Bc3luY2hyb25vdXNseXxydW5TaGVsbENvbW1hbmR8cnVuU2hlbGxDb21tYW5kQXN5bmNocm9ub3VzbHl8cnVubmluZ3xzY2FuTmV0d29ya3N8c2Nyb2xsRGlzcGxheUxlZnR8c2Nyb2xsRGlzcGxheVJpZ2h0fHNlZWt8c2VuZEFuYWxvZ3xzZW5kRGlnaXRhbFBvcnRQYWlyfHNlbmREaWdpdGFsUG9ydHN8c2VuZFN0cmluZ3xzZW5kU3lzZXh8c2VyaWFsRXZlbnR8c2V0QmFuZHxzZXRCaXRPcmRlcnxzZXRDbG9ja0RpdmlkZXJ8c2V0Q3Vyc29yfHNldEROU3xzZXREYXRhTW9kZXxzZXRGaXJtd2FyZVZlcnNpb258c2V0TW9kZXxzZXRQSU5Vc2VkfHNldFNwZWVkfHNldFRleHRTaXplfHNldFRpbWVvdXR8c2hpZnRJbnxzaGlmdE91dHxzaHV0ZG93bnxzaW58c2l6ZXxzcXJ0fHN0YXJ0TG9vcHxzdGVwfHN0b3B8c3Ryb2tlfHN1Ym5ldE1hc2t8c3dpdGNoUElOfHRhbnx0ZW1wb1dyaXRlfHRleHR8dG9uZXx0cmFuc2Zlcnx0dW5lV3JpdGV8dHVybnx1cGRhdGVJUnx1c2VyTmFtZVJlYWR8dXNlck5hbWVXcml0ZXx2b2ljZUNhbGx8d2FpdENvbnRpbnVlfHdpZHRofHdyaXRlfHdyaXRlQmx1ZXx3cml0ZUdyZWVufHdyaXRlSlNPTnx3cml0ZU1lc3NhZ2V8d3JpdGVNaWNyb3NlY29uZHN8d3JpdGVSR0J8d3JpdGVSZWR8eWllbGQpXFxiL1xufSk7XG5QcmlzbS5sYW5ndWFnZXMuaW5vID0gUHJpc20ubGFuZ3VhZ2VzLmFyZHVpbm87XG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIC8vICQgc2V0IHwgZ3JlcCAnXltBLVpdW15bOnNwYWNlOl1dKj0nIHwgY3V0IC1kPSAtZjEgfCB0ciAnXFxuJyAnfCdcbiAgLy8gKyBMQ19BTEwsIFJBTkRPTSwgUkVQTFksIFNFQ09ORFMuXG4gIC8vICsgbWFrZSBzdXJlIFBTMS4uNCBhcmUgaGVyZSBhcyB0aGV5IGFyZSBub3QgYWx3YXlzIHNldCxcbiAgLy8gLSBzb21lIHVzZWxlc3MgdGhpbmdzLlxuICB2YXIgZW52VmFycyA9ICdcXFxcYig/OkJBU0h8QkFTSE9QVFN8QkFTSF9BTElBU0VTfEJBU0hfQVJHQ3xCQVNIX0FSR1Z8QkFTSF9DTURTfEJBU0hfQ09NUExFVElPTl9DT01QQVRfRElSfEJBU0hfTElORU5PfEJBU0hfUkVNQVRDSHxCQVNIX1NPVVJDRXxCQVNIX1ZFUlNJTkZPfEJBU0hfVkVSU0lPTnxDT0xPUlRFUk18Q09MVU1OU3xDT01QX1dPUkRCUkVBS1N8REJVU19TRVNTSU9OX0JVU19BRERSRVNTfERFRkFVTFRTX1BBVEh8REVTS1RPUF9TRVNTSU9OfERJUlNUQUNLfERJU1BMQVl8RVVJRHxHRE1TRVNTSU9OfEdETV9MQU5HfEdOT01FX0tFWVJJTkdfQ09OVFJPTHxHTk9NRV9LRVlSSU5HX1BJRHxHUEdfQUdFTlRfSU5GT3xHUk9VUFN8SElTVENPTlRST0x8SElTVEZJTEV8SElTVEZJTEVTSVpFfEhJU1RTSVpFfEhPTUV8SE9TVE5BTUV8SE9TVFRZUEV8SUZTfElOU1RBTkNFfEpPQnxMQU5HfExBTkdVQUdFfExDX0FERFJFU1N8TENfQUxMfExDX0lERU5USUZJQ0FUSU9OfExDX01FQVNVUkVNRU5UfExDX01PTkVUQVJZfExDX05BTUV8TENfTlVNRVJJQ3xMQ19QQVBFUnxMQ19URUxFUEhPTkV8TENfVElNRXxMRVNTQ0xPU0V8TEVTU09QRU58TElORVN8TE9HTkFNRXxMU19DT0xPUlN8TUFDSFRZUEV8TUFJTENIRUNLfE1BTkRBVE9SWV9QQVRIfE5PX0FUX0JSSURHRXxPTERQV0R8T1BURVJSfE9QVElORHxPUkJJVF9TT0NLRVRESVJ8T1NUWVBFfFBBUEVSU0laRXxQQVRIfFBJUEVTVEFUVVN8UFBJRHxQUzF8UFMyfFBTM3xQUzR8UFdEfFJBTkRPTXxSRVBMWXxTRUNPTkRTfFNFTElOVVhfSU5JVHxTRVNTSU9OfFNFU1NJT05UWVBFfFNFU1NJT05fTUFOQUdFUnxTSEVMTHxTSEVMTE9QVFN8U0hMVkx8U1NIX0FVVEhfU09DS3xURVJNfFVJRHxVUFNUQVJUX0VWRU5UU3xVUFNUQVJUX0lOU1RBTkNFfFVQU1RBUlRfSk9CfFVQU1RBUlRfU0VTU0lPTnxVU0VSfFdJTkRPV0lEfFhBVVRIT1JJVFl8WERHX0NPTkZJR19ESVJTfFhER19DVVJSRU5UX0RFU0tUT1B8WERHX0RBVEFfRElSU3xYREdfR1JFRVRFUl9EQVRBX0RJUnxYREdfTUVOVV9QUkVGSVh8WERHX1JVTlRJTUVfRElSfFhER19TRUFUfFhER19TRUFUX1BBVEh8WERHX1NFU1NJT05fREVTS1RPUHxYREdfU0VTU0lPTl9JRHxYREdfU0VTU0lPTl9QQVRIfFhER19TRVNTSU9OX1RZUEV8WERHX1ZUTlJ8WE1PRElGSUVSUylcXFxcYic7XG4gIHZhciBjb21tYW5kQWZ0ZXJIZXJlZG9jID0ge1xuICAgIHBhdHRlcm46IC8oXihbXCInXT8pXFx3K1xcMilbIFxcdF0rXFxTLiovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgYWxpYXM6ICdwdW5jdHVhdGlvbicsXG4gICAgLy8gdGhpcyBsb29rcyByZWFzb25hYmx5IHdlbGwgaW4gYWxsIHRoZW1lc1xuICAgIGluc2lkZTogbnVsbCAvLyBzZWUgYmVsb3dcbiAgfTtcbiAgdmFyIGluc2lkZVN0cmluZyA9IHtcbiAgICAnYmFzaCc6IGNvbW1hbmRBZnRlckhlcmVkb2MsXG4gICAgJ2Vudmlyb25tZW50Jzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKCdcXFxcJCcgKyBlbnZWYXJzKSxcbiAgICAgIGFsaWFzOiAnY29uc3RhbnQnXG4gICAgfSxcbiAgICAndmFyaWFibGUnOiBbXG4gICAgLy8gWzBdOiBBcml0aG1ldGljIEVudmlyb25tZW50XG4gICAge1xuICAgICAgcGF0dGVybjogL1xcJD9cXChcXChbXFxzXFxTXSs/XFwpXFwpLyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhICQgc2lnbiBhdCB0aGUgYmVnaW5uaW5nIGhpZ2hsaWdodCAkKCggYW5kICkpIGFzIHZhcmlhYmxlXG4gICAgICAgICd2YXJpYWJsZSc6IFt7XG4gICAgICAgICAgcGF0dGVybjogLyheXFwkXFwoXFwoW1xcc1xcU10rKVxcKVxcKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9LCAvXlxcJFxcKFxcKC9dLFxuICAgICAgICAnbnVtYmVyJzogL1xcYjB4W1xcZEEtRmEtZl0rXFxifCg/OlxcYlxcZCsoPzpcXC5cXGQqKT98XFxCXFwuXFxkKykoPzpbRWVdLT9cXGQrKT8vLFxuICAgICAgICAvLyBPcGVyYXRvcnMgYWNjb3JkaW5nIHRvIGh0dHBzOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvYmFzaHJlZi5odG1sI1NoZWxsLUFyaXRobWV0aWNcbiAgICAgICAgJ29wZXJhdG9yJzogLy0tfFxcK1xcK3xcXCpcXCo9P3w8PD0/fD4+PT98JiZ8XFx8XFx8fFs9IStcXC0qLyU8Pl4mfF09P3xbP346XS8sXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vICQgc2lnbiBhdCB0aGUgYmVnaW5uaW5nIGhpZ2hsaWdodCAoKCBhbmQgKSkgYXMgcHVuY3R1YXRpb25cbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcKFxcKD98XFwpXFwpP3wsfDsvXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBbMV06IENvbW1hbmQgU3Vic3RpdHV0aW9uXG4gICAge1xuICAgICAgcGF0dGVybjogL1xcJFxcKCg/OlxcKFteKV0rXFwpfFteKCldKStcXCl8YFteYF0rYC8sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3ZhcmlhYmxlJzogL15cXCRcXCh8XmB8XFwpJHxgJC9cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFsyXTogQnJhY2UgZXhwYW5zaW9uXG4gICAge1xuICAgICAgcGF0dGVybjogL1xcJFxce1tefV0rXFx9LyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnb3BlcmF0b3InOiAvOlstPT8rXT98WyFcXC9dfCMjP3wlJT98XFxeXFxeP3wsLD8vLFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvW1xcW1xcXV0vLFxuICAgICAgICAnZW52aXJvbm1lbnQnOiB7XG4gICAgICAgICAgcGF0dGVybjogUmVnRXhwKCcoXFxcXHspJyArIGVudlZhcnMpLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgYWxpYXM6ICdjb25zdGFudCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIC9cXCQoPzpcXHcrfFsjPyohQCRdKS9dLFxuICAgIC8vIEVzY2FwZSBzZXF1ZW5jZXMgZnJvbSBlY2hvIGFuZCBwcmludGYncyBtYW51YWxzLCBhbmQgZXNjYXBlZCBxdW90ZXMuXG4gICAgJ2VudGl0eSc6IC9cXFxcKD86W2FiY2VFZm5ydHZcXFxcXCJdfE8/WzAtN117MSwzfXxVWzAtOWEtZkEtRl17OH18dVswLTlhLWZBLUZdezR9fHhbMC05YS1mQS1GXXsxLDJ9KS9cbiAgfTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmJhc2ggPSB7XG4gICAgJ3NoZWJhbmcnOiB7XG4gICAgICBwYXR0ZXJuOiAvXiMhXFxzKlxcLy4qLyxcbiAgICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICAgIH0sXG4gICAgJ2NvbW1lbnQnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W15cIntcXFxcJF0pIy4qLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdmdW5jdGlvbi1uYW1lJzogW1xuICAgIC8vIGEpIGZ1bmN0aW9uIGZvbyB7XG4gICAgLy8gYikgZm9vKCkge1xuICAgIC8vIGMpIGZ1bmN0aW9uIGZvbygpIHtcbiAgICAvLyBidXQgbm90IOKAnGZvbyB74oCdXG4gICAge1xuICAgICAgLy8gYSkgYW5kIGMpXG4gICAgICBwYXR0ZXJuOiAvKFxcYmZ1bmN0aW9uXFxzKylbXFx3LV0rKD89KD86XFxzKlxcKD86XFxzKlxcKSk/XFxzKlxceykvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gICAgfSwge1xuICAgICAgLy8gYilcbiAgICAgIHBhdHRlcm46IC9cXGJbXFx3LV0rKD89XFxzKlxcKFxccypcXClcXHMqXFx7KS8sXG4gICAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICAgIH1dLFxuICAgIC8vIEhpZ2hsaWdodCB2YXJpYWJsZSBuYW1lcyBhcyB2YXJpYWJsZXMgaW4gZm9yIGFuZCBzZWxlY3QgYmVnaW5uaW5ncy5cbiAgICAnZm9yLW9yLXNlbGVjdCc6IHtcbiAgICAgIHBhdHRlcm46IC8oXFxiKD86Zm9yfHNlbGVjdClcXHMrKVxcdysoPz1cXHMraW5cXHMpLyxcbiAgICAgIGFsaWFzOiAndmFyaWFibGUnLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgLy8gSGlnaGxpZ2h0IHZhcmlhYmxlIG5hbWVzIGFzIHZhcmlhYmxlcyBpbiB0aGUgbGVmdC1oYW5kIHBhcnRcbiAgICAvLyBvZiBhc3NpZ25tZW50cyAo4oCcPeKAnSBhbmQg4oCcKz3igJ0pLlxuICAgICdhc3NpZ24tbGVmdCc6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXFxzO3wmXXxbPD5dXFwoKVxcdysoPzpcXC5cXHcrKSooPz1cXCs/PSkvLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdlbnZpcm9ubWVudCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoJyhefFtcXFxcczt8Jl18Wzw+XVxcXFwoKScgKyBlbnZWYXJzKSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGFsaWFzOiAnY29uc3RhbnQnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhbGlhczogJ3ZhcmlhYmxlJyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgIC8vIEhpZ2hsaWdodCBwYXJhbWV0ZXIgbmFtZXMgYXMgdmFyaWFibGVzXG4gICAgJ3BhcmFtZXRlcic6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxcXHMpLXsxLDJ9KD86XFx3KzpbKy1dPyk/XFx3Kyg/OlxcLlxcdyspKig/PVs9XFxzXXwkKS8sXG4gICAgICBhbGlhczogJ3ZhcmlhYmxlJyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdzdHJpbmcnOiBbXG4gICAgLy8gU3VwcG9ydCBmb3IgSGVyZS1kb2N1bWVudHMgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVyZV9kb2N1bWVudFxuICAgIHtcbiAgICAgIHBhdHRlcm46IC8oKD86XnxbXjxdKTw8LT9cXHMqKShcXHcrKVxcc1tcXHNcXFNdKj8oPzpcXHI/XFxufFxccilcXDIvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZTogaW5zaWRlU3RyaW5nXG4gICAgfSxcbiAgICAvLyBIZXJlLWRvY3VtZW50IHdpdGggcXVvdGVzIGFyb3VuZCB0aGUgdGFnXG4gICAgLy8g4oaSIE5vIGV4cGFuc2lvbiAoc28gbm8g4oCcaW5zaWRl4oCdKS5cbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKCg/Ol58W148XSk8PC0/XFxzKikoW1wiJ10pKFxcdyspXFwyXFxzW1xcc1xcU10qPyg/Olxccj9cXG58XFxyKVxcMy8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdiYXNoJzogY29tbWFuZEFmdGVySGVyZWRvY1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8g4oCcTm9ybWFs4oCdIHN0cmluZ1xuICAgIHtcbiAgICAgIC8vIGh0dHBzOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvaHRtbF9ub2RlL0RvdWJsZS1RdW90ZXMuaHRtbFxuICAgICAgcGF0dGVybjogLyhefFteXFxcXF0oPzpcXFxcXFxcXCkqKVwiKD86XFxcXFtcXHNcXFNdfFxcJFxcKFteKV0rXFwpfFxcJCg/IVxcKCl8YFteYF0rYHxbXlwiXFxcXGAkXSkqXCIvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZTogaW5zaWRlU3RyaW5nXG4gICAgfSwge1xuICAgICAgLy8gaHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9odG1sX25vZGUvU2luZ2xlLVF1b3Rlcy5odG1sXG4gICAgICBwYXR0ZXJuOiAvKF58W14kXFxcXF0pJ1teJ10qJy8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSwge1xuICAgICAgLy8gaHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9odG1sX25vZGUvQU5TSV8wMDJkQy1RdW90aW5nLmh0bWxcbiAgICAgIHBhdHRlcm46IC9cXCQnKD86W14nXFxcXF18XFxcXFtcXHNcXFNdKSonLyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZW50aXR5JzogaW5zaWRlU3RyaW5nLmVudGl0eVxuICAgICAgfVxuICAgIH1dLFxuICAgICdlbnZpcm9ubWVudCc6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXFxcXCQ/JyArIGVudlZhcnMpLFxuICAgICAgYWxpYXM6ICdjb25zdGFudCdcbiAgICB9LFxuICAgICd2YXJpYWJsZSc6IGluc2lkZVN0cmluZy52YXJpYWJsZSxcbiAgICAnZnVuY3Rpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzphZGR8YXByb3Bvc3xhcHR8YXB0LWNhY2hlfGFwdC1nZXR8YXB0aXR1ZGV8YXNwZWxsfGF1dG9teXNxbGJhY2t1cHxhd2t8YmFzZW5hbWV8YmFzaHxiY3xiY29uc29sZXxiZ3xiemlwMnxjYWx8Y2FyZ298Y2F0fGNmZGlza3xjaGdycHxjaGtjb25maWd8Y2htb2R8Y2hvd258Y2hyb290fGNrc3VtfGNsZWFyfGNtcHxjb2x1bW58Y29tbXxjb21wb3NlcnxjcHxjcm9ufGNyb250YWJ8Y3NwbGl0fGN1cmx8Y3V0fGRhdGV8ZGN8ZGR8ZGRyZXNjdWV8ZGVib290c3RyYXB8ZGZ8ZGlmZnxkaWZmM3xkaWd8ZGlyfGRpcmNvbG9yc3xkaXJuYW1lfGRpcnN8ZG1lc2d8ZG9ja2VyfGRvY2tlci1jb21wb3NlfGR1fGVncmVwfGVqZWN0fGVudnxldGh0b29sfGV4cGFuZHxleHBlY3R8ZXhwcnxmZGZvcm1hdHxmZGlza3xmZ3xmZ3JlcHxmaWxlfGZpbmR8Zm10fGZvbGR8Zm9ybWF0fGZyZWV8ZnNja3xmdHB8ZnVzZXJ8Z2F3a3xnaXR8Z3BhcnRlZHxncmVwfGdyb3VwYWRkfGdyb3VwZGVsfGdyb3VwbW9kfGdyb3Vwc3xncnViLW1rY29uZmlnfGd6aXB8aGFsdHxoZWFkfGhnfGhpc3Rvcnl8aG9zdHxob3N0bmFtZXxodG9wfGljb252fGlkfGlmY29uZmlnfGlmZG93bnxpZnVwfGltcG9ydHxpbnN0YWxsfGlwfGphdmF8am9ic3xqb2lufGtpbGx8a2lsbGFsbHxsZXNzfGxpbmt8bG58bG9jYXRlfGxvZ25hbWV8bG9ncm90YXRlfGxvb2t8bHBjfGxwcnxscHJpbnR8bHByaW50ZHxscHJpbnRxfGxwcm18bHN8bHNvZnxseW54fG1ha2V8bWFufG1jfG1kYWRtfG1rY29uZmlnfG1rZGlyfG1rZTJmc3xta2ZpZm98bWtmc3xta2lzb2ZzfG1rbm9kfG1rc3dhcHxtbXZ8bW9yZXxtb3N0fG1vdW50fG10b29sc3xtdHJ8bXV0dHxtdnxuYW5vfG5jfG5ldHN0YXR8bmljZXxubHxub2RlfG5vaHVwfG5vdGlmeS1zZW5kfG5wbXxuc2xvb2t1cHxvcHxvcGVufHBhcnRlZHxwYXNzd2R8cGFzdGV8cGF0aGNoa3xwaW5nfHBraWxsfHBucG18cG9kbWFufHBvZG1hbi1jb21wb3NlfHBvcGR8cHJ8cHJpbnRjYXB8cHJpbnRlbnZ8cHN8cHVzaGR8cHZ8cXVvdGF8cXVvdGFjaGVja3xxdW90YWN0bHxyYW18cmFyfHJjcHxyZWJvb3R8cmVtc3luY3xyZW5hbWV8cmVuaWNlfHJldnxybXxybWRpcnxycG18cnN5bmN8c2NwfHNjcmVlbnxzZGlmZnxzZWR8c2VuZG1haWx8c2VxfHNlcnZpY2V8c2Z0cHxzaHxzaGVsbGNoZWNrfHNodWZ8c2h1dGRvd258c2xlZXB8c2xvY2F0ZXxzb3J0fHNwbGl0fHNzaHxzdGF0fHN0cmFjZXxzdXxzdWRvfHN1bXxzdXNwZW5kfHN3YXBvbnxzeW5jfHN5c2N0bHx0YWN8dGFpbHx0YXJ8dGVlfHRpbWV8dGltZW91dHx0b3B8dG91Y2h8dHJ8dHJhY2Vyb3V0ZXx0c29ydHx0dHl8dW1vdW50fHVuYW1lfHVuZXhwYW5kfHVuaXF8dW5pdHN8dW5yYXJ8dW5zaGFyfHVuemlwfHVwZGF0ZS1ncnVifHVwdGltZXx1c2VyYWRkfHVzZXJkZWx8dXNlcm1vZHx1c2Vyc3x1dWRlY29kZXx1dWVuY29kZXx2fHZjcGtnfHZkaXJ8dml8dmltfHZpcnNofHZtc3RhdHx3YWl0fHdhdGNofHdjfHdnZXR8d2hlcmVpc3x3aGljaHx3aG98d2hvYW1pfHdyaXRlfHhhcmdzfHhkZy1vcGVufHlhcm58eWVzfHplbml0eXx6aXB8enNofHp5cHBlcikoPz0kfFspXFxzO3wmXSkvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ2tleXdvcmQnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzpjYXNlfGRvfGRvbmV8ZWxpZnxlbHNlfGVzYWN8Zml8Zm9yfGZ1bmN0aW9ufGlmfGlufHNlbGVjdHx0aGVufHVudGlsfHdoaWxlKSg/PSR8WylcXHM7fCZdKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAvLyBodHRwczovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2h0bWxfbm9kZS9TaGVsbC1CdWlsdGluLUNvbW1hbmRzLmh0bWxcbiAgICAnYnVpbHRpbic6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXFxzO3wmXXxbPD5dXFwoKSg/OlxcLnw6fGFsaWFzfGJpbmR8YnJlYWt8YnVpbHRpbnxjYWxsZXJ8Y2R8Y29tbWFuZHxjb250aW51ZXxkZWNsYXJlfGVjaG98ZW5hYmxlfGV2YWx8ZXhlY3xleGl0fGV4cG9ydHxnZXRvcHRzfGhhc2h8aGVscHxsZXR8bG9jYWx8bG9nb3V0fG1hcGZpbGV8cHJpbnRmfHB3ZHxyZWFkfHJlYWRhcnJheXxyZWFkb25seXxyZXR1cm58c2V0fHNoaWZ0fHNob3B0fHNvdXJjZXx0ZXN0fHRpbWVzfHRyYXB8dHlwZXx0eXBlc2V0fHVsaW1pdHx1bWFza3x1bmFsaWFzfHVuc2V0KSg/PSR8WylcXHM7fCZdKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgLy8gQWxpYXMgYWRkZWQgdG8gbWFrZSB0aG9zZSBlYXNpZXIgdG8gZGlzdGluZ3Vpc2ggZnJvbSBzdHJpbmdzLlxuICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lJ1xuICAgIH0sXG4gICAgJ2Jvb2xlYW4nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzpmYWxzZXx0cnVlKSg/PSR8WylcXHM7fCZdKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnZmlsZS1kZXNjcmlwdG9yJzoge1xuICAgICAgcGF0dGVybjogL1xcQiZcXGRcXGIvLFxuICAgICAgYWxpYXM6ICdpbXBvcnRhbnQnXG4gICAgfSxcbiAgICAnb3BlcmF0b3InOiB7XG4gICAgICAvLyBMb3RzIG9mIHJlZGlyZWN0aW9ucyBoZXJlLCBidXQgbm90IGp1c3QgdGhhdC5cbiAgICAgIHBhdHRlcm46IC9cXGQ/PD58PlxcfHxcXCs9fD1bPX5dP3whPT98PDxbPC1dP3xbJlxcZF0/Pj58XFxkWzw+XSY/fFs8Pl1bJj1dP3wmWz4mXT98XFx8WyZ8XT8vLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdmaWxlLWRlc2NyaXB0b3InOiB7XG4gICAgICAgICAgcGF0dGVybjogL15cXGQvLFxuICAgICAgICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAncHVuY3R1YXRpb24nOiAvXFwkP1xcKFxcKD98XFwpXFwpP3xcXC5cXC58W3t9W1xcXTtcXFxcXS8sXG4gICAgJ251bWJlcic6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxcXHMpKD86WzEtOV1cXGQqfDApKD86Wy4sXVxcZCspP1xcYi8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfVxuICB9O1xuICBjb21tYW5kQWZ0ZXJIZXJlZG9jLmluc2lkZSA9IFByaXNtLmxhbmd1YWdlcy5iYXNoO1xuXG4gIC8qIFBhdHRlcm5zIGluIGNvbW1hbmQgc3Vic3RpdHV0aW9uLiAqL1xuICB2YXIgdG9CZUNvcGllZCA9IFsnY29tbWVudCcsICdmdW5jdGlvbi1uYW1lJywgJ2Zvci1vci1zZWxlY3QnLCAnYXNzaWduLWxlZnQnLCAncGFyYW1ldGVyJywgJ3N0cmluZycsICdlbnZpcm9ubWVudCcsICdmdW5jdGlvbicsICdrZXl3b3JkJywgJ2J1aWx0aW4nLCAnYm9vbGVhbicsICdmaWxlLWRlc2NyaXB0b3InLCAnb3BlcmF0b3InLCAncHVuY3R1YXRpb24nLCAnbnVtYmVyJ107XG4gIHZhciBpbnNpZGUgPSBpbnNpZGVTdHJpbmcudmFyaWFibGVbMV0uaW5zaWRlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRvQmVDb3BpZWQubGVuZ3RoOyBpKyspIHtcbiAgICBpbnNpZGVbdG9CZUNvcGllZFtpXV0gPSBQcmlzbS5sYW5ndWFnZXMuYmFzaFt0b0JlQ29waWVkW2ldXTtcbiAgfVxuICBQcmlzbS5sYW5ndWFnZXMuc2ggPSBQcmlzbS5sYW5ndWFnZXMuYmFzaDtcbiAgUHJpc20ubGFuZ3VhZ2VzLnNoZWxsID0gUHJpc20ubGFuZ3VhZ2VzLmJhc2g7XG59KShQcmlzbSk7XG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgcGxhY2Vob2xkZXJzIFwiPDxuPj5cIiBvZiBnaXZlbiBwYXR0ZXJuIHdpdGggdGhlIG4tdGggcmVwbGFjZW1lbnQgKHplcm8gYmFzZWQpLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGlzIGEgc2ltcGxlIHRleHQgYmFzZWQgcmVwbGFjZW1lbnQuIEJlIGNhcmVmdWwgd2hlbiB1c2luZyBiYWNrcmVmZXJlbmNlcyFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gdGhlIGdpdmVuIHBhdHRlcm4uXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHJlcGxhY2VtZW50cyBhIGxpc3Qgb2YgcmVwbGFjZW1lbnQgd2hpY2ggY2FuIGJlIGluc2VydGVkIGludG8gdGhlIGdpdmVuIHBhdHRlcm4uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBwYXR0ZXJuIHdpdGggYWxsIHBsYWNlaG9sZGVycyByZXBsYWNlZCB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmcgcmVwbGFjZW1lbnRzLlxuICAgKiBAZXhhbXBsZSByZXBsYWNlKC9hPDwwPj5hLy5zb3VyY2UsIFsvYisvLnNvdXJjZV0pID09PSAvYSg/OmIrKWEvLnNvdXJjZVxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlbWVudHMpIHtcbiAgICByZXR1cm4gcGF0dGVybi5yZXBsYWNlKC88PChcXGQrKT4+L2csIGZ1bmN0aW9uIChtLCBpbmRleCkge1xuICAgICAgcmV0dXJuICcoPzonICsgcmVwbGFjZW1lbnRzWytpbmRleF0gKyAnKSc7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHJlcGxhY2VtZW50c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZsYWdzXVxuICAgKiBAcmV0dXJucyB7UmVnRXhwfVxuICAgKi9cbiAgZnVuY3Rpb24gcmUocGF0dGVybiwgcmVwbGFjZW1lbnRzLCBmbGFncykge1xuICAgIHJldHVybiBSZWdFeHAocmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlbWVudHMpLCBmbGFncyB8fCAnJyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5lc3RlZCBwYXR0ZXJuIHdoZXJlIGFsbCBvY2N1cnJlbmNlcyBvZiB0aGUgc3RyaW5nIGA8PHNlbGY+PmAgYXJlIHJlcGxhY2VkIHdpdGggdGhlIHBhdHRlcm4gaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVyblxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGhMb2cyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBuZXN0ZWQocGF0dGVybiwgZGVwdGhMb2cyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXB0aExvZzI7IGkrKykge1xuICAgICAgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvPDxzZWxmPj4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJyg/OicgKyBwYXR0ZXJuICsgJyknO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UoLzw8c2VsZj4+L2csICdbXlxcXFxzXFxcXFNdJyk7XG4gIH1cblxuICAvLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9kb3RuZXQvY3NoYXJwL2xhbmd1YWdlLXJlZmVyZW5jZS9rZXl3b3Jkcy9cbiAgdmFyIGtleXdvcmRLaW5kcyA9IHtcbiAgICAvLyBrZXl3b3JkcyB3aGljaCByZXByZXNlbnQgYSByZXR1cm4gb3IgdmFyaWFibGUgdHlwZVxuICAgIHR5cGU6ICdib29sIGJ5dGUgY2hhciBkZWNpbWFsIGRvdWJsZSBkeW5hbWljIGZsb2F0IGludCBsb25nIG9iamVjdCBzYnl0ZSBzaG9ydCBzdHJpbmcgdWludCB1bG9uZyB1c2hvcnQgdmFyIHZvaWQnLFxuICAgIC8vIGtleXdvcmRzIHdoaWNoIGFyZSB1c2VkIHRvIGRlY2xhcmUgYSB0eXBlXG4gICAgdHlwZURlY2xhcmF0aW9uOiAnY2xhc3MgZW51bSBpbnRlcmZhY2UgcmVjb3JkIHN0cnVjdCcsXG4gICAgLy8gY29udGV4dHVhbCBrZXl3b3Jkc1xuICAgIC8vIChcInZhclwiIGFuZCBcImR5bmFtaWNcIiBhcmUgbWlzc2luZyBiZWNhdXNlIHRoZXkgYXJlIHVzZWQgbGlrZSB0eXBlcylcbiAgICBjb250ZXh0dWFsOiAnYWRkIGFsaWFzIGFuZCBhc2NlbmRpbmcgYXN5bmMgYXdhaXQgYnkgZGVzY2VuZGluZyBmcm9tKD89XFxcXHMqKD86XFxcXHd8JCkpIGdldCBnbG9iYWwgZ3JvdXAgaW50byBpbml0KD89XFxcXHMqOykgam9pbiBsZXQgbmFtZW9mIG5vdCBub3RudWxsIG9uIG9yIG9yZGVyYnkgcGFydGlhbCByZW1vdmUgc2VsZWN0IHNldCB1bm1hbmFnZWQgdmFsdWUgd2hlbiB3aGVyZSB3aXRoKD89XFxcXHMqeyknLFxuICAgIC8vIGFsbCBvdGhlciBrZXl3b3Jkc1xuICAgIG90aGVyOiAnYWJzdHJhY3QgYXMgYmFzZSBicmVhayBjYXNlIGNhdGNoIGNoZWNrZWQgY29uc3QgY29udGludWUgZGVmYXVsdCBkZWxlZ2F0ZSBkbyBlbHNlIGV2ZW50IGV4cGxpY2l0IGV4dGVybiBmaW5hbGx5IGZpeGVkIGZvciBmb3JlYWNoIGdvdG8gaWYgaW1wbGljaXQgaW4gaW50ZXJuYWwgaXMgbG9jayBuYW1lc3BhY2UgbmV3IG51bGwgb3BlcmF0b3Igb3V0IG92ZXJyaWRlIHBhcmFtcyBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgcmVhZG9ubHkgcmVmIHJldHVybiBzZWFsZWQgc2l6ZW9mIHN0YWNrYWxsb2Mgc3RhdGljIHN3aXRjaCB0aGlzIHRocm93IHRyeSB0eXBlb2YgdW5jaGVja2VkIHVuc2FmZSB1c2luZyB2aXJ0dWFsIHZvbGF0aWxlIHdoaWxlIHlpZWxkJ1xuICB9O1xuXG4gIC8vIGtleXdvcmRzXG4gIGZ1bmN0aW9uIGtleXdvcmRzVG9QYXR0ZXJuKHdvcmRzKSB7XG4gICAgcmV0dXJuICdcXFxcYig/OicgKyB3b3Jkcy50cmltKCkucmVwbGFjZSgvIC9nLCAnfCcpICsgJylcXFxcYic7XG4gIH1cbiAgdmFyIHR5cGVEZWNsYXJhdGlvbktleXdvcmRzID0ga2V5d29yZHNUb1BhdHRlcm4oa2V5d29yZEtpbmRzLnR5cGVEZWNsYXJhdGlvbik7XG4gIHZhciBrZXl3b3JkcyA9IFJlZ0V4cChrZXl3b3Jkc1RvUGF0dGVybihrZXl3b3JkS2luZHMudHlwZSArICcgJyArIGtleXdvcmRLaW5kcy50eXBlRGVjbGFyYXRpb24gKyAnICcgKyBrZXl3b3JkS2luZHMuY29udGV4dHVhbCArICcgJyArIGtleXdvcmRLaW5kcy5vdGhlcikpO1xuICB2YXIgbm9uVHlwZUtleXdvcmRzID0ga2V5d29yZHNUb1BhdHRlcm4oa2V5d29yZEtpbmRzLnR5cGVEZWNsYXJhdGlvbiArICcgJyArIGtleXdvcmRLaW5kcy5jb250ZXh0dWFsICsgJyAnICsga2V5d29yZEtpbmRzLm90aGVyKTtcbiAgdmFyIG5vbkNvbnRleHR1YWxLZXl3b3JkcyA9IGtleXdvcmRzVG9QYXR0ZXJuKGtleXdvcmRLaW5kcy50eXBlICsgJyAnICsga2V5d29yZEtpbmRzLnR5cGVEZWNsYXJhdGlvbiArICcgJyArIGtleXdvcmRLaW5kcy5vdGhlcik7XG5cbiAgLy8gdHlwZXNcbiAgdmFyIGdlbmVyaWMgPSBuZXN0ZWQoLzwoPzpbXjw+Oz0rXFwtKi8lJnxeXXw8PHNlbGY+PikqPi8uc291cmNlLCAyKTsgLy8gdGhlIGlkZWEgYmVoaW5kIHRoZSBvdGhlciBmb3JiaWRkZW4gY2hhcmFjdGVycyBpcyB0byBwcmV2ZW50IGZhbHNlIHBvc2l0aXZlcy4gU2FtZSBmb3IgdHVwbGVFbGVtZW50LlxuICB2YXIgbmVzdGVkUm91bmQgPSBuZXN0ZWQoL1xcKCg/OlteKCldfDw8c2VsZj4+KSpcXCkvLnNvdXJjZSwgMik7XG4gIHZhciBuYW1lID0gL0A/XFxiW0EtWmEtel9dXFx3KlxcYi8uc291cmNlO1xuICB2YXIgZ2VuZXJpY05hbWUgPSByZXBsYWNlKC88PDA+Pig/Olxccyo8PDE+Pik/Ly5zb3VyY2UsIFtuYW1lLCBnZW5lcmljXSk7XG4gIHZhciBpZGVudGlmaWVyID0gcmVwbGFjZSgvKD8hPDwwPj4pPDwxPj4oPzpcXHMqXFwuXFxzKjw8MT4+KSovLnNvdXJjZSwgW25vblR5cGVLZXl3b3JkcywgZ2VuZXJpY05hbWVdKTtcbiAgdmFyIGFycmF5ID0gL1xcW1xccyooPzosXFxzKikqXFxdLy5zb3VyY2U7XG4gIHZhciB0eXBlRXhwcmVzc2lvbldpdGhvdXRUdXBsZSA9IHJlcGxhY2UoLzw8MD4+KD86XFxzKig/OlxcP1xccyopPzw8MT4+KSooPzpcXHMqXFw/KT8vLnNvdXJjZSwgW2lkZW50aWZpZXIsIGFycmF5XSk7XG4gIHZhciB0dXBsZUVsZW1lbnQgPSByZXBsYWNlKC9bXiwoKTw+W1xcXTs9K1xcLSovJSZ8Xl18PDwwPj58PDwxPj58PDwyPj4vLnNvdXJjZSwgW2dlbmVyaWMsIG5lc3RlZFJvdW5kLCBhcnJheV0pO1xuICB2YXIgdHVwbGUgPSByZXBsYWNlKC9cXCg8PDA+PisoPzosPDwwPj4rKStcXCkvLnNvdXJjZSwgW3R1cGxlRWxlbWVudF0pO1xuICB2YXIgdHlwZUV4cHJlc3Npb24gPSByZXBsYWNlKC8oPzo8PDA+Pnw8PDE+PikoPzpcXHMqKD86XFw/XFxzKik/PDwyPj4pKig/OlxccypcXD8pPy8uc291cmNlLCBbdHVwbGUsIGlkZW50aWZpZXIsIGFycmF5XSk7XG4gIHZhciB0eXBlSW5zaWRlID0ge1xuICAgICdrZXl3b3JkJzoga2V5d29yZHMsXG4gICAgJ3B1bmN0dWF0aW9uJzogL1s8PigpPywuOltcXF1dL1xuICB9O1xuXG4gIC8vIHN0cmluZ3MgJiBjaGFyYWN0ZXJzXG4gIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9jc2hhcnAvbGFuZ3VhZ2UtcmVmZXJlbmNlL2xhbmd1YWdlLXNwZWNpZmljYXRpb24vbGV4aWNhbC1zdHJ1Y3R1cmUjY2hhcmFjdGVyLWxpdGVyYWxzXG4gIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9jc2hhcnAvbGFuZ3VhZ2UtcmVmZXJlbmNlL2xhbmd1YWdlLXNwZWNpZmljYXRpb24vbGV4aWNhbC1zdHJ1Y3R1cmUjc3RyaW5nLWxpdGVyYWxzXG4gIHZhciBjaGFyYWN0ZXIgPSAvJyg/OlteXFxyXFxuJ1xcXFxdfFxcXFwufFxcXFxbVXV4XVtcXGRhLWZBLUZdezEsOH0pJy8uc291cmNlOyAvLyBzaW1wbGlmaWVkIHBhdHRlcm5cbiAgdmFyIHJlZ3VsYXJTdHJpbmcgPSAvXCIoPzpcXFxcLnxbXlxcXFxcIlxcclxcbl0pKlwiLy5zb3VyY2U7XG4gIHZhciB2ZXJiYXRpbVN0cmluZyA9IC9AXCIoPzpcIlwifFxcXFxbXFxzXFxTXXxbXlxcXFxcIl0pKlwiKD8hXCIpLy5zb3VyY2U7XG4gIFByaXNtLmxhbmd1YWdlcy5jc2hhcnAgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcbiAgICAnc3RyaW5nJzogW3tcbiAgICAgIHBhdHRlcm46IHJlKC8oXnxbXiRcXFxcXSk8PDA+Pi8uc291cmNlLCBbdmVyYmF0aW1TdHJpbmddKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiByZSgvKF58W15AJFxcXFxdKTw8MD4+Ly5zb3VyY2UsIFtyZWd1bGFyU3RyaW5nXSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfV0sXG4gICAgJ2NsYXNzLW5hbWUnOiBbe1xuICAgICAgLy8gVXNpbmcgc3RhdGljXG4gICAgICAvLyB1c2luZyBzdGF0aWMgU3lzdGVtLk1hdGg7XG4gICAgICBwYXR0ZXJuOiByZSgvKFxcYnVzaW5nXFxzK3N0YXRpY1xccyspPDwwPj4oPz1cXHMqOykvLnNvdXJjZSwgW2lkZW50aWZpZXJdKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHR5cGVJbnNpZGVcbiAgICB9LCB7XG4gICAgICAvLyBVc2luZyBhbGlhcyAodHlwZSlcbiAgICAgIC8vIHVzaW5nIFByb2plY3QgPSBQQy5NeUNvbXBhbnkuUHJvamVjdDtcbiAgICAgIHBhdHRlcm46IHJlKC8oXFxidXNpbmdcXHMrPDwwPj5cXHMqPVxccyopPDwxPj4oPz1cXHMqOykvLnNvdXJjZSwgW25hbWUsIHR5cGVFeHByZXNzaW9uXSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB0eXBlSW5zaWRlXG4gICAgfSwge1xuICAgICAgLy8gVXNpbmcgYWxpYXMgKGFsaWFzKVxuICAgICAgLy8gdXNpbmcgUHJvamVjdCA9IFBDLk15Q29tcGFueS5Qcm9qZWN0O1xuICAgICAgcGF0dGVybjogcmUoLyhcXGJ1c2luZ1xccyspPDwwPj4oPz1cXHMqPSkvLnNvdXJjZSwgW25hbWVdKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LCB7XG4gICAgICAvLyBUeXBlIGRlY2xhcmF0aW9uc1xuICAgICAgLy8gY2xhc3MgRm9vPEEsIEI+XG4gICAgICAvLyBpbnRlcmZhY2UgRm9vPG91dCBBLCBCPlxuICAgICAgcGF0dGVybjogcmUoLyhcXGI8PDA+PlxccyspPDwxPj4vLnNvdXJjZSwgW3R5cGVEZWNsYXJhdGlvbktleXdvcmRzLCBnZW5lcmljTmFtZV0pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZTogdHlwZUluc2lkZVxuICAgIH0sIHtcbiAgICAgIC8vIFNpbmdsZSBjYXRjaCBleGNlcHRpb24gZGVjbGFyYXRpb25cbiAgICAgIC8vIGNhdGNoKEZvbylcbiAgICAgIC8vICh0aGluZ3MgbGlrZSBjYXRjaChGb28gZSkgaXMgY292ZXJlZCBieSB2YXJpYWJsZSBkZWNsYXJhdGlvbilcbiAgICAgIHBhdHRlcm46IHJlKC8oXFxiY2F0Y2hcXHMqXFwoXFxzKik8PDA+Pi8uc291cmNlLCBbaWRlbnRpZmllcl0pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZTogdHlwZUluc2lkZVxuICAgIH0sIHtcbiAgICAgIC8vIE5hbWUgb2YgdGhlIHR5cGUgcGFyYW1ldGVyIG9mIGdlbmVyaWMgY29uc3RyYWludHNcbiAgICAgIC8vIHdoZXJlIEZvbyA6IGNsYXNzXG4gICAgICBwYXR0ZXJuOiByZSgvKFxcYndoZXJlXFxzKyk8PDA+Pi8uc291cmNlLCBbbmFtZV0pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIC8vIENhc3RzIGFuZCBjaGVja3MgdmlhIGFzIGFuZCBpcy5cbiAgICAgIC8vIGFzIEZvbzxBPiwgaXMgQmFyPEI+XG4gICAgICAvLyAodGhpbmdzIGxpa2UgaWYoYSBpcyBGb28gYikgaXMgY292ZXJlZCBieSB2YXJpYWJsZSBkZWNsYXJhdGlvbilcbiAgICAgIHBhdHRlcm46IHJlKC8oXFxiKD86aXMoPzpcXHMrbm90KT98YXMpXFxzKyk8PDA+Pi8uc291cmNlLCBbdHlwZUV4cHJlc3Npb25XaXRob3V0VHVwbGVdKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHR5cGVJbnNpZGVcbiAgICB9LCB7XG4gICAgICAvLyBWYXJpYWJsZSwgZmllbGQgYW5kIHBhcmFtZXRlciBkZWNsYXJhdGlvblxuICAgICAgLy8gKEZvbyBiYXIsIEJhciBiYXosIEZvb1ssLF0gYmF5LCBGb288QmFyLCBGb29CYXI8QmFyPj4gYmF4KVxuICAgICAgcGF0dGVybjogcmUoL1xcYjw8MD4+KD89XFxzKyg/ITw8MT4+fHdpdGhcXHMqXFx7KTw8Mj4+KD86XFxzKls9LDs6eylcXF1dfFxccysoPzppbnx3aGVuKVxcYikpLy5zb3VyY2UsIFt0eXBlRXhwcmVzc2lvbiwgbm9uQ29udGV4dHVhbEtleXdvcmRzLCBuYW1lXSksXG4gICAgICBpbnNpZGU6IHR5cGVJbnNpZGVcbiAgICB9XSxcbiAgICAna2V5d29yZCc6IGtleXdvcmRzLFxuICAgIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9jc2hhcnAvbGFuZ3VhZ2UtcmVmZXJlbmNlL2xhbmd1YWdlLXNwZWNpZmljYXRpb24vbGV4aWNhbC1zdHJ1Y3R1cmUjbGl0ZXJhbHNcbiAgICAnbnVtYmVyJzogLyg/OlxcYjAoPzp4W1xcZGEtZl9dKltcXGRhLWZdfGJbMDFfXSpbMDFdKXwoPzpcXEJcXC5cXGQrKD86XytcXGQrKSp8XFxiXFxkKyg/Ol8rXFxkKykqKD86XFwuXFxkKyg/Ol8rXFxkKykqKT8pKD86ZVstK10/XFxkKyg/Ol8rXFxkKykqKT8pKD86W2RmbG11XXxsdXx1bCk/XFxiL2ksXG4gICAgJ29wZXJhdG9yJzogLz4+PT98PDw9P3xbLT1dPnwoWy0rJnxdKVxcMXx+fFxcP1xcPz0/fFstKyovJSZ8XiE9PD5dPT8vLFxuICAgICdwdW5jdHVhdGlvbic6IC9cXD9cXC4/fDo6fFt7fVtcXF07KCksLjpdL1xuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3NoYXJwJywgJ251bWJlcicsIHtcbiAgICAncmFuZ2UnOiB7XG4gICAgICBwYXR0ZXJuOiAvXFwuXFwuLyxcbiAgICAgIGFsaWFzOiAnb3BlcmF0b3InXG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3NoYXJwJywgJ3B1bmN0dWF0aW9uJywge1xuICAgICduYW1lZC1wYXJhbWV0ZXInOiB7XG4gICAgICBwYXR0ZXJuOiByZSgvKFsoLF1cXHMqKTw8MD4+KD89XFxzKjopLy5zb3VyY2UsIFtuYW1lXSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjc2hhcnAnLCAnY2xhc3MtbmFtZScsIHtcbiAgICAnbmFtZXNwYWNlJzoge1xuICAgICAgLy8gbmFtZXNwYWNlIEZvby5CYXIge31cbiAgICAgIC8vIHVzaW5nIEZvby5CYXI7XG4gICAgICBwYXR0ZXJuOiByZSgvKFxcYig/Om5hbWVzcGFjZXx1c2luZylcXHMrKTw8MD4+KD86XFxzKlxcLlxccyo8PDA+PikqKD89XFxzKls7e10pLy5zb3VyY2UsIFtuYW1lXSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9cXC4vXG4gICAgICB9XG4gICAgfSxcbiAgICAndHlwZS1leHByZXNzaW9uJzoge1xuICAgICAgLy8gZGVmYXVsdChGb28pLCB0eXBlb2YoRm9vPEJhcj4pLCBzaXplb2YoaW50KVxuICAgICAgcGF0dGVybjogcmUoLyhcXGIoPzpkZWZhdWx0fHNpemVvZnx0eXBlb2YpXFxzKlxcKFxccyooPyFcXHMpKSg/OlteKClcXHNdfFxccyg/IVxccyl8PDwwPj4pKig/PVxccypcXCkpLy5zb3VyY2UsIFtuZXN0ZWRSb3VuZF0pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZScsXG4gICAgICBpbnNpZGU6IHR5cGVJbnNpZGVcbiAgICB9LFxuICAgICdyZXR1cm4tdHlwZSc6IHtcbiAgICAgIC8vIEZvbzxCYXI+IEZvckJhcigpOyBGb28gSUZvby5CYXIoKSA9PiAwXG4gICAgICAvLyBpbnQgdGhpc1tpbnQgaW5kZXhdID0+IDA7IFQgSVJlYWRPbmx5TGlzdDxUPi50aGlzW2ludCBpbmRleF0gPT4gdGhpc1tpbmRleF07XG4gICAgICAvLyBpbnQgRm9vID0+IDA7IGludCBGb28geyBnZXQ7IHNldCB9ID0gMDtcbiAgICAgIHBhdHRlcm46IHJlKC88PDA+Pig/PVxccysoPzo8PDE+PlxccyooPzo9PnxbKHtdfFxcLlxccyp0aGlzXFxzKlxcWyl8dGhpc1xccypcXFspKS8uc291cmNlLCBbdHlwZUV4cHJlc3Npb24sIGlkZW50aWZpZXJdKSxcbiAgICAgIGluc2lkZTogdHlwZUluc2lkZSxcbiAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZSdcbiAgICB9LFxuICAgICdjb25zdHJ1Y3Rvci1pbnZvY2F0aW9uJzoge1xuICAgICAgLy8gbmV3IExpc3Q8Rm9vPEJhcltdPj4geyB9XG4gICAgICBwYXR0ZXJuOiByZSgvKFxcYm5ld1xccyspPDwwPj4oPz1cXHMqW1soe10pLy5zb3VyY2UsIFt0eXBlRXhwcmVzc2lvbl0pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZTogdHlwZUluc2lkZSxcbiAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZSdcbiAgICB9LFxuICAgIC8qJ2V4cGxpY2l0LWltcGxlbWVudGF0aW9uJzoge1xuICAgIFx0Ly8gaW50IElGb288Rm9vPi5CYXIgPT4gMDsgdm9pZCBJRm9vPEZvbzxGb28+Pi5Gb288VD4oKTtcbiAgICBcdHBhdHRlcm46IHJlcGxhY2UoL1xcYjw8MD4+KD89XFwuPDwxPj4pLywgY2xhc3NOYW1lLCBtZXRob2RPclByb3BlcnR5RGVjbGFyYXRpb24pLFxuICAgIFx0aW5zaWRlOiBjbGFzc05hbWVJbnNpZGUsXG4gICAgXHRhbGlhczogJ2NsYXNzLW5hbWUnXG4gICAgfSwqL1xuICAgICdnZW5lcmljLW1ldGhvZCc6IHtcbiAgICAgIC8vIGZvbzxCYXI+KClcbiAgICAgIHBhdHRlcm46IHJlKC88PDA+Plxccyo8PDE+Pig/PVxccypcXCgpLy5zb3VyY2UsIFtuYW1lLCBnZW5lcmljXSksXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2Z1bmN0aW9uJzogcmUoL148PDA+Pi8uc291cmNlLCBbbmFtZV0pLFxuICAgICAgICAnZ2VuZXJpYyc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoZ2VuZXJpYyksXG4gICAgICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lJyxcbiAgICAgICAgICBpbnNpZGU6IHR5cGVJbnNpZGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3R5cGUtbGlzdCc6IHtcbiAgICAgIC8vIFRoZSBsaXN0IG9mIHR5cGVzIGluaGVyaXRlZCBvciBvZiBnZW5lcmljIGNvbnN0cmFpbnRzXG4gICAgICAvLyBjbGFzcyBGb288Rj4gOiBCYXIsIElMaXN0PEZvb0Jhcj5cbiAgICAgIC8vIHdoZXJlIEYgOiBCYXIsIElMaXN0PGludD5cbiAgICAgIHBhdHRlcm46IHJlKC9cXGIoKD86PDwwPj5cXHMrPDwxPj58cmVjb3JkXFxzKzw8MT4+XFxzKjw8NT4+fHdoZXJlXFxzKzw8Mj4+KVxccyo6XFxzKikoPzo8PDM+Pnw8PDQ+Pnw8PDE+Plxccyo8PDU+Pnw8PDY+PikoPzpcXHMqLFxccyooPzo8PDM+Pnw8PDQ+Pnw8PDY+PikpKig/PVxccyooPzp3aGVyZXxbeztdfD0+fCQpKS8uc291cmNlLCBbdHlwZURlY2xhcmF0aW9uS2V5d29yZHMsIGdlbmVyaWNOYW1lLCBuYW1lLCB0eXBlRXhwcmVzc2lvbiwga2V5d29yZHMuc291cmNlLCBuZXN0ZWRSb3VuZCwgL1xcYm5ld1xccypcXChcXHMqXFwpLy5zb3VyY2VdKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3JlY29yZC1hcmd1bWVudHMnOiB7XG4gICAgICAgICAgcGF0dGVybjogcmUoLyheKD8hbmV3XFxzKlxcKCk8PDA+PlxccyopPDwxPj4vLnNvdXJjZSwgW2dlbmVyaWNOYW1lLCBuZXN0ZWRSb3VuZF0pLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmNzaGFycFxuICAgICAgICB9LFxuICAgICAgICAna2V5d29yZCc6IGtleXdvcmRzLFxuICAgICAgICAnY2xhc3MtbmFtZSc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAodHlwZUV4cHJlc3Npb24pLFxuICAgICAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgICAgICBpbnNpZGU6IHR5cGVJbnNpZGVcbiAgICAgICAgfSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1ssKCldL1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3ByZXByb2Nlc3Nvcic6IHtcbiAgICAgIHBhdHRlcm46IC8oXltcXHQgXSopIy4qL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdwcm9wZXJ0eScsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgLy8gaGlnaGxpZ2h0IHByZXByb2Nlc3NvciBkaXJlY3RpdmVzIGFzIGtleXdvcmRzXG4gICAgICAgICdkaXJlY3RpdmUnOiB7XG4gICAgICAgICAgcGF0dGVybjogLygjKVxcYig/OmRlZmluZXxlbGlmfGVsc2V8ZW5kaWZ8ZW5kcmVnaW9ufGVycm9yfGlmfGxpbmV8bnVsbGFibGV8cHJhZ21hfHJlZ2lvbnx1bmRlZnx3YXJuaW5nKVxcYi8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBhbGlhczogJ2tleXdvcmQnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIGF0dHJpYnV0ZXNcbiAgdmFyIHJlZ3VsYXJTdHJpbmdPckNoYXJhY3RlciA9IHJlZ3VsYXJTdHJpbmcgKyAnfCcgKyBjaGFyYWN0ZXI7XG4gIHZhciByZWd1bGFyU3RyaW5nQ2hhcmFjdGVyT3JDb21tZW50ID0gcmVwbGFjZSgvXFwvKD8hWyovXSl8XFwvXFwvW15cXHJcXG5dKltcXHJcXG5dfFxcL1xcKig/OlteKl18XFwqKD8hXFwvKSkqXFwqXFwvfDw8MD4+Ly5zb3VyY2UsIFtyZWd1bGFyU3RyaW5nT3JDaGFyYWN0ZXJdKTtcbiAgdmFyIHJvdW5kRXhwcmVzc2lvbiA9IG5lc3RlZChyZXBsYWNlKC9bXlwiJy8oKV18PDwwPj58XFwoPDxzZWxmPj4qXFwpLy5zb3VyY2UsIFtyZWd1bGFyU3RyaW5nQ2hhcmFjdGVyT3JDb21tZW50XSksIDIpO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9jc2hhcnAvcHJvZ3JhbW1pbmctZ3VpZGUvY29uY2VwdHMvYXR0cmlidXRlcy8jYXR0cmlidXRlLXRhcmdldHNcbiAgdmFyIGF0dHJUYXJnZXQgPSAvXFxiKD86YXNzZW1ibHl8ZXZlbnR8ZmllbGR8bWV0aG9kfG1vZHVsZXxwYXJhbXxwcm9wZXJ0eXxyZXR1cm58dHlwZSlcXGIvLnNvdXJjZTtcbiAgdmFyIGF0dHIgPSByZXBsYWNlKC88PDA+Pig/OlxccypcXCg8PDE+PipcXCkpPy8uc291cmNlLCBbaWRlbnRpZmllciwgcm91bmRFeHByZXNzaW9uXSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NzaGFycCcsICdjbGFzcy1uYW1lJywge1xuICAgICdhdHRyaWJ1dGUnOiB7XG4gICAgICAvLyBBdHRyaWJ1dGVzXG4gICAgICAvLyBbRm9vXSwgW0ZvbygxKSwgQmFyKDIsIFByb3AgPSBcImZvb1wiKV0sIFtyZXR1cm46IEZvbygxKSwgQmFyKDIpXSwgW2Fzc2VtYmx5OiBGb28oQmFyKV1cbiAgICAgIHBhdHRlcm46IHJlKC8oKD86XnxbXlxcc1xcdz4pP10pXFxzKlxcW1xccyopKD86PDwwPj5cXHMqOlxccyopPzw8MT4+KD86XFxzKixcXHMqPDwxPj4pKig/PVxccypcXF0pLy5zb3VyY2UsIFthdHRyVGFyZ2V0LCBhdHRyXSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICd0YXJnZXQnOiB7XG4gICAgICAgICAgcGF0dGVybjogcmUoL148PDA+Pig/PVxccyo6KS8uc291cmNlLCBbYXR0clRhcmdldF0pLFxuICAgICAgICAgIGFsaWFzOiAna2V5d29yZCdcbiAgICAgICAgfSxcbiAgICAgICAgJ2F0dHJpYnV0ZS1hcmd1bWVudHMnOiB7XG4gICAgICAgICAgcGF0dGVybjogcmUoL1xcKDw8MD4+KlxcKS8uc291cmNlLCBbcm91bmRFeHByZXNzaW9uXSksXG4gICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuY3NoYXJwXG4gICAgICAgIH0sXG4gICAgICAgICdjbGFzcy1uYW1lJzoge1xuICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cChpZGVudGlmaWVyKSxcbiAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9cXC4vXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvWzosXS9cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIHN0cmluZyBpbnRlcnBvbGF0aW9uXG4gIHZhciBmb3JtYXRTdHJpbmcgPSAvOltefVxcclxcbl0rLy5zb3VyY2U7XG4gIC8vIG11bHRpIGxpbmVcbiAgdmFyIG1JbnRlcnBvbGF0aW9uUm91bmQgPSBuZXN0ZWQocmVwbGFjZSgvW15cIicvKCldfDw8MD4+fFxcKDw8c2VsZj4+KlxcKS8uc291cmNlLCBbcmVndWxhclN0cmluZ0NoYXJhY3Rlck9yQ29tbWVudF0pLCAyKTtcbiAgdmFyIG1JbnRlcnBvbGF0aW9uID0gcmVwbGFjZSgvXFx7KD8hXFx7KSg/Oig/IVt9Ol0pPDwwPj4pKjw8MT4+P1xcfS8uc291cmNlLCBbbUludGVycG9sYXRpb25Sb3VuZCwgZm9ybWF0U3RyaW5nXSk7XG4gIC8vIHNpbmdsZSBsaW5lXG4gIHZhciBzSW50ZXJwb2xhdGlvblJvdW5kID0gbmVzdGVkKHJlcGxhY2UoL1teXCInLygpXXxcXC8oPyFcXCopfFxcL1xcKig/OlteKl18XFwqKD8hXFwvKSkqXFwqXFwvfDw8MD4+fFxcKDw8c2VsZj4+KlxcKS8uc291cmNlLCBbcmVndWxhclN0cmluZ09yQ2hhcmFjdGVyXSksIDIpO1xuICB2YXIgc0ludGVycG9sYXRpb24gPSByZXBsYWNlKC9cXHsoPyFcXHspKD86KD8hW306XSk8PDA+PikqPDwxPj4/XFx9Ly5zb3VyY2UsIFtzSW50ZXJwb2xhdGlvblJvdW5kLCBmb3JtYXRTdHJpbmddKTtcbiAgZnVuY3Rpb24gY3JlYXRlSW50ZXJwb2xhdGlvbkluc2lkZShpbnRlcnBvbGF0aW9uLCBpbnRlcnBvbGF0aW9uUm91bmQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ2ludGVycG9sYXRpb24nOiB7XG4gICAgICAgIHBhdHRlcm46IHJlKC8oKD86XnxbXntdKSg/Olxce1xceykqKTw8MD4+Ly5zb3VyY2UsIFtpbnRlcnBvbGF0aW9uXSksXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdmb3JtYXQtc3RyaW5nJzoge1xuICAgICAgICAgICAgcGF0dGVybjogcmUoLyheXFx7KD86KD8hW306XSk8PDA+PikqKTw8MT4+KD89XFx9JCkvLnNvdXJjZSwgW2ludGVycG9sYXRpb25Sb3VuZCwgZm9ybWF0U3RyaW5nXSksXG4gICAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9eOi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9eXFx7fFxcfSQvLFxuICAgICAgICAgICdleHByZXNzaW9uJzoge1xuICAgICAgICAgICAgcGF0dGVybjogL1tcXHNcXFNdKy8sXG4gICAgICAgICAgICBhbGlhczogJ2xhbmd1YWdlLWNzaGFycCcsXG4gICAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5jc2hhcnBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnc3RyaW5nJzogL1tcXHNcXFNdKy9cbiAgICB9O1xuICB9XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NzaGFycCcsICdzdHJpbmcnLCB7XG4gICAgJ2ludGVycG9sYXRpb24tc3RyaW5nJzogW3tcbiAgICAgIHBhdHRlcm46IHJlKC8oXnxbXlxcXFxdKSg/OlxcJEB8QFxcJClcIig/OlwiXCJ8XFxcXFtcXHNcXFNdfFxce1xce3w8PDA+PnxbXlxcXFx7XCJdKSpcIi8uc291cmNlLCBbbUludGVycG9sYXRpb25dKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IGNyZWF0ZUludGVycG9sYXRpb25JbnNpZGUobUludGVycG9sYXRpb24sIG1JbnRlcnBvbGF0aW9uUm91bmQpXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogcmUoLyhefFteQFxcXFxdKVxcJFwiKD86XFxcXC58XFx7XFx7fDw8MD4+fFteXFxcXFwie10pKlwiLy5zb3VyY2UsIFtzSW50ZXJwb2xhdGlvbl0pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZTogY3JlYXRlSW50ZXJwb2xhdGlvbkluc2lkZShzSW50ZXJwb2xhdGlvbiwgc0ludGVycG9sYXRpb25Sb3VuZClcbiAgICB9XSxcbiAgICAnY2hhcic6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cChjaGFyYWN0ZXIpLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmRvdG5ldCA9IFByaXNtLmxhbmd1YWdlcy5jcyA9IFByaXNtLmxhbmd1YWdlcy5jc2hhcnA7XG59KShQcmlzbSk7XG5QcmlzbS5sYW5ndWFnZXMubWFya3VwID0ge1xuICAnY29tbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvPCEtLSg/Oig/ITwhLS0pW1xcc1xcU10pKj8tLT4vLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAncHJvbG9nJzoge1xuICAgIHBhdHRlcm46IC88XFw/W1xcc1xcU10rP1xcPz4vLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnZG9jdHlwZSc6IHtcbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIveG1sLyNOVC1kb2N0eXBlZGVjbFxuICAgIHBhdHRlcm46IC88IURPQ1RZUEUoPzpbXj5cIidbXFxdXXxcIlteXCJdKlwifCdbXiddKicpKyg/OlxcWyg/OltePFwiJ1xcXV18XCJbXlwiXSpcInwnW14nXSonfDwoPyEhLS0pfDwhLS0oPzpbXi1dfC0oPyEtPikpKi0tPikqXFxdXFxzKik/Pi9pLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdpbnRlcm5hbC1zdWJzZXQnOiB7XG4gICAgICAgIHBhdHRlcm46IC8oXlteXFxbXSpcXFspW1xcc1xcU10rKD89XFxdPiQpLyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICBpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG4gICAgICB9LFxuICAgICAgJ3N0cmluZyc6IHtcbiAgICAgICAgcGF0dGVybjogL1wiW15cIl0qXCJ8J1teJ10qJy8sXG4gICAgICAgIGdyZWVkeTogdHJ1ZVxuICAgICAgfSxcbiAgICAgICdwdW5jdHVhdGlvbic6IC9ePCF8PiR8W1tcXF1dLyxcbiAgICAgICdkb2N0eXBlLXRhZyc6IC9eRE9DVFlQRS9pLFxuICAgICAgJ25hbWUnOiAvW15cXHM8PidcIl0rL1xuICAgIH1cbiAgfSxcbiAgJ2NkYXRhJzoge1xuICAgIHBhdHRlcm46IC88IVxcW0NEQVRBXFxbW1xcc1xcU10qP1xcXVxcXT4vaSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ3RhZyc6IHtcbiAgICBwYXR0ZXJuOiAvPFxcLz8oPyFcXGQpW15cXHM+XFwvPSQ8JV0rKD86XFxzKD86XFxzKlteXFxzPlxcLz1dKyg/Olxccyo9XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSsoPz1bXFxzPl0pKXwoPz1bXFxzLz5dKSkpKyk/XFxzKlxcLz8+LyxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAndGFnJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXjxcXC8/W15cXHM+XFwvXSsvLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAncHVuY3R1YXRpb24nOiAvXjxcXC8/LyxcbiAgICAgICAgICAnbmFtZXNwYWNlJzogL15bXlxccz5cXC86XSs6L1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ3NwZWNpYWwtYXR0cic6IFtdLFxuICAgICAgJ2F0dHItdmFsdWUnOiB7XG4gICAgICAgIHBhdHRlcm46IC89XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSspLyxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ3B1bmN0dWF0aW9uJzogW3tcbiAgICAgICAgICAgIHBhdHRlcm46IC9ePS8sXG4gICAgICAgICAgICBhbGlhczogJ2F0dHItZXF1YWxzJ1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHBhdHRlcm46IC9eKFxccyopW1wiJ118W1wiJ10kLyxcbiAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgICB9XVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcLz8+LyxcbiAgICAgICdhdHRyLW5hbWUnOiB7XG4gICAgICAgIHBhdHRlcm46IC9bXlxccz5cXC9dKy8sXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICduYW1lc3BhY2UnOiAvXlteXFxzPlxcLzpdKzovXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICdlbnRpdHknOiBbe1xuICAgIHBhdHRlcm46IC8mW1xcZGEtel17MSw4fTsvaSxcbiAgICBhbGlhczogJ25hbWVkLWVudGl0eSdcbiAgfSwgLyYjeD9bXFxkYS1mXXsxLDh9Oy9pXVxufTtcblByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ3RhZyddLmluc2lkZVsnYXR0ci12YWx1ZSddLmluc2lkZVsnZW50aXR5J10gPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwWydlbnRpdHknXTtcblByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ2RvY3R5cGUnXS5pbnNpZGVbJ2ludGVybmFsLXN1YnNldCddLmluc2lkZSA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5cbi8vIFBsdWdpbiB0byBtYWtlIGVudGl0eSB0aXRsZSBzaG93IHRoZSByZWFsIGVudGl0eSwgaWRlYSBieSBSb21hbiBLb21hcm92XG5QcmlzbS5ob29rcy5hZGQoJ3dyYXAnLCBmdW5jdGlvbiAoZW52KSB7XG4gIGlmIChlbnYudHlwZSA9PT0gJ2VudGl0eScpIHtcbiAgICBlbnYuYXR0cmlidXRlc1sndGl0bGUnXSA9IGVudi5jb250ZW50LnJlcGxhY2UoLyZhbXA7LywgJyYnKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcsICdhZGRJbmxpbmVkJywge1xuICAvKipcbiAgICogQWRkcyBhbiBpbmxpbmVkIGxhbmd1YWdlIHRvIG1hcmt1cC5cbiAgICpcbiAgICogQW4gZXhhbXBsZSBvZiBhbiBpbmxpbmVkIGxhbmd1YWdlIGlzIENTUyB3aXRoIGA8c3R5bGU+YCB0YWdzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFnIHRoYXQgY29udGFpbnMgdGhlIGlubGluZWQgbGFuZ3VhZ2UuIFRoaXMgbmFtZSB3aWxsIGJlIHRyZWF0ZWQgYXNcbiAgICogY2FzZSBpbnNlbnNpdGl2ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmcgVGhlIGxhbmd1YWdlIGtleS5cbiAgICogQGV4YW1wbGVcbiAgICogYWRkSW5saW5lZCgnc3R5bGUnLCAnY3NzJyk7XG4gICAqL1xuICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5saW5lZCh0YWdOYW1lLCBsYW5nKSB7XG4gICAgdmFyIGluY2x1ZGVkQ2RhdGFJbnNpZGUgPSB7fTtcbiAgICBpbmNsdWRlZENkYXRhSW5zaWRlWydsYW5ndWFnZS0nICsgbGFuZ10gPSB7XG4gICAgICBwYXR0ZXJuOiAvKF48IVxcW0NEQVRBXFxbKVtcXHNcXFNdKz8oPz1cXF1cXF0+JCkvaSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlc1tsYW5nXVxuICAgIH07XG4gICAgaW5jbHVkZWRDZGF0YUluc2lkZVsnY2RhdGEnXSA9IC9ePCFcXFtDREFUQVxcW3xcXF1cXF0+JC9pO1xuICAgIHZhciBpbnNpZGUgPSB7XG4gICAgICAnaW5jbHVkZWQtY2RhdGEnOiB7XG4gICAgICAgIHBhdHRlcm46IC88IVxcW0NEQVRBXFxbW1xcc1xcU10qP1xcXVxcXT4vaSxcbiAgICAgICAgaW5zaWRlOiBpbmNsdWRlZENkYXRhSW5zaWRlXG4gICAgICB9XG4gICAgfTtcbiAgICBpbnNpZGVbJ2xhbmd1YWdlLScgKyBsYW5nXSA9IHtcbiAgICAgIHBhdHRlcm46IC9bXFxzXFxTXSsvLFxuICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXNbbGFuZ11cbiAgICB9O1xuICAgIHZhciBkZWYgPSB7fTtcbiAgICBkZWZbdGFnTmFtZV0gPSB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyg8X19bXj5dKj4pKD86PCFcXFtDREFUQVxcWyg/OlteXFxdXXxcXF0oPyFcXF0+KSkqXFxdXFxdPnwoPyE8IVxcW0NEQVRBXFxbKVtcXHNcXFNdKSo/KD89PFxcL19fPikvLnNvdXJjZS5yZXBsYWNlKC9fXy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lO1xuICAgICAgfSksICdpJyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiBpbnNpZGVcbiAgICB9O1xuICAgIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjZGF0YScsIGRlZik7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLCAnYWRkQXR0cmlidXRlJywge1xuICAvKipcbiAgICogQWRkcyBhbiBwYXR0ZXJuIHRvIGhpZ2hsaWdodCBsYW5ndWFnZXMgZW1iZWRkZWQgaW4gSFRNTCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBBbiBleGFtcGxlIG9mIGFuIGlubGluZWQgbGFuZ3VhZ2UgaXMgQ1NTIHdpdGggYHN0eWxlYCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ck5hbWUgVGhlIG5hbWUgb2YgdGhlIHRhZyB0aGF0IGNvbnRhaW5zIHRoZSBpbmxpbmVkIGxhbmd1YWdlLiBUaGlzIG5hbWUgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAqIGNhc2UgaW5zZW5zaXRpdmUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5nIFRoZSBsYW5ndWFnZSBrZXkuXG4gICAqIEBleGFtcGxlXG4gICAqIGFkZEF0dHJpYnV0ZSgnc3R5bGUnLCAnY3NzJyk7XG4gICAqL1xuICB2YWx1ZTogZnVuY3Rpb24gKGF0dHJOYW1lLCBsYW5nKSB7XG4gICAgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuaW5zaWRlWydzcGVjaWFsLWF0dHInXS5wdXNoKHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKF58W1wiJ1xcc10pLy5zb3VyY2UgKyAnKD86JyArIGF0dHJOYW1lICsgJyknICsgL1xccyo9XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSsoPz1bXFxzPl0pKS8uc291cmNlLCAnaScpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnYXR0ci1uYW1lJzogL15bXlxccz1dKy8sXG4gICAgICAgICdhdHRyLXZhbHVlJzoge1xuICAgICAgICAgIHBhdHRlcm46IC89W1xcc1xcU10rLyxcbiAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgICd2YWx1ZSc6IHtcbiAgICAgICAgICAgICAgcGF0dGVybjogLyhePVxccyooW1wiJ118KD8hW1wiJ10pKSlcXFNbXFxzXFxTXSooPz1cXDIkKS8sXG4gICAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgICAgIGFsaWFzOiBbbGFuZywgJ2xhbmd1YWdlLScgKyBsYW5nXSxcbiAgICAgICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXNbbGFuZ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncHVuY3R1YXRpb24nOiBbe1xuICAgICAgICAgICAgICBwYXR0ZXJuOiAvXj0vLFxuICAgICAgICAgICAgICBhbGlhczogJ2F0dHItZXF1YWxzJ1xuICAgICAgICAgICAgfSwgL1wifCcvXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59KTtcblByaXNtLmxhbmd1YWdlcy5odG1sID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblByaXNtLmxhbmd1YWdlcy5tYXRobWwgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuUHJpc20ubGFuZ3VhZ2VzLnN2ZyA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5QcmlzbS5sYW5ndWFnZXMueG1sID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnbWFya3VwJywge30pO1xuUHJpc20ubGFuZ3VhZ2VzLnNzbWwgPSBQcmlzbS5sYW5ndWFnZXMueG1sO1xuUHJpc20ubGFuZ3VhZ2VzLmF0b20gPSBQcmlzbS5sYW5ndWFnZXMueG1sO1xuUHJpc20ubGFuZ3VhZ2VzLnJzcyA9IFByaXNtLmxhbmd1YWdlcy54bWw7XG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIHZhciBzdHJpbmcgPSAvKD86XCIoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlwiXFxcXFxcclxcbl0pKlwifCcoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXidcXFxcXFxyXFxuXSkqJykvO1xuICBQcmlzbS5sYW5ndWFnZXMuY3NzID0ge1xuICAgICdjb21tZW50JzogL1xcL1xcKltcXHNcXFNdKj9cXCpcXC8vLFxuICAgICdhdHJ1bGUnOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJ0BbXFxcXHctXSg/OicgKyAvW147e1xcc1wiJ118XFxzKyg/IVxccykvLnNvdXJjZSArICd8JyArIHN0cmluZy5zb3VyY2UgKyAnKSo/JyArIC8oPzo7fCg/PVxccypcXHspKS8uc291cmNlKSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncnVsZSc6IC9eQFtcXHctXSsvLFxuICAgICAgICAnc2VsZWN0b3ItZnVuY3Rpb24tYXJndW1lbnQnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyhcXGJzZWxlY3RvclxccypcXChcXHMqKD8hW1xccyldKSkoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXCgoPzpbXigpXXxcXChbXigpXSpcXCkpKlxcKSkrKD89XFxzKlxcKSkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgYWxpYXM6ICdzZWxlY3RvcidcbiAgICAgICAgfSxcbiAgICAgICAgJ2tleXdvcmQnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyhefFteXFx3LV0pKD86YW5kfG5vdHxvbmx5fG9yKSg/IVtcXHctXSkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgcmVzdCBiZWxvd1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3VybCc6IHtcbiAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXFxcXGJ1cmxcXFxcKCg/OicgKyBzdHJpbmcuc291cmNlICsgJ3wnICsgLyg/OlteXFxcXFxcclxcbigpXCInXXxcXFxcW1xcc1xcU10pKi8uc291cmNlICsgJylcXFxcKScsICdpJyksXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2Z1bmN0aW9uJzogL151cmwvaSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL15cXCh8XFwpJC8sXG4gICAgICAgICdzdHJpbmcnOiB7XG4gICAgICAgICAgcGF0dGVybjogUmVnRXhwKCdeJyArIHN0cmluZy5zb3VyY2UgKyAnJCcpLFxuICAgICAgICAgIGFsaWFzOiAndXJsJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnc2VsZWN0b3InOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJyhefFt7fVxcXFxzXSlbXnt9XFxcXHNdKD86W157fTtcIlxcJ1xcXFxzXXxcXFxccysoPyFbXFxcXHN7XSl8JyArIHN0cmluZy5zb3VyY2UgKyAnKSooPz1cXFxccypcXFxceyknKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdzdHJpbmcnOiB7XG4gICAgICBwYXR0ZXJuOiBzdHJpbmcsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdwcm9wZXJ0eSc6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXi1cXHdcXHhBMC1cXHVGRkZGXSkoPyFcXHMpWy1fYS16XFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWy1cXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKjopL2ksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnaW1wb3J0YW50JzogLyFpbXBvcnRhbnRcXGIvaSxcbiAgICAnZnVuY3Rpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W14tYS16MC05XSlbLWEtejAtOV0rKD89XFwoKS9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ3B1bmN0dWF0aW9uJzogL1soKXt9OzosXS9cbiAgfTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmNzc1snYXRydWxlJ10uaW5zaWRlLnJlc3QgPSBQcmlzbS5sYW5ndWFnZXMuY3NzO1xuICB2YXIgbWFya3VwID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcbiAgaWYgKG1hcmt1cCkge1xuICAgIG1hcmt1cC50YWcuYWRkSW5saW5lZCgnc3R5bGUnLCAnY3NzJyk7XG4gICAgbWFya3VwLnRhZy5hZGRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2NzcycpO1xuICB9XG59KShQcmlzbSk7XG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIFByaXNtLmxhbmd1YWdlcy5kaWZmID0ge1xuICAgICdjb29yZCc6IFtcbiAgICAvLyBNYXRjaCBhbGwga2luZHMgb2YgY29vcmQgbGluZXMgKHByZWZpeGVkIGJ5IFwiKysrXCIsIFwiLS0tXCIgb3IgXCIqKipcIikuXG4gICAgL14oPzpcXCp7M318LXszfXxcXCt7M30pLiokL20sXG4gICAgLy8gTWF0Y2ggXCJAQCAuLi4gQEBcIiBjb29yZCBsaW5lcyBpbiB1bmlmaWVkIGRpZmYuXG4gICAgL15AQC4qQEAkL20sXG4gICAgLy8gTWF0Y2ggY29vcmQgbGluZXMgaW4gbm9ybWFsIGRpZmYgKHN0YXJ0cyB3aXRoIGEgbnVtYmVyKS5cbiAgICAvXlxcZC4qJC9tXVxuXG4gICAgLy8gZGVsZXRlZCwgaW5zZXJ0ZWQsIHVuY2hhbmdlZCwgZGlmZlxuICB9O1xuXG4gIC8qKlxuICAgKiBBIG1hcCBmcm9tIHRoZSBuYW1lIG9mIGEgYmxvY2sgdG8gaXRzIGxpbmUgcHJlZml4LlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn1cbiAgICovXG4gIHZhciBQUkVGSVhFUyA9IHtcbiAgICAnZGVsZXRlZC1zaWduJzogJy0nLFxuICAgICdkZWxldGVkLWFycm93JzogJzwnLFxuICAgICdpbnNlcnRlZC1zaWduJzogJysnLFxuICAgICdpbnNlcnRlZC1hcnJvdyc6ICc+JyxcbiAgICAndW5jaGFuZ2VkJzogJyAnLFxuICAgICdkaWZmJzogJyEnXG4gIH07XG5cbiAgLy8gYWRkIGEgdG9rZW4gZm9yIGVhY2ggcHJlZml4XG4gIE9iamVjdC5rZXlzKFBSRUZJWEVTKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHByZWZpeCA9IFBSRUZJWEVTW25hbWVdO1xuICAgIHZhciBhbGlhcyA9IFtdO1xuICAgIGlmICghL15cXHcrJC8udGVzdChuYW1lKSkge1xuICAgICAgLy8gXCJkZWxldGVkLXNpZ25cIiAtPiBcImRlbGV0ZWRcIlxuICAgICAgYWxpYXMucHVzaCgvXFx3Ky8uZXhlYyhuYW1lKVswXSk7XG4gICAgfVxuICAgIGlmIChuYW1lID09PSAnZGlmZicpIHtcbiAgICAgIGFsaWFzLnB1c2goJ2JvbGQnKTtcbiAgICB9XG4gICAgUHJpc20ubGFuZ3VhZ2VzLmRpZmZbbmFtZV0gPSB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJ14oPzpbJyArIHByZWZpeCArICddLiooPzpcXHJcXG4/fFxcbnwoPyFbXFxcXHNcXFxcU10pKSkrJywgJ20nKSxcbiAgICAgIGFsaWFzOiBhbGlhcyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnbGluZSc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKC4pKD89W1xcc1xcU10pLiooPzpcXHJcXG4/fFxcbik/LyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICdwcmVmaXgnOiB7XG4gICAgICAgICAgcGF0dGVybjogL1tcXHNcXFNdLyxcbiAgICAgICAgICBhbGlhczogL1xcdysvLmV4ZWMobmFtZSlbMF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIC8vIG1ha2UgcHJlZml4ZXMgYXZhaWxhYmxlIHRvIERpZmYgcGx1Z2luXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcmlzbS5sYW5ndWFnZXMuZGlmZiwgJ1BSRUZJWEVTJywge1xuICAgIHZhbHVlOiBQUkVGSVhFU1xuICB9KTtcbn0pKFByaXNtKTtcblByaXNtLmxhbmd1YWdlcy5nbyA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NsaWtlJywge1xuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKVwiKD86XFxcXC58W15cIlxcXFxcXHJcXG5dKSpcInxgW15gXSpgLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAna2V5d29yZCc6IC9cXGIoPzpicmVha3xjYXNlfGNoYW58Y29uc3R8Y29udGludWV8ZGVmYXVsdHxkZWZlcnxlbHNlfGZhbGx0aHJvdWdofGZvcnxmdW5jfGdvKD86dG8pP3xpZnxpbXBvcnR8aW50ZXJmYWNlfG1hcHxwYWNrYWdlfHJhbmdlfHJldHVybnxzZWxlY3R8c3RydWN0fHN3aXRjaHx0eXBlfHZhcilcXGIvLFxuICAnYm9vbGVhbic6IC9cXGIoPzpffGZhbHNlfGlvdGF8bmlsfHRydWUpXFxiLyxcbiAgJ251bWJlcic6IFtcbiAgLy8gYmluYXJ5IGFuZCBvY3RhbCBpbnRlZ2Vyc1xuICAvXFxiMCg/OmJbMDFfXSt8b1swLTdfXSspaT9cXGIvaSxcbiAgLy8gaGV4YWRlY2ltYWwgaW50ZWdlcnMgYW5kIGZsb2F0c1xuICAvXFxiMHgoPzpbYS1mXFxkX10rKD86XFwuW2EtZlxcZF9dKik/fFxcLlthLWZcXGRfXSspKD86cFsrLV0/XFxkKyg/Ol9cXGQrKSopP2k/KD8hXFx3KS9pLFxuICAvLyBkZWNpbWFsIGludGVnZXJzIGFuZCBmbG9hdHNcbiAgLyg/OlxcYlxcZFtcXGRfXSooPzpcXC5bXFxkX10qKT98XFxCXFwuXFxkW1xcZF9dKikoPzplWystXT9bXFxkX10rKT9pPyg/IVxcdykvaV0sXG4gICdvcGVyYXRvcic6IC9bKlxcLyVeIT1dPT98XFwrWz0rXT98LVs9LV0/fFxcfFs9fF0/fCYoPzo9fCZ8XFxePT8pP3w+KD86Pj0/fD0pP3w8KD86PD0/fD18LSk/fDo9fFxcLlxcLlxcLi8sXG4gICdidWlsdGluJzogL1xcYig/OmFwcGVuZHxib29sfGJ5dGV8Y2FwfGNsb3NlfGNvbXBsZXh8Y29tcGxleCg/OjY0fDEyOCl8Y29weXxkZWxldGV8ZXJyb3J8ZmxvYXQoPzozMnw2NCl8dT9pbnQoPzo4fDE2fDMyfDY0KT98aW1hZ3xsZW58bWFrZXxuZXd8cGFuaWN8cHJpbnQoPzpsbik/fHJlYWx8cmVjb3ZlcnxydW5lfHN0cmluZ3x1aW50cHRyKVxcYi9cbn0pO1xuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnZ28nLCAnc3RyaW5nJywge1xuICAnY2hhcic6IHtcbiAgICBwYXR0ZXJuOiAvJyg/OlxcXFwufFteJ1xcXFxcXHJcXG5dKXswLDEwfScvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9XG59KTtcbmRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMuZ29bJ2NsYXNzLW5hbWUnXTtcblByaXNtLmxhbmd1YWdlcy5pbmkgPSB7XG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IG1pbWljcyB0aGUgYmVoYXZpb3Igb2YgdGhlIFdpbjMyIEFQSSBwYXJzZXIuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9QcmlzbUpTL3ByaXNtL2lzc3Vlcy8yNzc1I2lzc3VlY29tbWVudC03ODc0Nzc3MjN9XG4gICAqL1xuXG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC8oXlsgXFxmXFx0XFx2XSopWyM7XVteXFxuXFxyXSovbSxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdzZWN0aW9uJzoge1xuICAgIHBhdHRlcm46IC8oXlsgXFxmXFx0XFx2XSopXFxbW15cXG5cXHJcXF1dKlxcXT8vbSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ3NlY3Rpb24tbmFtZSc6IHtcbiAgICAgICAgcGF0dGVybjogLyheXFxbWyBcXGZcXHRcXHZdKilbXiBcXGZcXHRcXHZcXF1dKyg/OlsgXFxmXFx0XFx2XStbXiBcXGZcXHRcXHZcXF1dKykqLyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgYWxpYXM6ICdzZWxlY3RvcidcbiAgICAgIH0sXG4gICAgICAncHVuY3R1YXRpb24nOiAvXFxbfFxcXS9cbiAgICB9XG4gIH0sXG4gICdrZXknOiB7XG4gICAgcGF0dGVybjogLyheWyBcXGZcXHRcXHZdKilbXiBcXGZcXG5cXHJcXHRcXHY9XSsoPzpbIFxcZlxcdFxcdl0rW14gXFxmXFxuXFxyXFx0XFx2PV0rKSooPz1bIFxcZlxcdFxcdl0qPSkvbSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiAnYXR0ci1uYW1lJ1xuICB9LFxuICAndmFsdWUnOiB7XG4gICAgcGF0dGVybjogLyg9WyBcXGZcXHRcXHZdKilbXiBcXGZcXG5cXHJcXHRcXHZdKyg/OlsgXFxmXFx0XFx2XStbXiBcXGZcXG5cXHJcXHRcXHZdKykqLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiAnYXR0ci12YWx1ZScsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnaW5uZXItdmFsdWUnOiB7XG4gICAgICAgIHBhdHRlcm46IC9eKFwifCcpLisoPz1cXDEkKS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICdwdW5jdHVhdGlvbic6IC89L1xufTtcbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgdmFyIGtleXdvcmRzID0gL1xcYig/OmFic3RyYWN0fGFzc2VydHxib29sZWFufGJyZWFrfGJ5dGV8Y2FzZXxjYXRjaHxjaGFyfGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlZmF1bHR8ZG98ZG91YmxlfGVsc2V8ZW51bXxleHBvcnRzfGV4dGVuZHN8ZmluYWx8ZmluYWxseXxmbG9hdHxmb3J8Z290b3xpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnN0YW5jZW9mfGludHxpbnRlcmZhY2V8bG9uZ3xtb2R1bGV8bmF0aXZlfG5ld3xub24tc2VhbGVkfG51bGx8b3BlbnxvcGVuc3xwYWNrYWdlfHBlcm1pdHN8cHJpdmF0ZXxwcm90ZWN0ZWR8cHJvdmlkZXN8cHVibGljfHJlY29yZCg/IVxccypbKCl7fVtcXF08Pj0lfi46LDs/K1xcLSovJnxeXSl8cmVxdWlyZXN8cmV0dXJufHNlYWxlZHxzaG9ydHxzdGF0aWN8c3RyaWN0ZnB8c3VwZXJ8c3dpdGNofHN5bmNocm9uaXplZHx0aGlzfHRocm93fHRocm93c3x0b3x0cmFuc2llbnR8dHJhbnNpdGl2ZXx0cnl8dXNlc3x2YXJ8dm9pZHx2b2xhdGlsZXx3aGlsZXx3aXRofHlpZWxkKVxcYi87XG5cbiAgLy8gZnVsbCBwYWNrYWdlIChvcHRpb25hbCkgKyBwYXJlbnQgY2xhc3NlcyAob3B0aW9uYWwpXG4gIHZhciBjbGFzc05hbWVQcmVmaXggPSAvKD86W2Etel1cXHcqXFxzKlxcLlxccyopKig/OltBLVpdXFx3KlxccypcXC5cXHMqKSovLnNvdXJjZTtcblxuICAvLyBiYXNlZCBvbiB0aGUgamF2YSBuYW1pbmcgY29udmVudGlvbnNcbiAgdmFyIGNsYXNzTmFtZSA9IHtcbiAgICBwYXR0ZXJuOiBSZWdFeHAoLyhefFteXFx3Ll0pLy5zb3VyY2UgKyBjbGFzc05hbWVQcmVmaXggKyAvW0EtWl0oPzpbXFxkX0EtWl0qW2Etel1cXHcqKT9cXGIvLnNvdXJjZSksXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICduYW1lc3BhY2UnOiB7XG4gICAgICAgIHBhdHRlcm46IC9eW2Etel1cXHcqKD86XFxzKlxcLlxccypbYS16XVxcdyopKig/OlxccypcXC4pPy8sXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9cXC4vXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAncHVuY3R1YXRpb24nOiAvXFwuL1xuICAgIH1cbiAgfTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmphdmEgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcbiAgICAnc3RyaW5nJzoge1xuICAgICAgcGF0dGVybjogLyhefFteXFxcXF0pXCIoPzpcXFxcLnxbXlwiXFxcXFxcclxcbl0pKlwiLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdjbGFzcy1uYW1lJzogW2NsYXNzTmFtZSwge1xuICAgICAgLy8gdmFyaWFibGVzLCBwYXJhbWV0ZXJzLCBhbmQgY29uc3RydWN0b3IgcmVmZXJlbmNlc1xuICAgICAgLy8gdGhpcyB0byBzdXBwb3J0IGNsYXNzIG5hbWVzIChvciBnZW5lcmljIHBhcmFtZXRlcnMpIHdoaWNoIGRvIG5vdCBjb250YWluIGEgbG93ZXIgY2FzZSBsZXR0ZXIgKGFsc28gd29ya3MgZm9yIG1ldGhvZHMpXG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyhefFteXFx3Ll0pLy5zb3VyY2UgKyBjbGFzc05hbWVQcmVmaXggKyAvW0EtWl1cXHcqKD89XFxzK1xcdytcXHMqWzssPSgpXXxcXHMqKD86XFxbW1xccyxdKlxcXVxccyopPzo6XFxzKm5ld1xcYikvLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiBjbGFzc05hbWUuaW5zaWRlXG4gICAgfSwge1xuICAgICAgLy8gY2xhc3MgbmFtZXMgYmFzZWQgb24ga2V5d29yZFxuICAgICAgLy8gdGhpcyB0byBzdXBwb3J0IGNsYXNzIG5hbWVzIChvciBnZW5lcmljIHBhcmFtZXRlcnMpIHdoaWNoIGRvIG5vdCBjb250YWluIGEgbG93ZXIgY2FzZSBsZXR0ZXIgKGFsc28gd29ya3MgZm9yIG1ldGhvZHMpXG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyhcXGIoPzpjbGFzc3xlbnVtfGV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfGludGVyZmFjZXxuZXd8cmVjb3JkfHRocm93cylcXHMrKS8uc291cmNlICsgY2xhc3NOYW1lUHJlZml4ICsgL1tBLVpdXFx3KlxcYi8uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IGNsYXNzTmFtZS5pbnNpZGVcbiAgICB9XSxcbiAgICAna2V5d29yZCc6IGtleXdvcmRzLFxuICAgICdmdW5jdGlvbic6IFtQcmlzbS5sYW5ndWFnZXMuY2xpa2UuZnVuY3Rpb24sIHtcbiAgICAgIHBhdHRlcm46IC8oOjpcXHMqKVthLXpfXVxcdyovLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH1dLFxuICAgICdudW1iZXInOiAvXFxiMGJbMDFdWzAxX10qTD9cXGJ8XFxiMHgoPzpcXC5bXFxkYS1mX3ArLV0rfFtcXGRhLWZfXSsoPzpcXC5bXFxkYS1mX3ArLV0rKT8pXFxifCg/OlxcYlxcZFtcXGRfXSooPzpcXC5bXFxkX10qKT98XFxCXFwuXFxkW1xcZF9dKikoPzplWystXT9cXGRbXFxkX10qKT9bZGZsXT8vaSxcbiAgICAnb3BlcmF0b3InOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W14uXSkoPzo8PD0/fD4+Pj89P3wtPnwtLXxcXCtcXCt8JiZ8XFx8XFx8fDo6fFs/On5dfFstKyovJSZ8XiE9PD5dPT8pL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnY29uc3RhbnQnOiAvXFxiW0EtWl1bQS1aX1xcZF0rXFxiL1xuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YScsICdzdHJpbmcnLCB7XG4gICAgJ3RyaXBsZS1xdW90ZWQtc3RyaW5nJzoge1xuICAgICAgLy8gaHR0cDovL29wZW5qZGsuamF2YS5uZXQvamVwcy8zNTUjRGVzY3JpcHRpb25cbiAgICAgIHBhdHRlcm46IC9cIlwiXCJbIFxcdF0qW1xcclxcbl0oPzooPzpcInxcIlwiKT8oPzpcXFxcLnxbXlwiXFxcXF0pKSpcIlwiXCIvLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgYWxpYXM6ICdzdHJpbmcnXG4gICAgfSxcbiAgICAnY2hhcic6IHtcbiAgICAgIHBhdHRlcm46IC8nKD86XFxcXC58W14nXFxcXFxcclxcbl0pezEsNn0nLyxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmEnLCAnY2xhc3MtbmFtZScsIHtcbiAgICAnYW5ub3RhdGlvbic6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXi5dKUBcXHcrKD86XFxzKlxcLlxccypcXHcrKSovLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgfSxcbiAgICAnZ2VuZXJpY3MnOiB7XG4gICAgICBwYXR0ZXJuOiAvPCg/OltcXHdcXHMsLj9dfCYoPyEmKXw8KD86W1xcd1xccywuP118Jig/ISYpfDwoPzpbXFx3XFxzLC4/XXwmKD8hJil8PCg/OltcXHdcXHMsLj9dfCYoPyEmKSkqPikqPikqPikqPi8sXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2NsYXNzLW5hbWUnOiBjbGFzc05hbWUsXG4gICAgICAgICdrZXl3b3JkJzoga2V5d29yZHMsXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9bPD4oKSwuOl0vLFxuICAgICAgICAnb3BlcmF0b3InOiAvWz8mfF0vXG4gICAgICB9XG4gICAgfSxcbiAgICAnaW1wb3J0JzogW3tcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKFxcYmltcG9ydFxccyspLy5zb3VyY2UgKyBjbGFzc05hbWVQcmVmaXggKyAvKD86W0EtWl1cXHcqfFxcKikoPz1cXHMqOykvLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICduYW1lc3BhY2UnOiBjbGFzc05hbWUuaW5zaWRlLm5hbWVzcGFjZSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcLi8sXG4gICAgICAgICdvcGVyYXRvcic6IC9cXCovLFxuICAgICAgICAnY2xhc3MtbmFtZSc6IC9cXHcrL1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKFxcYmltcG9ydFxccytzdGF0aWNcXHMrKS8uc291cmNlICsgY2xhc3NOYW1lUHJlZml4ICsgLyg/Olxcdyt8XFwqKSg/PVxccyo7KS8uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ3N0YXRpYycsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ25hbWVzcGFjZSc6IGNsYXNzTmFtZS5pbnNpZGUubmFtZXNwYWNlLFxuICAgICAgICAnc3RhdGljJzogL1xcYlxcdyskLyxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcLi8sXG4gICAgICAgICdvcGVyYXRvcic6IC9cXCovLFxuICAgICAgICAnY2xhc3MtbmFtZSc6IC9cXHcrL1xuICAgICAgfVxuICAgIH1dLFxuICAgICduYW1lc3BhY2UnOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyhcXGIoPzpleHBvcnRzfGltcG9ydCg/OlxccytzdGF0aWMpP3xtb2R1bGV8b3BlbnxvcGVuc3xwYWNrYWdlfHByb3ZpZGVzfHJlcXVpcmVzfHRvfHRyYW5zaXRpdmV8dXNlc3x3aXRoKVxccyspKD8hPGtleXdvcmQ+KVthLXpdXFx3Kig/OlxcLlthLXpdXFx3KikqXFwuPy8uc291cmNlLnJlcGxhY2UoLzxrZXl3b3JkPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBrZXl3b3Jkcy5zb3VyY2U7XG4gICAgICB9KSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9cXC4vXG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pKFByaXNtKTtcbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgdmFyIHNwZWNpYWxFc2NhcGUgPSB7XG4gICAgcGF0dGVybjogL1xcXFxbXFxcXCgpe31bXFxdXiQrKj98Ll0vLFxuICAgIGFsaWFzOiAnZXNjYXBlJ1xuICB9O1xuICB2YXIgZXNjYXBlID0gL1xcXFwoPzp4W1xcZGEtZkEtRl17Mn18dVtcXGRhLWZBLUZdezR9fHVcXHtbXFxkYS1mQS1GXStcXH18MFswLTddezAsMn18WzEyM11bMC03XXsyfXxjW2EtekEtWl18LikvO1xuICB2YXIgY2hhclNldCA9IHtcbiAgICBwYXR0ZXJuOiAvXFwufFxcXFxbd3NkXXxcXFxccFxce1tee31dK1xcfS9pLFxuICAgIGFsaWFzOiAnY2xhc3MtbmFtZSdcbiAgfTtcbiAgdmFyIGNoYXJTZXRXaXRob3V0RG90ID0ge1xuICAgIHBhdHRlcm46IC9cXFxcW3dzZF18XFxcXHBcXHtbXnt9XStcXH0vaSxcbiAgICBhbGlhczogJ2NsYXNzLW5hbWUnXG4gIH07XG4gIHZhciByYW5nZUNoYXIgPSAnKD86W15cXFxcXFxcXC1dfCcgKyBlc2NhcGUuc291cmNlICsgJyknO1xuICB2YXIgcmFuZ2UgPSBSZWdFeHAocmFuZ2VDaGFyICsgJy0nICsgcmFuZ2VDaGFyKTtcblxuICAvLyB0aGUgbmFtZSBvZiBhIGNhcHR1cmluZyBncm91cFxuICB2YXIgZ3JvdXBOYW1lID0ge1xuICAgIHBhdHRlcm46IC8oPHwnKVtePD4nXSsoPz1bPiddJCkvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgYWxpYXM6ICd2YXJpYWJsZSdcbiAgfTtcbiAgUHJpc20ubGFuZ3VhZ2VzLnJlZ2V4ID0ge1xuICAgICdjaGFyLWNsYXNzJzoge1xuICAgICAgcGF0dGVybjogLygoPzpefFteXFxcXF0pKD86XFxcXFxcXFwpKilcXFsoPzpbXlxcXFxcXF1dfFxcXFxbXFxzXFxTXSkqXFxdLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2NoYXItY2xhc3MtbmVnYXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogLyheXFxbKVxcXi8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBhbGlhczogJ29wZXJhdG9yJ1xuICAgICAgICB9LFxuICAgICAgICAnY2hhci1jbGFzcy1wdW5jdHVhdGlvbic6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXlxcW3xcXF0kLyxcbiAgICAgICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgICAgICB9LFxuICAgICAgICAncmFuZ2UnOiB7XG4gICAgICAgICAgcGF0dGVybjogcmFuZ2UsXG4gICAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgICAnZXNjYXBlJzogZXNjYXBlLFxuICAgICAgICAgICAgJ3JhbmdlLXB1bmN0dWF0aW9uJzoge1xuICAgICAgICAgICAgICBwYXR0ZXJuOiAvLS8sXG4gICAgICAgICAgICAgIGFsaWFzOiAnb3BlcmF0b3InXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAnc3BlY2lhbC1lc2NhcGUnOiBzcGVjaWFsRXNjYXBlLFxuICAgICAgICAnY2hhci1zZXQnOiBjaGFyU2V0V2l0aG91dERvdCxcbiAgICAgICAgJ2VzY2FwZSc6IGVzY2FwZVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3NwZWNpYWwtZXNjYXBlJzogc3BlY2lhbEVzY2FwZSxcbiAgICAnY2hhci1zZXQnOiBjaGFyU2V0LFxuICAgICdiYWNrcmVmZXJlbmNlJzogW3tcbiAgICAgIC8vIGEgYmFja3JlZmVyZW5jZSB3aGljaCBpcyBub3QgYW4gb2N0YWwgZXNjYXBlXG4gICAgICBwYXR0ZXJuOiAvXFxcXCg/IVsxMjNdWzAtN117Mn0pWzEtOV0vLFxuICAgICAgYWxpYXM6ICdrZXl3b3JkJ1xuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC9cXFxcazxbXjw+J10rPi8sXG4gICAgICBhbGlhczogJ2tleXdvcmQnLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdncm91cC1uYW1lJzogZ3JvdXBOYW1lXG4gICAgICB9XG4gICAgfV0sXG4gICAgJ2FuY2hvcic6IHtcbiAgICAgIHBhdHRlcm46IC9bJF5dfFxcXFxbQUJiR1p6XS8sXG4gICAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICAgIH0sXG4gICAgJ2VzY2FwZSc6IGVzY2FwZSxcbiAgICAnZ3JvdXAnOiBbe1xuICAgICAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzEwL2RvY3MvYXBpL2phdmEvdXRpbC9yZWdleC9QYXR0ZXJuLmh0bWxcbiAgICAgIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9zdGFuZGFyZC9iYXNlLXR5cGVzL3JlZ3VsYXItZXhwcmVzc2lvbi1sYW5ndWFnZS1xdWljay1yZWZlcmVuY2U/dmlldz1uZXRmcmFtZXdvcmstNC43LjIjZ3JvdXBpbmctY29uc3RydWN0c1xuXG4gICAgICAvLyAoKSwgKD88bmFtZT4pLCAoPyduYW1lJyksICg/PiksICg/OiksICg/PSksICg/ISksICg/PD0pLCAoPzwhKSwgKD9pcy1tKSwgKD9pLW06KVxuICAgICAgcGF0dGVybjogL1xcKCg/OlxcPyg/OjxbXjw+J10rPnwnW148PiddKyd8Wz46XXw8P1s9IV18W2lkbW5zdXhVXSsoPzotW2lkbW5zdXhVXSspPzo/KSk/LyxcbiAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdncm91cC1uYW1lJzogZ3JvdXBOYW1lXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcGF0dGVybjogL1xcKS8sXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgIH1dLFxuICAgICdxdWFudGlmaWVyJzoge1xuICAgICAgcGF0dGVybjogLyg/OlsrKj9dfFxce1xcZCsoPzosXFxkKik/XFx9KVs/K10/LyxcbiAgICAgIGFsaWFzOiAnbnVtYmVyJ1xuICAgIH0sXG4gICAgJ2FsdGVybmF0aW9uJzoge1xuICAgICAgcGF0dGVybjogL1xcfC8sXG4gICAgICBhbGlhczogJ2tleXdvcmQnXG4gICAgfVxuICB9O1xufSkoUHJpc20pO1xuUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcbiAgJ2NsYXNzLW5hbWUnOiBbUHJpc20ubGFuZ3VhZ2VzLmNsaWtlWydjbGFzcy1uYW1lJ10sIHtcbiAgICBwYXR0ZXJuOiAvKF58W14kXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVtfJEEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxcLig/OmNvbnN0cnVjdG9yfHByb3RvdHlwZSkpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH1dLFxuICAna2V5d29yZCc6IFt7XG4gICAgcGF0dGVybjogLygoPzpefFxcfSlcXHMqKWNhdGNoXFxiLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKF58W14uXXxcXC5cXC5cXC5cXHMqKVxcYig/OmFzfGFzc2VydCg/PVxccypcXHspfGFzeW5jKD89XFxzKig/OmZ1bmN0aW9uXFxifFxcKHxbJFxcd1xceEEwLVxcdUZGRkZdfCQpKXxhd2FpdHxicmVha3xjYXNlfGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmaW5hbGx5KD89XFxzKig/Olxce3wkKSl8Zm9yfGZyb20oPz1cXHMqKD86WydcIl18JCkpfGZ1bmN0aW9ufCg/OmdldHxzZXQpKD89XFxzKig/OlsjXFxbJFxcd1xceEEwLVxcdUZGRkZdfCQpKXxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxsZXR8bmV3fG51bGx8b2Z8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmV0dXJufHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnl8dHlwZW9mfHVuZGVmaW5lZHx2YXJ8dm9pZHx3aGlsZXx3aXRofHlpZWxkKVxcYi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9XSxcbiAgLy8gQWxsb3cgZm9yIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycyAoU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIwMDg0NDQpXG4gICdmdW5jdGlvbic6IC8jPyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqKD86XFwuXFxzKig/OmFwcGx5fGJpbmR8Y2FsbClcXHMqKT9cXCgpLyxcbiAgJ251bWJlcic6IHtcbiAgICBwYXR0ZXJuOiBSZWdFeHAoLyhefFteXFx3JF0pLy5zb3VyY2UgKyAnKD86JyArIChcbiAgICAvLyBjb25zdGFudFxuICAgIC9OYU58SW5maW5pdHkvLnNvdXJjZSArICd8JyArXG4gICAgLy8gYmluYXJ5IGludGVnZXJcbiAgICAvMFtiQl1bMDFdKyg/Ol9bMDFdKykqbj8vLnNvdXJjZSArICd8JyArXG4gICAgLy8gb2N0YWwgaW50ZWdlclxuICAgIC8wW29PXVswLTddKyg/Ol9bMC03XSspKm4/Ly5zb3VyY2UgKyAnfCcgK1xuICAgIC8vIGhleGFkZWNpbWFsIGludGVnZXJcbiAgICAvMFt4WF1bXFxkQS1GYS1mXSsoPzpfW1xcZEEtRmEtZl0rKSpuPy8uc291cmNlICsgJ3wnICtcbiAgICAvLyBkZWNpbWFsIGJpZ2ludFxuICAgIC9cXGQrKD86X1xcZCspKm4vLnNvdXJjZSArICd8JyArXG4gICAgLy8gZGVjaW1hbCBudW1iZXIgKGludGVnZXIgb3IgZmxvYXQpIGJ1dCBubyBiaWdpbnRcbiAgICAvKD86XFxkKyg/Ol9cXGQrKSooPzpcXC4oPzpcXGQrKD86X1xcZCspKik/KT98XFwuXFxkKyg/Ol9cXGQrKSopKD86W0VlXVsrLV0/XFxkKyg/Ol9cXGQrKSopPy8uc291cmNlKSArICcpJyArIC8oPyFbXFx3JF0pLy5zb3VyY2UpLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ29wZXJhdG9yJzogLy0tfFxcK1xcK3xcXCpcXCo9P3w9PnwmJj0/fFxcfFxcfD0/fFshPV09PXw8PD0/fD4+Pj89P3xbLSsqLyUmfF4hPTw+XT0/fFxcLnszfXxcXD9cXD89P3xcXD9cXC4/fFt+Ol0vXG59KTtcblByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0WydjbGFzcy1uYW1lJ11bMF0ucGF0dGVybiA9IC8oXFxiKD86Y2xhc3N8ZXh0ZW5kc3xpbXBsZW1lbnRzfGluc3RhbmNlb2Z8aW50ZXJmYWNlfG5ldylcXHMrKVtcXHcuXFxcXF0rLztcblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAna2V5d29yZCcsIHtcbiAgJ3JlZ2V4Jzoge1xuICAgIHBhdHRlcm46IFJlZ0V4cChcbiAgICAvLyBsb29rYmVoaW5kXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby1kdXBlLWNoYXJhY3RlcnMtY2hhcmFjdGVyLWNsYXNzXG4gICAgLygoPzpefFteJFxcd1xceEEwLVxcdUZGRkYuXCInXFxdKVxcc118XFxiKD86cmV0dXJufHlpZWxkKSlcXHMqKS8uc291cmNlICtcbiAgICAvLyBSZWdleCBwYXR0ZXJuOlxuICAgIC8vIFRoZXJlIGFyZSAyIHJlZ2V4IHBhdHRlcm5zIGhlcmUuIFRoZSBSZWdFeHAgc2V0IG5vdGF0aW9uIHByb3Bvc2FsIGFkZGVkIHN1cHBvcnQgZm9yIG5lc3RlZCBjaGFyYWN0ZXJcbiAgICAvLyBjbGFzc2VzIGlmIHRoZSBgdmAgZmxhZyBpcyBwcmVzZW50LiBVbmZvcnR1bmF0ZWx5LCBuZXN0ZWQgQ0NzIGFyZSBib3RoIGNvbnRleHQtZnJlZSBhbmQgaW5jb21wYXRpYmxlXG4gICAgLy8gd2l0aCB0aGUgb25seSBzeW50YXgsIHNvIHdlIGhhdmUgdG8gZGVmaW5lIDIgZGlmZmVyZW50IHJlZ2V4IHBhdHRlcm5zLlxuICAgIC9cXC8vLnNvdXJjZSArICcoPzonICsgLyg/OlxcWyg/OlteXFxdXFxcXFxcclxcbl18XFxcXC4pKlxcXXxcXFxcLnxbXi9cXFxcXFxbXFxyXFxuXSkrXFwvW2RnaW15dXNdezAsN30vLnNvdXJjZSArICd8JyArXG4gICAgLy8gYHZgIGZsYWcgc3ludGF4LiBUaGlzIHN1cHBvcnRzIDMgbGV2ZWxzIG9mIG5lc3RlZCBjaGFyYWN0ZXIgY2xhc3Nlcy5cbiAgICAvKD86XFxbKD86W15bXFxdXFxcXFxcclxcbl18XFxcXC58XFxbKD86W15bXFxdXFxcXFxcclxcbl18XFxcXC58XFxbKD86W15bXFxdXFxcXFxcclxcbl18XFxcXC4pKlxcXSkqXFxdKSpcXF18XFxcXC58W14vXFxcXFxcW1xcclxcbl0pK1xcL1tkZ2lteXVzXXswLDd9dltkZ2lteXVzXXswLDd9Ly5zb3VyY2UgKyAnKScgK1xuICAgIC8vIGxvb2thaGVhZFxuICAgIC8oPz0oPzpcXHN8XFwvXFwqKD86W14qXXxcXCooPyFcXC8pKSpcXCpcXC8pKig/OiR8W1xcclxcbiwuOzp9KVxcXV18XFwvXFwvKSkvLnNvdXJjZSksXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAncmVnZXgtc291cmNlJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXihcXC8pW1xcc1xcU10rKD89XFwvW2Etel0qJCkvLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBhbGlhczogJ2xhbmd1YWdlLXJlZ2V4JyxcbiAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMucmVnZXhcbiAgICAgIH0sXG4gICAgICAncmVnZXgtZGVsaW1pdGVyJzogL15cXC98XFwvJC8sXG4gICAgICAncmVnZXgtZmxhZ3MnOiAvXlthLXpdKyQvXG4gICAgfVxuICB9LFxuICAvLyBUaGlzIG11c3QgYmUgZGVjbGFyZWQgYmVmb3JlIGtleXdvcmQgYmVjYXVzZSB3ZSB1c2UgXCJmdW5jdGlvblwiIGluc2lkZSB0aGUgbG9vay1mb3J3YXJkXG4gICdmdW5jdGlvbi12YXJpYWJsZSc6IHtcbiAgICBwYXR0ZXJuOiAvIz8oPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKls9Ol1cXHMqKD86YXN5bmNcXHMqKT8oPzpcXGJmdW5jdGlvblxcYnwoPzpcXCgoPzpbXigpXXxcXChbXigpXSpcXCkpKlxcKXwoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKVxccyo9PikpLyxcbiAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICB9LFxuICAncGFyYW1ldGVyJzogW3tcbiAgICBwYXR0ZXJuOiAvKGZ1bmN0aW9uKD86XFxzKyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSopP1xccypcXChcXHMqKSg/IVxccykoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXChbXigpXSpcXCkpKyg/PVxccypcXCkpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgfSwge1xuICAgIHBhdHRlcm46IC8oXnxbXiRcXHdcXHhBMC1cXHVGRkZGXSkoPyFcXHMpW18kYS16XFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKj0+KS9pLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICB9LCB7XG4gICAgcGF0dGVybjogLyhcXChcXHMqKSg/IVxccykoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXChbXigpXSpcXCkpKyg/PVxccypcXClcXHMqPT4pLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgfSwge1xuICAgIHBhdHRlcm46IC8oKD86XFxifFxcc3xeKSg/ISg/OmFzfGFzeW5jfGF3YWl0fGJyZWFrfGNhc2V8Y2F0Y2h8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZpbmFsbHl8Zm9yfGZyb218ZnVuY3Rpb258Z2V0fGlmfGltcGxlbWVudHN8aW1wb3J0fGlufGluc3RhbmNlb2Z8aW50ZXJmYWNlfGxldHxuZXd8bnVsbHxvZnxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZXR1cm58c2V0fHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnl8dHlwZW9mfHVuZGVmaW5lZHx2YXJ8dm9pZHx3aGlsZXx3aXRofHlpZWxkKSg/IVskXFx3XFx4QTAtXFx1RkZGRl0pKSg/Oig/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSpcXHMqKVxcKFxccyp8XFxdXFxzKlxcKFxccyopKD8hXFxzKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKFteKCldKlxcKSkrKD89XFxzKlxcKVxccypcXHspLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgfV0sXG4gICdjb25zdGFudCc6IC9cXGJbQS1aXSg/OltBLVpfXXxcXGR4PykqXFxiL1xufSk7XG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ3N0cmluZycsIHtcbiAgJ2hhc2hiYW5nJzoge1xuICAgIHBhdHRlcm46IC9eIyEuKi8sXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGFsaWFzOiAnY29tbWVudCdcbiAgfSxcbiAgJ3RlbXBsYXRlLXN0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvYCg/OlxcXFxbXFxzXFxTXXxcXCRcXHsoPzpbXnt9XXxcXHsoPzpbXnt9XXxcXHtbXn1dKlxcfSkqXFx9KStcXH18KD8hXFwkXFx7KVteXFxcXGBdKSpgLyxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAndGVtcGxhdGUtcHVuY3R1YXRpb24nOiB7XG4gICAgICAgIHBhdHRlcm46IC9eYHxgJC8sXG4gICAgICAgIGFsaWFzOiAnc3RyaW5nJ1xuICAgICAgfSxcbiAgICAgICdpbnRlcnBvbGF0aW9uJzoge1xuICAgICAgICBwYXR0ZXJuOiAvKCg/Ol58W15cXFxcXSkoPzpcXFxcezJ9KSopXFwkXFx7KD86W157fV18XFx7KD86W157fV18XFx7W159XSpcXH0pKlxcfSkrXFx9LyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ2ludGVycG9sYXRpb24tcHVuY3R1YXRpb24nOiB7XG4gICAgICAgICAgICBwYXR0ZXJuOiAvXlxcJFxce3xcXH0kLyxcbiAgICAgICAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXN0OiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ3N0cmluZyc6IC9bXFxzXFxTXSsvXG4gICAgfVxuICB9LFxuICAnc3RyaW5nLXByb3BlcnR5Jzoge1xuICAgIHBhdHRlcm46IC8oKD86XnxbLHtdKVsgXFx0XSopKFtcIiddKSg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMilbXlxcXFxcXHJcXG5dKSpcXDIoPz1cXHMqOikvbSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBhbGlhczogJ3Byb3BlcnR5J1xuICB9XG59KTtcblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnb3BlcmF0b3InLCB7XG4gICdsaXRlcmFsLXByb3BlcnR5Jzoge1xuICAgIHBhdHRlcm46IC8oKD86XnxbLHtdKVsgXFx0XSopKD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyo6KS9tLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgYWxpYXM6ICdwcm9wZXJ0eSdcbiAgfVxufSk7XG5pZiAoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCkge1xuICBQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5hZGRJbmxpbmVkKCdzY3JpcHQnLCAnamF2YXNjcmlwdCcpO1xuXG4gIC8vIGFkZCBhdHRyaWJ1dGUgc3VwcG9ydCBmb3IgYWxsIERPTSBldmVudHMuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cyNTdGFuZGFyZF9ldmVudHNcbiAgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuYWRkQXR0cmlidXRlKC9vbig/OmFib3J0fGJsdXJ8Y2hhbmdlfGNsaWNrfGNvbXBvc2l0aW9uKD86ZW5kfHN0YXJ0fHVwZGF0ZSl8ZGJsY2xpY2t8ZXJyb3J8Zm9jdXMoPzppbnxvdXQpP3xrZXkoPzpkb3dufHVwKXxsb2FkfG1vdXNlKD86ZG93bnxlbnRlcnxsZWF2ZXxtb3ZlfG91dHxvdmVyfHVwKXxyZXNldHxyZXNpemV8c2Nyb2xsfHNlbGVjdHxzbG90Y2hhbmdlfHN1Ym1pdHx1bmxvYWR8d2hlZWwpLy5zb3VyY2UsICdqYXZhc2NyaXB0Jyk7XG59XG5QcmlzbS5sYW5ndWFnZXMuanMgPSBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdDtcbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgdmFyIGphdmFzY3JpcHQgPSBQcmlzbS51dGlsLmNsb25lKFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0KTtcbiAgdmFyIHNwYWNlID0gLyg/Olxcc3xcXC9cXC8uKig/IS4pfFxcL1xcKig/OlteKl18XFwqKD8hXFwvKSlcXCpcXC8pLy5zb3VyY2U7XG4gIHZhciBicmFjZXMgPSAvKD86XFx7KD86XFx7KD86XFx7W157fV0qXFx9fFtee31dKSpcXH18W157fV0pKlxcfSkvLnNvdXJjZTtcbiAgdmFyIHNwcmVhZCA9IC8oPzpcXHs8Uz4qXFwuezN9KD86W157fV18PEJSQUNFUz4pKlxcfSkvLnNvdXJjZTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZsYWdzXVxuICAgKi9cbiAgZnVuY3Rpb24gcmUoc291cmNlLCBmbGFncykge1xuICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKC88Uz4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNwYWNlO1xuICAgIH0pLnJlcGxhY2UoLzxCUkFDRVM+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBicmFjZXM7XG4gICAgfSkucmVwbGFjZSgvPFNQUkVBRD4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNwcmVhZDtcbiAgICB9KTtcbiAgICByZXR1cm4gUmVnRXhwKHNvdXJjZSwgZmxhZ3MpO1xuICB9XG4gIHNwcmVhZCA9IHJlKHNwcmVhZCkuc291cmNlO1xuICBQcmlzbS5sYW5ndWFnZXMuanN4ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnbWFya3VwJywgamF2YXNjcmlwdCk7XG4gIFByaXNtLmxhbmd1YWdlcy5qc3gudGFnLnBhdHRlcm4gPSByZSgvPFxcLz8oPzpbXFx3LjotXSsoPzo8Uz4rKD86W1xcdy46JC1dKyg/Oj0oPzpcIig/OlxcXFxbXFxzXFxTXXxbXlxcXFxcIl0pKlwifCcoPzpcXFxcW1xcc1xcU118W15cXFxcJ10pKid8W15cXHN7J1wiLz49XSt8PEJSQUNFUz4pKT98PFNQUkVBRD4pKSo8Uz4qXFwvPyk/Pi8uc291cmNlKTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcuaW5zaWRlWyd0YWcnXS5wYXR0ZXJuID0gL148XFwvP1teXFxzPlxcL10qLztcbiAgUHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcuaW5zaWRlWydhdHRyLXZhbHVlJ10ucGF0dGVybiA9IC89KD8hXFx7KSg/OlwiKD86XFxcXFtcXHNcXFNdfFteXFxcXFwiXSkqXCJ8Jyg/OlxcXFxbXFxzXFxTXXxbXlxcXFwnXSkqJ3xbXlxccydcIj5dKykvO1xuICBQcmlzbS5sYW5ndWFnZXMuanN4LnRhZy5pbnNpZGVbJ3RhZyddLmluc2lkZVsnY2xhc3MtbmFtZSddID0gL15bQS1aXVxcdyooPzpcXC5bQS1aXVxcdyopKiQvO1xuICBQcmlzbS5sYW5ndWFnZXMuanN4LnRhZy5pbnNpZGVbJ2NvbW1lbnQnXSA9IGphdmFzY3JpcHRbJ2NvbW1lbnQnXTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnaW5zaWRlJywgJ2F0dHItbmFtZScsIHtcbiAgICAnc3ByZWFkJzoge1xuICAgICAgcGF0dGVybjogcmUoLzxTUFJFQUQ+Ly5zb3VyY2UpLFxuICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuanN4XG4gICAgfVxuICB9LCBQcmlzbS5sYW5ndWFnZXMuanN4LnRhZyk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2luc2lkZScsICdzcGVjaWFsLWF0dHInLCB7XG4gICAgJ3NjcmlwdCc6IHtcbiAgICAgIC8vIEFsbG93IGZvciB0d28gbGV2ZWxzIG9mIG5lc3RpbmdcbiAgICAgIHBhdHRlcm46IHJlKC89PEJSQUNFUz4vLnNvdXJjZSksXG4gICAgICBhbGlhczogJ2xhbmd1YWdlLWphdmFzY3JpcHQnLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdzY3JpcHQtcHVuY3R1YXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogL149KD89XFx7KS8sXG4gICAgICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdDogUHJpc20ubGFuZ3VhZ2VzLmpzeFxuICAgICAgfVxuICAgIH1cbiAgfSwgUHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcpO1xuXG4gIC8vIFRoZSBmb2xsb3dpbmcgd2lsbCBoYW5kbGUgcGxhaW4gdGV4dCBpbnNpZGUgdGFnc1xuICB2YXIgc3RyaW5naWZ5VG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdG9rZW4uY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0b2tlbi5jb250ZW50O1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW4uY29udGVudC5tYXAoc3RyaW5naWZ5VG9rZW4pLmpvaW4oJycpO1xuICB9O1xuICB2YXIgd2Fsa1Rva2VucyA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcbiAgICB2YXIgb3BlbmVkVGFncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICB2YXIgbm90VGFnTm9yQnJhY2UgPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAndGFnJyAmJiB0b2tlbi5jb250ZW50WzBdICYmIHRva2VuLmNvbnRlbnRbMF0udHlwZSA9PT0gJ3RhZycpIHtcbiAgICAgICAgICAvLyBXZSBmb3VuZCBhIHRhZywgbm93IGZpbmQgaXRzIGtpbmRcblxuICAgICAgICAgIGlmICh0b2tlbi5jb250ZW50WzBdLmNvbnRlbnRbMF0uY29udGVudCA9PT0gJzwvJykge1xuICAgICAgICAgICAgLy8gQ2xvc2luZyB0YWdcbiAgICAgICAgICAgIGlmIChvcGVuZWRUYWdzLmxlbmd0aCA+IDAgJiYgb3BlbmVkVGFnc1tvcGVuZWRUYWdzLmxlbmd0aCAtIDFdLnRhZ05hbWUgPT09IHN0cmluZ2lmeVRva2VuKHRva2VuLmNvbnRlbnRbMF0uY29udGVudFsxXSkpIHtcbiAgICAgICAgICAgICAgLy8gUG9wIG1hdGNoaW5nIG9wZW5pbmcgdGFnXG4gICAgICAgICAgICAgIG9wZW5lZFRhZ3MucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi5jb250ZW50W3Rva2VuLmNvbnRlbnQubGVuZ3RoIC0gMV0uY29udGVudCA9PT0gJy8+JykgOyBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gT3BlbmluZyB0YWdcbiAgICAgICAgICAgICAgb3BlbmVkVGFncy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiBzdHJpbmdpZnlUb2tlbih0b2tlbi5jb250ZW50WzBdLmNvbnRlbnRbMV0pLFxuICAgICAgICAgICAgICAgIG9wZW5lZEJyYWNlczogMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3BlbmVkVGFncy5sZW5ndGggPiAwICYmIHRva2VuLnR5cGUgPT09ICdwdW5jdHVhdGlvbicgJiYgdG9rZW4uY29udGVudCA9PT0gJ3snKSB7XG4gICAgICAgICAgLy8gSGVyZSB3ZSBtaWdodCBoYXZlIGVudGVyZWQgYSBKU1ggY29udGV4dCBpbnNpZGUgYSB0YWdcbiAgICAgICAgICBvcGVuZWRUYWdzW29wZW5lZFRhZ3MubGVuZ3RoIC0gMV0ub3BlbmVkQnJhY2VzKys7XG4gICAgICAgIH0gZWxzZSBpZiAob3BlbmVkVGFncy5sZW5ndGggPiAwICYmIG9wZW5lZFRhZ3Nbb3BlbmVkVGFncy5sZW5ndGggLSAxXS5vcGVuZWRCcmFjZXMgPiAwICYmIHRva2VuLnR5cGUgPT09ICdwdW5jdHVhdGlvbicgJiYgdG9rZW4uY29udGVudCA9PT0gJ30nKSB7XG4gICAgICAgICAgLy8gSGVyZSB3ZSBtaWdodCBoYXZlIGxlZnQgYSBKU1ggY29udGV4dCBpbnNpZGUgYSB0YWdcbiAgICAgICAgICBvcGVuZWRUYWdzW29wZW5lZFRhZ3MubGVuZ3RoIC0gMV0ub3BlbmVkQnJhY2VzLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm90VGFnTm9yQnJhY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm90VGFnTm9yQnJhY2UgfHwgdHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAob3BlbmVkVGFncy5sZW5ndGggPiAwICYmIG9wZW5lZFRhZ3Nbb3BlbmVkVGFncy5sZW5ndGggLSAxXS5vcGVuZWRCcmFjZXMgPT09IDApIHtcbiAgICAgICAgICAvLyBIZXJlIHdlIGFyZSBpbnNpZGUgYSB0YWcsIGFuZCBub3QgaW5zaWRlIGEgSlNYIGNvbnRleHQuXG4gICAgICAgICAgLy8gVGhhdCdzIHBsYWluIHRleHQ6IGRyb3AgYW55IHRva2VucyBtYXRjaGVkLlxuICAgICAgICAgIHZhciBwbGFpblRleHQgPSBzdHJpbmdpZnlUb2tlbih0b2tlbik7XG5cbiAgICAgICAgICAvLyBBbmQgbWVyZ2UgdGV4dCB3aXRoIGFkamFjZW50IHRleHRcbiAgICAgICAgICBpZiAoaSA8IHRva2Vucy5sZW5ndGggLSAxICYmICh0eXBlb2YgdG9rZW5zW2kgKyAxXSA9PT0gJ3N0cmluZycgfHwgdG9rZW5zW2kgKyAxXS50eXBlID09PSAncGxhaW4tdGV4dCcpKSB7XG4gICAgICAgICAgICBwbGFpblRleHQgKz0gc3RyaW5naWZ5VG9rZW4odG9rZW5zW2kgKyAxXSk7XG4gICAgICAgICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPiAwICYmICh0eXBlb2YgdG9rZW5zW2kgLSAxXSA9PT0gJ3N0cmluZycgfHwgdG9rZW5zW2kgLSAxXS50eXBlID09PSAncGxhaW4tdGV4dCcpKSB7XG4gICAgICAgICAgICBwbGFpblRleHQgPSBzdHJpbmdpZnlUb2tlbih0b2tlbnNbaSAtIDFdKSArIHBsYWluVGV4dDtcbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSAtIDEsIDEpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b2tlbnNbaV0gPSBuZXcgUHJpc20uVG9rZW4oJ3BsYWluLXRleHQnLCBwbGFpblRleHQsIG51bGwsIHBsYWluVGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5jb250ZW50ICYmIHR5cGVvZiB0b2tlbi5jb250ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB3YWxrVG9rZW5zKHRva2VuLmNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgUHJpc20uaG9va3MuYWRkKCdhZnRlci10b2tlbml6ZScsIGZ1bmN0aW9uIChlbnYpIHtcbiAgICBpZiAoZW52Lmxhbmd1YWdlICE9PSAnanN4JyAmJiBlbnYubGFuZ3VhZ2UgIT09ICd0c3gnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhbGtUb2tlbnMoZW52LnRva2Vucyk7XG4gIH0pO1xufSkoUHJpc20pO1xuXG4vLyBodHRwczovL3d3dy5qc29uLm9yZy9qc29uLWVuLmh0bWxcblByaXNtLmxhbmd1YWdlcy5qc29uID0ge1xuICAncHJvcGVydHknOiB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXF0pXCIoPzpcXFxcLnxbXlxcXFxcIlxcclxcbl0pKlwiKD89XFxzKjopLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKVwiKD86XFxcXC58W15cXFxcXCJcXHJcXG5dKSpcIig/IVxccyo6KS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2NvbW1lbnQnOiB7XG4gICAgcGF0dGVybjogL1xcL1xcLy4qfFxcL1xcKltcXHNcXFNdKj8oPzpcXCpcXC98JCkvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnbnVtYmVyJzogLy0/XFxiXFxkKyg/OlxcLlxcZCspPyg/OmVbKy1dP1xcZCspP1xcYi9pLFxuICAncHVuY3R1YXRpb24nOiAvW3t9W1xcXSxdLyxcbiAgJ29wZXJhdG9yJzogLzovLFxuICAnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi8sXG4gICdudWxsJzoge1xuICAgIHBhdHRlcm46IC9cXGJudWxsXFxiLyxcbiAgICBhbGlhczogJ2tleXdvcmQnXG4gIH1cbn07XG5QcmlzbS5sYW5ndWFnZXMud2VibWFuaWZlc3QgPSBQcmlzbS5sYW5ndWFnZXMuanNvbjtcbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLmtvdGxpbiA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NsaWtlJywge1xuICAgICdrZXl3b3JkJzoge1xuICAgICAgLy8gVGhlIGxvb2tiZWhpbmQgcHJldmVudHMgd3JvbmcgaGlnaGxpZ2h0aW5nIG9mIGUuZy4ga290bGluLnByb3BlcnRpZXMuZ2V0XG4gICAgICBwYXR0ZXJuOiAvKF58W14uXSlcXGIoPzphYnN0cmFjdHxhY3R1YWx8YW5ub3RhdGlvbnxhc3xicmVha3xieXxjYXRjaHxjbGFzc3xjb21wYW5pb258Y29uc3R8Y29uc3RydWN0b3J8Y29udGludWV8Y3Jvc3NpbmxpbmV8ZGF0YXxkb3xkeW5hbWljfGVsc2V8ZW51bXxleHBlY3R8ZXh0ZXJuYWx8ZmluYWx8ZmluYWxseXxmb3J8ZnVufGdldHxpZnxpbXBvcnR8aW58aW5maXh8aW5pdHxpbmxpbmV8aW5uZXJ8aW50ZXJmYWNlfGludGVybmFsfGlzfGxhdGVpbml0fG5vaW5saW5lfG51bGx8b2JqZWN0fG9wZW58b3BlcmF0b3J8b3V0fG92ZXJyaWRlfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJlaWZpZWR8cmV0dXJufHNlYWxlZHxzZXR8c3VwZXJ8c3VzcGVuZHx0YWlscmVjfHRoaXN8dGhyb3d8dG98dHJ5fHR5cGVhbGlhc3x2YWx8dmFyfHZhcmFyZ3x3aGVufHdoZXJlfHdoaWxlKVxcYi8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnZnVuY3Rpb24nOiBbe1xuICAgICAgcGF0dGVybjogLyg/OmBbXlxcclxcbmBdK2B8XFxiXFx3KykoPz1cXHMqXFwoKS8sXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvKFxcLikoPzpgW15cXHJcXG5gXStgfFxcdyspKD89XFxzKlxceykvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH1dLFxuICAgICdudW1iZXInOiAvXFxiKD86MFt4WF1bXFxkYS1mQS1GXSsoPzpfW1xcZGEtZkEtRl0rKSp8MFtiQl1bMDFdKyg/Ol9bMDFdKykqfFxcZCsoPzpfXFxkKykqKD86XFwuXFxkKyg/Ol9cXGQrKSopPyg/OltlRV1bKy1dP1xcZCsoPzpfXFxkKykqKT9bZkZMXT8pXFxiLyxcbiAgICAnb3BlcmF0b3InOiAvXFwrWys9XT98LVstPT5dP3w9PT89P3whKD86IXw9PT8pP3xbXFwvKiU8Pl09P3xbPzpdOj98XFwuXFwufCYmfFxcfFxcfHxcXGIoPzphbmR8aW52fG9yfHNobHxzaHJ8dXNocnx4b3IpXFxiL1xuICB9KTtcbiAgZGVsZXRlIFByaXNtLmxhbmd1YWdlcy5rb3RsaW5bJ2NsYXNzLW5hbWUnXTtcbiAgdmFyIGludGVycG9sYXRpb25JbnNpZGUgPSB7XG4gICAgJ2ludGVycG9sYXRpb24tcHVuY3R1YXRpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvXlxcJFxcez98XFx9JC8sXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgIH0sXG4gICAgJ2V4cHJlc3Npb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvW1xcc1xcU10rLyxcbiAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmtvdGxpblxuICAgIH1cbiAgfTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgna290bGluJywgJ3N0cmluZycsIHtcbiAgICAvLyBodHRwczovL2tvdGxpbmxhbmcub3JnL3NwZWMvZXhwcmVzc2lvbnMuaHRtbCNzdHJpbmctaW50ZXJwb2xhdGlvbi1leHByZXNzaW9uc1xuICAgICdzdHJpbmctbGl0ZXJhbCc6IFt7XG4gICAgICBwYXR0ZXJuOiAvXCJcIlwiKD86W14kXXxcXCQoPzooPyFcXHspfFxce1tee31dKlxcfSkpKj9cIlwiXCIvLFxuICAgICAgYWxpYXM6ICdtdWx0aWxpbmUnLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdpbnRlcnBvbGF0aW9uJzoge1xuICAgICAgICAgIHBhdHRlcm46IC9cXCQoPzpbYS16X11cXHcqfFxce1tee31dKlxcfSkvaSxcbiAgICAgICAgICBpbnNpZGU6IGludGVycG9sYXRpb25JbnNpZGVcbiAgICAgICAgfSxcbiAgICAgICAgJ3N0cmluZyc6IC9bXFxzXFxTXSsvXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcGF0dGVybjogL1wiKD86W15cIlxcXFxcXHJcXG4kXXxcXFxcLnxcXCQoPzooPyFcXHspfFxce1tee31dKlxcfSkpKlwiLyxcbiAgICAgIGFsaWFzOiAnc2luZ2xlbGluZScsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2ludGVycG9sYXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogLygoPzpefFteXFxcXF0pKD86XFxcXHsyfSkqKVxcJCg/OlthLXpfXVxcdyp8XFx7W157fV0qXFx9KS9pLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgaW5zaWRlOiBpbnRlcnBvbGF0aW9uSW5zaWRlXG4gICAgICAgIH0sXG4gICAgICAgICdzdHJpbmcnOiAvW1xcc1xcU10rL1xuICAgICAgfVxuICAgIH1dLFxuICAgICdjaGFyJzoge1xuICAgICAgLy8gaHR0cHM6Ly9rb3RsaW5sYW5nLm9yZy9zcGVjL2V4cHJlc3Npb25zLmh0bWwjY2hhcmFjdGVyLWxpdGVyYWxzXG4gICAgICBwYXR0ZXJuOiAvJyg/OlteJ1xcXFxcXHJcXG5dfFxcXFwoPzoufHVbYS1mQS1GMC05XXswLDR9KSknLyxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMua290bGluWydzdHJpbmcnXTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgna290bGluJywgJ2tleXdvcmQnLCB7XG4gICAgJ2Fubm90YXRpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvXFxCQCg/Olxcdys6KT8oPzpbQS1aXVxcdyp8XFxbW15cXF1dK1xcXSkvLFxuICAgICAgYWxpYXM6ICdidWlsdGluJ1xuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2tvdGxpbicsICdmdW5jdGlvbicsIHtcbiAgICAnbGFiZWwnOiB7XG4gICAgICBwYXR0ZXJuOiAvXFxiXFx3K0B8QFxcdytcXGIvLFxuICAgICAgYWxpYXM6ICdzeW1ib2wnXG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmt0ID0gUHJpc20ubGFuZ3VhZ2VzLmtvdGxpbjtcbiAgUHJpc20ubGFuZ3VhZ2VzLmt0cyA9IFByaXNtLmxhbmd1YWdlcy5rb3RsaW47XG59KShQcmlzbSk7XG5cbi8qIEZJWE1FIDpcbiA6ZXh0ZW5kKCkgaXMgbm90IGhhbmRsZWQgc3BlY2lmaWNhbGx5IDogaXRzIGhpZ2hsaWdodGluZyBpcyBidWdneS5cbiBNaXhpbiB1c2FnZSBtdXN0IGJlIGluc2lkZSBhIHJ1bGVzZXQgdG8gYmUgaGlnaGxpZ2h0ZWQuXG4gQXQtcnVsZXMgKGUuZy4gaW1wb3J0KSBjb250YWluaW5nIGludGVycG9sYXRpb25zIGFyZSBidWdneS5cbiBEZXRhY2hlZCBydWxlc2V0cyBhcmUgaGlnaGxpZ2h0ZWQgYXMgYXQtcnVsZXMuXG4gQSBjb21tZW50IGJlZm9yZSBhIG1peGluIHVzYWdlIHByZXZlbnRzIHRoZSBsYXR0ZXIgdG8gYmUgcHJvcGVybHkgaGlnaGxpZ2h0ZWQuXG4gKi9cblxuUHJpc20ubGFuZ3VhZ2VzLmxlc3MgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjc3MnLCB7XG4gICdjb21tZW50JzogWy9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvLywge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKVxcL1xcLy4qLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH1dLFxuICAnYXRydWxlJzoge1xuICAgIHBhdHRlcm46IC9AW1xcdy1dKD86XFwoKD86W14oKXt9XXxcXChbXigpe31dKlxcKSkqXFwpfFteKCl7fTtcXHNdfFxccysoPyFcXHMpKSo/KD89XFxzKlxceykvLFxuICAgIGluc2lkZToge1xuICAgICAgJ3B1bmN0dWF0aW9uJzogL1s6KCldL1xuICAgIH1cbiAgfSxcbiAgLy8gc2VsZWN0b3JzIGFuZCBtaXhpbnMgYXJlIGNvbnNpZGVyZWQgdGhlIHNhbWVcbiAgJ3NlbGVjdG9yJzoge1xuICAgIHBhdHRlcm46IC8oPzpAXFx7W1xcdy1dK1xcfXxbXnt9O1xcc0BdKSg/OkBcXHtbXFx3LV0rXFx9fFxcKCg/OlteKCl7fV18XFwoW14oKXt9XSpcXCkpKlxcKXxbXigpe307QFxcc118XFxzKyg/IVxccykpKj8oPz1cXHMqXFx7KS8sXG4gICAgaW5zaWRlOiB7XG4gICAgICAvLyBtaXhpbiBwYXJhbWV0ZXJzXG4gICAgICAndmFyaWFibGUnOiAvQCtbXFx3LV0rL1xuICAgIH1cbiAgfSxcbiAgJ3Byb3BlcnR5JzogLyg/OkBcXHtbXFx3LV0rXFx9fFtcXHctXSkrKD86XFwrXz8pPyg/PVxccyo6KS8sXG4gICdvcGVyYXRvcic6IC9bK1xcLSpcXC9dL1xufSk7XG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdsZXNzJywgJ3Byb3BlcnR5Jywge1xuICAndmFyaWFibGUnOiBbXG4gIC8vIFZhcmlhYmxlIGRlY2xhcmF0aW9uICh0aGUgY29sb24gbXVzdCBiZSBjb25zdW1lZCEpXG4gIHtcbiAgICBwYXR0ZXJuOiAvQFtcXHctXStcXHMqOi8sXG4gICAgaW5zaWRlOiB7XG4gICAgICAncHVuY3R1YXRpb24nOiAvOi9cbiAgICB9XG4gIH0sXG4gIC8vIFZhcmlhYmxlIHVzYWdlXG4gIC9AQD9bXFx3LV0rL10sXG4gICdtaXhpbi11c2FnZSc6IHtcbiAgICBwYXR0ZXJuOiAvKFt7O11cXHMqKVsuI10oPyFcXGQpW1xcdy1dLio/KD89Wyg7XSkvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgfVxufSk7XG5QcmlzbS5sYW5ndWFnZXMubHVhID0ge1xuICAnY29tbWVudCc6IC9eIyEuK3wtLSg/OlxcWyg9KilcXFtbXFxzXFxTXSo/XFxdXFwxXFxdfC4qKS9tLFxuICAvLyBcXHogbWF5IGJlIHVzZWQgdG8gc2tpcCB0aGUgZm9sbG93aW5nIHNwYWNlXG4gICdzdHJpbmcnOiB7XG4gICAgcGF0dGVybjogLyhbXCInXSkoPzooPyFcXDEpW15cXFxcXFxyXFxuXXxcXFxceig/OlxcclxcbnxcXHMpfFxcXFwoPzpcXHJcXG58W156XSkpKlxcMXxcXFsoPSopXFxbW1xcc1xcU10qP1xcXVxcMlxcXS8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdudW1iZXInOiAvXFxiMHhbYS1mXFxkXSsoPzpcXC5bYS1mXFxkXSopPyg/OnBbKy1dP1xcZCspP1xcYnxcXGJcXGQrKD86XFwuXFxCfCg/OlxcLlxcZCopPyg/OmVbKy1dP1xcZCspP1xcYil8XFxCXFwuXFxkKyg/OmVbKy1dP1xcZCspP1xcYi9pLFxuICAna2V5d29yZCc6IC9cXGIoPzphbmR8YnJlYWt8ZG98ZWxzZXxlbHNlaWZ8ZW5kfGZhbHNlfGZvcnxmdW5jdGlvbnxnb3RvfGlmfGlufGxvY2FsfG5pbHxub3R8b3J8cmVwZWF0fHJldHVybnx0aGVufHRydWV8dW50aWx8d2hpbGUpXFxiLyxcbiAgJ2Z1bmN0aW9uJzogLyg/IVxcZClcXHcrKD89XFxzKig/Olsoe10pKS8sXG4gICdvcGVyYXRvcic6IFsvWy0rKiVeJnwjXXxcXC9cXC8/fDxbPD1dP3w+Wz49XT98Wz1+XT0/Lywge1xuICAgIC8vIE1hdGNoIFwiLi5cIiBidXQgZG9uJ3QgYnJlYWsgXCIuLi5cIlxuICAgIHBhdHRlcm46IC8oXnxbXi5dKVxcLlxcLig/IVxcLikvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfV0sXG4gICdwdW5jdHVhdGlvbic6IC9bXFxbXFxdKCl7fSw7XXxcXC4rfDorL1xufTtcblByaXNtLmxhbmd1YWdlcy5tYWtlZmlsZSA9IHtcbiAgJ2NvbW1lbnQnOiB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXF0pIyg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteXFxcXFxcclxcbl0pKi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9LFxuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oW1wiJ10pKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdidWlsdGluLXRhcmdldCc6IHtcbiAgICBwYXR0ZXJuOiAvXFwuW0EtWl1bXjojPVxcc10rKD89XFxzKjooPyE9KSkvLFxuICAgIGFsaWFzOiAnYnVpbHRpbidcbiAgfSxcbiAgJ3RhcmdldCc6IHtcbiAgICBwYXR0ZXJuOiAvXig/OlteOj1cXHNdfFsgXFx0XSsoPyFbXFxzOl0pKSsoPz1cXHMqOig/IT0pKS9tLFxuICAgIGFsaWFzOiAnc3ltYm9sJyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICd2YXJpYWJsZSc6IC9cXCQrKD86KD8hXFwkKVteKCl7fTojPVxcc10rfCg/PVsoe10pKS9cbiAgICB9XG4gIH0sXG4gICd2YXJpYWJsZSc6IC9cXCQrKD86KD8hXFwkKVteKCl7fTojPVxcc10rfFxcKFtAKiU8Xis/XVtERl1cXCl8KD89Wyh7XSkpLyxcbiAgLy8gRGlyZWN0aXZlc1xuICAna2V5d29yZCc6IC8taW5jbHVkZVxcYnxcXGIoPzpkZWZpbmV8ZWxzZXxlbmRlZnxlbmRpZnxleHBvcnR8aWZuP2RlZnxpZm4/ZXF8aW5jbHVkZXxvdmVycmlkZXxwcml2YXRlfHNpbmNsdWRlfHVuZGVmaW5lfHVuZXhwb3J0fHZwYXRoKVxcYi8sXG4gICdmdW5jdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvKFxcKCkoPzphYnNwYXRofGFkZHN1ZmZpeHxhbmR8YmFzZW5hbWV8Y2FsbHxkaXJ8ZXJyb3J8ZXZhbHxmaWxlfGZpbHRlcig/Oi1vdXQpP3xmaW5kc3RyaW5nfGZpcnN0d29yZHxmbGF2b3J8Zm9yZWFjaHxndWlsZXxpZnxpbmZvfGpvaW58bGFzdHdvcmR8bG9hZHxub3RkaXJ8b3J8b3JpZ2lufHBhdHN1YnN0fHJlYWxwYXRofHNoZWxsfHNvcnR8c3RyaXB8c3Vic3R8c3VmZml4fHZhbHVlfHdhcm5pbmd8d2lsZGNhcmR8d29yZCg/Omxpc3R8cyk/KSg/PVsgXFx0XSkvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ29wZXJhdG9yJzogLyg/Ojo6fFs/OishXSk/PXxbfEBdLyxcbiAgJ3B1bmN0dWF0aW9uJzogL1s6Oygpe31dL1xufTtcbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgLy8gaHR0cHM6Ly95YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjYy1ucy1hbmNob3ItcHJvcGVydHlcbiAgLy8gaHR0cHM6Ly95YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjYy1ucy1hbGlhcy1ub2RlXG4gIHZhciBhbmNob3JPckFsaWFzID0gL1sqJl1bXlxcc1tcXF17fSxdKy87XG4gIC8vIGh0dHBzOi8veWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2MtbnMtdGFnLXByb3BlcnR5XG4gIHZhciB0YWcgPSAvISg/OjxbXFx3XFwtJSM7Lz86QCY9KyQsLiF+KicoKVtcXF1dKz58KD86W2EtekEtWlxcZC1dKiEpP1tcXHdcXC0lIzsvPzpAJj0rJC5+KicoKV0rKT8vO1xuICAvLyBodHRwczovL3lhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNjLW5zLXByb3BlcnRpZXMobixjKVxuICB2YXIgcHJvcGVydGllcyA9ICcoPzonICsgdGFnLnNvdXJjZSArICcoPzpbIFxcdF0rJyArIGFuY2hvck9yQWxpYXMuc291cmNlICsgJyk/fCcgKyBhbmNob3JPckFsaWFzLnNvdXJjZSArICcoPzpbIFxcdF0rJyArIHRhZy5zb3VyY2UgKyAnKT8pJztcbiAgLy8gaHR0cHM6Ly95YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjbnMtcGxhaW4obixjKVxuICAvLyBUaGlzIGlzIGEgc2ltcGxpZmllZCB2ZXJzaW9uIHRoYXQgZG9lc24ndCBzdXBwb3J0IFwiI1wiIGFuZCBtdWx0aWxpbmUga2V5c1xuICAvLyBBbGwgdGhlc2UgbG9uZyBzY2FycnkgY2hhcmFjdGVyIGNsYXNzZXMgYXJlIHNpbXBsaWZpZWQgdmVyc2lvbnMgb2YgWUFNTCdzIGNoYXJhY3RlcnNcbiAgdmFyIHBsYWluS2V5ID0gLyg/OlteXFxzXFx4MDAtXFx4MDhcXHgwZS1cXHgxZiFcIiMlJicqLFxcLTo+P0BbXFxdYHt8fVxceDdmLVxceDg0XFx4ODYtXFx4OWZcXHVkODAwLVxcdWRmZmZcXHVmZmZlXFx1ZmZmZl18Wz86LV08UExBSU4+KSg/OlsgXFx0XSooPzooPyFbIzpdKTxQTEFJTj58OjxQTEFJTj4pKSovLnNvdXJjZS5yZXBsYWNlKC88UExBSU4+L2csIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gL1teXFxzXFx4MDAtXFx4MDhcXHgwZS1cXHgxZixbXFxde31cXHg3Zi1cXHg4NFxceDg2LVxceDlmXFx1ZDgwMC1cXHVkZmZmXFx1ZmZmZVxcdWZmZmZdLy5zb3VyY2U7XG4gIH0pO1xuICB2YXIgc3RyaW5nID0gL1wiKD86W15cIlxcXFxcXHJcXG5dfFxcXFwuKSpcInwnKD86W14nXFxcXFxcclxcbl18XFxcXC4pKicvLnNvdXJjZTtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3NdXG4gICAqIEByZXR1cm5zIHtSZWdFeHB9XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVWYWx1ZVBhdHRlcm4odmFsdWUsIGZsYWdzKSB7XG4gICAgZmxhZ3MgPSAoZmxhZ3MgfHwgJycpLnJlcGxhY2UoL20vZywgJycpICsgJ20nOyAvLyBhZGQgbSBmbGFnXG4gICAgdmFyIHBhdHRlcm4gPSAvKFs6XFwtLFt7XVxccyooPzpcXHM8PHByb3A+PlsgXFx0XSspPykoPzo8PHZhbHVlPj4pKD89WyBcXHRdKig/OiR8LHxcXF18XFx9fCg/OltcXHJcXG5dXFxzKik/IykpLy5zb3VyY2UucmVwbGFjZSgvPDxwcm9wPj4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfSkucmVwbGFjZSgvPDx2YWx1ZT4+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgfVxuICBQcmlzbS5sYW5ndWFnZXMueWFtbCA9IHtcbiAgICAnc2NhbGFyJzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oW1xcLTpdXFxzKig/Olxcczw8cHJvcD4+WyBcXHRdKyk/W3w+XSlbIFxcdF0qKD86KCg/Olxccj9cXG58XFxyKVsgXFx0XSspXFxTW15cXHJcXG5dKig/OlxcMlteXFxyXFxuXSspKikvLnNvdXJjZS5yZXBsYWNlKC88PHByb3A+Pi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgICAgfSkpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnc3RyaW5nJ1xuICAgIH0sXG4gICAgJ2NvbW1lbnQnOiAvIy4qLyxcbiAgICAna2V5Jzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oKD86XnxbOlxcLSxbe1xcclxcbj9dKVsgXFx0XSooPzo8PHByb3A+PlsgXFx0XSspPyk8PGtleT4+KD89XFxzKjpcXHMpLy5zb3VyY2UucmVwbGFjZSgvPDxwcm9wPj4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICAgIH0pLnJlcGxhY2UoLzw8a2V5Pj4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJyg/OicgKyBwbGFpbktleSArICd8JyArIHN0cmluZyArICcpJztcbiAgICAgIH0pKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBhbGlhczogJ2F0cnVsZSdcbiAgICB9LFxuICAgICdkaXJlY3RpdmUnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF5bIFxcdF0qKSUuKy9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICAgIH0sXG4gICAgJ2RhdGV0aW1lJzoge1xuICAgICAgcGF0dGVybjogY3JlYXRlVmFsdWVQYXR0ZXJuKC9cXGR7NH0tXFxkXFxkPy1cXGRcXGQ/KD86W3RUXXxbIFxcdF0rKVxcZFxcZD86XFxkezJ9OlxcZHsyfSg/OlxcLlxcZCopPyg/OlsgXFx0XSooPzpafFstK11cXGRcXGQ/KD86OlxcZHsyfSk/KSk/fFxcZHs0fS1cXGR7Mn0tXFxkezJ9fFxcZFxcZD86XFxkezJ9KD86OlxcZHsyfSg/OlxcLlxcZCopPyk/Ly5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnbnVtYmVyJ1xuICAgIH0sXG4gICAgJ2Jvb2xlYW4nOiB7XG4gICAgICBwYXR0ZXJuOiBjcmVhdGVWYWx1ZVBhdHRlcm4oL2ZhbHNlfHRydWUvLnNvdXJjZSwgJ2knKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ2ltcG9ydGFudCdcbiAgICB9LFxuICAgICdudWxsJzoge1xuICAgICAgcGF0dGVybjogY3JlYXRlVmFsdWVQYXR0ZXJuKC9udWxsfH4vLnNvdXJjZSwgJ2knKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ2ltcG9ydGFudCdcbiAgICB9LFxuICAgICdzdHJpbmcnOiB7XG4gICAgICBwYXR0ZXJuOiBjcmVhdGVWYWx1ZVBhdHRlcm4oc3RyaW5nKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdudW1iZXInOiB7XG4gICAgICBwYXR0ZXJuOiBjcmVhdGVWYWx1ZVBhdHRlcm4oL1srLV0/KD86MHhbXFxkYS1mXSt8MG9bMC03XSt8KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspP3xcXC5pbmZ8XFwubmFuKS8uc291cmNlLCAnaScpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ3RhZyc6IHRhZyxcbiAgICAnaW1wb3J0YW50JzogYW5jaG9yT3JBbGlhcyxcbiAgICAncHVuY3R1YXRpb24nOiAvLS0tfFs6W1xcXXt9XFwtLHw+P118XFwuXFwuXFwuL1xuICB9O1xuICBQcmlzbS5sYW5ndWFnZXMueW1sID0gUHJpc20ubGFuZ3VhZ2VzLnlhbWw7XG59KShQcmlzbSk7XG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIC8vIEFsbG93IG9ubHkgb25lIGxpbmUgYnJlYWtcbiAgdmFyIGlubmVyID0gLyg/OlxcXFwufFteXFxcXFxcblxccl18KD86XFxufFxcclxcbj8pKD8hW1xcclxcbl0pKS8uc291cmNlO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIGZvciB0aGUgY3JlYXRpb24gb2YgdGhlIGJvbGQgb3IgaXRhbGljIHBhdHRlcm4uXG4gICAqXG4gICAqIFRoaXMgYWxzbyBhZGRzIGEgbG9va2JlaGluZCBncm91cCB0byB0aGUgZ2l2ZW4gcGF0dGVybiB0byBlbnN1cmUgdGhhdCB0aGUgcGF0dGVybiBpcyBub3QgYmFja3NsYXNoLWVzY2FwZWQuXG4gICAqXG4gICAqIF9Ob3RlOl8gS2VlcCBpbiBtaW5kIHRoYXQgdGhpcyBhZGRzIGEgY2FwdHVyaW5nIGdyb3VwLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVyblxuICAgKiBAcmV0dXJucyB7UmVnRXhwfVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlSW5saW5lKHBhdHRlcm4pIHtcbiAgICBwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKC88aW5uZXI+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbm5lcjtcbiAgICB9KTtcbiAgICByZXR1cm4gUmVnRXhwKC8oKD86XnxbXlxcXFxdKSg/OlxcXFx7Mn0pKikvLnNvdXJjZSArICcoPzonICsgcGF0dGVybiArICcpJyk7XG4gIH1cbiAgdmFyIHRhYmxlQ2VsbCA9IC8oPzpcXFxcLnxgYCg/OlteYFxcclxcbl18YCg/IWApKStgYHxgW15gXFxyXFxuXStgfFteXFxcXHxcXHJcXG5gXSkrLy5zb3VyY2U7XG4gIHZhciB0YWJsZVJvdyA9IC9cXHw/X18oPzpcXHxfXykrXFx8Pyg/Oig/OlxcbnxcXHJcXG4/KXwoPyFbXFxzXFxTXSkpLy5zb3VyY2UucmVwbGFjZSgvX18vZywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0YWJsZUNlbGw7XG4gIH0pO1xuICB2YXIgdGFibGVMaW5lID0gL1xcfD9bIFxcdF0qOj8tezMsfTo/WyBcXHRdKig/OlxcfFsgXFx0XSo6Py17Myx9Oj9bIFxcdF0qKStcXHw/KD86XFxufFxcclxcbj8pLy5zb3VyY2U7XG4gIFByaXNtLmxhbmd1YWdlcy5tYXJrZG93biA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ21hcmt1cCcsIHt9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya2Rvd24nLCAncHJvbG9nJywge1xuICAgICdmcm9udC1tYXR0ZXItYmxvY2snOiB7XG4gICAgICBwYXR0ZXJuOiAvKF4oPzpcXHMqW1xcclxcbl0pPyktLS0oPyEuKVtcXHNcXFNdKj9bXFxyXFxuXS0tLSg/IS4pLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL14tLS18LS0tJC8sXG4gICAgICAgICdmcm9udC1tYXR0ZXInOiB7XG4gICAgICAgICAgcGF0dGVybjogL1xcUysoPzpcXHMrXFxTKykqLyxcbiAgICAgICAgICBhbGlhczogWyd5YW1sJywgJ2xhbmd1YWdlLXlhbWwnXSxcbiAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy55YW1sXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdibG9ja3F1b3RlJzoge1xuICAgICAgLy8gPiAuLi5cbiAgICAgIHBhdHRlcm46IC9ePig/OltcXHQgXSo+KSovbSxcbiAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgfSxcbiAgICAndGFibGUnOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJ14nICsgdGFibGVSb3cgKyB0YWJsZUxpbmUgKyAnKD86JyArIHRhYmxlUm93ICsgJykqJywgJ20nKSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAndGFibGUtZGF0YS1yb3dzJzoge1xuICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXignICsgdGFibGVSb3cgKyB0YWJsZUxpbmUgKyAnKSg/OicgKyB0YWJsZVJvdyArICcpKiQnKSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ3RhYmxlLWRhdGEnOiB7XG4gICAgICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cCh0YWJsZUNlbGwpLFxuICAgICAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5tYXJrZG93blxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9cXHwvXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAndGFibGUtbGluZSc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoJ14oJyArIHRhYmxlUm93ICsgJyknICsgdGFibGVMaW5lICsgJyQnKSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcfHw6Py17Myx9Oj8vXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAndGFibGUtaGVhZGVyLXJvdyc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoJ14nICsgdGFibGVSb3cgKyAnJCcpLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ3RhYmxlLWhlYWRlcic6IHtcbiAgICAgICAgICAgICAgcGF0dGVybjogUmVnRXhwKHRhYmxlQ2VsbCksXG4gICAgICAgICAgICAgIGFsaWFzOiAnaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncHVuY3R1YXRpb24nOiAvXFx8L1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ2NvZGUnOiBbe1xuICAgICAgLy8gUHJlZml4ZWQgYnkgNCBzcGFjZXMgb3IgMSB0YWIgYW5kIHByZWNlZGVkIGJ5IGFuIGVtcHR5IGxpbmVcbiAgICAgIHBhdHRlcm46IC8oKD86XnxcXG4pWyBcXHRdKlxcbnwoPzpefFxcclxcbj8pWyBcXHRdKlxcclxcbj8pKD86IHs0fXxcXHQpLisoPzooPzpcXG58XFxyXFxuPykoPzogezR9fFxcdCkuKykqLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ2tleXdvcmQnXG4gICAgfSwge1xuICAgICAgLy8gYGBgb3B0aW9uYWwgbGFuZ3VhZ2VcbiAgICAgIC8vIGNvZGUgYmxvY2tcbiAgICAgIC8vIGBgYFxuICAgICAgcGF0dGVybjogL15gYGBbXFxzXFxTXSo/XmBgYCQvbSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnY29kZS1ibG9jayc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXihgYGAuKig/OlxcbnxcXHJcXG4/KSlbXFxzXFxTXSs/KD89KD86XFxufFxcclxcbj8pXmBgYCQpL20sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAnY29kZS1sYW5ndWFnZSc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXihgYGApLisvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL2BgYC9cbiAgICAgIH1cbiAgICB9XSxcbiAgICAndGl0bGUnOiBbe1xuICAgICAgLy8gdGl0bGUgMVxuICAgICAgLy8gPT09PT09PVxuXG4gICAgICAvLyB0aXRsZSAyXG4gICAgICAvLyAtLS0tLS0tXG4gICAgICBwYXR0ZXJuOiAvXFxTLiooPzpcXG58XFxyXFxuPykoPzo9PSt8LS0rKSg/PVsgXFx0XSokKS9tLFxuICAgICAgYWxpYXM6ICdpbXBvcnRhbnQnLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgIHB1bmN0dWF0aW9uOiAvPT0rJHwtLSskL1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vICMgdGl0bGUgMVxuICAgICAgLy8gIyMjIyMjIHRpdGxlIDZcbiAgICAgIHBhdHRlcm46IC8oXlxccyopIy4rL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdpbXBvcnRhbnQnLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgIHB1bmN0dWF0aW9uOiAvXiMrfCMrJC9cbiAgICAgIH1cbiAgICB9XSxcbiAgICAnaHInOiB7XG4gICAgICAvLyAqKipcbiAgICAgIC8vIC0tLVxuICAgICAgLy8gKiAqICpcbiAgICAgIC8vIC0tLS0tLS0tLS0tXG4gICAgICBwYXR0ZXJuOiAvKF5cXHMqKShbKi1dKSg/OltcXHQgXSpcXDIpezIsfSg/PVxccyokKS9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgfSxcbiAgICAnbGlzdCc6IHtcbiAgICAgIC8vICogaXRlbVxuICAgICAgLy8gKyBpdGVtXG4gICAgICAvLyAtIGl0ZW1cbiAgICAgIC8vIDEuIGl0ZW1cbiAgICAgIHBhdHRlcm46IC8oXlxccyopKD86WyorLV18XFxkK1xcLikoPz1bXFx0IF0uKS9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgfSxcbiAgICAndXJsLXJlZmVyZW5jZSc6IHtcbiAgICAgIC8vIFtpZF06IGh0dHA6Ly9leGFtcGxlLmNvbSBcIk9wdGlvbmFsIHRpdGxlXCJcbiAgICAgIC8vIFtpZF06IGh0dHA6Ly9leGFtcGxlLmNvbSAnT3B0aW9uYWwgdGl0bGUnXG4gICAgICAvLyBbaWRdOiBodHRwOi8vZXhhbXBsZS5jb20gKE9wdGlvbmFsIHRpdGxlKVxuICAgICAgLy8gW2lkXTogPGh0dHA6Ly9leGFtcGxlLmNvbT4gXCJPcHRpb25hbCB0aXRsZVwiXG4gICAgICBwYXR0ZXJuOiAvIT9cXFtbXlxcXV0rXFxdOltcXHQgXSsoPzpcXFMrfDwoPzpcXFxcLnxbXj5cXFxcXSkrPikoPzpbXFx0IF0rKD86XCIoPzpcXFxcLnxbXlwiXFxcXF0pKlwifCcoPzpcXFxcLnxbXidcXFxcXSkqJ3xcXCgoPzpcXFxcLnxbXilcXFxcXSkqXFwpKSk/LyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAndmFyaWFibGUnOiB7XG4gICAgICAgICAgcGF0dGVybjogL14oIT9cXFspW15cXF1dKy8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAnc3RyaW5nJzogLyg/OlwiKD86XFxcXC58W15cIlxcXFxdKSpcInwnKD86XFxcXC58W14nXFxcXF0pKid8XFwoKD86XFxcXC58W14pXFxcXF0pKlxcKSkkLyxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL15bXFxbXFxdITpdfFs8Pl0vXG4gICAgICB9LFxuICAgICAgYWxpYXM6ICd1cmwnXG4gICAgfSxcbiAgICAnYm9sZCc6IHtcbiAgICAgIC8vICoqc3Ryb25nKipcbiAgICAgIC8vIF9fc3Ryb25nX19cblxuICAgICAgLy8gYWxsb3cgb25lIG5lc3RlZCBpbnN0YW5jZSBvZiBpdGFsaWMgdGV4dCB1c2luZyB0aGUgc2FtZSBkZWxpbWl0ZXJcbiAgICAgIHBhdHRlcm46IGNyZWF0ZUlubGluZSgvXFxiX18oPzooPyFfKTxpbm5lcj58Xyg/Oig/IV8pPGlubmVyPikrXykrX19cXGJ8XFwqXFwqKD86KD8hXFwqKTxpbm5lcj58XFwqKD86KD8hXFwqKTxpbm5lcj4pK1xcKikrXFwqXFwqLy5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnY29udGVudCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF4uLilbXFxzXFxTXSsoPz0uLiQpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGluc2lkZToge30gLy8gc2VlIGJlbG93XG4gICAgICAgIH0sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9cXCpcXCp8X18vXG4gICAgICB9XG4gICAgfSxcbiAgICAnaXRhbGljJzoge1xuICAgICAgLy8gKmVtKlxuICAgICAgLy8gX2VtX1xuXG4gICAgICAvLyBhbGxvdyBvbmUgbmVzdGVkIGluc3RhbmNlIG9mIGJvbGQgdGV4dCB1c2luZyB0aGUgc2FtZSBkZWxpbWl0ZXJcbiAgICAgIHBhdHRlcm46IGNyZWF0ZUlubGluZSgvXFxiXyg/Oig/IV8pPGlubmVyPnxfXyg/Oig/IV8pPGlubmVyPikrX18pK19cXGJ8XFwqKD86KD8hXFwqKTxpbm5lcj58XFwqXFwqKD86KD8hXFwqKTxpbm5lcj4pK1xcKlxcKikrXFwqLy5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnY29udGVudCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF4uKVtcXHNcXFNdKyg/PS4kKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBpbnNpZGU6IHt9IC8vIHNlZSBiZWxvd1xuICAgICAgICB9LFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvWypfXS9cbiAgICAgIH1cbiAgICB9LFxuICAgICdzdHJpa2UnOiB7XG4gICAgICAvLyB+fnN0cmlrZSB0aHJvdWdofn5cbiAgICAgIC8vIH5zdHJpa2V+XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL3N0cmljdFxuICAgICAgcGF0dGVybjogY3JlYXRlSW5saW5lKC8ofn4/KSg/Oig/IX4pPGlubmVyPikrXFwyLy5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnY29udGVudCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF5+fj8pW1xcc1xcU10rKD89XFwxJCkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgaW5zaWRlOiB7fSAvLyBzZWUgYmVsb3dcbiAgICAgICAgfSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL35+Py9cbiAgICAgIH1cbiAgICB9LFxuICAgICdjb2RlLXNuaXBwZXQnOiB7XG4gICAgICAvLyBgY29kZWBcbiAgICAgIC8vIGBgY29kZWBgXG4gICAgICBwYXR0ZXJuOiAvKF58W15cXFxcYF0pKD86YGBbXmBcXHJcXG5dKyg/OmBbXmBcXHJcXG5dKykqYGAoPyFgKXxgW15gXFxyXFxuXStgKD8hYCkpLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBhbGlhczogWydjb2RlJywgJ2tleXdvcmQnXVxuICAgIH0sXG4gICAgJ3VybCc6IHtcbiAgICAgIC8vIFtleGFtcGxlXShodHRwOi8vZXhhbXBsZS5jb20gXCJPcHRpb25hbCB0aXRsZVwiKVxuICAgICAgLy8gW2V4YW1wbGVdW2lkXVxuICAgICAgLy8gW2V4YW1wbGVdIFtpZF1cbiAgICAgIHBhdHRlcm46IGNyZWF0ZUlubGluZSgvIT9cXFsoPzooPyFcXF0pPGlubmVyPikrXFxdKD86XFwoW15cXHMpXSsoPzpbXFx0IF0rXCIoPzpcXFxcLnxbXlwiXFxcXF0pKlwiKT9cXCl8WyBcXHRdP1xcWyg/Oig/IVxcXSk8aW5uZXI+KStcXF0pLy5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnb3BlcmF0b3InOiAvXiEvLFxuICAgICAgICAnY29udGVudCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF5cXFspW15cXF1dKyg/PVxcXSkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgaW5zaWRlOiB7fSAvLyBzZWUgYmVsb3dcbiAgICAgICAgfSxcbiAgICAgICAgJ3ZhcmlhYmxlJzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXlxcXVsgXFx0XT9cXFspW15cXF1dKyg/PVxcXSQpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICd1cmwnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyheXFxdXFwoKVteXFxzKV0rLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICdzdHJpbmcnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyheWyBcXHRdKylcIig/OlxcXFwufFteXCJcXFxcXSkqXCIoPz1cXCkkKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgWyd1cmwnLCAnYm9sZCcsICdpdGFsaWMnLCAnc3RyaWtlJ10uZm9yRWFjaChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBbJ3VybCcsICdib2xkJywgJ2l0YWxpYycsICdzdHJpa2UnLCAnY29kZS1zbmlwcGV0J10uZm9yRWFjaChmdW5jdGlvbiAoaW5zaWRlKSB7XG4gICAgICBpZiAodG9rZW4gIT09IGluc2lkZSkge1xuICAgICAgICBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd25bdG9rZW5dLmluc2lkZS5jb250ZW50Lmluc2lkZVtpbnNpZGVdID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmtkb3duW2luc2lkZV07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBQcmlzbS5ob29rcy5hZGQoJ2FmdGVyLXRva2VuaXplJywgZnVuY3Rpb24gKGVudikge1xuICAgIGlmIChlbnYubGFuZ3VhZ2UgIT09ICdtYXJrZG93bicgJiYgZW52Lmxhbmd1YWdlICE9PSAnbWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhbGtUb2tlbnModG9rZW5zKSB7XG4gICAgICBpZiAoIXRva2VucyB8fCB0eXBlb2YgdG9rZW5zID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gJ2NvZGUnKSB7XG4gICAgICAgICAgd2Fsa1Rva2Vucyh0b2tlbi5jb250ZW50KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEFkZCB0aGUgY29ycmVjdCBgbGFuZ3VhZ2UteHh4eGAgY2xhc3MgdG8gdGhpcyBjb2RlIGJsb2NrLiBLZWVwIGluIG1pbmQgdGhhdCB0aGUgYGNvZGUtbGFuZ3VhZ2VgIHRva2VuXG4gICAgICAgICAqIGlzIG9wdGlvbmFsLiBCdXQgdGhlIGdyYW1tYXIgaXMgZGVmaW5lZCBzbyB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIGNhc2Ugd2UgaGF2ZSB0byBoYW5kbGU6XG4gICAgICAgICAqXG4gICAgICAgICAqIHRva2VuLmNvbnRlbnQgPSBbXG4gICAgICAgICAqICAgICA8c3BhbiBjbGFzcz1cInB1bmN0dWF0aW9uXCI+YGBgPC9zcGFuPixcbiAgICAgICAgICogICAgIDxzcGFuIGNsYXNzPVwiY29kZS1sYW5ndWFnZVwiPnh4eHg8L3NwYW4+LFxuICAgICAgICAgKiAgICAgJ1xcbicsIC8vIGV4YWN0bHkgb25lIG5ldyBsaW5lcyAoXFxyIG9yIFxcbiBvciBcXHJcXG4pXG4gICAgICAgICAqICAgICA8c3BhbiBjbGFzcz1cImNvZGUtYmxvY2tcIj4uLi48L3NwYW4+LFxuICAgICAgICAgKiAgICAgJ1xcbicsIC8vIGV4YWN0bHkgb25lIG5ldyBsaW5lcyBhZ2FpblxuICAgICAgICAgKiAgICAgPHNwYW4gY2xhc3M9XCJwdW5jdHVhdGlvblwiPmBgYDwvc3Bhbj5cbiAgICAgICAgICogXTtcbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIGNvZGVMYW5nID0gdG9rZW4uY29udGVudFsxXTtcbiAgICAgICAgdmFyIGNvZGVCbG9jayA9IHRva2VuLmNvbnRlbnRbM107XG4gICAgICAgIGlmIChjb2RlTGFuZyAmJiBjb2RlQmxvY2sgJiYgY29kZUxhbmcudHlwZSA9PT0gJ2NvZGUtbGFuZ3VhZ2UnICYmIGNvZGVCbG9jay50eXBlID09PSAnY29kZS1ibG9jaycgJiYgdHlwZW9mIGNvZGVMYW5nLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gdGhpcyBtaWdodCBiZSBhIGxhbmd1YWdlIHRoYXQgUHJpc20gZG9lcyBub3Qgc3VwcG9ydFxuXG4gICAgICAgICAgLy8gZG8gc29tZSByZXBsYWNlbWVudHMgdG8gc3VwcG9ydCBDKyssIEMjLCBhbmQgRiNcbiAgICAgICAgICB2YXIgbGFuZyA9IGNvZGVMYW5nLmNvbnRlbnQucmVwbGFjZSgvXFxiIy9nLCAnc2hhcnAnKS5yZXBsYWNlKC9cXGJcXCtcXCsvZywgJ3BwJyk7XG4gICAgICAgICAgLy8gb25seSB1c2UgdGhlIGZpcnN0IHdvcmRcbiAgICAgICAgICBsYW5nID0gKC9bYS16XVtcXHctXSovaS5leGVjKGxhbmcpIHx8IFsnJ10pWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgdmFyIGFsaWFzID0gJ2xhbmd1YWdlLScgKyBsYW5nO1xuXG4gICAgICAgICAgLy8gYWRkIGFsaWFzXG4gICAgICAgICAgaWYgKCFjb2RlQmxvY2suYWxpYXMpIHtcbiAgICAgICAgICAgIGNvZGVCbG9jay5hbGlhcyA9IFthbGlhc107XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZUJsb2NrLmFsaWFzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29kZUJsb2NrLmFsaWFzID0gW2NvZGVCbG9jay5hbGlhcywgYWxpYXNdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlQmxvY2suYWxpYXMucHVzaChhbGlhcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHdhbGtUb2tlbnMoZW52LnRva2Vucyk7XG4gIH0pO1xuICBQcmlzbS5ob29rcy5hZGQoJ3dyYXAnLCBmdW5jdGlvbiAoZW52KSB7XG4gICAgaWYgKGVudi50eXBlICE9PSAnY29kZS1ibG9jaycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvZGVMYW5nID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbnYuY2xhc3Nlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjbHMgPSBlbnYuY2xhc3Nlc1tpXTtcbiAgICAgIHZhciBtYXRjaCA9IC9sYW5ndWFnZS0oLispLy5leGVjKGNscyk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY29kZUxhbmcgPSBtYXRjaFsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBncmFtbWFyID0gUHJpc20ubGFuZ3VhZ2VzW2NvZGVMYW5nXTtcbiAgICBpZiAoIWdyYW1tYXIpIHtcbiAgICAgIGlmIChjb2RlTGFuZyAmJiBjb2RlTGFuZyAhPT0gJ25vbmUnICYmIFByaXNtLnBsdWdpbnMuYXV0b2xvYWRlcikge1xuICAgICAgICB2YXIgaWQgPSAnbWQtJyArIG5ldyBEYXRlKCkudmFsdWVPZigpICsgJy0nICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWUxNik7XG4gICAgICAgIGVudi5hdHRyaWJ1dGVzWydpZCddID0gaWQ7XG4gICAgICAgIFByaXNtLnBsdWdpbnMuYXV0b2xvYWRlci5sb2FkTGFuZ3VhZ2VzKGNvZGVMYW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICBpZiAoZWxlKSB7XG4gICAgICAgICAgICBlbGUuaW5uZXJIVE1MID0gUHJpc20uaGlnaGxpZ2h0KGVsZS50ZXh0Q29udGVudCwgUHJpc20ubGFuZ3VhZ2VzW2NvZGVMYW5nXSwgY29kZUxhbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudi5jb250ZW50ID0gUHJpc20uaGlnaGxpZ2h0KHRleHRDb250ZW50KGVudi5jb250ZW50KSwgZ3JhbW1hciwgY29kZUxhbmcpO1xuICAgIH1cbiAgfSk7XG4gIHZhciB0YWdQYXR0ZXJuID0gUmVnRXhwKFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLnBhdHRlcm4uc291cmNlLCAnZ2knKTtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIGtub3duIGVudGl0eSBuYW1lcy5cbiAgICpcbiAgICogVGhpcyB3aWxsIGFsd2F5cyBiZSBpbmNvbXBsZXRlIHRvIHNhdmUgc3BhY2UuIFRoZSBjdXJyZW50IGxpc3QgaXMgdGhlIG9uZSB1c2VkIGJ5IGxvd2Rhc2gncyB1bmVzY2FwZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi8yZGEwMjRjM2I0Zjk5NDdhNDg1MTc2MzlkZTc1NjA0NTdjZDRlYzZjL3VuZXNjYXBlLmpzI0wyfVxuICAgKi9cbiAgdmFyIEtOT1dOX0VOVElUWV9OQU1FUyA9IHtcbiAgICAnYW1wJzogJyYnLFxuICAgICdsdCc6ICc8JyxcbiAgICAnZ3QnOiAnPicsXG4gICAgJ3F1b3QnOiAnXCInXG4gIH07XG5cbiAgLy8gSUUgMTEgZG9lc24ndCBzdXBwb3J0IGBTdHJpbmcuZnJvbUNvZGVQb2ludGBcbiAgdmFyIGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCB8fCBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYSBnaXZlbiBIVE1MIHNvdXJjZSBjb2RlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIHRleHRDb250ZW50KGh0bWwpIHtcbiAgICAvLyByZW1vdmUgYWxsIHRhZ3NcbiAgICB2YXIgdGV4dCA9IGh0bWwucmVwbGFjZSh0YWdQYXR0ZXJuLCAnJyk7XG5cbiAgICAvLyBkZWNvZGUga25vd24gZW50aXRpZXNcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8mKFxcd3sxLDh9fCN4P1tcXGRhLWZdezEsOH0pOy9naSwgZnVuY3Rpb24gKG0sIGNvZGUpIHtcbiAgICAgIGNvZGUgPSBjb2RlLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoY29kZVswXSA9PT0gJyMnKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKGNvZGVbMV0gPT09ICd4Jykge1xuICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoY29kZS5zbGljZSgyKSwgMTYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gTnVtYmVyKGNvZGUuc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tQ29kZVBvaW50KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrbm93biA9IEtOT1dOX0VOVElUWV9OQU1FU1tjb2RlXTtcbiAgICAgICAgaWYgKGtub3duKSB7XG4gICAgICAgICAgcmV0dXJuIGtub3duO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdW5hYmxlIHRvIGRlY29kZVxuICAgICAgICByZXR1cm4gbTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICBQcmlzbS5sYW5ndWFnZXMubWQgPSBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd247XG59KShQcmlzbSk7XG5QcmlzbS5sYW5ndWFnZXMub2JqZWN0aXZlYyA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2MnLCB7XG4gICdzdHJpbmcnOiB7XG4gICAgcGF0dGVybjogL0A/XCIoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlwiXFxcXFxcclxcbl0pKlwiLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2tleXdvcmQnOiAvXFxiKD86YXNtfGF1dG98YnJlYWt8Y2FzZXxjaGFyfGNvbnN0fGNvbnRpbnVlfGRlZmF1bHR8ZG98ZG91YmxlfGVsc2V8ZW51bXxleHRlcm58ZmxvYXR8Zm9yfGdvdG98aWZ8aW58aW5saW5lfGludHxsb25nfHJlZ2lzdGVyfHJldHVybnxzZWxmfHNob3J0fHNpZ25lZHxzaXplb2Z8c3RhdGljfHN0cnVjdHxzdXBlcnxzd2l0Y2h8dHlwZWRlZnx0eXBlb2Z8dW5pb258dW5zaWduZWR8dm9pZHx2b2xhdGlsZXx3aGlsZSlcXGJ8KD86QGludGVyZmFjZXxAZW5kfEBpbXBsZW1lbnRhdGlvbnxAcHJvdG9jb2x8QGNsYXNzfEBwdWJsaWN8QHByb3RlY3RlZHxAcHJpdmF0ZXxAcHJvcGVydHl8QHRyeXxAY2F0Y2h8QGZpbmFsbHl8QHRocm93fEBzeW50aGVzaXplfEBkeW5hbWljfEBzZWxlY3RvcilcXGIvLFxuICAnb3BlcmF0b3InOiAvLVstPl0/fFxcK1xcKz98IT0/fDw8Pz0/fD4+Pz0/fD09P3wmJj98XFx8XFx8P3xbfl4lPypcXC9AXS9cbn0pO1xuZGVsZXRlIFByaXNtLmxhbmd1YWdlcy5vYmplY3RpdmVjWydjbGFzcy1uYW1lJ107XG5QcmlzbS5sYW5ndWFnZXMub2JqYyA9IFByaXNtLmxhbmd1YWdlcy5vYmplY3RpdmVjO1xuKGZ1bmN0aW9uIChQcmlzbSkge1xuICB2YXIgYnJhY2tldHMgPSAvKD86XFwoKD86W14oKVxcXFxdfFxcXFxbXFxzXFxTXSkqXFwpfFxceyg/Oltee31cXFxcXXxcXFxcW1xcc1xcU10pKlxcfXxcXFsoPzpbXltcXF1cXFxcXXxcXFxcW1xcc1xcU10pKlxcXXw8KD86W148PlxcXFxdfFxcXFxbXFxzXFxTXSkqPikvLnNvdXJjZTtcbiAgUHJpc20ubGFuZ3VhZ2VzLnBlcmwgPSB7XG4gICAgJ2NvbW1lbnQnOiBbe1xuICAgICAgLy8gUE9EXG4gICAgICBwYXR0ZXJuOiAvKF5cXHMqKT1cXHdbXFxzXFxTXSo/PWN1dC4qL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogLyhefFteXFxcXCRdKSMuKi8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfV0sXG4gICAgLy8gVE9ETyBDb3VsZCBiZSBuaWNlIHRvIGhhbmRsZSBIZXJlZG9jIHRvby5cbiAgICAnc3RyaW5nJzogW3tcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvXFxiKD86cXxxcXxxd3xxeCkoPyFbYS16QS1aMC05XSlcXHMqLy5zb3VyY2UgKyAnKD86JyArIFtcbiAgICAgIC8vIHEvLi4uL1xuICAgICAgLyhbXmEtekEtWjAtOVxcc3soXFxbPF0pKD86KD8hXFwxKVteXFxcXF18XFxcXFtcXHNcXFNdKSpcXDEvLnNvdXJjZSxcbiAgICAgIC8vIHEgYS4uLmFcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvc3RyaWN0XG4gICAgICAvKFthLXpBLVowLTldKSg/Oig/IVxcMilbXlxcXFxdfFxcXFxbXFxzXFxTXSkqXFwyLy5zb3VyY2UsXG4gICAgICAvLyBxKC4uLilcbiAgICAgIC8vIHF7Li4ufVxuICAgICAgLy8gcVsuLi5dXG4gICAgICAvLyBxPC4uLj5cbiAgICAgIGJyYWNrZXRzXS5qb2luKCd8JykgKyAnKScpLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSxcbiAgICAvLyBcIi4uLlwiLCBgLi4uYFxuICAgIHtcbiAgICAgIHBhdHRlcm46IC8oXCJ8YCkoPzooPyFcXDEpW15cXFxcXXxcXFxcW1xcc1xcU10pKlxcMS8sXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgIC8vICcuLi4nXG4gICAgLy8gRklYTUUgTXVsdGktbGluZSBzaW5nbGUtcXVvdGVkIHN0cmluZ3MgYXJlIG5vdCBzdXBwb3J0ZWQgYXMgdGhleSB3b3VsZCBicmVhayB2YXJpYWJsZXMgY29udGFpbmluZyAnXG4gICAge1xuICAgICAgcGF0dGVybjogLycoPzpbXidcXFxcXFxyXFxuXXxcXFxcLikqJy8sXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9XSxcbiAgICAncmVnZXgnOiBbe1xuICAgICAgcGF0dGVybjogUmVnRXhwKC9cXGIoPzptfHFyKSg/IVthLXpBLVowLTldKVxccyovLnNvdXJjZSArICcoPzonICsgW1xuICAgICAgLy8gbS8uLi4vXG4gICAgICAvKFteYS16QS1aMC05XFxzeyhcXFs8XSkoPzooPyFcXDEpW15cXFxcXXxcXFxcW1xcc1xcU10pKlxcMS8uc291cmNlLFxuICAgICAgLy8gbSBhLi4uYVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9zdHJpY3RcbiAgICAgIC8oW2EtekEtWjAtOV0pKD86KD8hXFwyKVteXFxcXF18XFxcXFtcXHNcXFNdKSpcXDIvLnNvdXJjZSxcbiAgICAgIC8vIG0oLi4uKVxuICAgICAgLy8gbXsuLi59XG4gICAgICAvLyBtWy4uLl1cbiAgICAgIC8vIG08Li4uPlxuICAgICAgYnJhY2tldHNdLmpvaW4oJ3wnKSArICcpJyArIC9bbXNpeHBvZHVhbG5nY10qLy5zb3VyY2UpLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSxcbiAgICAvLyBUaGUgbG9va2JlaGluZHMgcHJldmVudCAtcyBmcm9tIGJyZWFraW5nXG4gICAge1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oXnxbXi1dKVxcYig/OnN8dHJ8eSkoPyFbYS16QS1aMC05XSlcXHMqLy5zb3VyY2UgKyAnKD86JyArIFtcbiAgICAgIC8vIHMvLi4uLy4uLi9cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvc3RyaWN0XG4gICAgICAvKFteYS16QS1aMC05XFxzeyhcXFs8XSkoPzooPyFcXDIpW15cXFxcXXxcXFxcW1xcc1xcU10pKlxcMig/Oig/IVxcMilbXlxcXFxdfFxcXFxbXFxzXFxTXSkqXFwyLy5zb3VyY2UsXG4gICAgICAvLyBzIGEuLi5hLi4uYVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9zdHJpY3RcbiAgICAgIC8oW2EtekEtWjAtOV0pKD86KD8hXFwzKVteXFxcXF18XFxcXFtcXHNcXFNdKSpcXDMoPzooPyFcXDMpW15cXFxcXXxcXFxcW1xcc1xcU10pKlxcMy8uc291cmNlLFxuICAgICAgLy8gcyguLi4pKC4uLilcbiAgICAgIC8vIHN7Li4ufXsuLi59XG4gICAgICAvLyBzWy4uLl1bLi4uXVxuICAgICAgLy8gczwuLi4+PC4uLj5cbiAgICAgIC8vIHMoLi4uKVsuLi5dXG4gICAgICBicmFja2V0cyArIC9cXHMqLy5zb3VyY2UgKyBicmFja2V0c10uam9pbignfCcpICsgJyknICsgL1ttc2l4cG9kdWFsbmdjZXJdKi8uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgIC8vIC8uLi4vXG4gICAgLy8gVGhlIGxvb2stYWhlYWQgdHJpZXMgdG8gcHJldmVudCB0d28gZGl2aXNpb25zIG9uXG4gICAgLy8gdGhlIHNhbWUgbGluZSBmcm9tIGJlaW5nIGhpZ2hsaWdodGVkIGFzIHJlZ2V4LlxuICAgIC8vIFRoaXMgZG9lcyBub3Qgc3VwcG9ydCBtdWx0aS1saW5lIHJlZ2V4LlxuICAgIHtcbiAgICAgIHBhdHRlcm46IC9cXC8oPzpbXlxcL1xcXFxcXHJcXG5dfFxcXFwuKSpcXC9bbXNpeHBvZHVhbG5nY10qKD89XFxzKig/OiR8W1xcclxcbiwuO30pJnxcXC0rKn48PiE/Xl18KD86YW5kfGNtcHxlcXxnZXxndHxsZXxsdHxuZXxub3R8b3J8eHx4b3IpXFxiKSkvLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfV0sXG4gICAgLy8gRklYTUUgTm90IHN1cmUgYWJvdXQgdGhlIGhhbmRsaW5nIG9mIDo6LCAnLCBhbmQgI1xuICAgICd2YXJpYWJsZSc6IFtcbiAgICAvLyAke15QT1NUTUFUQ0h9XG4gICAgL1smKiRAJV1cXHtcXF5bQS1aXStcXH0vLFxuICAgIC8vICReVlxuICAgIC9bJiokQCVdXFxeW0EtWl9dLyxcbiAgICAvLyAkey4uLn1cbiAgICAvWyYqJEAlXSM/KD89XFx7KS8sXG4gICAgLy8gJGZvb1xuICAgIC9bJiokQCVdIz8oPzooPzo6OikqJz8oPyFcXGQpW1xcdyRdKyg/IVtcXHckXSkpKyg/Ojo6KSovLFxuICAgIC8vICQxXG4gICAgL1smKiRAJV1cXGQrLyxcbiAgICAvLyAkXywgQF8sICUhXG4gICAgLy8gVGhlIG5lZ2F0aXZlIGxvb2thaGVhZCBwcmV2ZW50cyBmcm9tIGJyZWFraW5nIHRoZSAlPSBvcGVyYXRvclxuICAgIC8oPyElPSlbJEAlXVshXCIjJCUmJygpKissXFwtLlxcLzo7PD0+P0BbXFxcXFxcXV5fYHt8fX5dL10sXG4gICAgJ2ZpbGVoYW5kbGUnOiB7XG4gICAgICAvLyA8PiwgPEZPTz4sIF9cbiAgICAgIHBhdHRlcm46IC88KD8hWzw9XSlcXFMqPz58XFxiX1xcYi8sXG4gICAgICBhbGlhczogJ3N5bWJvbCdcbiAgICB9LFxuICAgICd2LXN0cmluZyc6IHtcbiAgICAgIC8vIHYxLjIsIDEuMi4zXG4gICAgICBwYXR0ZXJuOiAvdlxcZCsoPzpcXC5cXGQrKSp8XFxkKyg/OlxcLlxcZCspezIsfS8sXG4gICAgICBhbGlhczogJ3N0cmluZydcbiAgICB9LFxuICAgICdmdW5jdGlvbic6IHtcbiAgICAgIHBhdHRlcm46IC8oXFxic3ViWyBcXHRdKylcXHcrLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdrZXl3b3JkJzogL1xcYig/OmFueXxicmVha3xjb250aW51ZXxkZWZhdWx0fGRlbGV0ZXxkaWV8ZG98ZWxzZXxlbHNpZnxldmFsfGZvcnxmb3JlYWNofGdpdmVufGdvdG98aWZ8bGFzdHxsb2NhbHxteXxuZXh0fG91cnxwYWNrYWdlfHByaW50fHJlZG98cmVxdWlyZXxyZXR1cm58c2F5fHN0YXRlfHN1Ynxzd2l0Y2h8dW5kZWZ8dW5sZXNzfHVudGlsfHVzZXx3aGVufHdoaWxlKVxcYi8sXG4gICAgJ251bWJlcic6IC9cXGIoPzoweFtcXGRBLUZhLWZdKD86Xz9bXFxkQS1GYS1mXSkqfDBiWzAxXSg/Ol8/WzAxXSkqfCg/Oig/OlxcZCg/Ol8/XFxkKSopP1xcLik/XFxkKD86Xz9cXGQpKig/OltFZV1bKy1dP1xcZCspPylcXGIvLFxuICAgICdvcGVyYXRvcic6IC8tW3J3eG9SV1hPZXpzZmRscFNiY3R1Z2tUQk1BQ11cXGJ8XFwrWys9XT98LVstPT5dP3xcXCpcXCo/PT98XFwvXFwvPz0/fD1bPX4+XT98flt+PV0/fFxcfFxcfD89P3wmJj89P3w8KD86PT4/fDw9Pyk/fD4+Pz0/fCFbfj1dP3xbJV5dPT98XFwuKD86PXxcXC5cXC4/KT98W1xcXFw/XXxcXGJ4KD86PXxcXGIpfFxcYig/OmFuZHxjbXB8ZXF8Z2V8Z3R8bGV8bHR8bmV8bm90fG9yfHhvcilcXGIvLFxuICAgICdwdW5jdHVhdGlvbic6IC9be31bXFxdOygpLDpdL1xuICB9O1xufSkoUHJpc20pO1xuKGZ1bmN0aW9uIChQcmlzbSkge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgZm9yIHRoZSBnaXZlbiBsYW5ndWFnZSBpZCBhbmQgaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRQbGFjZWhvbGRlcihsYW5ndWFnZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gJ19fXycgKyBsYW5ndWFnZS50b1VwcGVyQ2FzZSgpICsgaW5kZXggKyAnX19fJztcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhQcmlzbS5sYW5ndWFnZXNbJ21hcmt1cC10ZW1wbGF0aW5nJ10gPSB7fSwge1xuICAgIGJ1aWxkUGxhY2Vob2xkZXJzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRva2VuaXplIGFsbCBpbmxpbmUgdGVtcGxhdGluZyBleHByZXNzaW9ucyBtYXRjaGluZyBgcGxhY2Vob2xkZXJQYXR0ZXJuYC5cbiAgICAgICAqXG4gICAgICAgKiBJZiBgcmVwbGFjZUZpbHRlcmAgaXMgcHJvdmlkZWQsIG9ubHkgbWF0Y2hlcyBvZiBgcGxhY2Vob2xkZXJQYXR0ZXJuYCBmb3Igd2hpY2ggYHJlcGxhY2VGaWx0ZXJgIHJldHVybnNcbiAgICAgICAqIGB0cnVlYCB3aWxsIGJlIHJlcGxhY2VkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbnYgVGhlIGVudmlyb25tZW50IG9mIHRoZSBgYmVmb3JlLXRva2VuaXplYCBob29rLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlIFRoZSBsYW5ndWFnZSBpZC5cbiAgICAgICAqIEBwYXJhbSB7UmVnRXhwfSBwbGFjZWhvbGRlclBhdHRlcm4gVGhlIG1hdGNoZXMgb2YgdGhpcyBwYXR0ZXJuIHdpbGwgYmUgcmVwbGFjZWQgYnkgcGxhY2Vob2xkZXJzLlxuICAgICAgICogQHBhcmFtIHsobWF0Y2g6IHN0cmluZykgPT4gYm9vbGVhbn0gW3JlcGxhY2VGaWx0ZXJdXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZW52LCBsYW5ndWFnZSwgcGxhY2Vob2xkZXJQYXR0ZXJuLCByZXBsYWNlRmlsdGVyKSB7XG4gICAgICAgIGlmIChlbnYubGFuZ3VhZ2UgIT09IGxhbmd1YWdlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b2tlblN0YWNrID0gZW52LnRva2VuU3RhY2sgPSBbXTtcbiAgICAgICAgZW52LmNvZGUgPSBlbnYuY29kZS5yZXBsYWNlKHBsYWNlaG9sZGVyUGF0dGVybiwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlRmlsdGVyID09PSAnZnVuY3Rpb24nICYmICFyZXBsYWNlRmlsdGVyKG1hdGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaSA9IHRva2VuU3RhY2subGVuZ3RoO1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlcjtcblxuICAgICAgICAgIC8vIENoZWNrIGZvciBleGlzdGluZyBzdHJpbmdzXG4gICAgICAgICAgd2hpbGUgKGVudi5jb2RlLmluZGV4T2YocGxhY2Vob2xkZXIgPSBnZXRQbGFjZWhvbGRlcihsYW5ndWFnZSwgaSkpICE9PSAtMSkge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSBhIHNwYXJzZSBhcnJheVxuICAgICAgICAgIHRva2VuU3RhY2tbaV0gPSBtYXRjaDtcbiAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN3aXRjaCB0aGUgZ3JhbW1hciB0byBtYXJrdXBcbiAgICAgICAgZW52LmdyYW1tYXIgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9rZW5pemVQbGFjZWhvbGRlcnM6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVwbGFjZSBwbGFjZWhvbGRlcnMgd2l0aCBwcm9wZXIgdG9rZW5zIGFmdGVyIHRva2VuaXppbmcuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IGVudiBUaGUgZW52aXJvbm1lbnQgb2YgdGhlIGBhZnRlci10b2tlbml6ZWAgaG9vay5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBUaGUgbGFuZ3VhZ2UgaWQuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZW52LCBsYW5ndWFnZSkge1xuICAgICAgICBpZiAoZW52Lmxhbmd1YWdlICE9PSBsYW5ndWFnZSB8fCAhZW52LnRva2VuU3RhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTd2l0Y2ggdGhlIGdyYW1tYXIgYmFja1xuICAgICAgICBlbnYuZ3JhbW1hciA9IFByaXNtLmxhbmd1YWdlc1tsYW5ndWFnZV07XG4gICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhlbnYudG9rZW5TdGFjayk7XG4gICAgICAgIGZ1bmN0aW9uIHdhbGtUb2tlbnModG9rZW5zKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGFsbCBwbGFjZWhvbGRlcnMgYXJlIHJlcGxhY2VkIGFscmVhZHlcbiAgICAgICAgICAgIGlmIChqID49IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycgfHwgdG9rZW4uY29udGVudCAmJiB0eXBlb2YgdG9rZW4uY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdmFyIGsgPSBrZXlzW2pdO1xuICAgICAgICAgICAgICB2YXIgdCA9IGVudi50b2tlblN0YWNrW2tdO1xuICAgICAgICAgICAgICB2YXIgcyA9IHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycgPyB0b2tlbiA6IHRva2VuLmNvbnRlbnQ7XG4gICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGdldFBsYWNlaG9sZGVyKGxhbmd1YWdlLCBrKTtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcy5pbmRleE9mKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHMuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB2YXIgbWlkZGxlID0gbmV3IFByaXNtLlRva2VuKGxhbmd1YWdlLCBQcmlzbS50b2tlbml6ZSh0LCBlbnYuZ3JhbW1hciksICdsYW5ndWFnZS0nICsgbGFuZ3VhZ2UsIHQpO1xuICAgICAgICAgICAgICAgIHZhciBhZnRlciA9IHMuc3Vic3RyaW5nKGluZGV4ICsgcGxhY2Vob2xkZXIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wdXNoLmFwcGx5KHJlcGxhY2VtZW50LCB3YWxrVG9rZW5zKFtiZWZvcmVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnB1c2gobWlkZGxlKTtcbiAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnB1c2guYXBwbHkocmVwbGFjZW1lbnQsIHdhbGtUb2tlbnMoW2FmdGVyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgdG9rZW5zLnNwbGljZS5hcHBseSh0b2tlbnMsIFtpLCAxXS5jb25jYXQocmVwbGFjZW1lbnQpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi5jb250ZW50IC8qICYmIHR5cGVvZiB0b2tlbi5jb250ZW50ICE9PSAnc3RyaW5nJyAqLykge1xuICAgICAgICAgICAgICB3YWxrVG9rZW5zKHRva2VuLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICB9XG4gICAgICAgIHdhbGtUb2tlbnMoZW52LnRva2Vucyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pKFByaXNtKTtcblxuLyoqXG4gKiBPcmlnaW5hbCBieSBBYXJvbiBIYXJ1bjogaHR0cDovL2FhaGFjcmVhdGl2ZS5jb20vMjAxMi8wNy8zMS9waHAtc3ludGF4LWhpZ2hsaWdodGluZy1wcmlzbS9cbiAqIE1vZGlmaWVkIGJ5IE1pbGVzIEpvaG5zb246IGh0dHA6Ly9taWxlc2oubWVcbiAqIFJld3JpdHRlbiBieSBUb20gUGF2ZWxlY1xuICpcbiAqIFN1cHBvcnRzIFBIUCA1LjMgLSA4LjBcbiAqL1xuKGZ1bmN0aW9uIChQcmlzbSkge1xuICB2YXIgY29tbWVudCA9IC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvfFxcL1xcLy4qfCMoPyFcXFspLiovO1xuICB2YXIgY29uc3RhbnQgPSBbe1xuICAgIHBhdHRlcm46IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi9pLFxuICAgIGFsaWFzOiAnYm9vbGVhbidcbiAgfSwge1xuICAgIHBhdHRlcm46IC8oOjpcXHMqKVxcYlthLXpfXVxcdypcXGIoPyFcXHMqXFwoKS9pLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKFxcYig/OmNhc2V8Y29uc3QpXFxzKylcXGJbYS16X11cXHcqKD89XFxzKls7PV0pL2ksXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSwgL1xcYig/Om51bGwpXFxiL2ksIC9cXGJbQS1aX11bQS1aMC05X10qXFxiKD8hXFxzKlxcKCkvXTtcbiAgdmFyIG51bWJlciA9IC9cXGIwYlswMV0rKD86X1swMV0rKSpcXGJ8XFxiMG9bMC03XSsoPzpfWzAtN10rKSpcXGJ8XFxiMHhbXFxkYS1mXSsoPzpfW1xcZGEtZl0rKSpcXGJ8KD86XFxiXFxkKyg/Ol9cXGQrKSpcXC4/KD86XFxkKyg/Ol9cXGQrKSopP3xcXEJcXC5cXGQrKSg/OmVbKy1dP1xcZCspPy9pO1xuICB2YXIgb3BlcmF0b3IgPSAvPD89PnxcXD9cXD89P3xcXC57M318XFw/Py0+fFshPV09Pz0/fDo6fFxcKlxcKj0/fC0tfFxcK1xcK3wmJnxcXHxcXHx8PDx8Pj58Wz9+XXxbL158JSomPD4uKy1dPT8vO1xuICB2YXIgcHVuY3R1YXRpb24gPSAvW3t9XFxbXFxdKCksOjtdLztcbiAgUHJpc20ubGFuZ3VhZ2VzLnBocCA9IHtcbiAgICAnZGVsaW1pdGVyJzoge1xuICAgICAgcGF0dGVybjogL1xcPz4kfF48XFw/KD86cGhwKD89XFxzKXw9KT8vaSxcbiAgICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICAgIH0sXG4gICAgJ2NvbW1lbnQnOiBjb21tZW50LFxuICAgICd2YXJpYWJsZSc6IC9cXCQrKD86XFx3K1xcYnwoPz1cXHspKS8sXG4gICAgJ3BhY2thZ2UnOiB7XG4gICAgICBwYXR0ZXJuOiAvKG5hbWVzcGFjZVxccyt8dXNlXFxzKyg/OmZ1bmN0aW9uXFxzKyk/KSg/OlxcXFw/XFxiW2Etel9dXFx3KikrXFxiKD8hXFxcXCkvaSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcXFwvXG4gICAgICB9XG4gICAgfSxcbiAgICAnY2xhc3MtbmFtZS1kZWZpbml0aW9uJzoge1xuICAgICAgcGF0dGVybjogLyhcXGIoPzpjbGFzc3xlbnVtfGludGVyZmFjZXx0cmFpdClcXHMrKVxcYlthLXpfXVxcdyooPyFcXFxcKVxcYi9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZSdcbiAgICB9LFxuICAgICdmdW5jdGlvbi1kZWZpbml0aW9uJzoge1xuICAgICAgcGF0dGVybjogLyhcXGJmdW5jdGlvblxccyspW2Etel9dXFx3Kig/PVxccypcXCgpL2ksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgICB9LFxuICAgICdrZXl3b3JkJzogW3tcbiAgICAgIHBhdHRlcm46IC8oXFwoXFxzKilcXGIoPzphcnJheXxib29sfGJvb2xlYW58ZmxvYXR8aW50fGludGVnZXJ8b2JqZWN0fHN0cmluZylcXGIoPz1cXHMqXFwpKS9pLFxuICAgICAgYWxpYXM6ICd0eXBlLWNhc3RpbmcnLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC8oWygsP11cXHMqKVxcYig/OmFycmF5KD8hXFxzKlxcKCl8Ym9vbHxjYWxsYWJsZXwoPzpmYWxzZXxudWxsKSg/PVxccypcXHwpfGZsb2F0fGludHxpdGVyYWJsZXxtaXhlZHxvYmplY3R8c2VsZnxzdGF0aWN8c3RyaW5nKVxcYig/PVxccypcXCQpL2ksXG4gICAgICBhbGlhczogJ3R5cGUtaGludCcsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogLyhcXClcXHMqOlxccyooPzpcXD9cXHMqKT8pXFxiKD86YXJyYXkoPyFcXHMqXFwoKXxib29sfGNhbGxhYmxlfCg/OmZhbHNlfG51bGwpKD89XFxzKlxcfCl8ZmxvYXR8aW50fGl0ZXJhYmxlfG1peGVkfG5ldmVyfG9iamVjdHxzZWxmfHN0YXRpY3xzdHJpbmd8dm9pZClcXGIvaSxcbiAgICAgIGFsaWFzOiAncmV0dXJuLXR5cGUnLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC9cXGIoPzphcnJheSg/IVxccypcXCgpfGJvb2x8ZmxvYXR8aW50fGl0ZXJhYmxlfG1peGVkfG9iamVjdHxzdHJpbmd8dm9pZClcXGIvaSxcbiAgICAgIGFsaWFzOiAndHlwZS1kZWNsYXJhdGlvbicsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvKFxcfFxccyopKD86ZmFsc2V8bnVsbClcXGJ8XFxiKD86ZmFsc2V8bnVsbCkoPz1cXHMqXFx8KS9pLFxuICAgICAgYWxpYXM6ICd0eXBlLWRlY2xhcmF0aW9uJyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvXFxiKD86cGFyZW50fHNlbGZ8c3RhdGljKSg/PVxccyo6OikvaSxcbiAgICAgIGFsaWFzOiAnc3RhdGljLWNvbnRleHQnLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSwge1xuICAgICAgLy8geWllbGQgZnJvbVxuICAgICAgcGF0dGVybjogLyhcXGJ5aWVsZFxccyspZnJvbVxcYi9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgLy8gYGNsYXNzYCBpcyBhbHdheXMgYSBrZXl3b3JkIHVubGlrZSBvdGhlciBrZXl3b3Jkc1xuICAgIC9cXGJjbGFzc1xcYi9pLCB7XG4gICAgICAvLyBodHRwczovL3d3dy5waHAubmV0L21hbnVhbC9lbi9yZXNlcnZlZC5rZXl3b3Jkcy5waHBcbiAgICAgIC8vXG4gICAgICAvLyBrZXl3b3JkcyBjYW5ub3QgYmUgcHJlY2VkZWQgYnkgXCItPlwiXG4gICAgICAvLyB0aGUgY29tcGxleCBsb29rYmVoaW5kIG1lYW5zIGAoPzwhKD86LT58OjopXFxzKilgXG4gICAgICBwYXR0ZXJuOiAvKCg/Ol58W15cXHM+Ol18KD86XnxbXi1dKT58KD86XnxbXjpdKTopXFxzKilcXGIoPzphYnN0cmFjdHxhbmR8YXJyYXl8YXN8YnJlYWt8Y2FsbGFibGV8Y2FzZXxjYXRjaHxjbG9uZXxjb25zdHxjb250aW51ZXxkZWNsYXJlfGRlZmF1bHR8ZGllfGRvfGVjaG98ZWxzZXxlbHNlaWZ8ZW1wdHl8ZW5kZGVjbGFyZXxlbmRmb3J8ZW5kZm9yZWFjaHxlbmRpZnxlbmRzd2l0Y2h8ZW5kd2hpbGV8ZW51bXxldmFsfGV4aXR8ZXh0ZW5kc3xmaW5hbHxmaW5hbGx5fGZufGZvcnxmb3JlYWNofGZ1bmN0aW9ufGdsb2JhbHxnb3RvfGlmfGltcGxlbWVudHN8aW5jbHVkZXxpbmNsdWRlX29uY2V8aW5zdGFuY2VvZnxpbnN0ZWFkb2Z8aW50ZXJmYWNlfGlzc2V0fGxpc3R8bWF0Y2h8bmFtZXNwYWNlfG5ldmVyfG5ld3xvcnxwYXJlbnR8cHJpbnR8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJlYWRvbmx5fHJlcXVpcmV8cmVxdWlyZV9vbmNlfHJldHVybnxzZWxmfHN0YXRpY3xzd2l0Y2h8dGhyb3d8dHJhaXR8dHJ5fHVuc2V0fHVzZXx2YXJ8d2hpbGV8eG9yfHlpZWxkfF9faGFsdF9jb21waWxlcilcXGIvaSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9XSxcbiAgICAnYXJndW1lbnQtbmFtZSc6IHtcbiAgICAgIHBhdHRlcm46IC8oWygsXVxccyopXFxiW2Etel9dXFx3Kig/PVxccyo6KD8hOikpL2ksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnY2xhc3MtbmFtZSc6IFt7XG4gICAgICBwYXR0ZXJuOiAvKFxcYig/OmV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfG5ldyg/IVxccytzZWxmfFxccytzdGF0aWMpKVxccyt8XFxiY2F0Y2hcXHMqXFwoKVxcYlthLXpfXVxcdyooPyFcXFxcKVxcYi9pLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC8oXFx8XFxzKilcXGJbYS16X11cXHcqKD8hXFxcXClcXGIvaSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvXFxiW2Etel9dXFx3Kig/IVxcXFwpXFxiKD89XFxzKlxcfCkvaSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC8oXFx8XFxzKikoPzpcXFxcP1xcYlthLXpfXVxcdyopK1xcYi9pLFxuICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lLWZ1bGx5LXF1YWxpZmllZCcsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9cXFxcL1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC8oPzpcXFxcP1xcYlthLXpfXVxcdyopK1xcYig/PVxccypcXHwpL2ksXG4gICAgICBhbGlhczogJ2NsYXNzLW5hbWUtZnVsbHktcXVhbGlmaWVkJyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFxcXC9cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvKFxcYig/OmV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfG5ldyg/IVxccytzZWxmXFxifFxccytzdGF0aWNcXGIpKVxccyt8XFxiY2F0Y2hcXHMqXFwoKSg/OlxcXFw/XFxiW2Etel9dXFx3KikrXFxiKD8hXFxcXCkvaSxcbiAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZS1mdWxseS1xdWFsaWZpZWQnLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFxcXC9cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvXFxiW2Etel9dXFx3Kig/PVxccypcXCQpL2ksXG4gICAgICBhbGlhczogJ3R5cGUtZGVjbGFyYXRpb24nLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogLyg/OlxcXFw/XFxiW2Etel9dXFx3KikrKD89XFxzKlxcJCkvaSxcbiAgICAgIGFsaWFzOiBbJ2NsYXNzLW5hbWUtZnVsbHktcXVhbGlmaWVkJywgJ3R5cGUtZGVjbGFyYXRpb24nXSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFxcXC9cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvXFxiW2Etel9dXFx3Kig/PVxccyo6OikvaSxcbiAgICAgIGFsaWFzOiAnc3RhdGljLWNvbnRleHQnLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogLyg/OlxcXFw/XFxiW2Etel9dXFx3KikrKD89XFxzKjo6KS9pLFxuICAgICAgYWxpYXM6IFsnY2xhc3MtbmFtZS1mdWxseS1xdWFsaWZpZWQnLCAnc3RhdGljLWNvbnRleHQnXSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFxcXC9cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvKFsoLD9dXFxzKilbYS16X11cXHcqKD89XFxzKlxcJCkvaSxcbiAgICAgIGFsaWFzOiAndHlwZS1oaW50JyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvKFsoLD9dXFxzKikoPzpcXFxcP1xcYlthLXpfXVxcdyopKyg/PVxccypcXCQpL2ksXG4gICAgICBhbGlhczogWydjbGFzcy1uYW1lLWZ1bGx5LXF1YWxpZmllZCcsICd0eXBlLWhpbnQnXSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcXFwvXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcGF0dGVybjogLyhcXClcXHMqOlxccyooPzpcXD9cXHMqKT8pXFxiW2Etel9dXFx3Kig/IVxcXFwpXFxiL2ksXG4gICAgICBhbGlhczogJ3JldHVybi10eXBlJyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvKFxcKVxccyo6XFxzKig/OlxcP1xccyopPykoPzpcXFxcP1xcYlthLXpfXVxcdyopK1xcYig/IVxcXFwpL2ksXG4gICAgICBhbGlhczogWydjbGFzcy1uYW1lLWZ1bGx5LXF1YWxpZmllZCcsICdyZXR1cm4tdHlwZSddLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFxcXC9cbiAgICAgIH1cbiAgICB9XSxcbiAgICAnY29uc3RhbnQnOiBjb25zdGFudCxcbiAgICAnZnVuY3Rpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W15cXFxcXFx3XSlcXFxcP1thLXpfXSg/OltcXHdcXFxcXSpcXHcpPyg/PVxccypcXCgpL2ksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9cXFxcL1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3Byb3BlcnR5Jzoge1xuICAgICAgcGF0dGVybjogLygtPlxccyopXFx3Ky8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnbnVtYmVyJzogbnVtYmVyLFxuICAgICdvcGVyYXRvcic6IG9wZXJhdG9yLFxuICAgICdwdW5jdHVhdGlvbic6IHB1bmN0dWF0aW9uXG4gIH07XG4gIHZhciBzdHJpbmdfaW50ZXJwb2xhdGlvbiA9IHtcbiAgICBwYXR0ZXJuOiAvXFx7XFwkKD86XFx7KD86XFx7W157fV0rXFx9fFtee31dKylcXH18W157fV0pK1xcfXwoXnxbXlxcXFx7XSlcXCQrKD86XFx3Kyg/OlxcW1teXFxyXFxuXFxbXFxdXStcXF18LT5cXHcrKT8pLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLnBocFxuICB9O1xuICB2YXIgc3RyaW5nID0gW3tcbiAgICBwYXR0ZXJuOiAvPDw8JyhbXiddKyknW1xcclxcbl0oPzouKltcXHJcXG5dKSo/XFwxOy8sXG4gICAgYWxpYXM6ICdub3dkb2Mtc3RyaW5nJyxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnZGVsaW1pdGVyJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXjw8PCdbXiddKyd8W2Etel9dXFx3KjskL2ksXG4gICAgICAgIGFsaWFzOiAnc3ltYm9sJyxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ3B1bmN0dWF0aW9uJzogL148PDwnP3xbJztdJC9cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIHBhdHRlcm46IC88PDwoPzpcIihbXlwiXSspXCJbXFxyXFxuXSg/Oi4qW1xcclxcbl0pKj9cXDE7fChbYS16X11cXHcqKVtcXHJcXG5dKD86LipbXFxyXFxuXSkqP1xcMjspL2ksXG4gICAgYWxpYXM6ICdoZXJlZG9jLXN0cmluZycsXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ2RlbGltaXRlcic6IHtcbiAgICAgICAgcGF0dGVybjogL148PDwoPzpcIlteXCJdK1wifFthLXpfXVxcdyopfFthLXpfXVxcdyo7JC9pLFxuICAgICAgICBhbGlhczogJ3N5bWJvbCcsXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9ePDw8XCI/fFtcIjtdJC9cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdpbnRlcnBvbGF0aW9uJzogc3RyaW5nX2ludGVycG9sYXRpb25cbiAgICB9XG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvYCg/OlxcXFxbXFxzXFxTXXxbXlxcXFxgXSkqYC8sXG4gICAgYWxpYXM6ICdiYWNrdGljay1xdW90ZWQtc3RyaW5nJyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSwge1xuICAgIHBhdHRlcm46IC8nKD86XFxcXFtcXHNcXFNdfFteXFxcXCddKSonLyxcbiAgICBhbGlhczogJ3NpbmdsZS1xdW90ZWQtc3RyaW5nJyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSwge1xuICAgIHBhdHRlcm46IC9cIig/OlxcXFxbXFxzXFxTXXxbXlxcXFxcIl0pKlwiLyxcbiAgICBhbGlhczogJ2RvdWJsZS1xdW90ZWQtc3RyaW5nJyxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnaW50ZXJwb2xhdGlvbic6IHN0cmluZ19pbnRlcnBvbGF0aW9uXG4gICAgfVxuICB9XTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgncGhwJywgJ3ZhcmlhYmxlJywge1xuICAgICdzdHJpbmcnOiBzdHJpbmcsXG4gICAgJ2F0dHJpYnV0ZSc6IHtcbiAgICAgIHBhdHRlcm46IC8jXFxbKD86W15cIidcXC8jXXxcXC8oPyFbKi9dKXxcXC9cXC8uKiR8Iyg/IVxcWykuKiR8XFwvXFwqKD86W14qXXxcXCooPyFcXC8pKSpcXCpcXC98XCIoPzpcXFxcW1xcc1xcU118W15cXFxcXCJdKSpcInwnKD86XFxcXFtcXHNcXFNdfFteXFxcXCddKSonKStcXF0oPz1cXHMqW2EteiQjXSkvaW0sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2F0dHJpYnV0ZS1jb250ZW50Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC9eKCNcXFspW1xcc1xcU10rKD89XFxdJCkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgLy8gaW5zaWRlIGNhbiBhcHBlYXIgc3Vic2V0IG9mIHBocFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ2NvbW1lbnQnOiBjb21tZW50LFxuICAgICAgICAgICAgJ3N0cmluZyc6IHN0cmluZyxcbiAgICAgICAgICAgICdhdHRyaWJ1dGUtY2xhc3MtbmFtZSc6IFt7XG4gICAgICAgICAgICAgIHBhdHRlcm46IC8oW146XXxeKVxcYlthLXpfXVxcdyooPyFcXFxcKVxcYi9pLFxuICAgICAgICAgICAgICBhbGlhczogJ2NsYXNzLW5hbWUnLFxuICAgICAgICAgICAgICBncmVlZHk6IHRydWUsXG4gICAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgcGF0dGVybjogLyhbXjpdfF4pKD86XFxcXD9cXGJbYS16X11cXHcqKSsvaSxcbiAgICAgICAgICAgICAgYWxpYXM6IFsnY2xhc3MtbmFtZScsICdjbGFzcy1uYW1lLWZ1bGx5LXF1YWxpZmllZCddLFxuICAgICAgICAgICAgICBncmVlZHk6IHRydWUsXG4gICAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9cXFxcL1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICdjb25zdGFudCc6IGNvbnN0YW50LFxuICAgICAgICAgICAgJ251bWJlcic6IG51bWJlcixcbiAgICAgICAgICAgICdvcGVyYXRvcic6IG9wZXJhdG9yLFxuICAgICAgICAgICAgJ3B1bmN0dWF0aW9uJzogcHVuY3R1YXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICdkZWxpbWl0ZXInOiB7XG4gICAgICAgICAgcGF0dGVybjogL14jXFxbfFxcXSQvLFxuICAgICAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBQcmlzbS5ob29rcy5hZGQoJ2JlZm9yZS10b2tlbml6ZScsIGZ1bmN0aW9uIChlbnYpIHtcbiAgICBpZiAoIS88XFw/Ly50ZXN0KGVudi5jb2RlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGhwUGF0dGVybiA9IC88XFw/KD86W15cIicvI118XFwvKD8hWyovXSl8KFwifCcpKD86XFxcXFtcXHNcXFNdfCg/IVxcMSlbXlxcXFxdKSpcXDF8KD86XFwvXFwvfCMoPyFcXFspKSg/OlteP1xcblxccl18XFw/KD8hPikpKig/PSR8XFw/PnxbXFxyXFxuXSl8I1xcW3xcXC9cXCooPzpbXipdfFxcKig/IVxcLykpKig/OlxcKlxcL3wkKSkqPyg/OlxcPz58JCkvZztcbiAgICBQcmlzbS5sYW5ndWFnZXNbJ21hcmt1cC10ZW1wbGF0aW5nJ10uYnVpbGRQbGFjZWhvbGRlcnMoZW52LCAncGhwJywgcGhwUGF0dGVybik7XG4gIH0pO1xuICBQcmlzbS5ob29rcy5hZGQoJ2FmdGVyLXRva2VuaXplJywgZnVuY3Rpb24gKGVudikge1xuICAgIFByaXNtLmxhbmd1YWdlc1snbWFya3VwLXRlbXBsYXRpbmcnXS50b2tlbml6ZVBsYWNlaG9sZGVycyhlbnYsICdwaHAnKTtcbiAgfSk7XG59KShQcmlzbSk7XG5QcmlzbS5sYW5ndWFnZXMucHl0aG9uID0ge1xuICAnY29tbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSkjLiovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdzdHJpbmctaW50ZXJwb2xhdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvKD86ZnxmcnxyZikoPzooXCJcIlwifCcnJylbXFxzXFxTXSo/XFwxfChcInwnKSg/OlxcXFwufCg/IVxcMilbXlxcXFxcXHJcXG5dKSpcXDIpL2ksXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ2ludGVycG9sYXRpb24nOiB7XG4gICAgICAgIC8vIFwie1wiIDxleHByZXNzaW9uPiA8b3B0aW9uYWwgXCIhc1wiLCBcIiFyXCIsIG9yIFwiIWFcIj4gPG9wdGlvbmFsIFwiOlwiIGZvcm1hdCBzcGVjaWZpZXI+IFwifVwiXG4gICAgICAgIHBhdHRlcm46IC8oKD86XnxbXntdKSg/Olxce1xceykqKVxceyg/IVxceykoPzpbXnt9XXxcXHsoPyFcXHspKD86W157fV18XFx7KD8hXFx7KSg/Oltee31dKStcXH0pK1xcfSkrXFx9LyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ2Zvcm1hdC1zcGVjJzoge1xuICAgICAgICAgICAgcGF0dGVybjogLyg6KVteOigpe31dKyg/PVxcfSQpLyxcbiAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgICdjb252ZXJzaW9uLW9wdGlvbic6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IC8hW3NyYV0oPz1bOn1dJCkvLFxuICAgICAgICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc3Q6IG51bGxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdzdHJpbmcnOiAvW1xcc1xcU10rL1xuICAgIH1cbiAgfSxcbiAgJ3RyaXBsZS1xdW90ZWQtc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oPzpbcnViXXxicnxyYik/KFwiXCJcInwnJycpW1xcc1xcU10qP1xcMS9pLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBhbGlhczogJ3N0cmluZydcbiAgfSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKD86W3J1Yl18YnJ8cmIpPyhcInwnKSg/OlxcXFwufCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvaSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2Z1bmN0aW9uJzoge1xuICAgIHBhdHRlcm46IC8oKD86XnxcXHMpZGVmWyBcXHRdKylbYS16QS1aX11cXHcqKD89XFxzKlxcKCkvZyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdjbGFzcy1uYW1lJzoge1xuICAgIHBhdHRlcm46IC8oXFxiY2xhc3NcXHMrKVxcdysvaSxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdkZWNvcmF0b3InOiB7XG4gICAgcGF0dGVybjogLyheW1xcdCBdKilAXFx3Kyg/OlxcLlxcdyspKi9tLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgYWxpYXM6IFsnYW5ub3RhdGlvbicsICdwdW5jdHVhdGlvbiddLFxuICAgIGluc2lkZToge1xuICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcLi9cbiAgICB9XG4gIH0sXG4gICdrZXl3b3JkJzogL1xcYig/Ol8oPz1cXHMqOil8YW5kfGFzfGFzc2VydHxhc3luY3xhd2FpdHxicmVha3xjYXNlfGNsYXNzfGNvbnRpbnVlfGRlZnxkZWx8ZWxpZnxlbHNlfGV4Y2VwdHxleGVjfGZpbmFsbHl8Zm9yfGZyb218Z2xvYmFsfGlmfGltcG9ydHxpbnxpc3xsYW1iZGF8bWF0Y2h8bm9ubG9jYWx8bm90fG9yfHBhc3N8cHJpbnR8cmFpc2V8cmV0dXJufHRyeXx3aGlsZXx3aXRofHlpZWxkKVxcYi8sXG4gICdidWlsdGluJzogL1xcYig/Ol9faW1wb3J0X198YWJzfGFsbHxhbnl8YXBwbHl8YXNjaWl8YmFzZXN0cmluZ3xiaW58Ym9vbHxidWZmZXJ8Ynl0ZWFycmF5fGJ5dGVzfGNhbGxhYmxlfGNocnxjbGFzc21ldGhvZHxjbXB8Y29lcmNlfGNvbXBpbGV8Y29tcGxleHxkZWxhdHRyfGRpY3R8ZGlyfGRpdm1vZHxlbnVtZXJhdGV8ZXZhbHxleGVjZmlsZXxmaWxlfGZpbHRlcnxmbG9hdHxmb3JtYXR8ZnJvemVuc2V0fGdldGF0dHJ8Z2xvYmFsc3xoYXNhdHRyfGhhc2h8aGVscHxoZXh8aWR8aW5wdXR8aW50fGludGVybnxpc2luc3RhbmNlfGlzc3ViY2xhc3N8aXRlcnxsZW58bGlzdHxsb2NhbHN8bG9uZ3xtYXB8bWF4fG1lbW9yeXZpZXd8bWlufG5leHR8b2JqZWN0fG9jdHxvcGVufG9yZHxwb3d8cHJvcGVydHl8cmFuZ2V8cmF3X2lucHV0fHJlZHVjZXxyZWxvYWR8cmVwcnxyZXZlcnNlZHxyb3VuZHxzZXR8c2V0YXR0cnxzbGljZXxzb3J0ZWR8c3RhdGljbWV0aG9kfHN0cnxzdW18c3VwZXJ8dHVwbGV8dHlwZXx1bmljaHJ8dW5pY29kZXx2YXJzfHhyYW5nZXx6aXApXFxiLyxcbiAgJ2Jvb2xlYW4nOiAvXFxiKD86RmFsc2V8Tm9uZXxUcnVlKVxcYi8sXG4gICdudW1iZXInOiAvXFxiMCg/OmIoPzpfP1swMV0pK3xvKD86Xz9bMC03XSkrfHgoPzpfP1thLWYwLTldKSspXFxifCg/OlxcYlxcZCsoPzpfXFxkKykqKD86XFwuKD86XFxkKyg/Ol9cXGQrKSopPyk/fFxcQlxcLlxcZCsoPzpfXFxkKykqKSg/OmVbKy1dP1xcZCsoPzpfXFxkKykqKT9qPyg/IVxcdykvaSxcbiAgJ29wZXJhdG9yJzogL1stKyU9XT0/fCE9fDo9fFxcKlxcKj89P3xcXC9cXC8/PT98PFs8PT5dP3w+Wz0+XT98WyZ8Xn5dLyxcbiAgJ3B1bmN0dWF0aW9uJzogL1t7fVtcXF07KCksLjpdL1xufTtcblByaXNtLmxhbmd1YWdlcy5weXRob25bJ3N0cmluZy1pbnRlcnBvbGF0aW9uJ10uaW5zaWRlWydpbnRlcnBvbGF0aW9uJ10uaW5zaWRlLnJlc3QgPSBQcmlzbS5sYW5ndWFnZXMucHl0aG9uO1xuUHJpc20ubGFuZ3VhZ2VzLnB5ID0gUHJpc20ubGFuZ3VhZ2VzLnB5dGhvbjtcblByaXNtLmxhbmd1YWdlcy5yID0ge1xuICAnY29tbWVudCc6IC8jLiovLFxuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oWydcIl0pKD86XFxcXC58KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdwZXJjZW50LW9wZXJhdG9yJzoge1xuICAgIC8vIEluY2x1ZGVzIHVzZXItZGVmaW5lZCBvcGVyYXRvcnNcbiAgICAvLyBhbmQgJSUsICUqJSwgJS8lLCAlaW4lLCAlbyUsICV4JVxuICAgIHBhdHRlcm46IC8lW14lXFxzXSolLyxcbiAgICBhbGlhczogJ29wZXJhdG9yJ1xuICB9LFxuICAnYm9vbGVhbic6IC9cXGIoPzpGQUxTRXxUUlVFKVxcYi8sXG4gICdlbGxpcHNpcyc6IC9cXC5cXC4oPzpcXC58XFxkKykvLFxuICAnbnVtYmVyJzogWy9cXGIoPzpJbmZ8TmFOKVxcYi8sIC8oPzpcXGIweFtcXGRBLUZhLWZdKyg/OlxcLlxcZCopP3xcXGJcXGQrKD86XFwuXFxkKik/fFxcQlxcLlxcZCspKD86W0VlUHBdWystXT9cXGQrKT9baUxdPy9dLFxuICAna2V5d29yZCc6IC9cXGIoPzpOQXxOQV9jaGFyYWN0ZXJffE5BX2NvbXBsZXhffE5BX2ludGVnZXJffE5BX3JlYWxffE5VTEx8YnJlYWt8ZWxzZXxmb3J8ZnVuY3Rpb258aWZ8aW58bmV4dHxyZXBlYXR8d2hpbGUpXFxiLyxcbiAgJ29wZXJhdG9yJzogLy0+Pz4/fDwoPzo9fDw/LSk/fFs+PSFdPT98Ojo/fCYmP3xcXHxcXHw/fFsrKlxcL14kQH5dLyxcbiAgJ3B1bmN0dWF0aW9uJzogL1soKXt9XFxbXFxdLDtdL1xufTtcblxuLyoqXG4gKiBPcmlnaW5hbCBieSBTYW11ZWwgRmxvcmVzXG4gKlxuICogQWRkcyB0aGUgZm9sbG93aW5nIG5ldyB0b2tlbiBjbGFzc2VzOlxuICogICAgIGNvbnN0YW50LCBidWlsdGluLCB2YXJpYWJsZSwgc3ltYm9sLCByZWdleFxuICovXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIFByaXNtLmxhbmd1YWdlcy5ydWJ5ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY2xpa2UnLCB7XG4gICAgJ2NvbW1lbnQnOiB7XG4gICAgICBwYXR0ZXJuOiAvIy4qfF49YmVnaW5cXHNbXFxzXFxTXSo/Xj1lbmQvbSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH0sXG4gICAgJ2NsYXNzLW5hbWUnOiB7XG4gICAgICBwYXR0ZXJuOiAvKFxcYig/OmNsYXNzfG1vZHVsZSlcXHMrfFxcYmNhdGNoXFxzK1xcKClbXFx3LlxcXFxdK3xcXGJbQS1aX11cXHcqKD89XFxzKlxcLlxccypuZXdcXGIpLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1suXFxcXF0vXG4gICAgICB9XG4gICAgfSxcbiAgICAna2V5d29yZCc6IC9cXGIoPzpCRUdJTnxFTkR8YWxpYXN8YW5kfGJlZ2lufGJyZWFrfGNhc2V8Y2xhc3N8ZGVmfGRlZmluZV9tZXRob2R8ZGVmaW5lZHxkb3xlYWNofGVsc2V8ZWxzaWZ8ZW5kfGVuc3VyZXxleHRlbmR8Zm9yfGlmfGlufGluY2x1ZGV8bW9kdWxlfG5ld3xuZXh0fG5pbHxub3R8b3J8cHJlcGVuZHxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmFpc2V8cmVkb3xyZXF1aXJlfHJlc2N1ZXxyZXRyeXxyZXR1cm58c2VsZnxzdXBlcnx0aGVufHRocm93fHVuZGVmfHVubGVzc3x1bnRpbHx3aGVufHdoaWxlfHlpZWxkKVxcYi8sXG4gICAgJ29wZXJhdG9yJzogL1xcLnsyLDN9fCZcXC58PT09fDw/PT58WyE9XT9+fCg/OiYmfFxcfFxcfHw8PHw+PnxcXCpcXCp8WytcXC0qLyU8PiFeJnw9XSk9P3xbPzpdLyxcbiAgICAncHVuY3R1YXRpb24nOiAvWygpe31bXFxdLiw7XS9cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ3J1YnknLCAnb3BlcmF0b3InLCB7XG4gICAgJ2RvdWJsZS1jb2xvbic6IHtcbiAgICAgIHBhdHRlcm46IC86Oi8sXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgIH1cbiAgfSk7XG4gIHZhciBpbnRlcnBvbGF0aW9uID0ge1xuICAgIHBhdHRlcm46IC8oKD86XnxbXlxcXFxdKSg/OlxcXFx7Mn0pKikjXFx7KD86W157fV18XFx7W157fV0qXFx9KSpcXH0vLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnY29udGVudCc6IHtcbiAgICAgICAgcGF0dGVybjogL14oI1xceylbXFxzXFxTXSsoPz1cXH0kKS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLnJ1YnlcbiAgICAgIH0sXG4gICAgICAnZGVsaW1pdGVyJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXiNcXHt8XFx9JC8sXG4gICAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgICB9XG4gICAgfVxuICB9O1xuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnJ1YnkuZnVuY3Rpb247XG4gIHZhciBwZXJjZW50RXhwcmVzc2lvbiA9ICcoPzonICsgWy8oW15hLXpBLVowLTlcXHN7KFxcWzw9XSkoPzooPyFcXDEpW15cXFxcXXxcXFxcW1xcc1xcU10pKlxcMS8uc291cmNlLCAvXFwoKD86W14oKVxcXFxdfFxcXFxbXFxzXFxTXXxcXCgoPzpbXigpXFxcXF18XFxcXFtcXHNcXFNdKSpcXCkpKlxcKS8uc291cmNlLCAvXFx7KD86W157fVxcXFxdfFxcXFxbXFxzXFxTXXxcXHsoPzpbXnt9XFxcXF18XFxcXFtcXHNcXFNdKSpcXH0pKlxcfS8uc291cmNlLCAvXFxbKD86W15cXFtcXF1cXFxcXXxcXFxcW1xcc1xcU118XFxbKD86W15cXFtcXF1cXFxcXXxcXFxcW1xcc1xcU10pKlxcXSkqXFxdLy5zb3VyY2UsIC88KD86W148PlxcXFxdfFxcXFxbXFxzXFxTXXw8KD86W148PlxcXFxdfFxcXFxbXFxzXFxTXSkqPikqPi8uc291cmNlXS5qb2luKCd8JykgKyAnKSc7XG4gIHZhciBzeW1ib2xOYW1lID0gLyg/OlwiKD86XFxcXC58W15cIlxcXFxcXHJcXG5dKSpcInwoPzpcXGJbYS16QS1aX11cXHcqfFteXFxzXFwwLVxceDdGXSspWz8hXT98XFwkLikvLnNvdXJjZTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgncnVieScsICdrZXl3b3JkJywge1xuICAgICdyZWdleC1saXRlcmFsJzogW3tcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvJXIvLnNvdXJjZSArIHBlcmNlbnRFeHByZXNzaW9uICsgL1tlZ2ltbm9zdXhdezAsNn0vLnNvdXJjZSksXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2ludGVycG9sYXRpb24nOiBpbnRlcnBvbGF0aW9uLFxuICAgICAgICAncmVnZXgnOiAvW1xcc1xcU10rL1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXi9dKVxcLyg/IVxcLykoPzpcXFtbXlxcclxcblxcXV0rXFxdfFxcXFwufFteWy9cXFxcXFxyXFxuXSkrXFwvW2VnaW1ub3N1eF17MCw2fSg/PVxccyooPzokfFtcXHJcXG4sLjt9KSNdKSkvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnaW50ZXJwb2xhdGlvbic6IGludGVycG9sYXRpb24sXG4gICAgICAgICdyZWdleCc6IC9bXFxzXFxTXSsvXG4gICAgICB9XG4gICAgfV0sXG4gICAgJ3ZhcmlhYmxlJzogL1tAJF0rW2EtekEtWl9dXFx3Kig/Ols/IV18XFxiKS8sXG4gICAgJ3N5bWJvbCc6IFt7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyhefFteOl0pOi8uc291cmNlICsgc3ltYm9sTmFtZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oW1xcclxcbnsoLF1bIFxcdF0qKS8uc291cmNlICsgc3ltYm9sTmFtZSArIC8oPz06KD8hOikpLy5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH1dLFxuICAgICdtZXRob2QtZGVmaW5pdGlvbic6IHtcbiAgICAgIHBhdHRlcm46IC8oXFxiZGVmXFxzKylcXHcrKD86XFxzKlxcLlxccypcXHcrKT8vLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZnVuY3Rpb24nOiAvXFxiXFx3KyQvLFxuICAgICAgICAna2V5d29yZCc6IC9ec2VsZlxcYi8sXG4gICAgICAgICdjbGFzcy1uYW1lJzogL15cXHcrLyxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcLi9cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdydWJ5JywgJ3N0cmluZycsIHtcbiAgICAnc3RyaW5nLWxpdGVyYWwnOiBbe1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8lW3FRaUl3V3NdPy8uc291cmNlICsgcGVyY2VudEV4cHJlc3Npb24pLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdpbnRlcnBvbGF0aW9uJzogaW50ZXJwb2xhdGlvbixcbiAgICAgICAgJ3N0cmluZyc6IC9bXFxzXFxTXSsvXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcGF0dGVybjogLyhcInwnKSg/OiNcXHtbXn1dK1xcfXwjKD8hXFx7KXxcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDEpW15cXFxcI1xcclxcbl0pKlxcMS8sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2ludGVycG9sYXRpb24nOiBpbnRlcnBvbGF0aW9uLFxuICAgICAgICAnc3RyaW5nJzogL1tcXHNcXFNdKy9cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvPDxbLX5dPyhbYS16X11cXHcqKVtcXHJcXG5dKD86LipbXFxyXFxuXSkqP1tcXHQgXSpcXDEvaSxcbiAgICAgIGFsaWFzOiAnaGVyZWRvYy1zdHJpbmcnLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdkZWxpbWl0ZXInOiB7XG4gICAgICAgICAgcGF0dGVybjogL148PFstfl0/W2Etel9dXFx3KnxcXGJbYS16X11cXHcqJC9pLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IC9cXGJcXHcrLyxcbiAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9ePDxbLX5dPy9cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICdpbnRlcnBvbGF0aW9uJzogaW50ZXJwb2xhdGlvbixcbiAgICAgICAgJ3N0cmluZyc6IC9bXFxzXFxTXSsvXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcGF0dGVybjogLzw8Wy1+XT8nKFthLXpfXVxcdyopJ1tcXHJcXG5dKD86LipbXFxyXFxuXSkqP1tcXHQgXSpcXDEvaSxcbiAgICAgIGFsaWFzOiAnaGVyZWRvYy1zdHJpbmcnLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdkZWxpbWl0ZXInOiB7XG4gICAgICAgICAgcGF0dGVybjogL148PFstfl0/J1thLXpfXVxcdyonfFxcYlthLXpfXVxcdyokL2ksXG4gICAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogL1xcYlxcdysvLFxuICAgICAgICAgICAgJ3B1bmN0dWF0aW9uJzogL148PFstfl0/J3wnJC9cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICdzdHJpbmcnOiAvW1xcc1xcU10rL1xuICAgICAgfVxuICAgIH1dLFxuICAgICdjb21tYW5kLWxpdGVyYWwnOiBbe1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8leC8uc291cmNlICsgcGVyY2VudEV4cHJlc3Npb24pLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdpbnRlcnBvbGF0aW9uJzogaW50ZXJwb2xhdGlvbixcbiAgICAgICAgJ2NvbW1hbmQnOiB7XG4gICAgICAgICAgcGF0dGVybjogL1tcXHNcXFNdKy8sXG4gICAgICAgICAgYWxpYXM6ICdzdHJpbmcnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvYCg/OiNcXHtbXn1dK1xcfXwjKD8hXFx7KXxcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlxcXFxgI1xcclxcbl0pKmAvLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdpbnRlcnBvbGF0aW9uJzogaW50ZXJwb2xhdGlvbixcbiAgICAgICAgJ2NvbW1hbmQnOiB7XG4gICAgICAgICAgcGF0dGVybjogL1tcXHNcXFNdKy8sXG4gICAgICAgICAgYWxpYXM6ICdzdHJpbmcnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XVxuICB9KTtcbiAgZGVsZXRlIFByaXNtLmxhbmd1YWdlcy5ydWJ5LnN0cmluZztcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgncnVieScsICdudW1iZXInLCB7XG4gICAgJ2J1aWx0aW4nOiAvXFxiKD86QXJyYXl8QmlnbnVtfEJpbmRpbmd8Q2xhc3N8Q29udGludWF0aW9ufERpcnxFeGNlcHRpb258RmFsc2VDbGFzc3xGaWxlfEZpeG51bXxGbG9hdHxIYXNofElPfEludGVnZXJ8TWF0Y2hEYXRhfE1ldGhvZHxNb2R1bGV8TmlsQ2xhc3N8TnVtZXJpY3xPYmplY3R8UHJvY3xSYW5nZXxSZWdleHB8U3RhdHxTdHJpbmd8U3RydWN0fFN5bWJvbHxUTVN8VGhyZWFkfFRocmVhZEdyb3VwfFRpbWV8VHJ1ZUNsYXNzKVxcYi8sXG4gICAgJ2NvbnN0YW50JzogL1xcYltBLVpdW0EtWjAtOV9dKig/Ols/IV18XFxiKS9cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5yYiA9IFByaXNtLmxhbmd1YWdlcy5ydWJ5O1xufSkoUHJpc20pO1xuKGZ1bmN0aW9uIChQcmlzbSkge1xuICB2YXIgbXVsdGlsaW5lQ29tbWVudCA9IC9cXC9cXCooPzpbXiovXXxcXCooPyFcXC8pfFxcLyg/IVxcKil8PHNlbGY+KSpcXCpcXC8vLnNvdXJjZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAvLyBzdXBwb3J0IDQgbGV2ZWxzIG9mIG5lc3RlZCBjb21tZW50c1xuICAgIG11bHRpbGluZUNvbW1lbnQgPSBtdWx0aWxpbmVDb21tZW50LnJlcGxhY2UoLzxzZWxmPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbXVsdGlsaW5lQ29tbWVudDtcbiAgICB9KTtcbiAgfVxuICBtdWx0aWxpbmVDb21tZW50ID0gbXVsdGlsaW5lQ29tbWVudC5yZXBsYWNlKC88c2VsZj4vZywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAvW15cXHNcXFNdLy5zb3VyY2U7XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMucnVzdCA9IHtcbiAgICAnY29tbWVudCc6IFt7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyhefFteXFxcXF0pLy5zb3VyY2UgKyBtdWx0aWxpbmVDb21tZW50KSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvKF58W15cXFxcOl0pXFwvXFwvLiovLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH1dLFxuICAgICdzdHJpbmcnOiB7XG4gICAgICBwYXR0ZXJuOiAvYj9cIig/OlxcXFxbXFxzXFxTXXxbXlxcXFxcIl0pKlwifGI/cigjKilcIig/OlteXCJdfFwiKD8hXFwxKSkqXCJcXDEvLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSxcbiAgICAnY2hhcic6IHtcbiAgICAgIHBhdHRlcm46IC9iPycoPzpcXFxcKD86eFswLTddW1xcZGEtZkEtRl18dVxceyg/OltcXGRhLWZBLUZdXyopezEsNn1cXH18Lil8W15cXFxcXFxyXFxuXFx0J10pJy8sXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdhdHRyaWJ1dGUnOiB7XG4gICAgICBwYXR0ZXJuOiAvIyE/XFxbKD86W15cXFtcXF1cIl18XCIoPzpcXFxcW1xcc1xcU118W15cXFxcXCJdKSpcIikqXFxdLyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnYXR0ci1uYW1lJyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnc3RyaW5nJzogbnVsbCAvLyBzZWUgYmVsb3dcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIENsb3N1cmUgcGFyYW1zIHNob3VsZCBub3QgYmUgY29uZnVzZWQgd2l0aCBiaXR3aXNlIE9SIHxcbiAgICAnY2xvc3VyZS1wYXJhbXMnOiB7XG4gICAgICBwYXR0ZXJuOiAvKFs9KCw6XVxccyp8XFxibW92ZVxccyopXFx8W158XSpcXHx8XFx8W158XSpcXHwoPz1cXHMqKD86XFx7fC0+KSkvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnY2xvc3VyZS1wdW5jdHVhdGlvbic6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXlxcfHxcXHwkLyxcbiAgICAgICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgICAgICB9LFxuICAgICAgICByZXN0OiBudWxsIC8vIHNlZSBiZWxvd1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2xpZmV0aW1lLWFubm90YXRpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvJ1xcdysvLFxuICAgICAgYWxpYXM6ICdzeW1ib2wnXG4gICAgfSxcbiAgICAnZnJhZ21lbnQtc3BlY2lmaWVyJzoge1xuICAgICAgcGF0dGVybjogLyhcXCRcXHcrOilbYS16XSsvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgfSxcbiAgICAndmFyaWFibGUnOiAvXFwkXFx3Ky8sXG4gICAgJ2Z1bmN0aW9uLWRlZmluaXRpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvKFxcYmZuXFxzKylcXHcrLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICAgIH0sXG4gICAgJ3R5cGUtZGVmaW5pdGlvbic6IHtcbiAgICAgIHBhdHRlcm46IC8oXFxiKD86ZW51bXxzdHJ1Y3R8dHJhaXR8dHlwZXx1bmlvbilcXHMrKVxcdysvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZSdcbiAgICB9LFxuICAgICdtb2R1bGUtZGVjbGFyYXRpb24nOiBbe1xuICAgICAgcGF0dGVybjogLyhcXGIoPzpjcmF0ZXxtb2QpXFxzKylbYS16XVthLXpfXFxkXSovLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnbmFtZXNwYWNlJ1xuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC8oXFxiKD86Y3JhdGV8c2VsZnxzdXBlcilcXHMqKTo6XFxzKlthLXpdW2Etel9cXGRdKlxcYig/Olxccyo6Oig/OlxccypbYS16XVthLXpfXFxkXSpcXHMqOjopKik/LyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ25hbWVzcGFjZScsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogLzo6L1xuICAgICAgfVxuICAgIH1dLFxuICAgICdrZXl3b3JkJzogW1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ydXN0LWxhbmcvcmVmZXJlbmNlL2Jsb2IvbWFzdGVyL3NyYy9rZXl3b3Jkcy5tZFxuICAgIC9cXGIoPzpTZWxmfGFic3RyYWN0fGFzfGFzeW5jfGF3YWl0fGJlY29tZXxib3h8YnJlYWt8Y29uc3R8Y29udGludWV8Y3JhdGV8ZG98ZHlufGVsc2V8ZW51bXxleHRlcm58ZmluYWx8Zm58Zm9yfGlmfGltcGx8aW58bGV0fGxvb3B8bWFjcm98bWF0Y2h8bW9kfG1vdmV8bXV0fG92ZXJyaWRlfHByaXZ8cHVifHJlZnxyZXR1cm58c2VsZnxzdGF0aWN8c3RydWN0fHN1cGVyfHRyYWl0fHRyeXx0eXBlfHR5cGVvZnx1bmlvbnx1bnNhZmV8dW5zaXplZHx1c2V8dmlydHVhbHx3aGVyZXx3aGlsZXx5aWVsZClcXGIvLFxuICAgIC8vIHByaW1pdGl2ZXMgYW5kIHN0clxuICAgIC8vIGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvc3RhYmxlL3J1c3QtYnktZXhhbXBsZS9wcmltaXRpdmVzLmh0bWxcbiAgICAvXFxiKD86Ym9vbHxjaGFyfGYoPzozMnw2NCl8W3VpXSg/Ojh8MTZ8MzJ8NjR8MTI4fHNpemUpfHN0cilcXGIvXSxcbiAgICAvLyBmdW5jdGlvbnMgY2FuIHRlY2huaWNhbGx5IHN0YXJ0IHdpdGggYW4gdXBwZXItY2FzZSBsZXR0ZXIsIGJ1dCB0aGlzIHdpbGwgaW50cm9kdWNlIGEgbG90IG9mIGZhbHNlIHBvc2l0aXZlc1xuICAgIC8vIGFuZCBSdXN0J3MgbmFtaW5nIGNvbnZlbnRpb25zIHJlY29tbWVuZCBzbmFrZV9jYXNlIGFueXdheS5cbiAgICAvLyBodHRwczovL2RvYy5ydXN0LWxhbmcub3JnLzEuMC4wL3N0eWxlL3N0eWxlL25hbWluZy9SRUFETUUuaHRtbFxuICAgICdmdW5jdGlvbic6IC9cXGJbYS16X11cXHcqKD89XFxzKig/Ojo6XFxzKjx8XFwoKSkvLFxuICAgICdtYWNybyc6IHtcbiAgICAgIHBhdHRlcm46IC9cXGJcXHcrIS8sXG4gICAgICBhbGlhczogJ3Byb3BlcnR5J1xuICAgIH0sXG4gICAgJ2NvbnN0YW50JzogL1xcYltBLVpfXVtBLVpfXFxkXStcXGIvLFxuICAgICdjbGFzcy1uYW1lJzogL1xcYltBLVpdXFx3KlxcYi8sXG4gICAgJ25hbWVzcGFjZSc6IHtcbiAgICAgIHBhdHRlcm46IC8oPzpcXGJbYS16XVthLXpfXFxkXSpcXHMqOjpcXHMqKSpcXGJbYS16XVthLXpfXFxkXSpcXHMqOjooPyFcXHMqPCkvLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdwdW5jdHVhdGlvbic6IC86Oi9cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEhleCwgb2N0LCBiaW4sIGRlYyBudW1iZXJzIHdpdGggdmlzdWFsIHNlcGFyYXRvcnMgYW5kIHR5cGUgc3VmZml4XG4gICAgJ251bWJlcic6IC9cXGIoPzoweFtcXGRBLUZhLWZdKD86Xz9bXFxkQS1GYS1mXSkqfDBvWzAtN10oPzpfP1swLTddKSp8MGJbMDFdKD86Xz9bMDFdKSp8KD86KD86XFxkKD86Xz9cXGQpKik/XFwuKT9cXGQoPzpfP1xcZCkqKD86W0VlXVsrLV0/XFxkKyk/KSg/Ol8/KD86ZjMyfGY2NHxbaXVdKD86OHwxNnwzMnw2NHxzaXplKT8pKT9cXGIvLFxuICAgICdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcbiAgICAncHVuY3R1YXRpb24nOiAvLT58XFwuXFwuPXxcXC57MSwzfXw6Onxbe31bXFxdOygpLDpdLyxcbiAgICAnb3BlcmF0b3InOiAvWy0rKlxcLyUhXl09P3w9Wz0+XT98JlsmPV0/fFxcfFt8PV0/fDw8Pz0/fD4+Pz0/fFtAP10vXG4gIH07XG4gIFByaXNtLmxhbmd1YWdlcy5ydXN0WydjbG9zdXJlLXBhcmFtcyddLmluc2lkZS5yZXN0ID0gUHJpc20ubGFuZ3VhZ2VzLnJ1c3Q7XG4gIFByaXNtLmxhbmd1YWdlcy5ydXN0WydhdHRyaWJ1dGUnXS5pbnNpZGVbJ3N0cmluZyddID0gUHJpc20ubGFuZ3VhZ2VzLnJ1c3RbJ3N0cmluZyddO1xufSkoUHJpc20pO1xuKGZ1bmN0aW9uIChQcmlzbSkge1xuICBQcmlzbS5sYW5ndWFnZXMuc2FzcyA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NzcycsIHtcbiAgICAvLyBTYXNzIGNvbW1lbnRzIGRvbid0IG5lZWQgdG8gYmUgY2xvc2VkLCBvbmx5IGluZGVudGVkXG4gICAgJ2NvbW1lbnQnOiB7XG4gICAgICBwYXR0ZXJuOiAvXihbIFxcdF0qKVxcL1tcXC8qXS4qKD86KD86XFxyP1xcbnxcXHIpXFwxWyBcXHRdLispKi9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ3Nhc3MnLCAnYXRydWxlJywge1xuICAgIC8vIFdlIHdhbnQgdG8gY29uc3VtZSB0aGUgd2hvbGUgbGluZVxuICAgICdhdHJ1bGUtbGluZSc6IHtcbiAgICAgIC8vIEluY2x1ZGVzIHN1cHBvcnQgZm9yID0gYW5kICsgc2hvcnRjdXRzXG4gICAgICBwYXR0ZXJuOiAvXig/OlsgXFx0XSopW0ArPV0uKy9tLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdhdHJ1bGUnOiAvKD86QFtcXHctXSt8Wys9XSkvXG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZGVsZXRlIFByaXNtLmxhbmd1YWdlcy5zYXNzLmF0cnVsZTtcbiAgdmFyIHZhcmlhYmxlID0gL1xcJFstXFx3XSt8I1xce1xcJFstXFx3XStcXH0vO1xuICB2YXIgb3BlcmF0b3IgPSBbL1srKlxcLyVdfFs9IV09fDw9P3w+PT98XFxiKD86YW5kfG5vdHxvcilcXGIvLCB7XG4gICAgcGF0dGVybjogLyhcXHMpLSg/PVxccykvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfV07XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ3Nhc3MnLCAncHJvcGVydHknLCB7XG4gICAgLy8gV2Ugd2FudCB0byBjb25zdW1lIHRoZSB3aG9sZSBsaW5lXG4gICAgJ3ZhcmlhYmxlLWxpbmUnOiB7XG4gICAgICBwYXR0ZXJuOiAvXlsgXFx0XSpcXCQuKy9tLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdwdW5jdHVhdGlvbic6IC86LyxcbiAgICAgICAgJ3ZhcmlhYmxlJzogdmFyaWFibGUsXG4gICAgICAgICdvcGVyYXRvcic6IG9wZXJhdG9yXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBXZSB3YW50IHRvIGNvbnN1bWUgdGhlIHdob2xlIGxpbmVcbiAgICAncHJvcGVydHktbGluZSc6IHtcbiAgICAgIHBhdHRlcm46IC9eWyBcXHRdKig/OlteOlxcc10rICo6Lip8OlteOlxcc10uKikvbSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHJvcGVydHknOiBbL1teOlxcc10rKD89XFxzKjopLywge1xuICAgICAgICAgIHBhdHRlcm46IC8oOilbXjpcXHNdKy8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9XSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogLzovLFxuICAgICAgICAndmFyaWFibGUnOiB2YXJpYWJsZSxcbiAgICAgICAgJ29wZXJhdG9yJzogb3BlcmF0b3IsXG4gICAgICAgICdpbXBvcnRhbnQnOiBQcmlzbS5sYW5ndWFnZXMuc2Fzcy5pbXBvcnRhbnRcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnNhc3MucHJvcGVydHk7XG4gIGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMuc2Fzcy5pbXBvcnRhbnQ7XG5cbiAgLy8gTm93IHRoYXQgd2hvbGUgbGluZXMgZm9yIG90aGVyIHBhdHRlcm5zIGFyZSBjb25zdW1lZCxcbiAgLy8gd2hhdCdzIGxlZnQgc2hvdWxkIGJlIHNlbGVjdG9yc1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdzYXNzJywgJ3B1bmN0dWF0aW9uJywge1xuICAgICdzZWxlY3Rvcic6IHtcbiAgICAgIHBhdHRlcm46IC9eKFsgXFx0XSopXFxTKD86LFteLFxcclxcbl0rfFteLFxcclxcbl0qKSg/OixbXixcXHJcXG5dKykqKD86LCg/Olxccj9cXG58XFxyKVxcMVsgXFx0XStcXFMoPzosW14sXFxyXFxuXSt8W14sXFxyXFxuXSopKD86LFteLFxcclxcbl0rKSopKi9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59KShQcmlzbSk7XG5QcmlzbS5sYW5ndWFnZXMuc2NzcyA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NzcycsIHtcbiAgJ2NvbW1lbnQnOiB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXF0pKD86XFwvXFwqW1xcc1xcU10qP1xcKlxcL3xcXC9cXC8uKikvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ2F0cnVsZSc6IHtcbiAgICBwYXR0ZXJuOiAvQFtcXHctXSg/OlxcKFteKCldK1xcKXxbXigpXFxzXXxcXHMrKD8hXFxzKSkqPyg/PVxccytbeztdKS8sXG4gICAgaW5zaWRlOiB7XG4gICAgICAncnVsZSc6IC9AW1xcdy1dKy9cbiAgICAgIC8vIFNlZSByZXN0IGJlbG93XG4gICAgfVxuICB9LFxuICAvLyB1cmwsIGNvbXBhc3NpZmllZFxuICAndXJsJzogLyg/OlstYS16XSstKT91cmwoPz1cXCgpL2ksXG4gIC8vIENTUyBzZWxlY3RvciByZWdleCBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIFNhc3NcbiAgLy8gc2luY2UgdGhlcmUgY2FuIGJlIGxvdCBtb3JlIHRoaW5ncyAodmFyLCBAIGRpcmVjdGl2ZSwgbmVzdGluZy4uKVxuICAvLyBhIHNlbGVjdG9yIG11c3Qgc3RhcnQgYXQgdGhlIGVuZCBvZiBhIHByb3BlcnR5IG9yIGFmdGVyIGEgYnJhY2UgKGVuZCBvZiBvdGhlciBydWxlcyBvciBuZXN0aW5nKVxuICAvLyBpdCBjYW4gY29udGFpbiBzb21lIGNoYXJhY3RlcnMgdGhhdCBhcmVuJ3QgdXNlZCBmb3IgZGVmaW5pbmcgcnVsZXMgb3IgZW5kIG9mIHNlbGVjdG9yLCAmIChwYXJlbnQgc2VsZWN0b3IpLCBvciBpbnRlcnBvbGF0ZWQgdmFyaWFibGVcbiAgLy8gdGhlIGVuZCBvZiBhIHNlbGVjdG9yIGlzIGZvdW5kIHdoZW4gdGhlcmUgaXMgbm8gcnVsZXMgaW4gaXQgKCB7fSBvciB7XFxzfSkgb3IgaWYgdGhlcmUgaXMgYSBwcm9wZXJ0eSAoYmVjYXVzZSBhbiBpbnRlcnBvbGF0ZWQgdmFyXG4gIC8vIGNhbiBcInBhc3NcIiBhcyBhIHNlbGVjdG9yLSBlLmc6IHByb3BlciN7JGVydHl9KVxuICAvLyB0aGlzIG9uZSB3YXMgaGFyZCB0byBkbywgc28gcGxlYXNlIGJlIGNhcmVmdWwgaWYgeW91IGVkaXQgdGhpcyBvbmUgOilcbiAgJ3NlbGVjdG9yJzoge1xuICAgIC8vIEluaXRpYWwgbG9vay1haGVhZCBpcyB1c2VkIHRvIHByZXZlbnQgbWF0Y2hpbmcgb2YgYmxhbmsgc2VsZWN0b3JzXG4gICAgcGF0dGVybjogLyg/PVxcUylbXkA7e30oKV0/KD86W15AO3t9KClcXHNdfFxccysoPyFcXHMpfCNcXHtcXCRbLVxcd10rXFx9KSsoPz1cXHMqXFx7KD86XFx9fFxcc3xbXn1dW146e31dKls6e11bXn1dKSkvLFxuICAgIGluc2lkZToge1xuICAgICAgJ3BhcmVudCc6IHtcbiAgICAgICAgcGF0dGVybjogLyYvLFxuICAgICAgICBhbGlhczogJ2ltcG9ydGFudCdcbiAgICAgIH0sXG4gICAgICAncGxhY2Vob2xkZXInOiAvJVstXFx3XSsvLFxuICAgICAgJ3ZhcmlhYmxlJzogL1xcJFstXFx3XSt8I1xce1xcJFstXFx3XStcXH0vXG4gICAgfVxuICB9LFxuICAncHJvcGVydHknOiB7XG4gICAgcGF0dGVybjogLyg/OlstXFx3XXxcXCRbLVxcd118I1xce1xcJFstXFx3XStcXH0pKyg/PVxccyo6KS8sXG4gICAgaW5zaWRlOiB7XG4gICAgICAndmFyaWFibGUnOiAvXFwkWy1cXHddK3wjXFx7XFwkWy1cXHddK1xcfS9cbiAgICB9XG4gIH1cbn0pO1xuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnc2NzcycsICdhdHJ1bGUnLCB7XG4gICdrZXl3b3JkJzogWy9AKD86Y29udGVudHxkZWJ1Z3xlYWNofGVsc2UoPzogaWYpP3xleHRlbmR8Zm9yfGZvcndhcmR8ZnVuY3Rpb258aWZ8aW1wb3J0fGluY2x1ZGV8bWl4aW58cmV0dXJufHVzZXx3YXJufHdoaWxlKVxcYi9pLCB7XG4gICAgcGF0dGVybjogLyggKSg/OmZyb218dGhyb3VnaCkoPz0gKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9XVxufSk7XG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdzY3NzJywgJ2ltcG9ydGFudCcsIHtcbiAgLy8gdmFyIGFuZCBpbnRlcnBvbGF0ZWQgdmFyc1xuICAndmFyaWFibGUnOiAvXFwkWy1cXHddK3wjXFx7XFwkWy1cXHddK1xcfS9cbn0pO1xuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnc2NzcycsICdmdW5jdGlvbicsIHtcbiAgJ21vZHVsZS1tb2RpZmllcic6IHtcbiAgICBwYXR0ZXJuOiAvXFxiKD86YXN8aGlkZXxzaG93fHdpdGgpXFxiL2ksXG4gICAgYWxpYXM6ICdrZXl3b3JkJ1xuICB9LFxuICAncGxhY2Vob2xkZXInOiB7XG4gICAgcGF0dGVybjogLyVbLVxcd10rLyxcbiAgICBhbGlhczogJ3NlbGVjdG9yJ1xuICB9LFxuICAnc3RhdGVtZW50Jzoge1xuICAgIHBhdHRlcm46IC9cXEIhKD86ZGVmYXVsdHxvcHRpb25hbClcXGIvaSxcbiAgICBhbGlhczogJ2tleXdvcmQnXG4gIH0sXG4gICdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcbiAgJ251bGwnOiB7XG4gICAgcGF0dGVybjogL1xcYm51bGxcXGIvLFxuICAgIGFsaWFzOiAna2V5d29yZCdcbiAgfSxcbiAgJ29wZXJhdG9yJzoge1xuICAgIHBhdHRlcm46IC8oXFxzKSg/OlstKypcXC8lXXxbPSFdPXw8PT98Pj0/fGFuZHxub3R8b3IpKD89XFxzKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9XG59KTtcblByaXNtLmxhbmd1YWdlcy5zY3NzWydhdHJ1bGUnXS5pbnNpZGUucmVzdCA9IFByaXNtLmxhbmd1YWdlcy5zY3NzO1xuUHJpc20ubGFuZ3VhZ2VzLnNxbCA9IHtcbiAgJ2NvbW1lbnQnOiB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXF0pKD86XFwvXFwqW1xcc1xcU10qP1xcKlxcL3woPzotLXxcXC9cXC98IykuKikvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ3ZhcmlhYmxlJzogW3tcbiAgICBwYXR0ZXJuOiAvQChbXCInYF0pKD86XFxcXFtcXHNcXFNdfCg/IVxcMSlbXlxcXFxdKStcXDEvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LCAvQFtcXHcuJF0rL10sXG4gICdzdHJpbmcnOiB7XG4gICAgcGF0dGVybjogLyhefFteQFxcXFxdKShcInwnKSg/OlxcXFxbXFxzXFxTXXwoPyFcXDIpW15cXFxcXXxcXDJcXDIpKlxcMi8sXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ2lkZW50aWZpZXInOiB7XG4gICAgcGF0dGVybjogLyhefFteQFxcXFxdKWAoPzpcXFxcW1xcc1xcU118W15gXFxcXF18YGApKmAvLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ3B1bmN0dWF0aW9uJzogL15gfGAkL1xuICAgIH1cbiAgfSxcbiAgJ2Z1bmN0aW9uJzogL1xcYig/OkFWR3xDT1VOVHxGSVJTVHxGT1JNQVR8TEFTVHxMQ0FTRXxMRU58TUFYfE1JRHxNSU58TU9EfE5PV3xST1VORHxTVU18VUNBU0UpKD89XFxzKlxcKCkvaSxcbiAgLy8gU2hvdWxkIHdlIGhpZ2hsaWdodCB1c2VyIGRlZmluZWQgZnVuY3Rpb25zIHRvbz9cbiAgJ2tleXdvcmQnOiAvXFxiKD86QUNUSU9OfEFERHxBRlRFUnxBTEdPUklUSE18QUxMfEFMVEVSfEFOQUxZWkV8QU5ZfEFQUExZfEFTfEFTQ3xBVVRIT1JJWkFUSU9OfEFVVE9fSU5DUkVNRU5UfEJBQ0tVUHxCREJ8QkVHSU58QkVSS0VMRVlEQnxCSUdJTlR8QklOQVJZfEJJVHxCTE9CfEJPT0x8Qk9PTEVBTnxCUkVBS3xCUk9XU0V8QlRSRUV8QlVMS3xCWXxDQUxMfENBU0NBREVEP3xDQVNFfENIQUlOfENIQVIoPzpBQ1RFUnxTRVQpP3xDSEVDSyg/OlBPSU5UKT98Q0xPU0V8Q0xVU1RFUkVEfENPQUxFU0NFfENPTExBVEV8Q09MVU1OUz98Q09NTUVOVHxDT01NSVQoPzpURUQpP3xDT01QVVRFfENPTk5FQ1R8Q09OU0lTVEVOVHxDT05TVFJBSU5UfENPTlRBSU5TKD86VEFCTEUpP3xDT05USU5VRXxDT05WRVJUfENSRUFURXxDUk9TU3xDVVJSRU5UKD86X0RBVEV8X1RJTUV8X1RJTUVTVEFNUHxfVVNFUik/fENVUlNPUnxDWUNMRXxEQVRBKD86QkFTRVM/KT98REFURSg/OlRJTUUpP3xEQVl8REJDQ3xERUFMTE9DQVRFfERFQ3xERUNJTUFMfERFQ0xBUkV8REVGQVVMVHxERUZJTkVSfERFTEFZRUR8REVMRVRFfERFTElNSVRFUlM/fERFTll8REVTQ3xERVNDUklCRXxERVRFUk1JTklTVElDfERJU0FCTEV8RElTQ0FSRHxESVNLfERJU1RJTkNUfERJU1RJTkNUUk9XfERJU1RSSUJVVEVEfERPfERPVUJMRXxEUk9QfERVTU1ZfERVTVAoPzpGSUxFKT98RFVQTElDQVRFfEVMU0UoPzpJRik/fEVOQUJMRXxFTkNMT1NFRHxFTkR8RU5HSU5FfEVOVU18RVJSTFZMfEVSUk9SU3xFU0NBUEVEP3xFWENFUFR8RVhFQyg/OlVURSk/fEVYSVNUU3xFWElUfEVYUExBSU58RVhURU5ERUR8RkVUQ0h8RklFTERTfEZJTEV8RklMTEZBQ1RPUnxGSVJTVHxGSVhFRHxGTE9BVHxGT0xMT1dJTkd8Rk9SKD86IEVBQ0ggUk9XKT98Rk9SQ0V8Rk9SRUlHTnxGUkVFVEVYVCg/OlRBQkxFKT98RlJPTXxGVUxMfEZVTkNUSU9OfEdFT01FVFJZKD86Q09MTEVDVElPTik/fEdMT0JBTHxHT1RPfEdSQU5UfEdST1VQfEhBTkRMRVJ8SEFTSHxIQVZJTkd8SE9MRExPQ0t8SE9VUnxJREVOVElUWSg/OkNPTHxfSU5TRVJUKT98SUZ8SUdOT1JFfElNUE9SVHxJTkRFWHxJTkZJTEV8SU5ORVJ8SU5OT0RCfElOT1VUfElOU0VSVHxJTlR8SU5URUdFUnxJTlRFUlNFQ1R8SU5URVJWQUx8SU5UT3xJTlZPS0VSfElTT0xBVElPTnxJVEVSQVRFfEpPSU58S0VZUz98S0lMTHxMQU5HVUFHRXxMQVNUfExFQVZFfExFRlR8TEVWRUx8TElNSVR8TElORU5PfExJTkVTfExJTkVTVFJJTkd8TE9BRHxMT0NBTHxMT0NLfExPTkcoPzpCTE9CfFRFWFQpfExPT1B8TUFUQ0goPzpFRCk/fE1FRElVTSg/OkJMT0J8SU5UfFRFWFQpfE1FUkdFfE1JRERMRUlOVHxNSU5VVEV8TU9ERXxNT0RJRklFU3xNT0RJRll8TU9OVEh8TVVMVEkoPzpMSU5FU1RSSU5HfFBPSU5UfFBPTFlHT04pfE5BVElPTkFMfE5BVFVSQUx8TkNIQVJ8TkVYVHxOT3xOT05DTFVTVEVSRUR8TlVMTElGfE5VTUVSSUN8T0ZGP3xPRkZTRVRTP3xPTnxPUEVOKD86REFUQVNPVVJDRXxRVUVSWXxST1dTRVQpP3xPUFRJTUlaRXxPUFRJT04oPzpBTExZKT98T1JERVJ8T1VUKD86RVJ8RklMRSk/fE9WRVJ8UEFSVElBTHxQQVJUSVRJT058UEVSQ0VOVHxQSVZPVHxQTEFOfFBPSU5UfFBPTFlHT058UFJFQ0VESU5HfFBSRUNJU0lPTnxQUkVQQVJFfFBSRVZ8UFJJTUFSWXxQUklOVHxQUklWSUxFR0VTfFBST0MoPzpFRFVSRSk/fFBVQkxJQ3xQVVJHRXxRVUlDS3xSQUlTRVJST1J8UkVBRFM/fFJFQUx8UkVDT05GSUdVUkV8UkVGRVJFTkNFU3xSRUxFQVNFfFJFTkFNRXxSRVBFQVQoPzpBQkxFKT98UkVQTEFDRXxSRVBMSUNBVElPTnxSRVFVSVJFfFJFU0lHTkFMfFJFU1RPUkV8UkVTVFJJQ1R8UkVUVVJOKD86SU5HfFMpP3xSRVZPS0V8UklHSFR8Uk9MTEJBQ0t8Uk9VVElORXxST1coPzpDT1VOVHxHVUlEQ09MfFMpP3xSVFJFRXxSVUxFfFNBVkUoPzpQT0lOVCk/fFNDSEVNQXxTRUNPTkR8U0VMRUNUfFNFUklBTCg/OklaQUJMRSk/fFNFU1NJT04oPzpfVVNFUik/fFNFVCg/OlVTRVIpP3xTSEFSRXxTSE9XfFNIVVRET1dOfFNJTVBMRXxTTUFMTElOVHxTTkFQU0hPVHxTT01FfFNPTkFNRXxTUUx8U1RBUlQoPzpJTkcpP3xTVEFUSVNUSUNTfFNUQVRVU3xTVFJJUEVEfFNZU1RFTV9VU0VSfFRBQkxFUz98VEFCTEVTUEFDRXxURU1QKD86T1JBUll8VEFCTEUpP3xURVJNSU5BVEVEfFRFWFQoPzpTSVpFKT98VEhFTnxUSU1FKD86U1RBTVApP3xUSU5ZKD86QkxPQnxJTlR8VEVYVCl8VE9QP3xUUkFOKD86U0FDVElPTlM/KT98VFJJR0dFUnxUUlVOQ0FURXxUU0VRVUFMfFRZUEVTP3xVTkJPVU5ERUR8VU5DT01NSVRURUR8VU5ERUZJTkVEfFVOSU9OfFVOSVFVRXxVTkxPQ0t8VU5QSVZPVHxVTlNJR05FRHxVUERBVEUoPzpURVhUKT98VVNBR0V8VVNFfFVTRVJ8VVNJTkd8VkFMVUVTP3xWQVIoPzpCSU5BUll8Q0hBUnxDSEFSQUNURVJ8WUlORyl8VklFV3xXQUlURk9SfFdBUk5JTkdTfFdIRU58V0hFUkV8V0hJTEV8V0lUSCg/OiBST0xMVVB8SU4pP3xXT1JLfFdSSVRFKD86VEVYVCk/fFlFQVIpXFxiL2ksXG4gICdib29sZWFuJzogL1xcYig/OkZBTFNFfE5VTEx8VFJVRSlcXGIvaSxcbiAgJ251bWJlcic6IC9cXGIweFtcXGRhLWZdK1xcYnxcXGJcXGQrKD86XFwuXFxkKik/fFxcQlxcLlxcZCtcXGIvaSxcbiAgJ29wZXJhdG9yJzogL1stKypcXC89JV5+XXwmJj98XFx8XFx8P3whPT98PCg/Oj0+P3w8fD4pP3w+Wz49XT98XFxiKD86QU5EfEJFVFdFRU58RElWfElMSUtFfElOfElTfExJS0V8Tk9UfE9SfFJFR0VYUHxSTElLRXxTT1VORFMgTElLRXxYT1IpXFxiL2ksXG4gICdwdW5jdHVhdGlvbic6IC9bO1tcXF0oKWAsLl0vXG59O1xuUHJpc20ubGFuZ3VhZ2VzLnN3aWZ0ID0ge1xuICAnY29tbWVudCc6IHtcbiAgICAvLyBOZXN0ZWQgY29tbWVudHMgYXJlIHN1cHBvcnRlZCB1cCB0byAyIGxldmVsc1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFw6XSkoPzpcXC9cXC8uKnxcXC9cXCooPzpbXi8qXXxcXC8oPyFcXCopfFxcKig/IVxcLyl8XFwvXFwqKD86W14qXXxcXCooPyFcXC8pKSpcXCpcXC8pKlxcKlxcLykvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdzdHJpbmctbGl0ZXJhbCc6IFtcbiAgLy8gaHR0cHM6Ly9kb2NzLnN3aWZ0Lm9yZy9zd2lmdC1ib29rL0xhbmd1YWdlR3VpZGUvU3RyaW5nc0FuZENoYXJhY3RlcnMuaHRtbFxuICB7XG4gICAgcGF0dGVybjogUmVnRXhwKC8oXnxbXlwiI10pLy5zb3VyY2UgKyAnKD86J1xuICAgIC8vIHNpbmdsZS1saW5lIHN0cmluZ1xuICAgICsgL1wiKD86XFxcXCg/OlxcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpfFxcclxcbnxbXihdKXxbXlxcXFxcXHJcXG5cIl0pKlwiLy5zb3VyY2UgKyAnfCdcbiAgICAvLyBtdWx0aS1saW5lIHN0cmluZ1xuICAgICsgL1wiXCJcIig/OlxcXFwoPzpcXCgoPzpbXigpXXxcXChbXigpXSpcXCkpKlxcKXxbXihdKXxbXlxcXFxcIl18XCIoPyFcIlwiKSkqXCJcIlwiLy5zb3VyY2UgKyAnKScgKyAvKD8hW1wiI10pLy5zb3VyY2UpLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ2ludGVycG9sYXRpb24nOiB7XG4gICAgICAgIHBhdHRlcm46IC8oXFxcXFxcKCkoPzpbXigpXXxcXChbXigpXSpcXCkpKig/PVxcKSkvLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG4gICAgICB9LFxuICAgICAgJ2ludGVycG9sYXRpb24tcHVuY3R1YXRpb24nOiB7XG4gICAgICAgIHBhdHRlcm46IC9eXFwpfFxcXFxcXCgkLyxcbiAgICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICAgIH0sXG4gICAgICAncHVuY3R1YXRpb24nOiAvXFxcXCg/PVtcXHJcXG5dKS8sXG4gICAgICAnc3RyaW5nJzogL1tcXHNcXFNdKy9cbiAgICB9XG4gIH0sIHtcbiAgICBwYXR0ZXJuOiBSZWdFeHAoLyhefFteXCIjXSkoIyspLy5zb3VyY2UgKyAnKD86J1xuICAgIC8vIHNpbmdsZS1saW5lIHN0cmluZ1xuICAgICsgL1wiKD86XFxcXCg/OiMrXFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCl8XFxyXFxufFteI10pfFteXFxcXFxcclxcbl0pKj9cIi8uc291cmNlICsgJ3wnXG4gICAgLy8gbXVsdGktbGluZSBzdHJpbmdcbiAgICArIC9cIlwiXCIoPzpcXFxcKD86IytcXCgoPzpbXigpXXxcXChbXigpXSpcXCkpKlxcKXxbXiNdKXxbXlxcXFxdKSo/XCJcIlwiLy5zb3VyY2UgKyAnKScgKyAnXFxcXDInKSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdpbnRlcnBvbGF0aW9uJzoge1xuICAgICAgICBwYXR0ZXJuOiAvKFxcXFwjK1xcKCkoPzpbXigpXXxcXChbXigpXSpcXCkpKig/PVxcKSkvLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG4gICAgICB9LFxuICAgICAgJ2ludGVycG9sYXRpb24tcHVuY3R1YXRpb24nOiB7XG4gICAgICAgIHBhdHRlcm46IC9eXFwpfFxcXFwjK1xcKCQvLFxuICAgICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgICAgfSxcbiAgICAgICdzdHJpbmcnOiAvW1xcc1xcU10rL1xuICAgIH1cbiAgfV0sXG4gICdkaXJlY3RpdmUnOiB7XG4gICAgLy8gZGlyZWN0aXZlcyB3aXRoIGNvbmRpdGlvbnNcbiAgICBwYXR0ZXJuOiBSZWdFeHAoLyMvLnNvdXJjZSArICcoPzonICsgKC8oPzplbHNlaWZ8aWYpXFxiLy5zb3VyY2UgKyAnKD86WyBcXHRdKidcbiAgICAvLyBUaGlzIHJlZ2V4IGlzIGEgbGl0dGxlIGNvbXBsZXguIEl0J3MgZXF1aXZhbGVudCB0byB0aGlzOlxuICAgIC8vICAgKD86IVsgXFx0XSopPyg/OlxcYlxcdytcXGIoPzpbIFxcdF0qPHJvdW5kPik/fDxyb3VuZD4pKD86WyBcXHRdKig/OiYmfFxcfFxcfCkpP1xuICAgIC8vIHdoZXJlIDxyb3VuZD4gaXMgYSBnZW5lcmFsIHBhcmVudGhlc2VzIGV4cHJlc3Npb24uXG4gICAgKyAvKD86IVsgXFx0XSopPyg/OlxcYlxcdytcXGIoPzpbIFxcdF0qXFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCkpP3xcXCgoPzpbXigpXXxcXChbXigpXSpcXCkpKlxcKSkoPzpbIFxcdF0qKD86JiZ8XFx8XFx8KSk/Ly5zb3VyY2UgKyAnKSsnKSArICd8JyArIC8oPzplbHNlfGVuZGlmKVxcYi8uc291cmNlICsgJyknKSxcbiAgICBhbGlhczogJ3Byb3BlcnR5JyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdkaXJlY3RpdmUtbmFtZSc6IC9eI1xcdysvLFxuICAgICAgJ2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuICAgICAgJ251bWJlcic6IC9cXGJcXGQrKD86XFwuXFxkKykqXFxiLyxcbiAgICAgICdvcGVyYXRvcic6IC8hfCYmfFxcfFxcfHxbPD5dPT8vLFxuICAgICAgJ3B1bmN0dWF0aW9uJzogL1soKSxdL1xuICAgIH1cbiAgfSxcbiAgJ2xpdGVyYWwnOiB7XG4gICAgcGF0dGVybjogLyMoPzpjb2xvckxpdGVyYWx8Y29sdW1ufGRzb2hhbmRsZXxmaWxlKD86SUR8TGl0ZXJhbHxQYXRoKT98ZnVuY3Rpb258aW1hZ2VMaXRlcmFsfGxpbmUpXFxiLyxcbiAgICBhbGlhczogJ2NvbnN0YW50J1xuICB9LFxuICAnb3RoZXItZGlyZWN0aXZlJzoge1xuICAgIHBhdHRlcm46IC8jXFx3K1xcYi8sXG4gICAgYWxpYXM6ICdwcm9wZXJ0eSdcbiAgfSxcbiAgJ2F0dHJpYnV0ZSc6IHtcbiAgICBwYXR0ZXJuOiAvQFxcdysvLFxuICAgIGFsaWFzOiAnYXRydWxlJ1xuICB9LFxuICAnZnVuY3Rpb24tZGVmaW5pdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvKFxcYmZ1bmNcXHMrKVxcdysvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgfSxcbiAgJ2xhYmVsJzoge1xuICAgIC8vIGh0dHBzOi8vZG9jcy5zd2lmdC5vcmcvc3dpZnQtYm9vay9MYW5ndWFnZUd1aWRlL0NvbnRyb2xGbG93Lmh0bWwjSUQxNDFcbiAgICBwYXR0ZXJuOiAvXFxiKGJyZWFrfGNvbnRpbnVlKVxccytcXHcrfFxcYlthLXpBLVpfXVxcdyooPz1cXHMqOlxccyooPzpmb3J8cmVwZWF0fHdoaWxlKVxcYikvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgYWxpYXM6ICdpbXBvcnRhbnQnXG4gIH0sXG4gICdrZXl3b3JkJzogL1xcYig/OkFueXxQcm90b2NvbHxTZWxmfFR5cGV8YWN0b3J8YXN8YXNzaWdubWVudHxhc3NvY2lhdGVkdHlwZXxhc3NvY2lhdGl2aXR5fGFzeW5jfGF3YWl0fGJyZWFrfGNhc2V8Y2F0Y2h8Y2xhc3N8Y29udGludWV8Y29udmVuaWVuY2V8ZGVmYXVsdHxkZWZlcnxkZWluaXR8ZGlkU2V0fGRvfGR5bmFtaWN8ZWxzZXxlbnVtfGV4dGVuc2lvbnxmYWxsdGhyb3VnaHxmaWxlcHJpdmF0ZXxmaW5hbHxmb3J8ZnVuY3xnZXR8Z3VhcmR8aGlnaGVyVGhhbnxpZnxpbXBvcnR8aW58aW5kaXJlY3R8aW5maXh8aW5pdHxpbm91dHxpbnRlcm5hbHxpc3xpc29sYXRlZHxsYXp5fGxlZnR8bGV0fGxvd2VyVGhhbnxtdXRhdGluZ3xub25lfG5vbmlzb2xhdGVkfG5vbm11dGF0aW5nfG9wZW58b3BlcmF0b3J8b3B0aW9uYWx8b3ZlcnJpZGV8cG9zdGZpeHxwcmVjZWRlbmNlZ3JvdXB8cHJlZml4fHByaXZhdGV8cHJvdG9jb2x8cHVibGljfHJlcGVhdHxyZXF1aXJlZHxyZXRocm93c3xyZXR1cm58cmlnaHR8c2FmZXxzZWxmfHNldHxzb21lfHN0YXRpY3xzdHJ1Y3R8c3Vic2NyaXB0fHN1cGVyfHN3aXRjaHx0aHJvd3x0aHJvd3N8dHJ5fHR5cGVhbGlhc3x1bm93bmVkfHVuc2FmZXx2YXJ8d2Vha3x3aGVyZXx3aGlsZXx3aWxsU2V0KVxcYi8sXG4gICdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcbiAgJ25pbCc6IHtcbiAgICBwYXR0ZXJuOiAvXFxibmlsXFxiLyxcbiAgICBhbGlhczogJ2NvbnN0YW50J1xuICB9LFxuICAnc2hvcnQtYXJndW1lbnQnOiAvXFwkXFxkK1xcYi8sXG4gICdvbWl0Jzoge1xuICAgIHBhdHRlcm46IC9cXGJfXFxiLyxcbiAgICBhbGlhczogJ2tleXdvcmQnXG4gIH0sXG4gICdudW1iZXInOiAvXFxiKD86W1xcZF9dKyg/OlxcLltcXGRlX10rKT98MHhbYS1mMC05X10rKD86XFwuW2EtZjAtOXBfXSspP3wwYlswMV9dK3wwb1swLTdfXSspXFxiL2ksXG4gIC8vIEEgY2xhc3MgbmFtZSBtdXN0IHN0YXJ0IHdpdGggYW4gdXBwZXItY2FzZSBsZXR0ZXIgYW5kIGJlIGVpdGhlciAxIGxldHRlciBsb25nIG9yIGNvbnRhaW4gYSBsb3dlci1jYXNlIGxldHRlci5cbiAgJ2NsYXNzLW5hbWUnOiAvXFxiW0EtWl0oPzpbQS1aX1xcZF0qW2Etel1cXHcqKT9cXGIvLFxuICAnZnVuY3Rpb24nOiAvXFxiW2Etel9dXFx3Kig/PVxccypcXCgpL2ksXG4gICdjb25zdGFudCc6IC9cXGIoPzpbQS1aX117Mix9fGtbQS1aXVtBLVphLXpfXSspXFxiLyxcbiAgLy8gT3BlcmF0b3JzIGFyZSBnZW5lcmljIGluIFN3aWZ0LiBEZXZlbG9wZXJzIGNhbiBldmVuIGNyZWF0ZSBuZXcgb3BlcmF0b3JzIChlLmcuICsrKykuXG4gIC8vIGh0dHBzOi8vZG9jcy5zd2lmdC5vcmcvc3dpZnQtYm9vay9SZWZlcmVuY2VNYW51YWwvenpTdW1tYXJ5T2ZUaGVHcmFtbWFyLmh0bWwjSUQ0ODFcbiAgLy8gVGhpcyByZWdleCBvbmx5IHN1cHBvcnRzIEFTQ0lJIG9wZXJhdG9ycy5cbiAgJ29wZXJhdG9yJzogL1stKyovJT0hPD4mfF5+P10rfFxcLlsuXFwtKyovJT0hPD4mfF5+P10rLyxcbiAgJ3B1bmN0dWF0aW9uJzogL1t7fVtcXF0oKTssLjpcXFxcXS9cbn07XG5QcmlzbS5sYW5ndWFnZXMuc3dpZnRbJ3N0cmluZy1saXRlcmFsJ10uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICBydWxlLmluc2lkZVsnaW50ZXJwb2xhdGlvbiddLmluc2lkZSA9IFByaXNtLmxhbmd1YWdlcy5zd2lmdDtcbn0pO1xuKGZ1bmN0aW9uIChQcmlzbSkge1xuICBQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2phdmFzY3JpcHQnLCB7XG4gICAgJ2NsYXNzLW5hbWUnOiB7XG4gICAgICBwYXR0ZXJuOiAvKFxcYig/OmNsYXNzfGV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfGludGVyZmFjZXxuZXd8dHlwZSlcXHMrKSg/IWtleW9mXFxiKSg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPzpcXHMqPCg/OltePD5dfDwoPzpbXjw+XXw8W148Pl0qPikqPikqPik/LyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG4gICAgfSxcbiAgICAnYnVpbHRpbic6IC9cXGIoPzpBcnJheXxGdW5jdGlvbnxQcm9taXNlfGFueXxib29sZWFufGNvbnNvbGV8bmV2ZXJ8bnVtYmVyfHN0cmluZ3xzeW1ib2x8dW5rbm93bilcXGIvXG4gIH0pO1xuXG4gIC8vIFRoZSBrZXl3b3JkcyBUeXBlU2NyaXB0IGFkZHMgdG8gSmF2YVNjcmlwdFxuICBQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdC5rZXl3b3JkLnB1c2goL1xcYig/OmFic3RyYWN0fGRlY2xhcmV8aXN8a2V5b2Z8cmVhZG9ubHl8cmVxdWlyZSlcXGIvLFxuICAvLyBrZXl3b3JkcyB0aGF0IGhhdmUgdG8gYmUgZm9sbG93ZWQgYnkgYW4gaWRlbnRpZmllclxuICAvXFxiKD86YXNzZXJ0c3xpbmZlcnxpbnRlcmZhY2V8bW9kdWxlfG5hbWVzcGFjZXx0eXBlKVxcYig/PVxccyooPzpbe18kYS16QS1aXFx4QTAtXFx1RkZGRl18JCkpLyxcbiAgLy8gVGhpcyBpcyBmb3IgYGltcG9ydCB0eXBlICosIHt9YFxuICAvXFxidHlwZVxcYig/PVxccyooPzpbXFx7Kl18JCkpLyk7XG5cbiAgLy8gZG9lc24ndCB3b3JrIHdpdGggVFMgYmVjYXVzZSBUUyBpcyB0b28gY29tcGxleFxuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHRbJ3BhcmFtZXRlciddO1xuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHRbJ2xpdGVyYWwtcHJvcGVydHknXTtcblxuICAvLyBhIHZlcnNpb24gb2YgdHlwZXNjcmlwdCBzcGVjaWZpY2FsbHkgZm9yIGhpZ2hsaWdodGluZyB0eXBlc1xuICB2YXIgdHlwZUluc2lkZSA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ3R5cGVzY3JpcHQnLCB7fSk7XG4gIGRlbGV0ZSB0eXBlSW5zaWRlWydjbGFzcy1uYW1lJ107XG4gIFByaXNtLmxhbmd1YWdlcy50eXBlc2NyaXB0WydjbGFzcy1uYW1lJ10uaW5zaWRlID0gdHlwZUluc2lkZTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgndHlwZXNjcmlwdCcsICdmdW5jdGlvbicsIHtcbiAgICAnZGVjb3JhdG9yJzoge1xuICAgICAgcGF0dGVybjogL0BbJFxcd1xceEEwLVxcdUZGRkZdKy8sXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2F0Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC9eQC8sXG4gICAgICAgICAgYWxpYXM6ICdvcGVyYXRvcidcbiAgICAgICAgfSxcbiAgICAgICAgJ2Z1bmN0aW9uJzogL15bXFxzXFxTXSsvXG4gICAgICB9XG4gICAgfSxcbiAgICAnZ2VuZXJpYy1mdW5jdGlvbic6IHtcbiAgICAgIC8vIGUuZy4gZm9vPFQgZXh0ZW5kcyBcImJhclwiIHwgXCJiYXpcIj4oIC4uLlxuICAgICAgcGF0dGVybjogLyM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKlxccyo8KD86W148Pl18PCg/OltePD5dfDxbXjw+XSo+KSo+KSo+KD89XFxzKlxcKCkvLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdmdW5jdGlvbic6IC9eIz8oPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqLyxcbiAgICAgICAgJ2dlbmVyaWMnOiB7XG4gICAgICAgICAgcGF0dGVybjogLzxbXFxzXFxTXSsvLFxuICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IDxcbiAgICAgICAgICBhbGlhczogJ2NsYXNzLW5hbWUnLFxuICAgICAgICAgIGluc2lkZTogdHlwZUluc2lkZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLnRzID0gUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHQ7XG59KShQcmlzbSk7XG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIHZhciB0eXBlc2NyaXB0ID0gUHJpc20udXRpbC5jbG9uZShQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdCk7XG4gIFByaXNtLmxhbmd1YWdlcy50c3ggPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdqc3gnLCB0eXBlc2NyaXB0KTtcblxuICAvLyBkb2Vzbid0IHdvcmsgd2l0aCBUUyBiZWNhdXNlIFRTIGlzIHRvbyBjb21wbGV4XG4gIGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMudHN4WydwYXJhbWV0ZXInXTtcbiAgZGVsZXRlIFByaXNtLmxhbmd1YWdlcy50c3hbJ2xpdGVyYWwtcHJvcGVydHknXTtcblxuICAvLyBUaGlzIHdpbGwgcHJldmVudCBjb2xsaXNpb25zIGJldHdlZW4gVFNYIHRhZ3MgYW5kIFRTIGdlbmVyaWMgdHlwZXMuXG4gIC8vIElkZWEgYnkgaHR0cHM6Ly9naXRodWIuY29tL2thcmxob3JreVxuICAvLyBEaXNjdXNzaW9uOiBodHRwczovL2dpdGh1Yi5jb20vUHJpc21KUy9wcmlzbS9pc3N1ZXMvMjU5NCNpc3N1ZWNvbW1lbnQtNzEwNjY2OTI4XG4gIHZhciB0YWcgPSBQcmlzbS5sYW5ndWFnZXMudHN4LnRhZztcbiAgdGFnLnBhdHRlcm4gPSBSZWdFeHAoLyhefFteXFx3JF18KD89PFxcLykpLy5zb3VyY2UgKyAnKD86JyArIHRhZy5wYXR0ZXJuLnNvdXJjZSArICcpJywgdGFnLnBhdHRlcm4uZmxhZ3MpO1xuICB0YWcubG9va2JlaGluZCA9IHRydWU7XG59KShQcmlzbSk7XG5QcmlzbS5sYW5ndWFnZXMuYmFzaWMgPSB7XG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC8oPzohfFJFTVxcYikuKy9pLFxuICAgIGluc2lkZToge1xuICAgICAgJ2tleXdvcmQnOiAvXlJFTS9pXG4gICAgfVxuICB9LFxuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC9cIig/OlwiXCJ8WyEjJCUmJygpKixcXC86Ozw9Pj9eXFx3ICtcXC0uXSkqXCIvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnbnVtYmVyJzogLyg/OlxcYlxcZCsoPzpcXC5cXGQqKT98XFxCXFwuXFxkKykoPzpFWystXT9cXGQrKT8vaSxcbiAgJ2tleXdvcmQnOiAvXFxiKD86QVN8QkVFUHxCTE9BRHxCU0FWRXxDQUxMKD86IEFCU09MVVRFKT98Q0FTRXxDSEFJTnxDSERJUnxDTEVBUnxDTE9TRXxDTFN8Q09NfENPTU1PTnxDT05TVHxEQVRBfERFQ0xBUkV8REVGKD86IEZOfCBTRUd8REJMfElOVHxMTkd8U05HfFNUUil8RElNfERPfERPVUJMRXxFTFNFfEVMU0VJRnxFTkR8RU5WSVJPTnxFUkFTRXxFUlJPUnxFWElUfEZJRUxEfEZJTEVTfEZPUnxGVU5DVElPTnxHRVR8R09TVUJ8R09UT3xJRnxJTlBVVHxJTlRFR0VSfElPQ1RMfEtFWXxLSUxMfExJTkUgSU5QVVR8TE9DQVRFfExPQ0t8TE9OR3xMT09QfExTRVR8TUtESVJ8TkFNRXxORVhUfE9GRnxPTig/OiBDT018IEVSUk9SfCBLRVl8IFRJTUVSKT98T1BFTnxPUFRJT04gQkFTRXxPVVR8UE9LRXxQVVR8UkVBRHxSRURJTXxSRU18UkVTVE9SRXxSRVNVTUV8UkVUVVJOfFJNRElSfFJTRVR8UlVOfFNFTEVDVCBDQVNFfFNIQVJFRHxTSEVMTHxTSU5HTEV8U0xFRVB8U1RBVElDfFNURVB8U1RPUHxTVFJJTkd8U1VCfFNXQVB8U1lTVEVNfFRIRU58VElNRVJ8VE98VFJPRkZ8VFJPTnxUWVBFfFVOTE9DS3xVTlRJTHxVU0lOR3xWSUVXIFBSSU5UfFdBSVR8V0VORHxXSElMRXxXUklURSkoPzpcXCR8XFxiKS9pLFxuICAnZnVuY3Rpb24nOiAvXFxiKD86QUJTfEFDQ0VTU3xBQ09TfEFOR0xFfEFSRUF8QVJJVEhNRVRJQ3xBUlJBWXxBU0lOfEFTS3xBVHxBVE58QkFTRXxCRUdJTnxCUkVBS3xDQVVTRXxDRUlMfENIUnxDTElQfENPTExBVEV8Q09MT1J8Q09OfENPU3xDT1NIfENPVHxDU0N8REFURXxEQVRVTXxERUJVR3xERUNJTUFMfERFRnxERUd8REVHUkVFU3xERUxFVEV8REVUfERFVklDRXxESVNQTEFZfERPVHxFTEFQU0VEfEVQU3xFUkFTQUJMRXxFWExJTkV8RVhQfEVYVEVSTkFMfEVYVFlQRXxGSUxFVFlQRXxGSVhFRHxGUHxHT3xHUkFQSHxIQU5ETEVSfElETnxJTUFHRXxJTnxJTlR8SU5URVJOQUx8SVB8SVN8S0VZRUR8TEJPVU5EfExDQVNFfExFRlR8TEVOfExFTkdUSHxMRVR8TElORXxMSU5FU3xMT0d8TE9HMTB8TE9HMnxMVFJJTXxNQVJHSU58TUFUfE1BWHxNQVhOVU18TUlEfE1JTnxNSVNTSU5HfE1PRHxOQVRJVkV8TlVMfE5VTUVSSUN8T0Z8T1BUSU9OfE9SRHxPUkdBTklaQVRJT058T1VUSU58T1VUUFVUfFBJfFBPSU5UfFBPSU5URVJ8UE9JTlRTfFBPU3xQUklOVHxQUk9HUkFNfFBST01QVHxSQUR8UkFESUFOU3xSQU5ET01JWkV8UkVDT1JEfFJFQ1NJWkV8UkVDVFlQRXxSRUxBVElWRXxSRU1BSU5ERVJ8UkVQRUFUfFJFU1R8UkVUUll8UkVXUklURXxSSUdIVHxSTkR8Uk9VTkR8UlRSSU18U0FNRXxTRUN8U0VMRUNUfFNFUVVFTlRJQUx8U0VUfFNFVFRFUnxTR058U0lOfFNJTkh8U0laRXxTS0lQfFNRUnxTVEFOREFSRHxTVEFUVVN8U1RSfFNUUkVBTXxTVFlMRXxUQUJ8VEFOfFRBTkh8VEVNUExBVEV8VEVYVHxUSEVSRXxUSU1FfFRJTUVPVVR8VFJBQ0V8VFJBTlNGT1JNfFRSVU5DQVRFfFVCT1VORHxVQ0FTRXxVU0V8VkFMfFZBUklBQkxFfFZJRVdQT1JUfFdIRU58V0lORE9XfFdJVEh8WkVSfFpPTkVXSURUSCkoPzpcXCR8XFxiKS9pLFxuICAnb3BlcmF0b3InOiAvPFs9Pl0/fD49P3xbK1xcLSpcXC9ePSZdfFxcYig/OkFORHxFUVZ8SU1QfE5PVHxPUnxYT1IpXFxiL2ksXG4gICdwdW5jdHVhdGlvbic6IC9bLDs6KCldL1xufTtcblByaXNtLmxhbmd1YWdlcy52Ym5ldCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2Jhc2ljJywge1xuICAnY29tbWVudCc6IFt7XG4gICAgcGF0dGVybjogLyg/OiF8UkVNXFxiKS4rL2ksXG4gICAgaW5zaWRlOiB7XG4gICAgICAna2V5d29yZCc6IC9eUkVNL2lcbiAgICB9XG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcOl0pJy4qLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9XSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cIl0pXCIoPzpcIlwifFteXCJdKSpcIig/IVwiKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2tleXdvcmQnOiAvKD86XFxiKD86QURESEFORExFUnxBRERSRVNTT0Z8QUxJQVN8QU5EfEFOREFMU098QVN8QkVFUHxCTE9BRHxCT09MRUFOfEJTQVZFfEJZUkVGfEJZVEV8QllWQUx8Q0FMTCg/OiBBQlNPTFVURSk/fENBU0V8Q0FUQ0h8Q0JPT0x8Q0JZVEV8Q0NIQVJ8Q0RBVEV8Q0RCTHxDREVDfENIQUlOfENIQVJ8Q0hESVJ8Q0lOVHxDTEFTU3xDTEVBUnxDTE5HfENMT1NFfENMU3xDT0JKfENPTXxDT01NT058Q09OU1R8Q09OVElOVUV8Q1NCWVRFfENTSE9SVHxDU05HfENTVFJ8Q1RZUEV8Q1VJTlR8Q1VMTkd8Q1VTSE9SVHxEQVRBfERBVEV8REVDSU1BTHxERUNMQVJFfERFRig/OiBGTnwgU0VHfERCTHxJTlR8TE5HfFNOR3xTVFIpfERFRkFVTFR8REVMRUdBVEV8RElNfERJUkVDVENBU1R8RE98RE9VQkxFfEVMU0V8RUxTRUlGfEVORHxFTlVNfEVOVklST058RVJBU0V8RVJST1J8RVZFTlR8RVhJVHxGQUxTRXxGSUVMRHxGSUxFU3xGSU5BTExZfEZPUig/OiBFQUNIKT98RlJJRU5EfEZVTkNUSU9OfEdFVHxHRVRUWVBFfEdFVFhNTE5BTUVTUEFDRXxHTE9CQUx8R09TVUJ8R09UT3xIQU5ETEVTfElGfElNUExFTUVOVFN8SU1QT1JUU3xJTnxJTkhFUklUU3xJTlBVVHxJTlRFR0VSfElOVEVSRkFDRXxJT0NUTHxJU3xJU05PVHxLRVl8S0lMTHxMRVR8TElCfExJS0V8TElORSBJTlBVVHxMT0NBVEV8TE9DS3xMT05HfExPT1B8TFNFVHxNRXxNS0RJUnxNT0R8TU9EVUxFfE1VU1RJTkhFUklUfE1VU1RPVkVSUklERXxNWUJBU0V8TVlDTEFTU3xOQU1FfE5BTUVTUEFDRXxOQVJST1dJTkd8TkVXfE5FWFR8Tk9UfE5PVEhJTkd8Tk9USU5IRVJJVEFCTEV8Tk9UT1ZFUlJJREFCTEV8T0JKRUNUfE9GfE9GRnxPTig/OiBDT018IEVSUk9SfCBLRVl8IFRJTUVSKT98T1BFTnxPUEVSQVRPUnxPUFRJT04oPzogQkFTRSk/fE9QVElPTkFMfE9SfE9SRUxTRXxPVVR8T1ZFUkxPQURTfE9WRVJSSURBQkxFfE9WRVJSSURFU3xQQVJBTUFSUkFZfFBBUlRJQUx8UE9LRXxQUklWQVRFfFBST1BFUlRZfFBST1RFQ1RFRHxQVUJMSUN8UFVUfFJBSVNFRVZFTlR8UkVBRHxSRUFET05MWXxSRURJTXxSRU18UkVNT1ZFSEFORExFUnxSRVNUT1JFfFJFU1VNRXxSRVRVUk58Uk1ESVJ8UlNFVHxSVU58U0JZVEV8U0VMRUNUKD86IENBU0UpP3xTRVR8U0hBRE9XU3xTSEFSRUR8U0hFTEx8U0hPUlR8U0lOR0xFfFNMRUVQfFNUQVRJQ3xTVEVQfFNUT1B8U1RSSU5HfFNUUlVDVFVSRXxTVUJ8U1dBUHxTWU5DTE9DS3xTWVNURU18VEhFTnxUSFJPV3xUSU1FUnxUT3xUUk9GRnxUUk9OfFRSVUV8VFJZfFRSWUNBU1R8VFlQRXxUWVBFT0Z8VUlOVEVHRVJ8VUxPTkd8VU5MT0NLfFVOVElMfFVTSE9SVHxVU0lOR3xWSUVXIFBSSU5UfFdBSVR8V0VORHxXSEVOfFdISUxFfFdJREVOSU5HfFdJVEh8V0lUSEVWRU5UU3xXUklURXxXUklURU9OTFl8WE9SKXxcXEIoPzojQ09OU1R8I0VMU0V8I0VMU0VJRnwjRU5EfCNJRikpKD86XFwkfFxcYikvaSxcbiAgJ3B1bmN0dWF0aW9uJzogL1ssOzooKXt9XS9cbn0pO1xuXG5jb25zdCBsYW5ndWFnZXMgPSBbe1xuICBsYWJlbDogJ0MnLFxuICB2YWx1ZTogJ2MnXG59LCB7XG4gIGxhYmVsOiAnQysrJyxcbiAgdmFsdWU6ICdjcHAnXG59LCB7XG4gIGxhYmVsOiAnQXJkdWlubycsXG4gIHZhbHVlOiAnYXJkdWlubydcbn0sIHtcbiAgbGFiZWw6ICdCYXNoJyxcbiAgdmFsdWU6ICdiYXNoJ1xufSwge1xuICBsYWJlbDogJ0MjJyxcbiAgdmFsdWU6ICdjc2hhcnAnXG59LCB7XG4gIGxhYmVsOiAnQ1NTJyxcbiAgdmFsdWU6ICdjc3MnXG59LCB7XG4gIGxhYmVsOiAnRGlmZicsXG4gIHZhbHVlOiAnZGlmZidcbn0sIHtcbiAgbGFiZWw6ICdHbycsXG4gIHZhbHVlOiAnZ28nXG59LCB7XG4gIGxhYmVsOiAnSU5JJyxcbiAgdmFsdWU6ICdpbmknXG59LCB7XG4gIGxhYmVsOiAnSmF2YScsXG4gIHZhbHVlOiAnamF2YSdcbn0sIHtcbiAgbGFiZWw6ICdKYXZhU2NyaXB0JyxcbiAgdmFsdWU6ICdqYXZhc2NyaXB0J1xufSwge1xuICBsYWJlbDogJ0pTWCcsXG4gIHZhbHVlOiAnanN4J1xufSwge1xuICBsYWJlbDogJ0pTT04nLFxuICB2YWx1ZTogJ2pzb24nXG59LCB7XG4gIGxhYmVsOiAnS290bGluJyxcbiAgdmFsdWU6ICdrb3RsaW4nXG59LCB7XG4gIGxhYmVsOiAnTGVzcycsXG4gIHZhbHVlOiAnbGVzcydcbn0sIHtcbiAgbGFiZWw6ICdMdWEnLFxuICB2YWx1ZTogJ2x1YSdcbn0sIHtcbiAgbGFiZWw6ICdNYWtlZmlsZScsXG4gIHZhbHVlOiAnbWFrZWZpbGUnXG59LCB7XG4gIGxhYmVsOiAnTWFya2Rvd24nLFxuICB2YWx1ZTogJ21hcmtkb3duJ1xufSwge1xuICBsYWJlbDogJ09iamVjdGl2ZS1DJyxcbiAgdmFsdWU6ICdvYmplY3RpdmVjJ1xufSwge1xuICBsYWJlbDogJ1BlcmwnLFxuICB2YWx1ZTogJ3BlcmwnXG59LCB7XG4gIGxhYmVsOiAnUEhQJyxcbiAgdmFsdWU6ICdwaHAnXG59LCB7XG4gIGxhYmVsOiAnUHl0aG9uJyxcbiAgdmFsdWU6ICdweXRob24nXG59LCB7XG4gIGxhYmVsOiAnUicsXG4gIHZhbHVlOiAncidcbn0sIHtcbiAgbGFiZWw6ICdSdWJ5JyxcbiAgdmFsdWU6ICdydWJ5J1xufSwge1xuICBsYWJlbDogJ1J1c3QnLFxuICB2YWx1ZTogJ3J1c3QnXG59LCB7XG4gIGxhYmVsOiAnU2FzcycsXG4gIHZhbHVlOiAnc2Fzcydcbn0sIHtcbiAgbGFiZWw6ICdTQ1NTJyxcbiAgdmFsdWU6ICdzY3NzJ1xufSwge1xuICBsYWJlbDogJ1NRTCcsXG4gIHZhbHVlOiAnc3FsJ1xufSwge1xuICBsYWJlbDogJ1N3aWZ0JyxcbiAgdmFsdWU6ICdzd2lmdCdcbn0sIHtcbiAgbGFiZWw6ICdUeXBlU2NyaXB0JyxcbiAgdmFsdWU6ICd0eXBlc2NyaXB0J1xufSwge1xuICBsYWJlbDogJ1RTWCcsXG4gIHZhbHVlOiAndHN4J1xufSwge1xuICBsYWJlbDogJ1ZCLk5FVCcsXG4gIHZhbHVlOiAndmJuZXQnXG59LCB7XG4gIGxhYmVsOiAnWUFNTCcsXG4gIHZhbHVlOiAneWFtbCdcbn1dO1xuY29uc3QgY2Fub25pY2FsTmFtZVRvTGFiZWwgPSBuZXcgTWFwKGxhbmd1YWdlcy5tYXAoeCA9PiBbeC52YWx1ZSwgeC5sYWJlbF0pKTtcbmNvbnN0IGxhYmVsVG9DYW5vbmljYWxOYW1lID0gbmV3IE1hcChsYW5ndWFnZXMubWFwKHggPT4gW3gubGFiZWwsIHgudmFsdWVdKSk7XG5jb25zdCBsYW5ndWFnZVRvQ2Fub25pY2FsTmFtZSA9IG5ldyBNYXAobGFuZ3VhZ2VzLm1hcChsYW5nID0+IFtQcmlzbS5sYW5ndWFnZXNbbGFuZy52YWx1ZV0sIGxhbmcudmFsdWVdKSk7XG5jb25zdCBhbGlhc2VzVG9DYW5vbmljYWxOYW1lID0gbmV3IE1hcChPYmplY3Qua2V5cyhQcmlzbS5sYW5ndWFnZXMpLmZsYXRNYXAobGFuZyA9PiB7XG4gIGNvbnN0IGNhbm9uaWNhbE5hbWUgPSBsYW5ndWFnZVRvQ2Fub25pY2FsTmFtZS5nZXQoUHJpc20ubGFuZ3VhZ2VzW2xhbmddKTtcbiAgaWYgKGNhbm9uaWNhbE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gW1tsYW5nLCBjYW5vbmljYWxOYW1lXV07XG59KSk7XG5jb25zdCBsYW5ndWFnZXNUb0FsaWFzZXMgPSBuZXcgTWFwKGxhbmd1YWdlcy5tYXAobGFuZyA9PiBbbGFuZy52YWx1ZSwgW11dKSk7XG5mb3IgKGNvbnN0IFthbGlhcywgY2Fub25pY2FsTmFtZV0gb2YgYWxpYXNlc1RvQ2Fub25pY2FsTmFtZSkge1xuICBsYW5ndWFnZXNUb0FsaWFzZXMuZ2V0KGNhbm9uaWNhbE5hbWUpLnB1c2goYWxpYXMpO1xufVxuY29uc3QgbGFuZ3VhZ2VzV2l0aEFsaWFzZXMgPSBbe1xuICBsYWJlbDogJ1BsYWluIHRleHQnLFxuICB2YWx1ZTogJ3BsYWluJyxcbiAgYWxpYXNlczogW11cbn0sIC4uLlsuLi5sYW5ndWFnZXNUb0FsaWFzZXNdLm1hcCgoW2Nhbm9uaWNhbE5hbWUsIGFsaWFzZXNdKSA9PiAoe1xuICBsYWJlbDogY2Fub25pY2FsTmFtZVRvTGFiZWwuZ2V0KGNhbm9uaWNhbE5hbWUpLFxuICB2YWx1ZTogY2Fub25pY2FsTmFtZSxcbiAgYWxpYXNlc1xufSkpXTtcbmNvbnN0IGFsaWFzZXNUb0xhYmVsID0gbmV3IE1hcChbLi4uYWxpYXNlc1RvQ2Fub25pY2FsTmFtZV0ubWFwKChbYWxpYXMsIGNhbm9uaWNhbE5hbWVdKSA9PiBbYWxpYXMsIGNhbm9uaWNhbE5hbWVUb0xhYmVsLmdldChjYW5vbmljYWxOYW1lKV0pKTtcblxuY29uc3QgY29kZUJsb2NrU2hvcnRjdXRQYXR0ZXJuID0gL15gYGAoXFx3Kyk/ID8kLztcbmZ1bmN0aW9uIHdpdGhDb2RlQmxvY2soZG9jdW1lbnRGZWF0dXJlcywgY29tcG9uZW50QmxvY2tzLCBlZGl0b3IpIHtcbiAgY29uc3Qge1xuICAgIGluc2VydEJyZWFrLFxuICAgIG5vcm1hbGl6ZU5vZGUsXG4gICAgaW5zZXJ0VGV4dFxuICB9ID0gZWRpdG9yO1xuICBmdW5jdGlvbiBjb2RlQmxvY2tTaG9ydGN1dChibG9jaykge1xuICAgIHZhciBfYWxpYXNlc1RvQ2Fub25pY2FsTmE7XG4gICAgaWYgKChibG9jayA9PT0gbnVsbCB8fCBibG9jayA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmxvY2tbMF0udHlwZSkgIT09ICdwYXJhZ3JhcGgnIHx8IGJsb2NrWzBdLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBibG9ja1swXS5jaGlsZHJlblswXS50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBjb2RlQmxvY2tTaG9ydGN1dFBhdHRlcm4uZXhlYyhibG9ja1swXS5jaGlsZHJlblswXS50ZXh0KTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGxvY2F0aW9uRG9jdW1lbnRGZWF0dXJlcyA9IGdldEFuY2VzdG9yQ29tcG9uZW50Q2hpbGRGaWVsZERvY3VtZW50RmVhdHVyZXMoZWRpdG9yLCBkb2N1bWVudEZlYXR1cmVzLCBjb21wb25lbnRCbG9ja3MpO1xuICAgIGlmIChsb2NhdGlvbkRvY3VtZW50RmVhdHVyZXMgJiYgKGxvY2F0aW9uRG9jdW1lbnRGZWF0dXJlcy5raW5kID09PSAnaW5saW5lJyB8fCAhbG9jYXRpb25Eb2N1bWVudEZlYXR1cmVzLmRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5ibG9ja1R5cGVzLmNvZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gc28gdGhhdCB0aGlzIHN0YXJ0cyBhIG5ldyB1bmRvIGdyb3VwXG4gICAgZWRpdG9yLmhpc3RvcnkudW5kb3MucHVzaCh7XG4gICAgICBvcGVyYXRpb25zOiBbXSxcbiAgICAgIHNlbGVjdGlvbkJlZm9yZTogZWRpdG9yLnNlbGVjdGlvblxuICAgIH0pO1xuICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYmxvY2tbMV0pO1xuICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvcik7XG4gICAgVHJhbnNmb3Jtcy53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICB0eXBlOiAnY29kZScsXG4gICAgICAuLi4obWF0Y2hbMV0gPyB7XG4gICAgICAgIGxhbmd1YWdlOiAoX2FsaWFzZXNUb0Nhbm9uaWNhbE5hID0gYWxpYXNlc1RvQ2Fub25pY2FsTmFtZS5nZXQobWF0Y2hbMV0udG9Mb3dlckNhc2UoKSkpICE9PSBudWxsICYmIF9hbGlhc2VzVG9DYW5vbmljYWxOYSAhPT0gdm9pZCAwID8gX2FsaWFzZXNUb0Nhbm9uaWNhbE5hIDogbWF0Y2hbMV1cbiAgICAgIH0gOiB7fSksXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9LCB7XG4gICAgICBtYXRjaDogbm9kZSA9PiBub2RlLnR5cGUgPT09ICdwYXJhZ3JhcGgnXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZWRpdG9yLmluc2VydEJyZWFrID0gKCkgPT4ge1xuICAgIGNvbnN0IGJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IGlzQmxvY2tcbiAgICB9KTtcbiAgICBpZiAoKGJsb2NrID09PSBudWxsIHx8IGJsb2NrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBibG9ja1swXS50eXBlKSA9PT0gJ2NvZGUnICYmIFRleHQuaXNUZXh0KGJsb2NrWzBdLmNoaWxkcmVuWzBdKSkge1xuICAgICAgY29uc3QgdGV4dCA9IGJsb2NrWzBdLmNoaWxkcmVuWzBdLnRleHQ7XG4gICAgICBpZiAodGV4dFt0ZXh0Lmxlbmd0aCAtIDFdID09PSAnXFxuJyAmJiBlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pICYmIFBvaW50LmVxdWFscyhFZGl0b3IuZW5kKGVkaXRvciwgYmxvY2tbMV0pLCBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvcikpIHtcbiAgICAgICAgaW5zZXJ0QnJlYWsoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgfSk7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgIGRpc3RhbmNlOiAxLFxuICAgICAgICAgIGF0OiB7XG4gICAgICAgICAgICBwYXRoOiBbLi4uYmxvY2tbMV0sIDBdLFxuICAgICAgICAgICAgb2Zmc2V0OiB0ZXh0Lmxlbmd0aCAtIDFcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3IuaW5zZXJ0VGV4dCgnXFxuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pICYmIGNvZGVCbG9ja1Nob3J0Y3V0KGJsb2NrKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnNlcnRCcmVhaygpO1xuICB9O1xuICBlZGl0b3IuaW5zZXJ0VGV4dCA9IHRleHQgPT4ge1xuICAgIGluc2VydFRleHQodGV4dCk7XG4gICAgaWYgKHRleHQgPT09ICcgJyAmJiBlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSB7XG4gICAgICBjb2RlQmxvY2tTaG9ydGN1dChFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBpc0Jsb2NrXG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuICBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICBpZiAobm9kZS50eXBlID09PSAnY29kZScgJiYgRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSkge1xuICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGNoaWxkTm9kZV0gb2Ygbm9kZS5jaGlsZHJlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKCFUZXh0LmlzVGV4dChjaGlsZE5vZGUpKSB7XG4gICAgICAgICAgaWYgKGVkaXRvci5pc1ZvaWQoY2hpbGROb2RlKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IFsuLi5wYXRoLCBpbmRleF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogWy4uLnBhdGgsIGluZGV4XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXJrcyA9IE9iamVjdC5rZXlzKGNoaWxkTm9kZSkuZmlsdGVyKHggPT4geCAhPT0gJ3RleHQnKTtcbiAgICAgICAgaWYgKG1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMudW5zZXROb2RlcyhlZGl0b3IsIG1hcmtzLCB7XG4gICAgICAgICAgICBhdDogWy4uLnBhdGgsIGluZGV4XVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBub3JtYWxpemVOb2RlKFtub2RlLCBwYXRoXSk7XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59XG5cbmZ1bmN0aW9uIGZpbmRDaGlsZFByb3BQYXRoc0ZvclByb3AodmFsdWUsIHNjaGVtYSwgcGF0aCkge1xuICBzd2l0Y2ggKHNjaGVtYS5raW5kKSB7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICByZXR1cm4gW107XG4gICAgY2FzZSAnY2hpbGQnOlxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIG9wdGlvbnM6IHNjaGVtYS5vcHRpb25zXG4gICAgICB9XTtcbiAgICBjYXNlICdjb25kaXRpb25hbCc6XG4gICAgICByZXR1cm4gZmluZENoaWxkUHJvcFBhdGhzRm9yUHJvcCh2YWx1ZS52YWx1ZSwgc2NoZW1hLnZhbHVlc1t2YWx1ZS5kaXNjcmltaW5hbnRdLCBwYXRoLmNvbmNhdCgndmFsdWUnKSk7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICAgICAgT2JqZWN0LmtleXMoc2NoZW1hLmZpZWxkcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgIHBhdGhzLnB1c2goLi4uZmluZENoaWxkUHJvcFBhdGhzRm9yUHJvcCh2YWx1ZVtrZXldLCBzY2hlbWEuZmllbGRzW2tleV0sIHBhdGguY29uY2F0KGtleSkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXRocztcbiAgICAgIH1cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgICAgIHZhbHVlLmZvckVhY2goKHZhbCwgaSkgPT4ge1xuICAgICAgICAgIHBhdGhzLnB1c2goLi4uZmluZENoaWxkUHJvcFBhdGhzRm9yUHJvcCh2YWwsIHNjaGVtYS5lbGVtZW50LCBwYXRoLmNvbmNhdChpKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhdGhzO1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBmaW5kQ2hpbGRQcm9wUGF0aHModmFsdWUsIHByb3BzKSB7XG4gIGNvbnN0IHByb3BQYXRocyA9IGZpbmRDaGlsZFByb3BQYXRoc0ZvclByb3AodmFsdWUsIHtcbiAgICBraW5kOiAnb2JqZWN0JyxcbiAgICBmaWVsZHM6IHByb3BzXG4gIH0sIFtdKTtcbiAgaWYgKCFwcm9wUGF0aHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFt7XG4gICAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGtpbmQ6ICdpbmxpbmUnLFxuICAgICAgICBwbGFjZWhvbGRlcjogJydcbiAgICAgIH1cbiAgICB9XTtcbiAgfVxuICByZXR1cm4gcHJvcFBhdGhzO1xufVxuXG5mdW5jdGlvbiBnZXRBbmNlc3RvckNvbXBvbmVudEJsb2NrKGVkaXRvcikge1xuICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgIGNvbnN0IGFuY2VzdG9yRW50cnkgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogbm9kZSA9PiBpc0Jsb2NrKG5vZGUpICYmIG5vZGUudHlwZSAhPT0gJ3BhcmFncmFwaCdcbiAgICB9KTtcbiAgICBpZiAoYW5jZXN0b3JFbnRyeSAmJiAoYW5jZXN0b3JFbnRyeVswXS50eXBlID09PSAnY29tcG9uZW50LWJsb2NrLXByb3AnIHx8IGFuY2VzdG9yRW50cnlbMF0udHlwZSA9PT0gJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCcpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0luc2lkZTogdHJ1ZSxcbiAgICAgICAgY29tcG9uZW50QmxvY2s6IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhbmNlc3RvckVudHJ5WzFdKSxcbiAgICAgICAgcHJvcDogYW5jZXN0b3JFbnRyeVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0luc2lkZTogZmFsc2VcbiAgfTtcbn1cbmNvbnN0IGFscmVhZHlOb3JtYWxpemVkVGhpbmdzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZU5vZGVXaXRoaW5Db21wb25lbnRQcm9wKFtub2RlLCBwYXRoXSwgZWRpdG9yLCBmaWVsZE9wdGlvbnMpIHtcbiAgbGV0IGFscmVhZHlOb3JtYWxpemVkTm9kZXMgPSBhbHJlYWR5Tm9ybWFsaXplZFRoaW5ncy5nZXQoZmllbGRPcHRpb25zKTtcbiAgaWYgKCFhbHJlYWR5Tm9ybWFsaXplZE5vZGVzKSB7XG4gICAgYWxyZWFkeU5vcm1hbGl6ZWROb2RlcyA9IG5ldyBXZWFrU2V0KCk7XG4gICAgYWxyZWFkeU5vcm1hbGl6ZWRUaGluZ3Muc2V0KGZpZWxkT3B0aW9ucywgYWxyZWFkeU5vcm1hbGl6ZWROb2Rlcyk7XG4gIH1cbiAgaWYgKGFscmVhZHlOb3JtYWxpemVkTm9kZXMuaGFzKG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBkaWROb3JtYWxpemF0aW9uID0gZmFsc2U7XG4gIGlmIChmaWVsZE9wdGlvbnMuaW5saW5lTWFya3MgIT09ICdpbmhlcml0JyAmJiBUZXh0LmlzVGV4dChub2RlKSkge1xuICAgIGRpZE5vcm1hbGl6YXRpb24gPSBub3JtYWxpemVUZXh0QmFzZWRPbklubGluZU1hcmtzQW5kU29mdEJyZWFrcyhbbm9kZSwgcGF0aF0sIGVkaXRvciwgZmllbGRPcHRpb25zLmlubGluZU1hcmtzLCBmaWVsZE9wdGlvbnMuc29mdEJyZWFrcyk7XG4gIH1cbiAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICBsZXQgY2hpbGRyZW5IYXNDaGFuZ2VkID0gbm9kZS5jaGlsZHJlbi5tYXAoKG5vZGUsIGkpID0+IG5vcm1hbGl6ZU5vZGVXaXRoaW5Db21wb25lbnRQcm9wKFtub2RlLCBbLi4ucGF0aCwgaV1dLCBlZGl0b3IsIGZpZWxkT3B0aW9ucykpXG4gICAgLy8gLm1hcCB0aGVuIC5zb21lIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBleGl0IGVhcmx5XG4gICAgLnNvbWUoeCA9PiB4KTtcbiAgICBpZiAoZmllbGRPcHRpb25zLmtpbmQgPT09ICdibG9jaycpIHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09ICdjb21wb25lbnQtYmxvY2snKSB7XG4gICAgICAgIGlmICghZmllbGRPcHRpb25zLmNvbXBvbmVudEJsb2Nrcykge1xuICAgICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRpZE5vcm1hbGl6YXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWROb3JtYWxpemF0aW9uID0gbm9ybWFsaXplRWxlbWVudEJhc2VkT25Eb2N1bWVudEZlYXR1cmVzKFtub2RlLCBwYXRoXSwgZWRpdG9yLCBmaWVsZE9wdGlvbnMuZG9jdW1lbnRGZWF0dXJlcykgfHwgY2hpbGRyZW5IYXNDaGFuZ2VkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkaWROb3JtYWxpemF0aW9uID0gbm9ybWFsaXplSW5saW5lQmFzZWRPbkxpbmtzKFtub2RlLCBwYXRoXSwgZWRpdG9yLCBmaWVsZE9wdGlvbnMuZG9jdW1lbnRGZWF0dXJlcy5saW5rcyk7XG4gICAgfVxuICB9XG4gIGlmIChkaWROb3JtYWxpemF0aW9uID09PSBmYWxzZSkge1xuICAgIGFscmVhZHlOb3JtYWxpemVkTm9kZXMuYWRkKG5vZGUpO1xuICB9XG4gIHJldHVybiBkaWROb3JtYWxpemF0aW9uO1xufVxuZnVuY3Rpb24gY2FuU2NoZW1hQ29udGFpbkNoaWxkRmllbGQocm9vdFNjaGVtYSkge1xuICBjb25zdCBxdWV1ZSA9IG5ldyBTZXQoW3Jvb3RTY2hlbWFdKTtcbiAgZm9yIChjb25zdCBzY2hlbWEgb2YgcXVldWUpIHtcbiAgICBpZiAoc2NoZW1hLmtpbmQgPT09ICdmb3JtJykgOyBlbHNlIGlmIChzY2hlbWEua2luZCA9PT0gJ2NoaWxkJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChzY2hlbWEua2luZCA9PT0gJ2FycmF5Jykge1xuICAgICAgcXVldWUuYWRkKHNjaGVtYS5lbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHNjaGVtYS5raW5kID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yIChjb25zdCBpbm5lclByb3Agb2YgT2JqZWN0LnZhbHVlcyhzY2hlbWEuZmllbGRzKSkge1xuICAgICAgICBxdWV1ZS5hZGQoaW5uZXJQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjaGVtYS5raW5kID09PSAnY29uZGl0aW9uYWwnKSB7XG4gICAgICBmb3IgKGNvbnN0IGlubmVyUHJvcCBvZiBPYmplY3QudmFsdWVzKHNjaGVtYS52YWx1ZXMpKSB7XG4gICAgICAgIHF1ZXVlLmFkZChpbm5lclByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnROZXZlcihzY2hlbWEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkb2VzU2NoZW1hT25seUV2ZXJDb250YWluQVNpbmdsZUNoaWxkRmllbGQocm9vdFNjaGVtYSkge1xuICBjb25zdCBxdWV1ZSA9IG5ldyBTZXQoW3Jvb3RTY2hlbWFdKTtcbiAgbGV0IGhhc0ZvdW5kQ2hpbGRGaWVsZCA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IHNjaGVtYSBvZiBxdWV1ZSkge1xuICAgIGlmIChzY2hlbWEua2luZCA9PT0gJ2Zvcm0nKSA7IGVsc2UgaWYgKHNjaGVtYS5raW5kID09PSAnY2hpbGQnKSB7XG4gICAgICBpZiAoaGFzRm91bmRDaGlsZEZpZWxkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGhhc0ZvdW5kQ2hpbGRGaWVsZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzY2hlbWEua2luZCA9PT0gJ2FycmF5Jykge1xuICAgICAgaWYgKGNhblNjaGVtYUNvbnRhaW5DaGlsZEZpZWxkKHNjaGVtYS5lbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY2hlbWEua2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAoY29uc3QgaW5uZXJQcm9wIG9mIE9iamVjdC52YWx1ZXMoc2NoZW1hLmZpZWxkcykpIHtcbiAgICAgICAgcXVldWUuYWRkKGlubmVyUHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY2hlbWEua2luZCA9PT0gJ2NvbmRpdGlvbmFsJykge1xuICAgICAgZm9yIChjb25zdCBpbm5lclByb3Agb2YgT2JqZWN0LnZhbHVlcyhzY2hlbWEudmFsdWVzKSkge1xuICAgICAgICBxdWV1ZS5hZGQoaW5uZXJQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0TmV2ZXIoc2NoZW1hKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc0ZvdW5kQ2hpbGRGaWVsZDtcbn1cbmZ1bmN0aW9uIGZpbmRBcnJheUZpZWxkc1dpdGhTaW5nbGVDaGlsZEZpZWxkKHNjaGVtYSwgdmFsdWUpIHtcbiAgY29uc3QgcHJvcFBhdGhzID0gW107XG4gIHRyYXZlcnNlUHJvcHMoc2NoZW1hLCB2YWx1ZSwgKHNjaGVtYSwgdmFsdWUsIHBhdGgpID0+IHtcbiAgICBpZiAoc2NoZW1hLmtpbmQgPT09ICdhcnJheScgJiYgZG9lc1NjaGVtYU9ubHlFdmVyQ29udGFpbkFTaW5nbGVDaGlsZEZpZWxkKHNjaGVtYS5lbGVtZW50KSkge1xuICAgICAgcHJvcFBhdGhzLnB1c2goW3BhdGgsIHNjaGVtYV0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcm9wUGF0aHM7XG59XG5mdW5jdGlvbiBpc0VtcHR5Q2hpbGRGaWVsZE5vZGUoZWxlbWVudCkge1xuICBjb25zdCBmaXJzdENoaWxkID0gZWxlbWVudC5jaGlsZHJlblswXTtcbiAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIChlbGVtZW50LnR5cGUgPT09ICdjb21wb25lbnQtaW5saW5lLXByb3AnICYmIGZpcnN0Q2hpbGQudHlwZSA9PT0gdW5kZWZpbmVkICYmIGZpcnN0Q2hpbGQudGV4dCA9PT0gJycgfHwgZWxlbWVudC50eXBlID09PSAnY29tcG9uZW50LWJsb2NrLXByb3AnICYmIGZpcnN0Q2hpbGQudHlwZSA9PT0gJ3BhcmFncmFwaCcgJiYgZmlyc3RDaGlsZC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgZmlyc3RDaGlsZC5jaGlsZHJlblswXS50eXBlID09PSB1bmRlZmluZWQgJiYgZmlyc3RDaGlsZC5jaGlsZHJlblswXS50ZXh0ID09PSAnJyk7XG59XG5mdW5jdGlvbiB3aXRoQ29tcG9uZW50QmxvY2tzKGJsb2NrQ29tcG9uZW50cywgZWRpdG9yRG9jdW1lbnRGZWF0dXJlcywgZWRpdG9yKSB7XG4gIC8vIG5vdGUgdGhhdCBjb25mbGljdHMgYmV0d2VlbiB0aGUgZWRpdG9yIGRvY3VtZW50IGZlYXR1cmVzXG4gIC8vIGFuZCB0aGUgY2hpbGQgZmllbGQgZG9jdW1lbnQgZmVhdHVyZXMgYXJlIGRlYWx0IHdpdGggZWxzZXdoZXJlXG4gIGNvbnN0IG1lbW9pemVkR2V0RG9jdW1lbnRGZWF0dXJlc0ZvckNoaWxkRmllbGQgPSB3ZWFrTWVtb2l6ZShvcHRpb25zID0+IHtcbiAgICByZXR1cm4gZ2V0RG9jdW1lbnRGZWF0dXJlc0ZvckNoaWxkRmllbGQoZWRpdG9yRG9jdW1lbnRGZWF0dXJlcywgb3B0aW9ucyk7XG4gIH0pO1xuICBjb25zdCB7XG4gICAgbm9ybWFsaXplTm9kZSxcbiAgICBkZWxldGVCYWNrd2FyZCxcbiAgICBpbnNlcnRCcmVha1xuICB9ID0gZWRpdG9yO1xuICBlZGl0b3IuZGVsZXRlQmFja3dhcmQgPSB1bml0ID0+IHtcbiAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgY29uc3QgYW5jZXN0b3JDb21wb25lbnRCbG9jayA9IGdldEFuY2VzdG9yQ29tcG9uZW50QmxvY2soZWRpdG9yKTtcbiAgICAgIGlmIChhbmNlc3RvckNvbXBvbmVudEJsb2NrLmlzSW5zaWRlICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pICYmIEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5hbmNob3IsIGFuY2VzdG9yQ29tcG9uZW50QmxvY2sucHJvcFsxXSkgJiYgYW5jZXN0b3JDb21wb25lbnRCbG9jay5wcm9wWzFdW2FuY2VzdG9yQ29tcG9uZW50QmxvY2sucHJvcFsxXS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBhbmNlc3RvckNvbXBvbmVudEJsb2NrLmNvbXBvbmVudEJsb2NrWzFdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZUJhY2t3YXJkKHVuaXQpO1xuICB9O1xuICBlZGl0b3IuaW5zZXJ0QnJlYWsgPSAoKSA9PiB7XG4gICAgY29uc3QgYW5jZXN0b3JDb21wb25lbnRCbG9jayA9IGdldEFuY2VzdG9yQ29tcG9uZW50QmxvY2soZWRpdG9yKTtcbiAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbiAmJiBhbmNlc3RvckNvbXBvbmVudEJsb2NrLmlzSW5zaWRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHByb3A6IFtjb21wb25lbnRQcm9wTm9kZSwgY29tcG9uZW50UHJvcFBhdGhdLFxuICAgICAgICBjb21wb25lbnRCbG9jazogW2NvbXBvbmVudEJsb2NrTm9kZSwgY29tcG9uZW50QmxvY2tQYXRoXVxuICAgICAgfSA9IGFuY2VzdG9yQ29tcG9uZW50QmxvY2s7XG4gICAgICBjb25zdCBpc0xhc3RQcm9wID0gY29tcG9uZW50UHJvcFBhdGhbY29tcG9uZW50UHJvcFBhdGgubGVuZ3RoIC0gMV0gPT09IGNvbXBvbmVudEJsb2NrTm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgaWYgKGNvbXBvbmVudFByb3BOb2RlLnR5cGUgPT09ICdjb21wb25lbnQtYmxvY2stcHJvcCcpIHtcbiAgICAgICAgY29uc3QgW1twYXJhZ3JhcGhOb2RlLCBwYXJhZ3JhcGhQYXRoXV0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWF0Y2g6IG5vZGUgPT4gbm9kZS50eXBlID09PSAncGFyYWdyYXBoJ1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaXNMYXN0UGFyYWdyYXBoID0gcGFyYWdyYXBoUGF0aFtwYXJhZ3JhcGhQYXRoLmxlbmd0aCAtIDFdID09PSBjb21wb25lbnRQcm9wTm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoTm9kZS5zdHJpbmcocGFyYWdyYXBoTm9kZSkgPT09ICcnICYmIGlzTGFzdFBhcmFncmFwaCkge1xuICAgICAgICAgIGlmIChpc0xhc3RQcm9wKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHBhcmFncmFwaFBhdGgsXG4gICAgICAgICAgICAgIHRvOiBQYXRoLm5leHQoYW5jZXN0b3JDb21wb25lbnRCbG9jay5jb21wb25lbnRCbG9ja1sxXSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGRpc3RhbmNlOiAxLFxuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHBhcmFncmFwaFBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb21wb25lbnRQcm9wTm9kZS50eXBlID09PSAnY29tcG9uZW50LWlubGluZS1wcm9wJykge1xuICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbXBvbmVudEJsb2NrID0gYmxvY2tDb21wb25lbnRzW2NvbXBvbmVudEJsb2NrTm9kZS5jb21wb25lbnRdO1xuICAgICAgICAgIGlmIChjb21wb25lbnRQcm9wTm9kZS5wcm9wUGF0aCAhPT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudEJsb2NrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RTY2hlbWEgPSB7XG4gICAgICAgICAgICAgIGtpbmQ6ICdvYmplY3QnLFxuICAgICAgICAgICAgICBmaWVsZHM6IGNvbXBvbmVudEJsb2NrLnNjaGVtYVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9yRmllbGRzID0gZ2V0QW5jZXN0b3JTY2hlbWFzKHJvb3RTY2hlbWEsIGNvbXBvbmVudFByb3BOb2RlLnByb3BQYXRoLCBjb21wb25lbnRCbG9ja05vZGUucHJvcHMpO1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gWy4uLmFuY2VzdG9yRmllbGRzXS5yZXZlcnNlKCkuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS5raW5kID09PSAnYXJyYXknKTtcbiAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFycmF5RmllbGRJZHggPSBhbmNlc3RvckZpZWxkcy5sZW5ndGggLSAxIC0gaWR4O1xuICAgICAgICAgICAgICBjb25zdCBhcnJheUZpZWxkID0gYW5jZXN0b3JGaWVsZHNbYXJyYXlGaWVsZElkeF07XG4gICAgICAgICAgICAgIGFzc2VydChhcnJheUZpZWxkLmtpbmQgPT09ICdhcnJheScpO1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSBnZXRWYWx1ZUF0UHJvcFBhdGgoY29tcG9uZW50QmxvY2tOb2RlLnByb3BzLCBjb21wb25lbnRQcm9wTm9kZS5wcm9wUGF0aC5zbGljZSgwLCBhcnJheUZpZWxkSWR4KSk7XG4gICAgICAgICAgICAgIGlmIChkb2VzU2NoZW1hT25seUV2ZXJDb250YWluQVNpbmdsZUNoaWxkRmllbGQoYXJyYXlGaWVsZC5lbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGlmIChOb2RlLnN0cmluZyhjb21wb25lbnRQcm9wTm9kZSkgPT09ICcnICYmIHZhbC5sZW5ndGggLSAxID09PSBjb21wb25lbnRQcm9wTm9kZS5wcm9wUGF0aFthcnJheUZpZWxkSWR4XSkge1xuICAgICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgICAgYXQ6IGNvbXBvbmVudFByb3BQYXRoXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc0xhc3RQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICBhdDogUGF0aC5uZXh0KGNvbXBvbmVudEJsb2NrUGF0aClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgUGF0aC5uZXh0KGNvbXBvbmVudEJsb2NrUGF0aCkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiAxLFxuICAgICAgICAgICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0QnJlYWsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGFsd2F5czogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHNwbGl0Tm9kZVBhdGggPSBQYXRoLm5leHQoY29tcG9uZW50UHJvcFBhdGgpO1xuICAgICAgICAgIGlmIChpc0xhc3RQcm9wKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHNwbGl0Tm9kZVBhdGgsXG4gICAgICAgICAgICAgIHRvOiBQYXRoLm5leHQoY29tcG9uZW50QmxvY2tQYXRoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdmVDaGlsZHJlbihlZGl0b3IsIHNwbGl0Tm9kZVBhdGgsIFsuLi5QYXRoLm5leHQoc3BsaXROb2RlUGF0aCksIDBdKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBzcGxpdE5vZGVQYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGluc2VydEJyZWFrKCk7XG4gIH07XG4gIGVkaXRvci5ub3JtYWxpemVOb2RlID0gZW50cnkgPT4ge1xuICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuICAgIGlmIChub2RlLnR5cGUgPT09ICdjb21wb25lbnQtaW5saW5lLXByb3AnICYmICFub2RlLnByb3BQYXRoICYmIChub2RlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCAhVGV4dC5pc1RleHQobm9kZS5jaGlsZHJlblswXSkgfHwgbm9kZS5jaGlsZHJlblswXS50ZXh0ICE9PSAnJykpIHtcbiAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwYXRoXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2NvbXBvbmVudC1ibG9jaycpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudEJsb2NrID0gYmxvY2tDb21wb25lbnRzW25vZGUuY29tcG9uZW50XTtcbiAgICAgIGlmIChjb21wb25lbnRCbG9jaykge1xuICAgICAgICBjb25zdCByb290U2NoZW1hID0ge1xuICAgICAgICAgIGtpbmQ6ICdvYmplY3QnLFxuICAgICAgICAgIGZpZWxkczogY29tcG9uZW50QmxvY2suc2NoZW1hXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9wcyA9IGFkZE1pc3NpbmdGaWVsZHMobm9kZS5wcm9wcywgcm9vdFNjaGVtYSk7XG4gICAgICAgIGlmICh1cGRhdGVkUHJvcHMgIT09IG5vZGUucHJvcHMpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgcHJvcHM6IHVwZGF0ZWRQcm9wc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3Byb3BQYXRoLCBhcnJheUZpZWxkXSBvZiBmaW5kQXJyYXlGaWVsZHNXaXRoU2luZ2xlQ2hpbGRGaWVsZChyb290U2NoZW1hLCBub2RlLnByb3BzKSkge1xuICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09ICdjb21wb25lbnQtaW5saW5lLXByb3AnICYmIG5vZGUuY2hpbGRyZW5bMF0ucHJvcFBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5vZGVzV2l0aGluID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCBbaWR4LCBjaGlsZE5vZGVdIG9mIG5vZGUuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoKGNoaWxkTm9kZS50eXBlID09PSAnY29tcG9uZW50LWJsb2NrLXByb3AnIHx8IGNoaWxkTm9kZS50eXBlID09PSAnY29tcG9uZW50LWlubGluZS1wcm9wJykgJiYgY2hpbGROb2RlLnByb3BQYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3ViUGF0aCA9IGNoaWxkTm9kZS5wcm9wUGF0aC5jb25jYXQoKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHN1YlBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWJQYXRoLnBvcCgpID09PSAnbnVtYmVyJykgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGFyZUFycmF5c0VxdWFsKHByb3BQYXRoLCBzdWJQYXRoKSkge1xuICAgICAgICAgICAgICAgIG5vZGVzV2l0aGluLnB1c2goW2lkeCwgY2hpbGROb2RlXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYXJyVmFsID0gZ2V0VmFsdWVBdFByb3BQYXRoKG5vZGUucHJvcHMsIHByb3BQYXRoKTtcbiAgICAgICAgICBjb25zdCBwcmV2S2V5cyA9IGdldEtleXNGb3JBcnJheVZhbHVlKGFyclZhbCk7XG4gICAgICAgICAgY29uc3QgcHJldktleXNTZXQgPSBuZXcgU2V0KHByZXZLZXlzKTtcbiAgICAgICAgICBjb25zdCBhbHJlYWR5VXNlZEluZGljaWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGNvbnN0IG5ld1ZhbCA9IFtdO1xuICAgICAgICAgIGNvbnN0IG5ld0tleXMgPSBbXTtcbiAgICAgICAgICBjb25zdCBnZXROZXdLZXkgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQga2V5ID0gZ2V0TmV3QXJyYXlFbGVtZW50S2V5KCk7XG4gICAgICAgICAgICB3aGlsZSAocHJldktleXNTZXQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAga2V5ID0gZ2V0TmV3QXJyYXlFbGVtZW50S2V5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgIH07XG4gICAgICAgICAgZm9yIChjb25zdCBbLCBub2RlXSBvZiBub2Rlc1dpdGhpbikge1xuICAgICAgICAgICAgY29uc3QgaWR4RnJvbVZhbHVlID0gbm9kZS5wcm9wUGF0aFtwcm9wUGF0aC5sZW5ndGhdO1xuICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiBpZHhGcm9tVmFsdWUgPT09ICdudW1iZXInKTtcbiAgICAgICAgICAgIGlmIChhcnJWYWwubGVuZ3RoIDw9IGlkeEZyb21WYWx1ZSB8fCBhbHJlYWR5VXNlZEluZGljaWVzLmhhcyhpZHhGcm9tVmFsdWUpICYmIGlzRW1wdHlDaGlsZEZpZWxkTm9kZShub2RlKSkge1xuICAgICAgICAgICAgICBuZXdWYWwucHVzaChnZXRJbml0aWFsUHJvcHNWYWx1ZShhcnJheUZpZWxkLmVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgbmV3S2V5cy5wdXNoKGdldE5ld0tleSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFscmVhZHlVc2VkSW5kaWNpZXMuYWRkKGlkeEZyb21WYWx1ZSk7XG4gICAgICAgICAgICAgIG5ld1ZhbC5wdXNoKGFyclZhbFtpZHhGcm9tVmFsdWVdKTtcbiAgICAgICAgICAgICAgbmV3S2V5cy5wdXNoKGFscmVhZHlVc2VkSW5kaWNpZXMuaGFzKGlkeEZyb21WYWx1ZSkgPyBnZXROZXdLZXkoKSA6IHByZXZLZXlzW2lkeEZyb21WYWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRLZXlzRm9yQXJyYXlWYWx1ZShuZXdWYWwsIG5ld0tleXMpO1xuICAgICAgICAgIGlmICghYXJlQXJyYXlzRXF1YWwoYXJyVmFsLCBuZXdWYWwpKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFByb3BzID0gcmVwbGFjZVZhbHVlQXRQcm9wUGF0aChyb290U2NoZW1hLCBub2RlLnByb3BzLCBuZXdWYWwsIHByb3BQYXRoKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHByb3BzOiB0cmFuc2Zvcm1lZFByb3BzXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2lkeCwgW2lkeEluQ2hpbGRyZW5PZkJsb2NrLCBub2RlV2l0aGluXV0gb2Ygbm9kZXNXaXRoaW4uZW50cmllcygpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BQYXRoID0gWy4uLm5vZGVXaXRoaW4ucHJvcFBhdGhdO1xuICAgICAgICAgICAgICBuZXdQcm9wUGF0aFtwcm9wUGF0aC5sZW5ndGhdID0gaWR4O1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIHByb3BQYXRoOiBuZXdQcm9wUGF0aFxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgYXQ6IFsuLi5wYXRoLCBpZHhJbkNoaWxkcmVuT2ZCbG9ja11cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pc3NpbmdLZXlzID0gbmV3IE1hcChmaW5kQ2hpbGRQcm9wUGF0aHMobm9kZS5wcm9wcywgY29tcG9uZW50QmxvY2suc2NoZW1hKS5tYXAoeCA9PiBbSlNPTi5zdHJpbmdpZnkoeC5wYXRoKSwgeC5vcHRpb25zLmtpbmRdKSk7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICBhc3NlcnQobm9kZS50eXBlID09PSAnY29tcG9uZW50LWJsb2NrLXByb3AnIHx8IG5vZGUudHlwZSA9PT0gJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCcpO1xuICAgICAgICAgIG1pc3NpbmdLZXlzLmRlbGV0ZShKU09OLnN0cmluZ2lmeShub2RlLnByb3BQYXRoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWlzc2luZ0tleXMuc2l6ZSkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBbLi4ubWlzc2luZ0tleXNdLm1hcCgoW3Byb3AsIGtpbmRdKSA9PiAoe1xuICAgICAgICAgICAgdHlwZTogYGNvbXBvbmVudC0ke2tpbmR9LXByb3BgLFxuICAgICAgICAgICAgcHJvcFBhdGg6IHByb3AgPyBKU09OLnBhcnNlKHByb3ApIDogcHJvcCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9KSksIHtcbiAgICAgICAgICAgIGF0OiBbLi4ucGF0aCwgbm9kZS5jaGlsZHJlbi5sZW5ndGhdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvdW5kUHJvcHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkSW5saW5lUHJvcFBhdGhzID0ge307XG4gICAgICAgIGZpbmRDaGlsZFByb3BQYXRocyhub2RlLnByb3BzLCBibG9ja0NvbXBvbmVudHNbbm9kZS5jb21wb25lbnRdLnNjaGVtYSkuZm9yRWFjaCgoeCwgaW5kZXgpID0+IHtcbiAgICAgICAgICBzdHJpbmdpZmllZElubGluZVByb3BQYXRoc1tKU09OLnN0cmluZ2lmeSh4LnBhdGgpXSA9IHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHgub3B0aW9ucyxcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBjaGlsZE5vZGVdIG9mIG5vZGUuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIGNoaWxkcmVuIHRoYXQgYXJlIG5vdCB0aGVzZSB3aWxsIGJlIGhhbmRsZWQgYnlcbiAgICAgICAgICAvLyB0aGUgZ2VuZXJpYyBhbGxvd2VkQ2hpbGRyZW4gbm9ybWFsaXphdGlvblxuICAgICAgICAgIGNoaWxkTm9kZS50eXBlICE9PSAnY29tcG9uZW50LWlubGluZS1wcm9wJyAmJiBjaGlsZE5vZGUudHlwZSAhPT0gJ2NvbXBvbmVudC1ibG9jay1wcm9wJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IFsuLi5wYXRoLCBpbmRleF07XG4gICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRQcm9wUGF0aCA9IEpTT04uc3RyaW5naWZ5KGNoaWxkTm9kZS5wcm9wUGF0aCk7XG4gICAgICAgICAgaWYgKHN0cmluZ2lmaWVkSW5saW5lUHJvcFBhdGhzW3N0cmluZ2lmaWVkUHJvcFBhdGhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm91bmRQcm9wcy5oYXMoc3RyaW5naWZpZWRQcm9wUGF0aCkpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3VuZFByb3BzLmFkZChzdHJpbmdpZmllZFByb3BQYXRoKTtcbiAgICAgICAgICBjb25zdCBwcm9wSW5mbyA9IHN0cmluZ2lmaWVkSW5saW5lUHJvcFBhdGhzW3N0cmluZ2lmaWVkUHJvcFBhdGhdO1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkSW5kZXggPSBwcm9wSW5mby5pbmRleDtcbiAgICAgICAgICBpZiAoaW5kZXggIT09IGV4cGVjdGVkSW5kZXgpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogY2hpbGRQYXRoLFxuICAgICAgICAgICAgICB0bzogWy4uLnBhdGgsIGV4cGVjdGVkSW5kZXhdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRDaGlsZE5vZGVUeXBlID0gYGNvbXBvbmVudC0ke3Byb3BJbmZvLm9wdGlvbnMua2luZH0tcHJvcGA7XG4gICAgICAgICAgaWYgKGNoaWxkTm9kZS50eXBlICE9PSBleHBlY3RlZENoaWxkTm9kZVR5cGUpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHR5cGU6IGV4cGVjdGVkQ2hpbGROb2RlVHlwZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZG9jdW1lbnRGZWF0dXJlcyA9IG1lbW9pemVkR2V0RG9jdW1lbnRGZWF0dXJlc0ZvckNoaWxkRmllbGQocHJvcEluZm8ub3B0aW9ucyk7XG4gICAgICAgICAgaWYgKG5vcm1hbGl6ZU5vZGVXaXRoaW5Db21wb25lbnRQcm9wKFtjaGlsZE5vZGUsIGNoaWxkUGF0aF0sIGVkaXRvciwgZG9jdW1lbnRGZWF0dXJlcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59XG5cbi8vIHRoZSBvbmx5IHRoaW5nIHRoYXQgdGhpcyB3aWxsIGZpeCBpcyBhIG5ldyBmaWVsZCBiZWluZyBhZGRlZCB0byBhbiBvYmplY3QgZmllbGQsIG5vdGhpbmcgZWxzZS5cbmZ1bmN0aW9uIGFkZE1pc3NpbmdGaWVsZHModmFsdWUsIHNjaGVtYSkge1xuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdjaGlsZCcgfHwgc2NoZW1hLmtpbmQgPT09ICdmb3JtJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdjb25kaXRpb25hbCcpIHtcbiAgICBjb25zdCBjb25kaXRpb25hbFZhbHVlID0gdmFsdWU7XG4gICAgY29uc3QgdXBkYXRlZElubmVyVmFsdWUgPSBhZGRNaXNzaW5nRmllbGRzKGNvbmRpdGlvbmFsVmFsdWUudmFsdWUsIHNjaGVtYS52YWx1ZXNbY29uZGl0aW9uYWxWYWx1ZS5kaXNjcmltaW5hbnQudG9TdHJpbmcoKV0pO1xuICAgIGlmICh1cGRhdGVkSW5uZXJWYWx1ZSA9PT0gY29uZGl0aW9uYWxWYWx1ZS52YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGlzY3JpbWluYW50OiBjb25kaXRpb25hbFZhbHVlLmRpc2NyaW1pbmFudCxcbiAgICAgIHZhbHVlOiB1cGRhdGVkSW5uZXJWYWx1ZVxuICAgIH07XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnYXJyYXknKSB7XG4gICAgY29uc3QgYXJyVmFsdWUgPSB2YWx1ZTtcbiAgICBjb25zdCBuZXdBcnJWYWx1ZSA9IGFyclZhbHVlLm1hcCh4ID0+IGFkZE1pc3NpbmdGaWVsZHMoeCwgc2NoZW1hLmVsZW1lbnQpKTtcbiAgICBpZiAoYXJlQXJyYXlzRXF1YWwoYXJyVmFsdWUsIG5ld0FyclZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyVmFsdWU7XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IG9iamVjdFZhbHVlID0gdmFsdWU7XG4gICAgbGV0IGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBjb25zdCBuZXdPYmplY3RWYWx1ZSA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgaW5uZXJTY2hlbWFdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5maWVsZHMpKSB7XG4gICAgICBjb25zdCBpbm5lclZhbHVlID0gb2JqZWN0VmFsdWVba2V5XTtcbiAgICAgIGlmIChpbm5lclZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIG5ld09iamVjdFZhbHVlW2tleV0gPSBnZXRJbml0aWFsUHJvcHNWYWx1ZShpbm5lclNjaGVtYSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3SW5uZXJWYWx1ZSA9IGFkZE1pc3NpbmdGaWVsZHMoaW5uZXJWYWx1ZSwgaW5uZXJTY2hlbWEpO1xuICAgICAgaWYgKG5ld0lubmVyVmFsdWUgIT09IGlubmVyVmFsdWUpIHtcbiAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBuZXdPYmplY3RWYWx1ZVtrZXldID0gbmV3SW5uZXJWYWx1ZTtcbiAgICB9XG4gICAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICAgIHJldHVybiBuZXdPYmplY3RWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGFzc2VydE5ldmVyKHNjaGVtYSk7XG59XG5cbmNvbnN0IHBhcmFncmFwaEVsZW1lbnQgPSAoKSA9PiAoe1xuICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgY2hpbGRyZW46IFt7XG4gICAgdGV4dDogJydcbiAgfV1cbn0pO1xuZnVuY3Rpb24gd2l0aFBhcmFncmFwaHMoZWRpdG9yKSB7XG4gIGNvbnN0IHtcbiAgICBub3JtYWxpemVOb2RlXG4gIH0gPSBlZGl0b3I7XG4gIGVkaXRvci5ub3JtYWxpemVOb2RlID0gZW50cnkgPT4ge1xuICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuICAgIGlmIChFZGl0b3IuaXNFZGl0b3Iobm9kZSkpIHtcbiAgICAgIGxldCBsYXN0Tm9kZSA9IG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIGlmICgobGFzdE5vZGUgPT09IG51bGwgfHwgbGFzdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3ROb2RlLnR5cGUpICE9PSAncGFyYWdyYXBoJykge1xuICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgcGFyYWdyYXBoRWxlbWVudCgpLCB7XG4gICAgICAgICAgYXQ6IFsuLi5wYXRoLCBub2RlLmNoaWxkcmVuLmxlbmd0aF1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59XG5cbmZ1bmN0aW9uIHdpdGhMYXlvdXRzKGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgbm9ybWFsaXplTm9kZSxcbiAgICBkZWxldGVCYWNrd2FyZFxuICB9ID0gZWRpdG9yO1xuICBlZGl0b3IuZGVsZXRlQmFja3dhcmQgPSB1bml0ID0+IHtcbiAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSAmJlxuICAgIC8vIHRoaXMgaXMganVzdCBhbiBsaXR0bGUgb3B0aW1pc2F0aW9uXG4gICAgLy8gd2UncmUgb25seSBkb2luZyB0aGluZ3MgaWYgd2UncmUgYXQgdGhlIHN0YXJ0IG9mIGEgbGF5b3V0IGFyZWFcbiAgICAvLyBhbmQgdGhlIHN0YXJ0IG9mIGFueXRoaW5nIHdpbGwgYWx3YXlzIGJlIG9mZnNldCAwXG4gICAgLy8gc28gd2UnbGwgYmFpbG91dCBpZiB3ZSdyZSBub3QgYXQgb2Zmc2V0IDBcbiAgICBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAgIGNvbnN0IFthYm92ZU5vZGUsIGFib3ZlUGF0aF0gPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBub2RlID0+IG5vZGUudHlwZSA9PT0gJ2xheW91dC1hcmVhJ1xuICAgICAgfSkgfHwgW2VkaXRvciwgW11dO1xuICAgICAgaWYgKGFib3ZlTm9kZS50eXBlID09PSAnbGF5b3V0LWFyZWEnICYmIFBvaW50LmVxdWFscyhFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhYm92ZVBhdGgpLCBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWxldGVCYWNrd2FyZCh1bml0KTtcbiAgfTtcbiAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSBlbnRyeSA9PiB7XG4gICAgY29uc3QgW25vZGUsIHBhdGhdID0gZW50cnk7XG4gICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS50eXBlID09PSAnbGF5b3V0Jykge1xuICAgICAgaWYgKG5vZGUubGF5b3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoIDwgbm9kZS5sYXlvdXQubGVuZ3RoKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBBcnJheS5mcm9tKHtcbiAgICAgICAgICBsZW5ndGg6IG5vZGUubGF5b3V0Lmxlbmd0aCAtIG5vZGUuY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgIH0pLm1hcCgoKSA9PiAoe1xuICAgICAgICAgIHR5cGU6ICdsYXlvdXQtYXJlYScsXG4gICAgICAgICAgY2hpbGRyZW46IFtwYXJhZ3JhcGhFbGVtZW50KCldXG4gICAgICAgIH0pKSwge1xuICAgICAgICAgIGF0OiBbLi4ucGF0aCwgbm9kZS5jaGlsZHJlbi5sZW5ndGhdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPiBub2RlLmxheW91dC5sZW5ndGgpIHtcbiAgICAgICAgQXJyYXkuZnJvbSh7XG4gICAgICAgICAgbGVuZ3RoOiBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIG5vZGUubGF5b3V0Lmxlbmd0aFxuICAgICAgICB9KS5tYXAoKF8sIGkpID0+IGkpLnJldmVyc2UoKS5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgIGNvbnN0IGxheW91dEFyZWFUb1JlbW92ZVBhdGggPSBbLi4ucGF0aCwgaSArIG5vZGUubGF5b3V0Lmxlbmd0aF07XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2kgKyBub2RlLmxheW91dC5sZW5ndGhdO1xuICAgICAgICAgIG1vdmVDaGlsZHJlbihlZGl0b3IsIGxheW91dEFyZWFUb1JlbW92ZVBhdGgsIFsuLi5wYXRoLCBub2RlLmxheW91dC5sZW5ndGggLSAxLCBub2RlLmNoaWxkcmVuW25vZGUubGF5b3V0Lmxlbmd0aCAtIDFdLmNoaWxkcmVuLmxlbmd0aF0sIG5vZGUgPT4gbm9kZS50eXBlICE9PSAncGFyYWdyYXBoJyB8fCBOb2RlLnN0cmluZyhjaGlsZCkgIT09ICcnKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGxheW91dEFyZWFUb1JlbW92ZVBhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59XG5cbmNvbnN0IG1hcmtkb3duTGlua1BhdHRlcm4gPSAvKF58XFxzKVxcWyguKz8pXFxdXFwoKFxcUyspXFwpJC87XG5mdW5jdGlvbiB3aXRoTGluayhlZGl0b3JEb2N1bWVudEZlYXR1cmVzLCBjb21wb25lbnRCbG9ja3MsIGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgaW5zZXJ0VGV4dCxcbiAgICBpc0lubGluZSxcbiAgICBub3JtYWxpemVOb2RlXG4gIH0gPSBlZGl0b3I7XG4gIGVkaXRvci5pc0lubGluZSA9IGVsZW1lbnQgPT4ge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGUgPT09ICdsaW5rJyA/IHRydWUgOiBpc0lubGluZShlbGVtZW50KTtcbiAgfTtcbiAgaWYgKGVkaXRvckRvY3VtZW50RmVhdHVyZXMubGlua3MpIHtcbiAgICBlZGl0b3IuaW5zZXJ0VGV4dCA9IHRleHQgPT4ge1xuICAgICAgaW5zZXJ0VGV4dCh0ZXh0KTtcbiAgICAgIGlmICh0ZXh0ICE9PSAnKScgfHwgIWVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRPZkJsb2NrID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogaXNCbG9ja1xuICAgICAgfSlbMV0pO1xuICAgICAgY29uc3Qgc3RhcnRPZkJsb2NrVG9FbmRPZlNob3J0Y3V0U3RyaW5nID0gRWRpdG9yLnN0cmluZyhlZGl0b3IsIHtcbiAgICAgICAgYW5jaG9yOiBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvcixcbiAgICAgICAgZm9jdXM6IHN0YXJ0T2ZCbG9ja1xuICAgICAgfSk7XG4gICAgICBjb25zdCBtYXRjaCA9IG1hcmtkb3duTGlua1BhdHRlcm4uZXhlYyhzdGFydE9mQmxvY2tUb0VuZE9mU2hvcnRjdXRTdHJpbmcpO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhbmNlc3RvckNvbXBvbmVudENoaWxkRmllbGREb2N1bWVudEZlYXR1cmVzID0gZ2V0QW5jZXN0b3JDb21wb25lbnRDaGlsZEZpZWxkRG9jdW1lbnRGZWF0dXJlcyhlZGl0b3IsIGVkaXRvckRvY3VtZW50RmVhdHVyZXMsIGNvbXBvbmVudEJsb2Nrcyk7XG4gICAgICBpZiAoKGFuY2VzdG9yQ29tcG9uZW50Q2hpbGRGaWVsZERvY3VtZW50RmVhdHVyZXMgPT09IG51bGwgfHwgYW5jZXN0b3JDb21wb25lbnRDaGlsZEZpZWxkRG9jdW1lbnRGZWF0dXJlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5jZXN0b3JDb21wb25lbnRDaGlsZEZpZWxkRG9jdW1lbnRGZWF0dXJlcy5kb2N1bWVudEZlYXR1cmVzLmxpbmtzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgWywgbWF5YmVXaGl0ZXNwYWNlLCBsaW5rVGV4dCwgaHJlZl0gPSBtYXRjaDtcbiAgICAgIC8vIGJ5IGRvaW5nIHRoaXMsIHRoZSBpbnNlcnRUZXh0KCcpJykgYWJvdmUgd2lsbCBoYXBwZW4gaW4gYSBkaWZmZXJlbnQgdW5kbyB0aGFuIHRoZSBsaW5rIHJlcGxhY2VtZW50XG4gICAgICAvLyBzbyB0aGF0IG1lYW5zIHRoYXQgd2hlbiBzb21lb25lIGRvZXMgYW4gdW5kbyBhZnRlciB0aGlzXG4gICAgICAvLyBpdCB3aWxsIHVuZG8gdG8gdGhlIHN0YXRlIG9mIFwiW2NvbnRlbnRdKGxpbmspXCIgcmF0aGVyIHRoYW4gXCJbY29udGVudF0obGlua1wiIChub3RlIHRoZSBtaXNzaW5nIGNsb3NpbmcgYnJhY2tldClcbiAgICAgIGVkaXRvci5oaXN0b3J5LnVuZG9zLnB1c2goe1xuICAgICAgICBvcGVyYXRpb25zOiBbXSxcbiAgICAgICAgc2VsZWN0aW9uQmVmb3JlOiBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHN0YXJ0T2ZTaG9ydGN1dCA9IG1hdGNoLmluZGV4ID09PSAwID8gc3RhcnRPZkJsb2NrIDogRWRpdG9yQWZ0ZXJCdXRJZ25vcmluZ2luZ1BvaW50c1dpdGhOb0NvbnRlbnQoZWRpdG9yLCBzdGFydE9mQmxvY2ssIHtcbiAgICAgICAgZGlzdGFuY2U6IG1hdGNoLmluZGV4XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHN0YXJ0T2ZMaW5rVGV4dCA9IEVkaXRvckFmdGVyQnV0SWdub3JpbmdpbmdQb2ludHNXaXRoTm9Db250ZW50KGVkaXRvciwgc3RhcnRPZlNob3J0Y3V0LCB7XG4gICAgICAgIGRpc3RhbmNlOiBtYXliZVdoaXRlc3BhY2UgPT09ICcnID8gMSA6IDJcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZW5kT2ZMaW5rVGV4dCA9IEVkaXRvckFmdGVyQnV0SWdub3JpbmdpbmdQb2ludHNXaXRoTm9Db250ZW50KGVkaXRvciwgc3RhcnRPZkxpbmtUZXh0LCB7XG4gICAgICAgIGRpc3RhbmNlOiBsaW5rVGV4dC5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgIGF0OiB7XG4gICAgICAgICAgYW5jaG9yOiBlbmRPZkxpbmtUZXh0LFxuICAgICAgICAgIGZvY3VzOiBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvclxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICBhdDoge1xuICAgICAgICAgIGFuY2hvcjogc3RhcnRPZlNob3J0Y3V0LFxuICAgICAgICAgIGZvY3VzOiBzdGFydE9mTGlua1RleHRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBUcmFuc2Zvcm1zLndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICBocmVmLFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgIH0sIHtcbiAgICAgICAgYXQ6IHtcbiAgICAgICAgICBhbmNob3I6IGVkaXRvci5zZWxlY3Rpb24uYW5jaG9yLFxuICAgICAgICAgIGZvY3VzOiBzdGFydE9mU2hvcnRjdXRcbiAgICAgICAgfSxcbiAgICAgICAgc3BsaXQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmV4dE5vZGUgPSBFZGl0b3IubmV4dChlZGl0b3IpO1xuICAgICAgaWYgKG5leHROb2RlKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgbmV4dE5vZGVbMV0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSAoW25vZGUsIHBhdGhdKSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgICBpZiAoTm9kZS5zdHJpbmcobm9kZSkgPT09ICcnKSB7XG4gICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW2lkeCwgY2hpbGRdIG9mIG5vZGUuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnbGluaycpIHtcbiAgICAgICAgICAvLyBsaW5rcyBjYW5ub3QgY29udGFpbiBsaW5rc1xuICAgICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogWy4uLnBhdGgsIGlkeF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSW5saW5lQ29udGFpbmVyKG5vZGUpKSB7XG4gICAgICBsZXQgbGFzdE1lcmdhYmxlTGluayA9IG51bGw7XG4gICAgICBmb3IgKGNvbnN0IFtpZHgsIGNoaWxkXSBvZiBub2RlLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgICB2YXIgX2xhc3RNZXJnYWJsZUxpbms7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnbGluaycgJiYgY2hpbGQuaHJlZiA9PT0gKChfbGFzdE1lcmdhYmxlTGluayA9IGxhc3RNZXJnYWJsZUxpbmspID09PSBudWxsIHx8IF9sYXN0TWVyZ2FibGVMaW5rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGFzdE1lcmdhYmxlTGluay5ub2RlLmhyZWYpKSB7XG4gICAgICAgICAgY29uc3QgZmlyc3RMaW5rUGF0aCA9IFsuLi5wYXRoLCBsYXN0TWVyZ2FibGVMaW5rLmluZGV4XTtcbiAgICAgICAgICBjb25zdCBzZWNvbmRMaW5rUGF0aCA9IFsuLi5wYXRoLCBpZHhdO1xuICAgICAgICAgIGNvbnN0IHRvID0gWy4uLmZpcnN0TGlua1BhdGgsIGxhc3RNZXJnYWJsZUxpbmsubm9kZS5jaGlsZHJlbi5sZW5ndGhdO1xuICAgICAgICAgIC8vIG5vdGUgdGhpcyBpcyBnb2luZyBpbiByZXZlcnNlLCBqcyBkb2Vzbid0IGhhdmUgZG91YmxlLWVuZGVkIGl0ZXJhdG9ycyBzbyBpdCdzIGEgZm9yKDs7KVxuICAgICAgICAgIGZvciAobGV0IGkgPSBjaGlsZC5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gWy4uLnNlY29uZExpbmtQYXRoLCBpXTtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogY2hpbGRQYXRoLFxuICAgICAgICAgICAgICB0b1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogc2Vjb25kTGlua1BhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFUZXh0LmlzVGV4dChjaGlsZCkgfHwgY2hpbGQudGV4dCAhPT0gJycpIHtcbiAgICAgICAgICBsYXN0TWVyZ2FibGVMaW5rID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgICAgICAgbGFzdE1lcmdhYmxlTGluayA9IHtcbiAgICAgICAgICAgIGluZGV4OiBpZHgsXG4gICAgICAgICAgICBub2RlOiBjaGlsZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbm9ybWFsaXplTm9kZShbbm9kZSwgcGF0aF0pO1xuICB9O1xuICByZXR1cm4gZWRpdG9yO1xufVxuXG5jb25zdCBpc0xpc3RUeXBlID0gdHlwZSA9PiB0eXBlID09PSAnb3JkZXJlZC1saXN0JyB8fCB0eXBlID09PSAndW5vcmRlcmVkLWxpc3QnO1xuY29uc3QgaXNMaXN0Tm9kZSA9IG5vZGUgPT4gaXNMaXN0VHlwZShub2RlLnR5cGUpO1xuZnVuY3Rpb24gZ2V0QW5jZXN0b3JMaXN0KGVkaXRvcikge1xuICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgIGNvbnN0IGxpc3RJdGVtID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IG5vZGVUeXBlTWF0Y2hlcignbGlzdC1pdGVtJylcbiAgICB9KTtcbiAgICBjb25zdCBsaXN0ID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IGlzTGlzdE5vZGVcbiAgICB9KTtcbiAgICBpZiAobGlzdEl0ZW0gJiYgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNJbnNpZGU6IHRydWUsXG4gICAgICAgIGxpc3RJdGVtLFxuICAgICAgICBsaXN0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGlzSW5zaWRlOiBmYWxzZVxuICB9O1xufVxuZnVuY3Rpb24gd2l0aExpc3QoZWRpdG9yKSB7XG4gIGNvbnN0IHtcbiAgICBpbnNlcnRCcmVhayxcbiAgICBub3JtYWxpemVOb2RlLFxuICAgIGRlbGV0ZUJhY2t3YXJkXG4gIH0gPSBlZGl0b3I7XG4gIGVkaXRvci5kZWxldGVCYWNrd2FyZCA9IHVuaXQgPT4ge1xuICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICBjb25zdCBhbmNlc3Rvckxpc3QgPSBnZXRBbmNlc3Rvckxpc3QoZWRpdG9yKTtcbiAgICAgIGlmIChhbmNlc3Rvckxpc3QuaXNJbnNpZGUgJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbikgJiYgRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvciwgYW5jZXN0b3JMaXN0Lmxpc3RbMV0pKSB7XG4gICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWF0Y2g6IGlzTGlzdE5vZGUsXG4gICAgICAgICAgc3BsaXQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlQmFja3dhcmQodW5pdCk7XG4gIH07XG4gIGVkaXRvci5pbnNlcnRCcmVhayA9ICgpID0+IHtcbiAgICBjb25zdCBbbGlzdEl0ZW1dID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IG5vZGUgPT4gbm9kZS50eXBlID09PSAnbGlzdC1pdGVtJyxcbiAgICAgIG1vZGU6ICdsb3dlc3QnXG4gICAgfSk7XG4gICAgaWYgKGxpc3RJdGVtICYmIE5vZGUuc3RyaW5nKGxpc3RJdGVtWzBdKSA9PT0gJycpIHtcbiAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBpc0xpc3ROb2RlLFxuICAgICAgICBzcGxpdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGluc2VydEJyZWFrKCk7XG4gIH07XG4gIGVkaXRvci5ub3JtYWxpemVOb2RlID0gZW50cnkgPT4ge1xuICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuICAgIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpIHx8IEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgICAgY29uc3QgaXNFbGVtZW50QmVpbmdOb3JtYWxpemVkQUxpc3QgPSBpc0xpc3ROb2RlKG5vZGUpO1xuICAgICAgZm9yIChjb25zdCBbY2hpbGROb2RlLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBwYXRoKSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGNoaWxkUGF0aFtjaGlsZFBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIG1lcmdlIHNpYmxpbmcgbGlzdHNcbiAgICAgICAgaWYgKGlzTGlzdE5vZGUoY2hpbGROb2RlKSkge1xuICAgICAgICAgIHZhciBfbm9kZSRjaGlsZHJlbjtcbiAgICAgICAgICBpZiAoKChfbm9kZSRjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW5bY2hpbGRQYXRoW2NoaWxkUGF0aC5sZW5ndGggLSAxXSArIDFdKSA9PT0gbnVsbCB8fCBfbm9kZSRjaGlsZHJlbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkY2hpbGRyZW4udHlwZSkgPT09IGNoaWxkTm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nTm9kZVBhdGggPSBQYXRoLm5leHQoY2hpbGRQYXRoKTtcbiAgICAgICAgICAgIG1vdmVDaGlsZHJlbihlZGl0b3IsIHNpYmxpbmdOb2RlUGF0aCwgWy4uLmNoaWxkUGF0aCwgY2hpbGROb2RlLmNoaWxkcmVuLmxlbmd0aF0pO1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHNpYmxpbmdOb2RlUGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0VsZW1lbnRCZWluZ05vcm1hbGl6ZWRBTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNDaGlsZCA9IG5vZGUuY2hpbGRyZW5baW5kZXggLSAxXTtcbiAgICAgICAgICAgIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KHByZXZpb3VzQ2hpbGQpKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGgsXG4gICAgICAgICAgICAgICAgdG86IFsuLi5QYXRoLnByZXZpb3VzKGNoaWxkUGF0aCksIHByZXZpb3VzQ2hpbGQuY2hpbGRyZW4ubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdsaXN0LWl0ZW0nICYmIGNoaWxkTm9kZS50eXBlICE9PSAnbGlzdC1pdGVtLWNvbnRlbnQnICYmIGluZGV4ID09PSAwICYmIGlzQmxvY2soY2hpbGROb2RlKSkge1xuICAgICAgICAgIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzQ2hpbGQgPSBOb2RlLmdldChlZGl0b3IsIFBhdGgucHJldmlvdXMocGF0aCkpO1xuICAgICAgICAgICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQocHJldmlvdXNDaGlsZCkpIHtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgICAgICAgdG86IFsuLi5QYXRoLnByZXZpb3VzKHBhdGgpLCBwcmV2aW91c0NoaWxkLmNoaWxkcmVuLmxlbmd0aF1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2xpc3QtaXRlbScgJiYgY2hpbGROb2RlLnR5cGUgPT09ICdsaXN0LWl0ZW0tY29udGVudCcgJiYgaW5kZXggIT09IDApIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5vcm1hbGl6ZU5vZGUoZW50cnkpO1xuICB9O1xuICByZXR1cm4gZWRpdG9yO1xufVxuXG5mdW5jdGlvbiBvcmRlcihhLCBiKSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IE1hdGgubWluKGEsIGIpLFxuICAgIGVuZDogTWF0aC5tYXgoYSwgYilcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJlbGF0aXZlUm93UGF0aChoYXNIZWFkLCByb3dJbmRleCkge1xuICByZXR1cm4gaGFzSGVhZCA/IHJvd0luZGV4ID09PSAwID8gWzAsIDBdIDogWzEsIHJvd0luZGV4IC0gMV0gOiBbMCwgcm93SW5kZXhdO1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0ZWRUYWJsZUFyZWEoZWRpdG9yKSB7XG4gIHZhciBfRWRpdG9yJGFib3ZlLCBfZWRpdG9yJHNlbGVjdGlvbiwgX0VkaXRvciRhYm92ZTIsIF9lZGl0b3Ikc2VsZWN0aW9uMjtcbiAgY29uc3QgYW5jaG9yID0gKF9FZGl0b3IkYWJvdmUgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgbWF0Y2g6IG5vZGVUeXBlTWF0Y2hlcigndGFibGUtY2VsbCcpLFxuICAgIGF0OiAoX2VkaXRvciRzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uKSA9PT0gbnVsbCB8fCBfZWRpdG9yJHNlbGVjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VkaXRvciRzZWxlY3Rpb24uYW5jaG9yLnBhdGhcbiAgfSkpID09PSBudWxsIHx8IF9FZGl0b3IkYWJvdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9FZGl0b3IkYWJvdmVbMV07XG4gIGNvbnN0IGZvY3VzID0gKF9FZGl0b3IkYWJvdmUyID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgIG1hdGNoOiBub2RlVHlwZU1hdGNoZXIoJ3RhYmxlLWNlbGwnKSxcbiAgICBhdDogKF9lZGl0b3Ikc2VsZWN0aW9uMiA9IGVkaXRvci5zZWxlY3Rpb24pID09PSBudWxsIHx8IF9lZGl0b3Ikc2VsZWN0aW9uMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VkaXRvciRzZWxlY3Rpb24yLmZvY3VzLnBhdGhcbiAgfSkpID09PSBudWxsIHx8IF9FZGl0b3IkYWJvdmUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRWRpdG9yJGFib3ZlMlsxXTtcbiAgY29uc3QgdGFibGUgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgbWF0Y2g6IG5vZGVUeXBlTWF0Y2hlcigndGFibGUnKVxuICB9KTtcbiAgaWYgKGVkaXRvci5zZWxlY3Rpb24gJiYgdGFibGUgJiYgRWxlbWVudCQxLmlzRWxlbWVudCh0YWJsZVswXS5jaGlsZHJlblswXSkgJiYgYW5jaG9yICYmIGZvY3VzICYmIFBhdGguZXF1YWxzKGFuY2hvci5zbGljZSgwLCAtMyksIGZvY3VzLnNsaWNlKDAsIC0zKSkpIHtcbiAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBFZGl0b3IuZWRnZXMoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGFibGVQYXRoOiB0YWJsZVsxXSxcbiAgICAgIHRhYmxlOiB0YWJsZVswXSxcbiAgICAgIHNpbmdsZUNlbGw6IFBhdGguZXF1YWxzKGFuY2hvciwgZm9jdXMpID8gUG9pbnQuZXF1YWxzKEVkaXRvci5zdGFydChlZGl0b3IsIGFuY2hvciksIHN0YXJ0KSAmJiBQb2ludC5lcXVhbHMoRWRpdG9yLmVuZChlZGl0b3IsIGFuY2hvciksIGVuZCkgJiYgIVBvaW50LmVxdWFscyhzdGFydCwgZW5kKSA/ICdzZWxlY3RlZCcgOiAnbm90LXNlbGVjdGVkJyA6ICdtYW55JyxcbiAgICAgIHJvdzogb3JkZXIoYW5jaG9yW2FuY2hvci5sZW5ndGggLSAyXSArIGFuY2hvclthbmNob3IubGVuZ3RoIC0gM10sIGZvY3VzW2ZvY3VzLmxlbmd0aCAtIDJdICsgZm9jdXNbYW5jaG9yLmxlbmd0aCAtIDNdKSxcbiAgICAgIGNvbHVtbjogb3JkZXIoYW5jaG9yW2FuY2hvci5sZW5ndGggLSAxXSwgZm9jdXNbZm9jdXMubGVuZ3RoIC0gMV0pXG4gICAgfTtcbiAgfVxufVxuY29uc3QgY2VsbCA9IGhlYWRlciA9PiAoe1xuICB0eXBlOiAndGFibGUtY2VsbCcsXG4gIC4uLihoZWFkZXIgPyB7XG4gICAgaGVhZGVyOiB0cnVlXG4gIH0gOiB7fSksXG4gIGNoaWxkcmVuOiBbe1xuICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgIGNoaWxkcmVuOiBbe1xuICAgICAgdGV4dDogJydcbiAgICB9XVxuICB9XVxufSk7XG5mdW5jdGlvbiBjbG9uZURlc2NlbmRhbnQobm9kZSkge1xuICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHJldHVybiB7XG4gICAgLi4ubm9kZVxuICB9O1xuICByZXR1cm4ge1xuICAgIC4uLm5vZGUsXG4gICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4ubWFwKGNsb25lRGVzY2VuZGFudClcbiAgfTtcbn1cbmZ1bmN0aW9uIHdpdGhUYWJsZShlZGl0b3IpIHtcbiAgY29uc3Qge1xuICAgIGRlbGV0ZUZyYWdtZW50LFxuICAgIG5vcm1hbGl6ZU5vZGUsXG4gICAgZ2V0RnJhZ21lbnQsXG4gICAgaW5zZXJ0RnJhZ21lbnQsXG4gICAgZGVsZXRlQmFja3dhcmRcbiAgfSA9IGVkaXRvcjtcbiAgZWRpdG9yLmluc2VydEZyYWdtZW50ID0gZnJhZ21lbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkVGFibGVBcmVhID0gZ2V0U2VsZWN0ZWRUYWJsZUFyZWEoZWRpdG9yKTtcbiAgICBpZiAoIXNlbGVjdGVkVGFibGVBcmVhIHx8IGZyYWdtZW50Lmxlbmd0aCAhPT0gMSB8fCBmcmFnbWVudFswXS50eXBlICE9PSAndGFibGUnKSB7XG4gICAgICBpbnNlcnRGcmFnbWVudChmcmFnbWVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld1Jvd3MgPSBmcmFnbWVudFswXS5jaGlsZHJlbi5mbGF0TWFwKGNoaWxkID0+IGNoaWxkLnR5cGUgPT09ICd0YWJsZS1oZWFkJyB8fCBjaGlsZC50eXBlID09PSAndGFibGUtYm9keScgPyBjaGlsZC5jaGlsZHJlbiA6IFtdKTtcbiAgICBpZiAoIW5ld1Jvd3MuZXZlcnkobm9kZVR5cGVNYXRjaGVyKCd0YWJsZS1yb3cnKSkpIHtcbiAgICAgIGluc2VydEZyYWdtZW50KGZyYWdtZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHJvdyxcbiAgICAgIGNvbHVtbixcbiAgICAgIHRhYmxlUGF0aCxcbiAgICAgIHRhYmxlXG4gICAgfSA9IHNlbGVjdGVkVGFibGVBcmVhO1xuICAgIGNvbnN0IGV4aXN0aW5nQm9keSA9IHNlbGVjdGVkVGFibGVBcmVhLnRhYmxlLmNoaWxkcmVuW3NlbGVjdGVkVGFibGVBcmVhLnRhYmxlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSA/IDAgOiAxXTtcbiAgICBpZiAobmV3Um93c1swXS50eXBlICE9PSAndGFibGUtcm93JyB8fCBleGlzdGluZ0JvZHkudHlwZSAhPT0gJ3RhYmxlLWJvZHknIHx8IGV4aXN0aW5nQm9keS5jaGlsZHJlblswXS50eXBlICE9PSAndGFibGUtcm93Jykge1xuICAgICAgaW5zZXJ0RnJhZ21lbnQoZnJhZ21lbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYXNIZWFkID0gdGFibGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gJ3RhYmxlLWhlYWQnO1xuICAgIGlmIChzZWxlY3RlZFRhYmxlQXJlYS5zaW5nbGVDZWxsICE9PSAnbWFueScpIHtcbiAgICAgIHJvdyA9IHtcbiAgICAgICAgc3RhcnQ6IHJvdy5zdGFydCxcbiAgICAgICAgZW5kOiBNYXRoLm1pbihyb3cuc3RhcnQgKyBuZXdSb3dzLmxlbmd0aCAtIDEsIGV4aXN0aW5nQm9keS5jaGlsZHJlbi5sZW5ndGggLSAxICsgKGhhc0hlYWQgPyAxIDogMCkpXG4gICAgICB9O1xuICAgICAgY29sdW1uID0ge1xuICAgICAgICBzdGFydDogY29sdW1uLnN0YXJ0LFxuICAgICAgICBlbmQ6IE1hdGgubWluKGNvbHVtbi5zdGFydCArIG5ld1Jvd3NbMF0uY2hpbGRyZW4ubGVuZ3RoIC0gMSwgZXhpc3RpbmdCb2R5LmNoaWxkcmVuWzBdLmNoaWxkcmVuLmxlbmd0aCAtIDEpXG4gICAgICB9O1xuICAgIH1cbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgZm9yIChsZXQgcm93SW5kZXggPSByb3cuc3RhcnQ7IHJvd0luZGV4IDw9IHJvdy5lbmQ7IHJvd0luZGV4KyspIHtcbiAgICAgICAgY29uc3QgbmV3Um93ID0gbmV3Um93c1socm93SW5kZXggLSByb3cuc3RhcnQpICUgbmV3Um93cy5sZW5ndGhdO1xuICAgICAgICBmb3IgKGxldCBjZWxsSW5kZXggPSBjb2x1bW4uc3RhcnQ7IGNlbGxJbmRleCA8PSBjb2x1bW4uZW5kOyBjZWxsSW5kZXgrKykge1xuICAgICAgICAgIGNvbnN0IHJlbGF0aXZlQ2VsbFBhdGggPSBbLi4uZ2V0UmVsYXRpdmVSb3dQYXRoKGhhc0hlYWQsIHJvd0luZGV4KSwgY2VsbEluZGV4XTtcbiAgICAgICAgICBjb25zdCBjZWxsID0gTm9kZS5nZXQodGFibGUsIHJlbGF0aXZlQ2VsbFBhdGgpO1xuICAgICAgICAgIGNvbnN0IG5ld0NlbGwgPSBuZXdSb3cuY2hpbGRyZW5bKGNlbGxJbmRleCAtIGNvbHVtbi5zdGFydCkgJSBuZXdSb3cuY2hpbGRyZW4ubGVuZ3RoXTtcbiAgICAgICAgICBpZiAoY2VsbC50eXBlICE9PSAndGFibGUtY2VsbCcgfHwgbmV3Q2VsbC50eXBlICE9PSAndGFibGUtY2VsbCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjZWxsUGF0aCA9IFsuLi50YWJsZVBhdGgsIC4uLnJlbGF0aXZlQ2VsbFBhdGhdO1xuICAgICAgICAgIGZvciAoY29uc3QgY2hpbGRJZHggb2YgWy4uLmNlbGwuY2hpbGRyZW4ua2V5cygpXS5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBbLi4uY2VsbFBhdGgsIGNoaWxkSWR4XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBuZXdDZWxsLmNoaWxkcmVuLm1hcChjbG9uZURlc2NlbmRhbnQpLCB7XG4gICAgICAgICAgICBhdDogWy4uLmNlbGxQYXRoLCAwXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgYW5jaG9yOiBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbLi4udGFibGVQYXRoLCAuLi5nZXRSZWxhdGl2ZVJvd1BhdGgoaGFzSGVhZCwgcm93LnN0YXJ0KSwgY29sdW1uLnN0YXJ0XSksXG4gICAgICAgIGZvY3VzOiBFZGl0b3IuZW5kKGVkaXRvciwgWy4uLnRhYmxlUGF0aCwgLi4uZ2V0UmVsYXRpdmVSb3dQYXRoKGhhc0hlYWQsIHJvdy5lbmQpLCBjb2x1bW4uZW5kXSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBlZGl0b3IuZGVsZXRlQmFja3dhcmQgPSB1bml0ID0+IHtcbiAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSAmJiBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAgIGNvbnN0IHRhYmxlQ2VsbCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG5vZGVUeXBlTWF0Y2hlcigndGFibGUtY2VsbCcpXG4gICAgICB9KTtcbiAgICAgIGlmICh0YWJsZUNlbGwgJiYgdGFibGVDZWxsWzBdLmNoaWxkcmVuWzBdLnR5cGUgPT09ICdwYXJhZ3JhcGgnICYmIHRhYmxlQ2VsbFswXS5jaGlsZHJlblswXS5jaGlsZHJlblswXS50eXBlID09PSB1bmRlZmluZWQgJiYgUGF0aC5lcXVhbHMoZWRpdG9yLnNlbGVjdGlvbi5hbmNob3IucGF0aCwgWy4uLnRhYmxlQ2VsbFsxXSwgMCwgMF0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlQmFja3dhcmQodW5pdCk7XG4gIH07XG4gIGVkaXRvci5nZXRGcmFnbWVudCA9ICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3RlZFRhYmxlQXJlYSA9IGdldFNlbGVjdGVkVGFibGVBcmVhKGVkaXRvcik7XG4gICAgaWYgKHNlbGVjdGVkVGFibGVBcmVhICYmIHNlbGVjdGVkVGFibGVBcmVhLnNpbmdsZUNlbGwgIT09ICdub3Qtc2VsZWN0ZWQnKSB7XG4gICAgICB2YXIgX3RhYmxlJGNoaWxkcmVuJDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdGFibGVcbiAgICAgIH0gPSBzZWxlY3RlZFRhYmxlQXJlYTtcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGFibGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gJ3RhYmxlLWhlYWQnIHx8IHRhYmxlLmNoaWxkcmVuWzBdLnR5cGUgPT09ICd0YWJsZS1ib2R5JyA/IHRhYmxlLmNoaWxkcmVuWzBdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICByZXR1cm4gZ2V0RnJhZ21lbnQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlY29uZCA9ICgoX3RhYmxlJGNoaWxkcmVuJCA9IHRhYmxlLmNoaWxkcmVuWzFdKSA9PT0gbnVsbCB8fCBfdGFibGUkY2hpbGRyZW4kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGFibGUkY2hpbGRyZW4kLnR5cGUpID09PSAndGFibGUtYm9keScgPyB0YWJsZS5jaGlsZHJlblsxXSA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGJvZHkgPSBzZWNvbmQgfHwgZmlyc3Q7XG4gICAgICBjb25zdCBoYXNIZWFkID0gZmlyc3QudHlwZSA9PT0gJ3RhYmxlLWhlYWQnO1xuICAgICAgY29uc3QgaXNTZWxlY3Rpb25JbkhlYWQgPSBzZWxlY3RlZFRhYmxlQXJlYS5yb3cuc3RhcnQgPT09IDAgJiYgISFzZWNvbmQ7XG4gICAgICBjb25zdCBjb2x1bW5MZW5ndGggPSBzZWxlY3RlZFRhYmxlQXJlYS5jb2x1bW4uZW5kIC0gc2VsZWN0ZWRUYWJsZUFyZWEuY29sdW1uLnN0YXJ0ICsgMTtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICBjaGlsZHJlbjogWy4uLihpc1NlbGVjdGlvbkluSGVhZCA/IFt7XG4gICAgICAgICAgdHlwZTogJ3RhYmxlLWhlYWQnLFxuICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgdHlwZTogJ3RhYmxlLXJvdycsXG4gICAgICAgICAgICBjaGlsZHJlbjogQXJyYXkuZnJvbSh7XG4gICAgICAgICAgICAgIGxlbmd0aDogY29sdW1uTGVuZ3RoXG4gICAgICAgICAgICB9KS5tYXAoKF8sIGNvbHVtbkluZGV4KSA9PiBmaXJzdC5jaGlsZHJlblswXS5jaGlsZHJlbltjb2x1bW5JbmRleCArIHNlbGVjdGVkVGFibGVBcmVhLmNvbHVtbi5zdGFydF0pXG4gICAgICAgICAgfV1cbiAgICAgICAgfV0gOiBbXSksIHtcbiAgICAgICAgICB0eXBlOiAndGFibGUtYm9keScsXG4gICAgICAgICAgY2hpbGRyZW46IEFycmF5LmZyb20oe1xuICAgICAgICAgICAgbGVuZ3RoOiBzZWxlY3RlZFRhYmxlQXJlYS5yb3cuZW5kIC0gc2VsZWN0ZWRUYWJsZUFyZWEucm93LnN0YXJ0ICsgKGlzU2VsZWN0aW9uSW5IZWFkID8gMCA6IDEpXG4gICAgICAgICAgfSkubWFwKChfLCByb3dJbmRleCkgPT4gKHtcbiAgICAgICAgICAgIHR5cGU6ICd0YWJsZS1yb3cnLFxuICAgICAgICAgICAgY2hpbGRyZW46IEFycmF5LmZyb20oe1xuICAgICAgICAgICAgICBsZW5ndGg6IGNvbHVtbkxlbmd0aFxuICAgICAgICAgICAgfSkubWFwKChfLCBjb2x1bW5JbmRleCkgPT4gYm9keS5jaGlsZHJlbltyb3dJbmRleCArIHNlbGVjdGVkVGFibGVBcmVhLnJvdy5zdGFydCAtIChoYXNIZWFkICYmICFpc1NlbGVjdGlvbkluSGVhZCA/IDEgOiAwKV0uY2hpbGRyZW5bY29sdW1uSW5kZXggKyBzZWxlY3RlZFRhYmxlQXJlYS5jb2x1bW4uc3RhcnRdKVxuICAgICAgICAgIH0pKVxuICAgICAgICB9XVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBnZXRGcmFnbWVudCgpO1xuICB9O1xuICBlZGl0b3IuZGVsZXRlRnJhZ21lbnQgPSBkaXJlY3Rpb24gPT4ge1xuICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbiB8fCBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSkge1xuICAgICAgZGVsZXRlRnJhZ21lbnQoZGlyZWN0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRUYWJsZUFyZWEgPSBnZXRTZWxlY3RlZFRhYmxlQXJlYShlZGl0b3IpO1xuICAgIGlmICghc2VsZWN0ZWRUYWJsZUFyZWEgfHwgc2VsZWN0ZWRUYWJsZUFyZWEuc2luZ2xlQ2VsbCA9PT0gJ25vdC1zZWxlY3RlZCcpIHtcbiAgICAgIGRlbGV0ZUZyYWdtZW50KGRpcmVjdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhlYWRPckJvZHkgPSBzZWxlY3RlZFRhYmxlQXJlYS50YWJsZS5jaGlsZHJlblswXTtcbiAgICBpZiAoIUVsZW1lbnQkMS5pc0VsZW1lbnQoaGVhZE9yQm9keSkgfHwgIUVsZW1lbnQkMS5pc0VsZW1lbnQoaGVhZE9yQm9keS5jaGlsZHJlblswXSkpIHtcbiAgICAgIGRlbGV0ZUZyYWdtZW50KGRpcmVjdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1heFJvd0lkeCA9IHNlbGVjdGVkVGFibGVBcmVhLnRhYmxlLmNoaWxkcmVuLnJlZHVjZSgoc3VtLCBoZWFkT3JCb2R5KSA9PiBzdW0gKyAoaGVhZE9yQm9keS50eXBlID09PSAndGFibGUtaGVhZCcgfHwgaGVhZE9yQm9keS50eXBlID09PSAndGFibGUtYm9keScgPyBoZWFkT3JCb2R5LmNoaWxkcmVuLmxlbmd0aCA6IDApLCAwKSAtIDE7XG4gICAgY29uc3Qge1xuICAgICAgcm93LFxuICAgICAgY29sdW1uLFxuICAgICAgdGFibGVQYXRoXG4gICAgfSA9IHNlbGVjdGVkVGFibGVBcmVhO1xuICAgIC8vIG5vdGUgdGhlIGZhY3QgdGhhdCBoYXNXaG9sZUNvbHVtblNlbGVjdGVkIHVzZXMgcm93IGFuZCBoYXNXaG9sZVJvd1NlbGVjdGVkIHVzZXMgY29sdW1uXG4gICAgLy8gaXMgbm90IGEgbWlzdGFrZS4gaWYgYSB3aG9sZSBjb2x1bW4gaGFzIGJlZW4gc2VsZWN0ZWQsIHRoZW4gdGhlIHN0YXJ0aW5nIHJvdyBpcyAwIGFuZCB0aGUgZW5kIGlzIHRoZSBsYXN0IHJvd1xuICAgIGNvbnN0IGhhc1dob2xlQ29sdW1uU2VsZWN0ZWQgPSByb3cuc3RhcnQgPT09IDAgJiYgcm93LmVuZCA9PT0gbWF4Um93SWR4O1xuICAgIGNvbnN0IGhhc1dob2xlUm93U2VsZWN0ZWQgPSBjb2x1bW4uc3RhcnQgPT09IDAgJiYgY29sdW1uLmVuZCA9PT0gaGVhZE9yQm9keS5jaGlsZHJlblswXS5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgIGlmIChoYXNXaG9sZUNvbHVtblNlbGVjdGVkICYmIGhhc1dob2xlUm93U2VsZWN0ZWQpIHtcbiAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiB0YWJsZVBhdGhcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYXNIZWFkID0gaGVhZE9yQm9keS50eXBlID09PSAndGFibGUtaGVhZCc7XG4gICAgaWYgKGhhc1dob2xlUm93U2VsZWN0ZWQpIHtcbiAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSByb3cuZW5kOyBpID49IHJvdy5zdGFydDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGhhc0hlYWQpIHtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IFsuLi50YWJsZVBhdGgsIDBdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBbLi4udGFibGVQYXRoLCAxLCBpIC0gMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogWy4uLnRhYmxlUGF0aCwgMCwgaV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChoYXNXaG9sZUNvbHVtblNlbGVjdGVkKSB7XG4gICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gY29sdW1uLmVuZDsgaSA+PSBjb2x1bW4uc3RhcnQ7IGktLSkge1xuICAgICAgICAgIGZvciAobGV0IHJvd0lkeCA9IDA7IHJvd0lkeCA8PSBtYXhSb3dJZHg7IHJvd0lkeCsrKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogWy4uLnRhYmxlUGF0aCwgLi4uZ2V0UmVsYXRpdmVSb3dQYXRoKGhhc0hlYWQsIHJvd0lkeCksIGldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uUGF0aCA9IFsuLi50YWJsZVBhdGgsIDAsIDAsIGNvbHVtbi5zdGFydF07XG4gICAgICAgIGNvbnN0IHBvaW50ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgY29sdW1uLnN0YXJ0ID09PSAwID8gc2VsZWN0aW9uUGF0aCA6IFBhdGgucHJldmlvdXMoc2VsZWN0aW9uUGF0aCkpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHBvaW50KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb25TdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24pLnBhdGg7XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIGZvciAobGV0IHJvd0luZGV4ID0gcm93LnN0YXJ0OyByb3dJbmRleCA8PSByb3cuZW5kOyByb3dJbmRleCsrKSB7XG4gICAgICAgIGZvciAobGV0IGNlbGxJbmRleCA9IGNvbHVtbi5zdGFydDsgY2VsbEluZGV4IDw9IGNvbHVtbi5lbmQ7IGNlbGxJbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgcmVsYXRpdmVDZWxsUGF0aCA9IFsuLi5nZXRSZWxhdGl2ZVJvd1BhdGgoaGFzSGVhZCwgcm93SW5kZXgpLCBjZWxsSW5kZXhdO1xuICAgICAgICAgIGNvbnN0IGNlbGwgPSBOb2RlLmdldChzZWxlY3RlZFRhYmxlQXJlYS50YWJsZSwgcmVsYXRpdmVDZWxsUGF0aCk7XG4gICAgICAgICAgaWYgKCFFbGVtZW50JDEuaXNFbGVtZW50KGNlbGwpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY2VsbFBhdGggPSBbLi4udGFibGVQYXRoLCAuLi5yZWxhdGl2ZUNlbGxQYXRoXTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IFsuLi5jZWxsUGF0aCwgMF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkSWR4IG9mIFsuLi5jZWxsLmNoaWxkcmVuLmtleXMoKV0ucmV2ZXJzZSgpKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogWy4uLmNlbGxQYXRoLCBjaGlsZElkeCArIDFdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uU3RhcnQpO1xuICAgIH0pO1xuICB9O1xuICBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IGVudHJ5ID0+IHtcbiAgICBjb25zdCBbbm9kZSwgcGF0aF0gPSBlbnRyeTtcbiAgICBpZiAobm9kZS50eXBlID09PSAndGFibGUtaGVhZCcgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICBtb3ZlQ2hpbGRyZW4oZWRpdG9yLCBwYXRoLCBQYXRoLm5leHQocGF0aCksIChfLCBpKSA9PiBpICE9PSAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGRpZFVwZGF0ZVRoaW5ncyA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgcGFyZW50IG9mIFsndGFibGUtYm9keScsICd0YWJsZS1oZWFkJ10pIHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09IHBhcmVudCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtyb3dJZHgsIHJvd10gb2Ygbm9kZS5jaGlsZHJlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBpZiAocm93LnR5cGUgPT09ICd0YWJsZS1yb3cnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtjZWxsSWR4LCBjZWxsXSBvZiByb3cuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgICAgICAgIGlmIChjZWxsLnR5cGUgPT09ICd0YWJsZS1jZWxsJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0ID0gWy4uLnBhdGgsIHJvd0lkeCwgY2VsbElkeF07XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwuaGVhZGVyICYmIHBhcmVudCA9PT0gJ3RhYmxlLWJvZHknKSB7XG4gICAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnVuc2V0Tm9kZXMoZWRpdG9yLCAnaGVhZGVyJywge1xuICAgICAgICAgICAgICAgICAgICBhdFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBkaWRVcGRhdGVUaGluZ3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNlbGwuaGVhZGVyICYmIHBhcmVudCA9PT0gJ3RhYmxlLWhlYWQnKSB7XG4gICAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IHRydWVcbiAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgYXRcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgZGlkVXBkYXRlVGhpbmdzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRpZFVwZGF0ZVRoaW5ncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobm9kZS50eXBlID09PSAndGFibGUnKSB7XG4gICAgICBjb25zdCBtYXhSb3dDb3VudCA9IG5vZGUuY2hpbGRyZW4ucmVkdWNlKChtYXgsIG5vZGUpID0+IG5vZGUudHlwZSA9PT0gJ3RhYmxlLWhlYWQnIHx8IG5vZGUudHlwZSA9PT0gJ3RhYmxlLWJvZHknID8gbm9kZS5jaGlsZHJlbi5yZWR1Y2UoKG1heCwgbm9kZSkgPT4gbm9kZS50eXBlID09PSAndGFibGUtcm93JyA/IE1hdGgubWF4KG1heCwgbm9kZS5jaGlsZHJlbi5sZW5ndGgpIDogbWF4LCBtYXgpIDogbWF4LCAwKTtcbiAgICAgIGxldCBkaWRJbnNlcnQgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgW2lkeCwgY2hpbGRdIG9mIG5vZGUuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAndGFibGUtYm9keScgfHwgY2hpbGQudHlwZSA9PT0gJ3RhYmxlLWhlYWQnKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbcm93SWR4LCByb3ddIG9mIGNoaWxkLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHJvdy50eXBlID09PSAndGFibGUtcm93JyAmJiByb3cuY2hpbGRyZW4ubGVuZ3RoICE9PSBtYXhSb3dDb3VudCkge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgQXJyYXkuZnJvbSh7XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBtYXhSb3dDb3VudCAtIHJvdy5jaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgICAgICAgfSwgKCkgPT4gY2VsbChjaGlsZC50eXBlID09PSAndGFibGUtaGVhZCcpKSwge1xuICAgICAgICAgICAgICAgIGF0OiBbLi4ucGF0aCwgaWR4LCByb3dJZHgsIHJvdy5jaGlsZHJlbi5sZW5ndGhdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBkaWRJbnNlcnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpZEluc2VydCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAndGFibGUtaGVhZCcpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICB0eXBlOiAndGFibGUtYm9keScsXG4gICAgICAgICAgY2hpbGRyZW46IEFycmF5LmZyb20oe1xuICAgICAgICAgICAgbGVuZ3RoOiBub2RlLmNoaWxkcmVuWzBdLmNoaWxkcmVuLmxlbmd0aFxuICAgICAgICAgIH0sICgpID0+IGNlbGwoZmFsc2UpKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IFsuLi5wYXRoLCAxXVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAyICYmIG5vZGUuY2hpbGRyZW5bMV0udHlwZSA9PT0gJ3RhYmxlLWhlYWQnKSB7XG4gICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBbLi4ucGF0aCwgMV0sXG4gICAgICAgICAgdG86IFsuLi5wYXRoLCAwXVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMikge1xuICAgICAgICBtb3ZlQ2hpbGRyZW4oZWRpdG9yLCBwYXRoLCBQYXRoLm5leHQocGF0aCksIChfLCBpKSA9PiBpICE9PSAwICYmIGkgIT09IDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG5vcm1hbGl6ZU5vZGUoZW50cnkpO1xuICB9O1xuICByZXR1cm4gZWRpdG9yO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEb2N1bWVudEVkaXRvckZvck5vcm1hbGl6YXRpb24oZG9jdW1lbnRGZWF0dXJlcywgY29tcG9uZW50QmxvY2tzKSB7XG4gIHJldHVybiBfY3JlYXRlRG9jdW1lbnRFZGl0b3IoY3JlYXRlRWRpdG9yKCksIGRvY3VtZW50RmVhdHVyZXMsIGNvbXBvbmVudEJsb2Nrcyk7XG59XG5mdW5jdGlvbiBfY3JlYXRlRG9jdW1lbnRFZGl0b3IoYmFzZUVkaXRvciwgZG9jdW1lbnRGZWF0dXJlcywgY29tcG9uZW50QmxvY2tzKSB7XG4gIHJldHVybiB3aXRoQmxvY2tzU2NoZW1hKHdpdGhQYXJhZ3JhcGhzKHdpdGhMaW5rKGRvY3VtZW50RmVhdHVyZXMsIGNvbXBvbmVudEJsb2Nrcywgd2l0aExpc3Qod2l0aFRhYmxlKHdpdGhDb21wb25lbnRCbG9ja3MoY29tcG9uZW50QmxvY2tzLCBkb2N1bWVudEZlYXR1cmVzLCB3aXRoVm9pZEVsZW1lbnRzKHdpdGhMYXlvdXRzKHdpdGhDb2RlQmxvY2soZG9jdW1lbnRGZWF0dXJlcywgY29tcG9uZW50QmxvY2tzLCB3aXRoRG9jdW1lbnRGZWF0dXJlc05vcm1hbGl6YXRpb24oZG9jdW1lbnRGZWF0dXJlcywgYmFzZUVkaXRvcikpKSkpKSkpKSk7XG59XG5mdW5jdGlvbiB3aXRoQmxvY2tzU2NoZW1hKGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgbm9ybWFsaXplTm9kZVxuICB9ID0gZWRpdG9yO1xuICBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpICYmIG5vZGUudHlwZSAhPT0gJ2xpbmsnKSB7XG4gICAgICBjb25zdCBub2RlVHlwZSA9IEVkaXRvci5pc0VkaXRvcihub2RlKSA/ICdlZGl0b3InIDogbm9kZS50eXBlO1xuICAgICAgaWYgKHR5cGVvZiBub2RlVHlwZSAhPT0gJ3N0cmluZycgfHwgZWRpdG9yU2NoZW1hW25vZGVUeXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZm8gPSBlZGl0b3JTY2hlbWFbbm9kZVR5cGVdO1xuICAgICAgaWYgKGluZm8ua2luZCA9PT0gJ2Jsb2NrcycgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggIT09IDAgJiYgbm9kZS5jaGlsZHJlbi5ldmVyeShjaGlsZCA9PiAhaXNCbG9jayhjaGlsZCkpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIHR5cGU6IGluZm8uYmxvY2tUb1dyYXBJbmxpbmVzSW4sXG4gICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICBtYXRjaDogbm9kZSA9PiAhaXNCbG9jayhub2RlKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGRpZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGNoaWxkTm9kZV0gb2YgWy4uLm5vZGUuY2hpbGRyZW4uZW50cmllcygpXS5yZXZlcnNlKCkpIHtcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gWy4uLnBhdGgsIGluZGV4XTtcbiAgICAgICAgaWYgKGluZm8ua2luZCA9PT0gJ2lubGluZXMnKSB7XG4gICAgICAgICAgaWYgKCFUZXh0LmlzVGV4dChjaGlsZE5vZGUpICYmIGlzQmxvY2soY2hpbGROb2RlKSkge1xuICAgICAgICAgICAgaGFuZGxlTm9kZUluSW52YWxpZFBvc2l0aW9uKGVkaXRvciwgW2NoaWxkTm9kZSwgY2hpbGRQYXRoXSwgcGF0aCk7XG4gICAgICAgICAgICBkaWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghaXNCbG9jayhjaGlsZE5vZGUpKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdHlwZTogaW5mby5ibG9ja1RvV3JhcElubGluZXNJbixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWluZm8uYWxsb3dlZENoaWxkcmVuLmhhcyhjaGlsZE5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZU5vZGVJbkludmFsaWRQb3NpdGlvbihlZGl0b3IsIFtjaGlsZE5vZGUsIGNoaWxkUGF0aF0sIHBhdGgpO1xuICAgICAgICAgICAgZGlkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpZFVwZGF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG5vcm1hbGl6ZU5vZGUoW25vZGUsIHBhdGhdKTtcbiAgfTtcbiAgcmV0dXJuIGVkaXRvcjtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5vZGVJbkludmFsaWRQb3NpdGlvbihlZGl0b3IsIFtub2RlLCBwYXRoXSwgYW5jZXN0b3JQYXRoKSB7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuICBjb25zdCBjaGlsZE5vZGVJbmZvID0gZWRpdG9yU2NoZW1hW25vZGVUeXBlXTtcbiAgLy8gdGhlIHBhcmVudCBvZiBhIGJsb2NrIHdpbGwgbmV2ZXIgYmUgYW4gaW5saW5lIHNvIHRoaXMgY2FzdGluZyBpcyBva2F5XG4gIGNvbnN0IGFuY2VzdG9yTm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgYW5jZXN0b3JQYXRoKTtcbiAgY29uc3QgcGFyZW50Tm9kZVR5cGUgPSBFZGl0b3IuaXNFZGl0b3IoYW5jZXN0b3JOb2RlKSA/ICdlZGl0b3InIDogYW5jZXN0b3JOb2RlLnR5cGU7XG4gIGNvbnN0IHBhcmVudE5vZGVJbmZvID0gZWRpdG9yU2NoZW1hW3BhcmVudE5vZGVUeXBlXTtcbiAgaWYgKCFjaGlsZE5vZGVJbmZvIHx8IGNoaWxkTm9kZUluZm8uaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZSA9PT0gJ3Vud3JhcCcpIHtcbiAgICBpZiAocGFyZW50Tm9kZUluZm8ua2luZCA9PT0gJ2Jsb2NrcycgJiYgcGFyZW50Tm9kZUluZm8uYmxvY2tUb1dyYXBJbmxpbmVzSW4pIHtcbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIHR5cGU6IHBhcmVudE5vZGVJbmZvLmJsb2NrVG9XcmFwSW5saW5lc0luLFxuICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmtleXMobm9kZSkuZmlsdGVyKGtleSA9PiBrZXkgIT09ICd0eXBlJyAmJiBrZXkgIT09ICdjaGlsZHJlbicpLm1hcChrZXkgPT4gW2tleSwgbnVsbF0pKSAvLyB0aGUgU2xhdGUgdHlwZXMgZG9uJ3QgdW5kZXJzdGFuZCB0aGF0IG51bGwgaXMgYWxsb3dlZCBhbmQgaXQgd2lsbCB1bnNldCBwcm9wZXJ0aWVzIHdpdGggc2V0Tm9kZXNcbiAgICAgIH0sIHtcbiAgICAgICAgYXQ6IHBhdGhcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGhcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaW5mbyA9IGVkaXRvclNjaGVtYVthbmNlc3Rvck5vZGUudHlwZSB8fCAnZWRpdG9yJ107XG4gIGlmICgoaW5mbyA9PT0gbnVsbCB8fCBpbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbmZvLmtpbmQpID09PSAnYmxvY2tzJyAmJiBpbmZvLmFsbG93ZWRDaGlsZHJlbi5oYXMobm9kZVR5cGUpKSB7XG4gICAgaWYgKGFuY2VzdG9yUGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgdG86IFtwYXRoWzBdICsgMV1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIHRvOiBQYXRoLm5leHQoYW5jZXN0b3JQYXRoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoRWRpdG9yLmlzRWRpdG9yKGFuY2VzdG9yTm9kZSkpIHtcbiAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoLFxuICAgICAgdG86IFtwYXRoWzBdICsgMV1cbiAgICB9KTtcbiAgICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IFtwYXRoWzBdICsgMV1cbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaGFuZGxlTm9kZUluSW52YWxpZFBvc2l0aW9uKGVkaXRvciwgW25vZGUsIHBhdGhdLCBhbmNlc3RvclBhdGguc2xpY2UoMCwgLTEpKTtcbn1cbmZ1bmN0aW9uIHdpdGhWb2lkRWxlbWVudHMoZWRpdG9yKSB7XG4gIGNvbnN0IHtcbiAgICBpc1ZvaWRcbiAgfSA9IGVkaXRvcjtcbiAgZWRpdG9yLmlzVm9pZCA9IG5vZGUgPT4ge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdkaXZpZGVyJyB8fCBub2RlLnR5cGUgPT09ICdpbWFnZScgfHwgaXNWb2lkKG5vZGUpO1xuICB9O1xuICByZXR1cm4gZWRpdG9yO1xufVxuXG5jb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbmNvbnN0IGRlZmF1bHRBbHRGaWVsZCA9IHRleHQoe1xuICBsYWJlbDogJ0FsdCB0ZXh0JyxcbiAgZGVzY3JpcHRpb246ICdUaGlzIHRleHQgd2lsbCBiZSB1c2VkIGJ5IHNjcmVlbiByZWFkZXJzIGFuZCBzZWFyY2ggZW5naW5lcy4nXG59KTtcbmNvbnN0IGVtcHR5VGl0bGVGaWVsZCA9IGJhc2ljRm9ybUZpZWxkV2l0aFNpbXBsZVJlYWRlclBhcnNlKHtcbiAgSW5wdXQoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH0sXG4gIHBhcnNlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKCdNdXN0IGJlIHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWVcbiAgICB9O1xuICB9LFxuICBsYWJlbDogJ1RpdGxlJ1xufSk7XG5mdW5jdGlvbiBub3JtYWxpc2VEb2N1bWVudEZlYXR1cmVzKGNvbmZpZykge1xuICB2YXIgX2NvbmZpZyRmb3JtYXR0aW5nLCBfZm9ybWF0dGluZyRhbGlnbm1lbnQsIF9mb3JtYXR0aW5nJGFsaWdubWVudDIsIF9mb3JtYXR0aW5nJGJsb2NrVHlwZSwgX2Zvcm1hdHRpbmckaW5saW5lTWFyLCBfZm9ybWF0dGluZyRpbmxpbmVNYXIyLCBfZm9ybWF0dGluZyRpbmxpbmVNYXIzLCBfZm9ybWF0dGluZyRpbmxpbmVNYXI0LCBfZm9ybWF0dGluZyRpbmxpbmVNYXI1LCBfZm9ybWF0dGluZyRpbmxpbmVNYXI2LCBfZm9ybWF0dGluZyRpbmxpbmVNYXI3LCBfZm9ybWF0dGluZyRpbmxpbmVNYXI4LCBfZm9ybWF0dGluZyRsaXN0VHlwZXMsIF9mb3JtYXR0aW5nJGxpc3RUeXBlczIsIF9pbWFnZXNDb25maWckc2NoZW1hJCwgX2ltYWdlc0NvbmZpZyRzY2hlbWEsIF9pbWFnZXNDb25maWckc2NoZW1hJDIsIF9pbWFnZXNDb25maWckc2NoZW1hMjtcbiAgY29uc3QgZm9ybWF0dGluZyA9IGNvbmZpZy5mb3JtYXR0aW5nID09PSB0cnVlID8ge1xuICAgIC8vIGFsaWdubWVudDogdHJ1ZSwgLy8gbm90IHN1cHBvcnRlZCBuYXRpdmVseSBpbiBtYXJrZG93blxuICAgIGJsb2NrVHlwZXM6IHRydWUsXG4gICAgaGVhZGluZ0xldmVsczogdHJ1ZSxcbiAgICBpbmxpbmVNYXJrczogdHJ1ZSxcbiAgICBsaXN0VHlwZXM6IHRydWUsXG4gICAgc29mdEJyZWFrczogdHJ1ZVxuICB9IDogKF9jb25maWckZm9ybWF0dGluZyA9IGNvbmZpZy5mb3JtYXR0aW5nKSAhPT0gbnVsbCAmJiBfY29uZmlnJGZvcm1hdHRpbmcgIT09IHZvaWQgMCA/IF9jb25maWckZm9ybWF0dGluZyA6IHt9O1xuICBjb25zdCBpbWFnZXNDb25maWcgPSBjb25maWcuaW1hZ2VzID09PSB0cnVlID8ge30gOiBjb25maWcuaW1hZ2VzO1xuICByZXR1cm4ge1xuICAgIGZvcm1hdHRpbmc6IHtcbiAgICAgIGFsaWdubWVudDogZm9ybWF0dGluZy5hbGlnbm1lbnQgPT09IHRydWUgPyB7XG4gICAgICAgIGNlbnRlcjogdHJ1ZSxcbiAgICAgICAgZW5kOiB0cnVlXG4gICAgICB9IDoge1xuICAgICAgICBjZW50ZXI6ICEhKChfZm9ybWF0dGluZyRhbGlnbm1lbnQgPSBmb3JtYXR0aW5nLmFsaWdubWVudCkgIT09IG51bGwgJiYgX2Zvcm1hdHRpbmckYWxpZ25tZW50ICE9PSB2b2lkIDAgJiYgX2Zvcm1hdHRpbmckYWxpZ25tZW50LmNlbnRlciksXG4gICAgICAgIGVuZDogISEoKF9mb3JtYXR0aW5nJGFsaWdubWVudDIgPSBmb3JtYXR0aW5nLmFsaWdubWVudCkgIT09IG51bGwgJiYgX2Zvcm1hdHRpbmckYWxpZ25tZW50MiAhPT0gdm9pZCAwICYmIF9mb3JtYXR0aW5nJGFsaWdubWVudDIuZW5kKVxuICAgICAgfSxcbiAgICAgIGJsb2NrVHlwZXM6IChmb3JtYXR0aW5nID09PSBudWxsIHx8IGZvcm1hdHRpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdHRpbmcuYmxvY2tUeXBlcykgPT09IHRydWUgPyB7XG4gICAgICAgIGJsb2NrcXVvdGU6IHRydWUsXG4gICAgICAgIGNvZGU6IHtcbiAgICAgICAgICBzY2hlbWE6IG9iamVjdCh7fSlcbiAgICAgICAgfVxuICAgICAgfSA6IHtcbiAgICAgICAgYmxvY2txdW90ZTogISEoKF9mb3JtYXR0aW5nJGJsb2NrVHlwZSA9IGZvcm1hdHRpbmcuYmxvY2tUeXBlcykgIT09IG51bGwgJiYgX2Zvcm1hdHRpbmckYmxvY2tUeXBlICE9PSB2b2lkIDAgJiYgX2Zvcm1hdHRpbmckYmxvY2tUeXBlLmJsb2NrcXVvdGUpLFxuICAgICAgICBjb2RlOiAoX2Zvcm1hdHRpbmckYmxvY2tUeXBlMiA9PiB7XG4gICAgICAgICAgaWYgKCgoX2Zvcm1hdHRpbmckYmxvY2tUeXBlMiA9IGZvcm1hdHRpbmcuYmxvY2tUeXBlcykgPT09IG51bGwgfHwgX2Zvcm1hdHRpbmckYmxvY2tUeXBlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Zvcm1hdHRpbmckYmxvY2tUeXBlMi5jb2RlKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmb3JtYXR0aW5nLmJsb2NrVHlwZXMuY29kZSA9PT0gdHJ1ZSB8fCAhZm9ybWF0dGluZy5ibG9ja1R5cGVzLmNvZGUuc2NoZW1hKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzY2hlbWE6IG9iamVjdCh7fSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFsndHlwZScsICdjaGlsZHJlbicsICdsYW5ndWFnZSddKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIGZvcm1hdHRpbmcuYmxvY2tUeXBlcy5jb2RlLnNjaGVtYSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtrZXl9XCIgY2Fubm90IGJlIGEga2V5IGluIHRoZSBzY2hlbWEgZm9yIGNvZGUgYmxvY2tzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2hlbWE6IG9iamVjdChmb3JtYXR0aW5nLmJsb2NrVHlwZXMuY29kZS5zY2hlbWEpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSkoKVxuICAgICAgfSxcbiAgICAgIGhlYWRpbmdzOiAoX29iaiRzY2hlbWEgPT4ge1xuICAgICAgICBjb25zdCBvcHQgPSBmb3JtYXR0aW5nID09PSBudWxsIHx8IGZvcm1hdHRpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdHRpbmcuaGVhZGluZ0xldmVscztcbiAgICAgICAgY29uc3Qgb2JqID0gdHlwZW9mIG9wdCA9PT0gJ29iamVjdCcgJiYgJ2xldmVscycgaW4gb3B0ID8gb3B0IDoge1xuICAgICAgICAgIGxldmVsczogb3B0LFxuICAgICAgICAgIHNjaGVtYTogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvYmouc2NoZW1hKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgWyd0eXBlJywgJ2NoaWxkcmVuJywgJ2xldmVsJywgJ3RleHRBbGlnbiddKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIG9iai5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7a2V5fVwiIGNhbm5vdCBiZSBhIGtleSBpbiB0aGUgc2NoZW1hIGZvciBoZWFkaW5nc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxldmVsczogWy4uLm5ldyBTZXQob2JqLmxldmVscyA9PT0gdHJ1ZSA/IFsxLCAyLCAzLCA0LCA1LCA2XSA6IG9iai5sZXZlbHMpXSxcbiAgICAgICAgICBzY2hlbWE6IG9iamVjdCgoX29iaiRzY2hlbWEgPSBvYmouc2NoZW1hKSAhPT0gbnVsbCAmJiBfb2JqJHNjaGVtYSAhPT0gdm9pZCAwID8gX29iaiRzY2hlbWEgOiB7fSlcbiAgICAgICAgfTtcbiAgICAgIH0pKCksXG4gICAgICBpbmxpbmVNYXJrczogZm9ybWF0dGluZy5pbmxpbmVNYXJrcyA9PT0gdHJ1ZSA/IHtcbiAgICAgICAgYm9sZDogdHJ1ZSxcbiAgICAgICAgY29kZTogdHJ1ZSxcbiAgICAgICAgaXRhbGljOiB0cnVlLFxuICAgICAgICBrZXlib2FyZDogZmFsc2UsXG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgbmF0aXZlbHkgaW4gbWFya2Rvd25cbiAgICAgICAgc3RyaWtldGhyb3VnaDogdHJ1ZSxcbiAgICAgICAgc3Vic2NyaXB0OiBmYWxzZSxcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBuYXRpdmVseSBpbiBtYXJrZG93blxuICAgICAgICBzdXBlcnNjcmlwdDogZmFsc2UsXG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgbmF0aXZlbHkgaW4gbWFya2Rvd25cbiAgICAgICAgdW5kZXJsaW5lOiBmYWxzZSAvLyBub3Qgc3VwcG9ydGVkIG5hdGl2ZWx5IGluIG1hcmtkb3duXG4gICAgICB9IDoge1xuICAgICAgICBib2xkOiAhISgoX2Zvcm1hdHRpbmckaW5saW5lTWFyID0gZm9ybWF0dGluZy5pbmxpbmVNYXJrcykgIT09IG51bGwgJiYgX2Zvcm1hdHRpbmckaW5saW5lTWFyICE9PSB2b2lkIDAgJiYgX2Zvcm1hdHRpbmckaW5saW5lTWFyLmJvbGQpLFxuICAgICAgICBjb2RlOiAhISgoX2Zvcm1hdHRpbmckaW5saW5lTWFyMiA9IGZvcm1hdHRpbmcuaW5saW5lTWFya3MpICE9PSBudWxsICYmIF9mb3JtYXR0aW5nJGlubGluZU1hcjIgIT09IHZvaWQgMCAmJiBfZm9ybWF0dGluZyRpbmxpbmVNYXIyLmNvZGUpLFxuICAgICAgICBpdGFsaWM6ICEhKChfZm9ybWF0dGluZyRpbmxpbmVNYXIzID0gZm9ybWF0dGluZy5pbmxpbmVNYXJrcykgIT09IG51bGwgJiYgX2Zvcm1hdHRpbmckaW5saW5lTWFyMyAhPT0gdm9pZCAwICYmIF9mb3JtYXR0aW5nJGlubGluZU1hcjMuaXRhbGljKSxcbiAgICAgICAgc3RyaWtldGhyb3VnaDogISEoKF9mb3JtYXR0aW5nJGlubGluZU1hcjQgPSBmb3JtYXR0aW5nLmlubGluZU1hcmtzKSAhPT0gbnVsbCAmJiBfZm9ybWF0dGluZyRpbmxpbmVNYXI0ICE9PSB2b2lkIDAgJiYgX2Zvcm1hdHRpbmckaW5saW5lTWFyNC5zdHJpa2V0aHJvdWdoKSxcbiAgICAgICAgdW5kZXJsaW5lOiAhISgoX2Zvcm1hdHRpbmckaW5saW5lTWFyNSA9IGZvcm1hdHRpbmcuaW5saW5lTWFya3MpICE9PSBudWxsICYmIF9mb3JtYXR0aW5nJGlubGluZU1hcjUgIT09IHZvaWQgMCAmJiBfZm9ybWF0dGluZyRpbmxpbmVNYXI1LnVuZGVybGluZSksXG4gICAgICAgIGtleWJvYXJkOiAhISgoX2Zvcm1hdHRpbmckaW5saW5lTWFyNiA9IGZvcm1hdHRpbmcuaW5saW5lTWFya3MpICE9PSBudWxsICYmIF9mb3JtYXR0aW5nJGlubGluZU1hcjYgIT09IHZvaWQgMCAmJiBfZm9ybWF0dGluZyRpbmxpbmVNYXI2LmtleWJvYXJkKSxcbiAgICAgICAgc3Vic2NyaXB0OiAhISgoX2Zvcm1hdHRpbmckaW5saW5lTWFyNyA9IGZvcm1hdHRpbmcuaW5saW5lTWFya3MpICE9PSBudWxsICYmIF9mb3JtYXR0aW5nJGlubGluZU1hcjcgIT09IHZvaWQgMCAmJiBfZm9ybWF0dGluZyRpbmxpbmVNYXI3LnN1YnNjcmlwdCksXG4gICAgICAgIHN1cGVyc2NyaXB0OiAhISgoX2Zvcm1hdHRpbmckaW5saW5lTWFyOCA9IGZvcm1hdHRpbmcuaW5saW5lTWFya3MpICE9PSBudWxsICYmIF9mb3JtYXR0aW5nJGlubGluZU1hcjggIT09IHZvaWQgMCAmJiBfZm9ybWF0dGluZyRpbmxpbmVNYXI4LnN1cGVyc2NyaXB0KVxuICAgICAgfSxcbiAgICAgIGxpc3RUeXBlczogZm9ybWF0dGluZy5saXN0VHlwZXMgPT09IHRydWUgPyB7XG4gICAgICAgIG9yZGVyZWQ6IHRydWUsXG4gICAgICAgIHVub3JkZXJlZDogdHJ1ZVxuICAgICAgfSA6IHtcbiAgICAgICAgb3JkZXJlZDogISEoKF9mb3JtYXR0aW5nJGxpc3RUeXBlcyA9IGZvcm1hdHRpbmcubGlzdFR5cGVzKSAhPT0gbnVsbCAmJiBfZm9ybWF0dGluZyRsaXN0VHlwZXMgIT09IHZvaWQgMCAmJiBfZm9ybWF0dGluZyRsaXN0VHlwZXMub3JkZXJlZCksXG4gICAgICAgIHVub3JkZXJlZDogISEoKF9mb3JtYXR0aW5nJGxpc3RUeXBlczIgPSBmb3JtYXR0aW5nLmxpc3RUeXBlcykgIT09IG51bGwgJiYgX2Zvcm1hdHRpbmckbGlzdFR5cGVzMiAhPT0gdm9pZCAwICYmIF9mb3JtYXR0aW5nJGxpc3RUeXBlczIudW5vcmRlcmVkKVxuICAgICAgfSxcbiAgICAgIHNvZnRCcmVha3M6ICEhZm9ybWF0dGluZy5zb2Z0QnJlYWtzXG4gICAgfSxcbiAgICBsaW5rczogISFjb25maWcubGlua3MsXG4gICAgbGF5b3V0czogWy4uLm5ldyBTZXQoKGNvbmZpZy5sYXlvdXRzIHx8IFtdKS5tYXAoeCA9PiBKU09OLnN0cmluZ2lmeSh4KSkpXS5tYXAoeCA9PiBKU09OLnBhcnNlKHgpKSxcbiAgICBkaXZpZGVyczogISFjb25maWcuZGl2aWRlcnMsXG4gICAgaW1hZ2VzOiBpbWFnZXNDb25maWcgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDoge1xuICAgICAgLi4uaW1hZ2VzQ29uZmlnLFxuICAgICAgc2NoZW1hOiB7XG4gICAgICAgIGFsdDogKF9pbWFnZXNDb25maWckc2NoZW1hJCA9IChfaW1hZ2VzQ29uZmlnJHNjaGVtYSA9IGltYWdlc0NvbmZpZy5zY2hlbWEpID09PSBudWxsIHx8IF9pbWFnZXNDb25maWckc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW1hZ2VzQ29uZmlnJHNjaGVtYS5hbHQpICE9PSBudWxsICYmIF9pbWFnZXNDb25maWckc2NoZW1hJCAhPT0gdm9pZCAwID8gX2ltYWdlc0NvbmZpZyRzY2hlbWEkIDogZGVmYXVsdEFsdEZpZWxkLFxuICAgICAgICB0aXRsZTogKF9pbWFnZXNDb25maWckc2NoZW1hJDIgPSAoX2ltYWdlc0NvbmZpZyRzY2hlbWEyID0gaW1hZ2VzQ29uZmlnLnNjaGVtYSkgPT09IG51bGwgfHwgX2ltYWdlc0NvbmZpZyRzY2hlbWEyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW1hZ2VzQ29uZmlnJHNjaGVtYTIudGl0bGUpICE9PSBudWxsICYmIF9pbWFnZXNDb25maWckc2NoZW1hJDIgIT09IHZvaWQgMCA/IF9pbWFnZXNDb25maWckc2NoZW1hJDIgOiBlbXB0eVRpdGxlRmllbGRcbiAgICAgIH1cbiAgICB9LFxuICAgIHRhYmxlczogISFjb25maWcudGFibGVzXG4gIH07XG59XG5mdW5jdGlvbiBkb2N1bWVudCQxKHtcbiAgbGFiZWwsXG4gIGNvbXBvbmVudEJsb2NrcyA9IHt9LFxuICBkZXNjcmlwdGlvbixcbiAgLi4uZG9jdW1lbnRGZWF0dXJlc0NvbmZpZ1xufSkge1xuICBjb25zdCBkb2N1bWVudEZlYXR1cmVzID0gbm9ybWFsaXNlRG9jdW1lbnRGZWF0dXJlcyhkb2N1bWVudEZlYXR1cmVzQ29uZmlnKTtcbiAgY29uc3QgcGFyc2UgPSBtb2RlID0+IChfdmFsdWUsIGRhdGEpID0+IHtcbiAgICBjb25zdCBtYXJrZG9jID0gdGV4dERlY29kZXIuZGVjb2RlKGRhdGEuY29udGVudCk7XG4gICAgY29uc3QgZG9jdW1lbnQgPSBmcm9tTWFya2RvYyhNYXJrZG9jLnBhcnNlKG1hcmtkb2MpLCBjb21wb25lbnRCbG9ja3MpO1xuICAgIGNvbnN0IGVkaXRvciA9IGNyZWF0ZURvY3VtZW50RWRpdG9yRm9yTm9ybWFsaXphdGlvbihkb2N1bWVudEZlYXR1cmVzLCBjb21wb25lbnRCbG9ja3MpO1xuICAgIGVkaXRvci5jaGlsZHJlbiA9IGRvY3VtZW50O1xuICAgIEVkaXRvci5ub3JtYWxpemUoZWRpdG9yLCB7XG4gICAgICBmb3JjZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBkZXNlcmlhbGl6ZUZpbGVzKGVkaXRvci5jaGlsZHJlbiwgY29tcG9uZW50QmxvY2tzLCBkYXRhLm90aGVyLCBkYXRhLmV4dGVybmFsIHx8IG5ldyBNYXAoKSwgbW9kZSwgZG9jdW1lbnRGZWF0dXJlcywgZGF0YS5zbHVnKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiAnZm9ybScsXG4gICAgZm9ybUtpbmQ6ICdjb250ZW50JyxcbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgIH1dXG4gICAgICB9XTtcbiAgICB9LFxuICAgIElucHV0KHByb3BzKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2pzeChEb2N1bWVudEZpZWxkSW5wdXQsIHtcbiAgICAgICAgY29tcG9uZW50QmxvY2tzOiBjb21wb25lbnRCbG9ja3MsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBkb2N1bWVudEZlYXR1cmVzOiBkb2N1bWVudEZlYXR1cmVzLFxuICAgICAgICAuLi5wcm9wc1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwYXJzZTogcGFyc2UoJ2VkaXQnKSxcbiAgICBjb250ZW50RXh0ZW5zaW9uOiAnLm1kb2MnLFxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBkaXJlY3RvcmllczogWy4uLmNvbGxlY3REaXJlY3Rvcmllc1VzZWRJblNjaGVtYShvYmplY3QoT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGNvbXBvbmVudEJsb2NrcykubWFwKChbbmFtZSwgYmxvY2tdKSA9PiBbbmFtZSwgb2JqZWN0KGJsb2NrLnNjaGVtYSldKSkpKSwgLi4uKHR5cGVvZiBkb2N1bWVudEZlYXR1cmVzLmltYWdlcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRvY3VtZW50RmVhdHVyZXMuaW1hZ2VzLmRpcmVjdG9yeSA9PT0gJ3N0cmluZycgPyBbZml4UGF0aChkb2N1bWVudEZlYXR1cmVzLmltYWdlcy5kaXJlY3RvcnkpXSA6IFtdKV0sXG4gICAgc2VyaWFsaXplKHZhbHVlLCBvcHRzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGV4dHJhRmlsZXMsXG4gICAgICAgIG5vZGVcbiAgICAgIH0gPSB0b01hcmtkb2NEb2N1bWVudCh2YWx1ZSwge1xuICAgICAgICBjb21wb25lbnRCbG9ja3MsXG4gICAgICAgIGRvY3VtZW50RmVhdHVyZXMsXG4gICAgICAgIHNsdWc6IG9wdHMuc2x1Z1xuICAgICAgfSk7XG4gICAgICBjb25zdCBvdGhlciA9IG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IGV4dGVybmFsID0gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGV4dHJhRmlsZXMpIHtcbiAgICAgICAgaWYgKGZpbGUucGFyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvdGhlci5zZXQoZmlsZS5wYXRoLCBmaWxlLmNvbnRlbnRzKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV4dGVybmFsLmhhcyhmaWxlLnBhcmVudCkpIHtcbiAgICAgICAgICBleHRlcm5hbC5zZXQoZmlsZS5wYXJlbnQsIG5ldyBNYXAoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZXJuYWwuZ2V0KGZpbGUucGFyZW50KS5zZXQoZmlsZS5wYXRoLCBmaWxlLmNvbnRlbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IHRleHRFbmNvZGVyLmVuY29kZShNYXJrZG9jLmZvcm1hdChNYXJrZG9jLnBhcnNlKE1hcmtkb2MuZm9ybWF0KG5vZGUpKSkpLFxuICAgICAgICBvdGhlcixcbiAgICAgICAgZXh0ZXJuYWwsXG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfSxcbiAgICByZWFkZXI6IHtcbiAgICAgIHBhcnNlOiBwYXJzZSgncmVhZCcpXG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgeyBnZXRJbmxpbmVOb2RlcyBhcyAkLCBnZXRLZXlzRm9yQXJyYXlWYWx1ZSBhcyBBLCBzZXRLZXlzRm9yQXJyYXlWYWx1ZSBhcyBCLCBnZXRTbHVnRnJvbVN0YXRlIGFzIEMsIGdldEluaXRpYWxQcm9wc1ZhbHVlIGFzIEQsIGdldEFuY2VzdG9yQ29tcG9uZW50Q2hpbGRGaWVsZERvY3VtZW50RmVhdHVyZXMgYXMgRSwgaXNCbG9jayBhcyBGLCBhbGxNYXJrcyBhcyBHLCBpc0xpc3ROb2RlIGFzIEgsIGlzRWxlbWVudEFjdGl2ZSBhcyBJLCBnZXRJbml0aWFsUHJvcHNWYWx1ZUZyb21Jbml0aWFsaXplciBhcyBKLCBLRVlTVEFUSUNfQ0xPVURfQVBJX1VSTCBhcyBLLCBhbGlhc2VzVG9MYWJlbCBhcyBMLCBhbGlhc2VzVG9DYW5vbmljYWxOYW1lIGFzIE0sIGNhbm9uaWNhbE5hbWVUb0xhYmVsIGFzIE4sIGxhYmVsVG9DYW5vbmljYWxOYW1lIGFzIE8sIGxhbmd1YWdlc1dpdGhBbGlhc2VzIGFzIFAsIHRyYW5zZm9ybVByb3BzIGFzIFEsIGdldFZhbHVlQXRQcm9wUGF0aCBhcyBSLCBjbG9uZURlc2NlbmRlbnQgYXMgUywgYXJlQXJyYXlzRXF1YWwgYXMgVCwgZ2V0U2NoZW1hQXRQcm9wUGF0aCBhcyBVLCBmaW5kQ2hpbGRQcm9wUGF0aHMgYXMgViwgZ2V0U2VsZWN0ZWRUYWJsZUFyZWEgYXMgVywgZ2V0UmVsYXRpdmVSb3dQYXRoIGFzIFgsIGNlbGwgYXMgWSwgY2xlYXJGb3JtYXR0aW5nIGFzIFosIEVkaXRvckFmdGVyQnV0SWdub3JpbmdpbmdQb2ludHNXaXRoTm9Db250ZW50IGFzIF8sIEtFWVNUQVRJQ19DTE9VRF9IRUFERVJTIGFzIGEsIGFkZE1hcmtzVG9DaGlsZHJlbiBhcyBhMCwgc2V0TGlua0ZvckNoaWxkcmVuIGFzIGExLCBmb3JjZURpc2FibGVNYXJrRm9yQ2hpbGRyZW4gYXMgYTIsIGFkZE1hcmtUb0NoaWxkcmVuIGFzIGEzLCBnZXRQbGFjZWhvbGRlclRleHRGb3JQcm9wUGF0aCBhcyBhNCwgUHJpc20gYXMgYTUsIF9jcmVhdGVEb2N1bWVudEVkaXRvciBhcyBhNiwgZ2V0V2hvbGVEb2N1bWVudEZlYXR1cmVzRm9yQ2hpbGRGaWVsZCBhcyBhNywgc2VyaWFsaXplUHJvcHMgYXMgYTgsIHVwZGF0ZVRyZWVXaXRoQ2hhbmdlcyBhcyBhOSwgc2hhMSBhcyBhQSwgZ2V0RGVmYXVsdFZhbHVlIGFzIGFCLCBEb2N1bWVudEZpZWxkSW5wdXQgYXMgYUMsIHBhcnNlVG9FZGl0b3JTdGF0ZSBhcyBhRCwgY29sbGVjdERpcmVjdG9yaWVzVXNlZEluU2NoZW1hIGFzIGFFLCBzZXJpYWxpemVGcm9tRWRpdG9yU3RhdGUgYXMgYUYsIHBhcnNlVG9FZGl0b3JTdGF0ZU1EWCBhcyBhRywgc2VyaWFsaXplRnJvbUVkaXRvclN0YXRlTURYIGFzIGFILCBjcmVhdGVFZGl0b3JTY2hlbWEgYXMgYUksIGdldERhdGFGaWxlRXh0ZW5zaW9uIGFzIGFhLCBnZXRTaW5nbGV0b25Gb3JtYXQgYXMgYWIsIGlzQ2xvdWRDb25maWcgYXMgYWMsIEZpZWxkRGF0YUVycm9yIGFzIGFkLCBiYXNpY0Zvcm1GaWVsZFdpdGhTaW1wbGVSZWFkZXJQYXJzZSBhcyBhZSwgQ2hlY2tib3hGaWVsZElucHV0IGFzIGFmLCBEYXRlRmllbGRJbnB1dCBhcyBhZywgYXNzZXJ0UmVxdWlyZWQgYXMgYWgsIERhdGV0aW1lRmllbGRJbnB1dCBhcyBhaSwgSW1hZ2VGaWVsZElucHV0IGFzIGFqLCBnZXRTcmNQcmVmaXggYXMgYWssIGZpeFBhdGggYXMgYWwsIEZpbGVGaWVsZElucHV0IGFzIGFtLCBOdW1iZXJGaWVsZElucHV0IGFzIGFuLCBNdWx0aXNlbGVjdEZpZWxkSW5wdXQgYXMgYW8sIFBhdGhSZWZlcmVuY2VJbnB1dCBhcyBhcCwgUmVsYXRpb25zaGlwSW5wdXQgYXMgYXEsIFNlbGVjdEZpZWxkSW5wdXQgYXMgYXIsIFNsdWdGaWVsZElucHV0IGFzIGFzLCB2YWxpZGF0ZVRleHQgYXMgYXQsIFVybEZpZWxkSW5wdXQgYXMgYXUsIEJsb2Nrc0ZpZWxkSW5wdXQgYXMgYXYsIHRleHQgYXMgYXcsIENsb3VkSW1hZ2VGaWVsZElucHV0IGFzIGF4LCBkb2N1bWVudCQxIGFzIGF5LCBJbnRlZ2VyRmllbGRJbnB1dCBhcyBheiwgZ2V0RW50cmllc0luQ29sbGVjdGlvbldpdGhUcmVlS2V5IGFzIGIsIGdldFNpbmdsZXRvblBhdGggYXMgYywgZ2V0VHJlZU5vZGVBdFBhdGggYXMgZCwgdHJlZVNoYSBhcyBlLCB0cmVlVG9FbnRyaWVzIGFzIGYsIGdldFBhdGhQcmVmaXggYXMgZywgZ2V0QnJhbmNoUHJlZml4IGFzIGgsIGlzR2l0SHViQ29uZmlnIGFzIGksIGdldFNwbGl0Q2xvdWRQcm9qZWN0IGFzIGosIGdldFJlcG9VcmwgYXMgaywgaXNMb2NhbENvbmZpZyBhcyBsLCBnZXRFbnRyeURhdGFGaWxlcGF0aCBhcyBtLCBub2RlVHlwZU1hdGNoZXIgYXMgbiwgb2JqZWN0IGFzIG8sIHBsdXJhbGl6ZSBhcyBwLCBnZXREaXJlY3Rvcmllc0ZvclRyZWVLZXkgYXMgcSwgcmVkaXJlY3RUb0Nsb3VkQXV0aCBhcyByLCBnZXRUcmVlS2V5IGFzIHMsIHRyZWVFbnRyaWVzVG9UcmVlTm9kZXMgYXMgdCwgYmxvYlNoYSBhcyB1LCBnZXRDb2xsZWN0aW9uUGF0aCBhcyB2LCBnZXRDb2xsZWN0aW9uRm9ybWF0IGFzIHcsIGdldENvbGxlY3Rpb25JdGVtUGF0aCBhcyB4LCBnZXRTbHVnR2xvYkZvckNvbGxlY3Rpb24gYXMgeSwgdXBkYXRlVmFsdWUgYXMgeiB9O1xuIl0sIm5hbWVzIjpbIk1hcmtkb2MiLCJFbGVtZW50IiwiRWxlbWVudCQxIiwiUGF0aCIsIk5vZGUiLCJUcmFuc2Zvcm1zIiwiRWRpdG9yIiwiVGV4dCIsIlJhbmdlIiwiUG9pbnQiLCJjcmVhdGVFZGl0b3IiLCJhc3NlcnROZXZlciIsImFzc2VydE5ldmVyJDEiLCJhc3NlcnQiLCJhc3NlcnQkMSIsImZyb21VaW50OEFycmF5IiwiY3JlYXRlSGFzaCIsImpzeCIsIndlYWtNZW1vaXplIiwiZml4UGF0aCIsInBhdGgiLCJyZXBsYWNlIiwiY29sbGVjdGlvblBhdGgiLCJnZXRDb25maWd1cmVkQ29sbGVjdGlvblBhdGgiLCJjb25maWciLCJjb2xsZWN0aW9uIiwiX2NvbGxlY3Rpb25Db25maWckcGF0IiwiY29sbGVjdGlvbkNvbmZpZyIsImNvbGxlY3Rpb25zIiwidGVzdCIsIkVycm9yIiwiZ2V0Q29sbGVjdGlvblBhdGgiLCJjb25maWd1cmVkUGF0aCIsImdldENvbGxlY3Rpb25Gb3JtYXQiLCJfY29sbGVjdGlvbkNvbmZpZyRmb3IiLCJnZXRGb3JtYXRJbmZvIiwiZm9ybWF0Iiwic2NoZW1hIiwiZ2V0U2luZ2xldG9uRm9ybWF0Iiwic2luZ2xldG9uIiwiX3NpbmdsZXRvbkNvbmZpZyRmb3JtIiwiX3NpbmdsZXRvbkNvbmZpZyRwYXRoIiwic2luZ2xldG9uQ29uZmlnIiwic2luZ2xldG9ucyIsImdldENvbGxlY3Rpb25JdGVtUGF0aCIsInNsdWciLCJiYXNlUGF0aCIsInN1ZmZpeCIsImdldENvbGxlY3Rpb25JdGVtU2x1Z1N1ZmZpeCIsImdldEVudHJ5RGF0YUZpbGVwYXRoIiwiZGlyIiwiZm9ybWF0SW5mbyIsImRhdGFMb2NhdGlvbiIsImdldERhdGFGaWxlRXh0ZW5zaW9uIiwiZ2V0U2x1Z0dsb2JGb3JDb2xsZWN0aW9uIiwiaW5jbHVkZXMiLCJnZXRTaW5nbGV0b25QYXRoIiwiX3NpbmdsZXRvbiRwYXRoIiwiX3NpbmdsZXRvbiRwYXRoMiIsImNvbnRlbnRGaWVsZCIsImNvbnRlbnRFeHRlbnNpb24iLCJkYXRhIiwiX2Zvcm1hdCRkYXRhIiwiZW5kc1dpdGgiLCJ1bmRlZmluZWQiLCJmaWVsZCIsImtpbmQiLCJmb3JtS2luZCIsImtleSIsImdldFBhdGhQcmVmaXgiLCJzdG9yYWdlIiwicGF0aFByZWZpeCIsInNoYTEiLCJjb250ZW50IiwidXBkYXRlIiwiZGlnZXN0IiwidGV4dEVuY29kZXIkMiIsIlRleHRFbmNvZGVyIiwiYmxvYlNoYSIsImNvbnRlbnRzIiwiYmxvYlByZWZpeCIsImVuY29kZSIsImxlbmd0aCIsImFycmF5IiwiVWludDhBcnJheSIsImJ5dGVMZW5ndGgiLCJzZXQiLCJnZXRUcmVlTm9kZUF0UGF0aCIsInJvb3QiLCJwYXJ0cyIsInNwbGl0Iiwibm9kZSIsImdldCIsInBhcnQiLCJzbGljZSIsImNoaWxkcmVuIiwiZ2V0Tm9kZUF0UGF0aCIsInRyZWUiLCJoYXMiLCJNYXAiLCJpbm5lck5vZGUiLCJnZXRGaWxlbmFtZSIsImdldERpcm5hbWUiLCJ0b1RyZWVDaGFuZ2VzIiwiY2hhbmdlcyIsImNoYW5nZXNSb290IiwiZGVsZXRpb24iLCJkZWxldGlvbnMiLCJwYXJlbnRUcmVlIiwiYWRkaXRpb24iLCJhZGRpdGlvbnMiLCJTUEFDRV9DSEFSX0NPREUiLCJzcGFjZSIsIm51bGxjaGFyIiwidHJlZVNoYSIsImVudHJpZXMiLCJtYXAiLCJuYW1lIiwic2hhIiwiZW50cnkiLCJtb2RlIiwic29ydCIsImEiLCJiIiwiYU5hbWUiLCJiTmFtZSIsInRyZWVPYmplY3QiLCJmbGF0TWFwIiwiaGV4VG9CeXRlcyIsImNvbmNhdEJ5dGVzIiwicmVkdWNlIiwic3VtIiwidmFsIiwidG9TdHJpbmciLCJieXRlQXJyYXlzIiwidG90YWxMZW5ndGgiLCJhcnIiLCJyZXN1bHQiLCJvZmZzZXQiLCJzdHIiLCJieXRlcyIsImkiLCJzdGFydCIsInBhcnNlSW50IiwiY3JlYXRlVHJlZU5vZGVFbnRyeSIsInR5cGUiLCJjcmVhdGVCbG9iTm9kZUVudHJ5IiwidXBkYXRlVHJlZVdpdGhDaGFuZ2VzIiwiX2F3YWl0JHVwZGF0ZVRyZWUiLCJuZXdUcmVlIiwidXBkYXRlVHJlZSIsInRyZWVUb0VudHJpZXMiLCJ2YWx1ZXMiLCJ4IiwiY2hhbmdlZFRyZWUiLCJ2YWx1ZSIsImRlbGV0ZSIsIl9uZXdUcmVlJGdldCRjaGlsZHJlbiIsIl9uZXdUcmVlJGdldCIsImV4aXN0aW5nQ2hpbGRyZW4iLCJjb25jYXQiLCJqb2luIiwic2l6ZSIsInRyZWVFbnRyaWVzVG9UcmVlTm9kZXMiLCJnZXRDaGlsZHJlbkF0UGF0aCIsIl9ub2RlIiwiY29sbGVjdERpcmVjdG9yaWVzVXNlZEluU2NoZW1hSW5uZXIiLCJkaXJlY3RvcmllcyIsInNlZW5TY2hlbWFzIiwiYWRkIiwiZWxlbWVudCIsImRpcmVjdG9yeSIsIk9iamVjdCIsImZpZWxkcyIsImlubmVyU2NoZW1hIiwiY29sbGVjdERpcmVjdG9yaWVzVXNlZEluU2NoZW1hIiwiU2V0IiwiZ2V0RGlyZWN0b3JpZXNGb3JUcmVlS2V5IiwicHVzaCIsInRvQWRkIiwiZ2V0VHJlZUtleSIsImQiLCJfZ2V0VHJlZU5vZGVBdFBhdGgiLCJwa2dKc29uIiwidmVyc2lvbiIsImxpY2Vuc2UiLCJyZXBvc2l0b3J5IiwidXJsIiwiZXhwb3J0cyIsInR5cGVzIiwiZmlsZXMiLCJzY3JpcHRzIiwic2V0dXAiLCJidWlsZCIsImRldiIsImRlcGVuZGVuY2llcyIsImNvb2tpZSIsImVtZXJ5IiwiZ3JhcGhxbCIsImlnbm9yZSIsIm1pbmltYXRjaCIsInNsYXRlIiwidXJxbCIsInpvZCIsImRldkRlcGVuZGVuY2llcyIsImVzbGludCIsIm91dGRlbnQiLCJwcmlzbWpzIiwicmVhY3QiLCJ0c3giLCJ0eXBlc2NyaXB0IiwicGVlckRlcGVuZGVuY2llcyIsInByZWNvbnN0cnVjdCIsImVudHJ5cG9pbnRzIiwiYWRkVHlwZW5hbWUiLCJzY2FsYXJzIiwiR2l0T2JqZWN0SUQiLCJpbXBvcnRzIiwib2JqZWN0Iiwib3B0cyIsInBsdXJhbGl6ZSIsImNvdW50Iiwib3B0aW9ucyIsInNpbmd1bGFyIiwicGx1cmFsIiwiaW5jbHVzaXZlIiwidmFyaWFudCIsImdldEJyYW5jaFByZWZpeCIsImJyYW5jaFByZWZpeCIsImlzR2l0SHViQ29uZmlnIiwiaXNMb2NhbENvbmZpZyIsImlzQ2xvdWRDb25maWciLCJfY29uZmlnJGNsb3VkIiwiY2xvdWQiLCJwcm9qZWN0IiwiZ2V0U3BsaXRDbG91ZFByb2plY3QiLCJfY29uZmlnJGNsb3VkMiIsInRlYW0iLCJnZXRSZXBvUGF0aCIsIm1haW5Pd25lciIsIm1haW5SZXBvIiwiZ2V0UmVwb1VybCIsImdldFNsdWdGcm9tU3RhdGUiLCJzdGF0ZSIsInNsdWdGaWVsZCIsInNlcmlhbGl6ZVdpdGhTbHVnIiwiZ2V0RW50cmllc0luQ29sbGVjdGlvbldpdGhUcmVlS2V5Iiwicm9vdFRyZWUiLCJfZ2V0VHJlZU5vZGVBdFBhdGgkY2giLCJleHRlbnNpb24iLCJnbG9iIiwiZGlyZWN0b3JpZXNVc2VkSW5TY2hlbWEiLCJwb3NzaWJsZUVudHJpZXMiLCJoYW5kbGVEaXJlY3RvcnkiLCJwcmVmaXgiLCJfYWN0dWFsRW50cnkkY2hpbGRyZW4iLCJhY3R1YWxFbnRyeSIsIm5ld0VudHJ5IiwiS0VZU1RBVElDX0NMT1VEX0FQSV9VUkwiLCJLRVlTVEFUSUNfQ0xPVURfSEVBREVSUyIsInRleHRFbmNvZGVyJDEiLCJyZWRpcmVjdFRvQ2xvdWRBdXRoIiwiZnJvbSIsIl9jb25maWckY2xvdWQzIiwiY29kZV92ZXJpZmllciIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsImNvZGVfY2hhbGxlbmdlIiwic3VidGxlIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImhyZWYiLCJ0YWJsZUNlbGxDaGlsZHJlbiIsImJsb2NrcXVvdGVDaGlsZHJlbiIsInBhcmFncmFwaExpa2UiLCJpbnNpZGVPZkxheW91dHMiLCJibG9ja0NvbnRhaW5lciIsImFyZ3MiLCJhbGxvd2VkQ2hpbGRyZW4iLCJibG9ja1RvV3JhcElubGluZXNJbiIsImludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGUiLCJpbmxpbmVDb250YWluZXIiLCJlZGl0b3JTY2hlbWEiLCJlZGl0b3IiLCJsYXlvdXQiLCJibG9ja3F1b3RlIiwicGFyYWdyYXBoIiwiY29kZSIsImRpdmlkZXIiLCJoZWFkaW5nIiwiaW1hZ2UiLCJ0YWJsZSIsImlubGluZUNvbnRhaW5lclR5cGVzIiwiZmlsdGVyIiwiaXNJbmxpbmVDb250YWluZXIiLCJibG9ja1R5cGVzIiwia2V5cyIsImlzQmxvY2siLCJnZXRXaG9sZURvY3VtZW50RmVhdHVyZXNGb3JDaGlsZEZpZWxkIiwiZWRpdG9yRG9jdW1lbnRGZWF0dXJlcyIsIl9vcHRpb25zJGZvcm1hdHRpbmciLCJfb3B0aW9ucyRmb3JtYXR0aW5nMiIsIl9vcHRpb25zJGZvcm1hdHRpbmczIiwiX29wdGlvbnMkZm9ybWF0dGluZzQiLCJfb3B0aW9ucyRmb3JtYXR0aW5nNSIsIl9vcHRpb25zJGZvcm1hdHRpbmc2IiwiX29wdGlvbnMkZm9ybWF0dGluZzciLCJpbmxpbmVNYXJrc0Zyb21PcHRpb25zIiwiZm9ybWF0dGluZyIsImlubGluZU1hcmtzIiwiZnJvbUVudHJpZXMiLCJfbWFyayIsIm1hcmsiLCJoZWFkaW5nTGV2ZWxzIiwic29mdEJyZWFrcyIsImFsaWdubWVudCIsImNlbnRlciIsImVuZCIsImhlYWRpbmdzIiwibGV2ZWxzIiwibGV2ZWwiLCJsaXN0VHlwZXMiLCJvcmRlcmVkIiwidW5vcmRlcmVkIiwiZGl2aWRlcnMiLCJpbWFnZXMiLCJsYXlvdXRzIiwibGlua3MiLCJ0YWJsZXMiLCJnZXREb2N1bWVudEZlYXR1cmVzRm9yQ2hpbGRGaWVsZCIsIl9vcHRpb25zJGZvcm1hdHRpbmc4IiwiX29wdGlvbnMkZm9ybWF0dGluZzEwIiwiX29wdGlvbnMkZm9ybWF0dGluZzExIiwiX29wdGlvbnMkZm9ybWF0dGluZzEyIiwiX29wdGlvbnMkZm9ybWF0dGluZzEzIiwiX29wdGlvbnMkZm9ybWF0dGluZzE0IiwiX29wdGlvbnMkZm9ybWF0dGluZzkiLCJkb2N1bWVudEZlYXR1cmVzIiwiY29tcG9uZW50QmxvY2tzIiwiZ2V0U2NoZW1hQXRQcm9wUGF0aElubmVyIiwic2hpZnQiLCJkaXNjcmltaW5hbnQiLCJwcm9wVmFsIiwiaW5kZXgiLCJnZXRTY2hlbWFBdFByb3BQYXRoIiwicHJvcHMiLCJnZXRBbmNlc3RvclNjaGVtYXMiLCJyb290U2NoZW1hIiwiYW5jZXN0b3JzIiwiY3VycmVudFBhdGgiLCJjdXJyZW50UHJvcCIsImN1cnJlbnRWYWx1ZSIsImdldFBsYWNlaG9sZGVyVGV4dEZvclByb3BQYXRoIiwicHJvcFBhdGgiLCJmb3JtUHJvcHMiLCJlZGl0SW4iLCJwbGFjZWhvbGRlciIsImNsb25lRGVzY2VuZGVudCIsImlzRWxlbWVudCIsImFsbE1hcmtzIiwiaXNFbGVtZW50QWN0aXZlIiwibWF0Y2giLCJub2RlcyIsIm4iLCJjbGVhckZvcm1hdHRpbmciLCJ1bndyYXBOb2RlcyIsInVuc2V0Tm9kZXMiLCJpc1RleHQiLCJtb3ZlQ2hpbGRyZW4iLCJwYXJlbnQiLCJ0byIsInNob3VsZE1vdmVOb2RlIiwicGFyZW50UGF0aCIsImlzUGF0aCIsInBhcmVudE5vZGUiLCJjaGlsZFBhdGgiLCJtb3ZlTm9kZXMiLCJhdCIsIkVkaXRvckFmdGVyQnV0SWdub3JpbmdpbmdQb2ludHNXaXRoTm9Db250ZW50IiwiZGlzdGFuY2UiLCJhbmNob3IiLCJwb2ludCIsImVkZ2UiLCJmb2N1cyIsInJhbmdlIiwidGFyZ2V0IiwicCIsInBvc2l0aW9ucyIsInRleHQiLCJub2RlVHlwZU1hdGNoZXIiLCJnZXRBbmNlc3RvckNvbXBvbmVudENoaWxkRmllbGREb2N1bWVudEZlYXR1cmVzIiwiYW5jZXN0b3JDb21wb25lbnRQcm9wIiwiYWJvdmUiLCJhbmNlc3RvckNvbXBvbmVudCIsImNvbXBvbmVudCIsImNvbXBvbmVudEJsb2NrIiwiY2hpbGRGaWVsZCIsImVtcHR5IiwiU2x1Z0ZpZWxkSW5wdXQiLCJUZXh0RmllbGRJbnB1dCIsIlVybEZpZWxkSW5wdXQiLCJTZWxlY3RGaWVsZElucHV0IiwiUmVsYXRpb25zaGlwSW5wdXQiLCJQYXRoUmVmZXJlbmNlSW5wdXQiLCJNdWx0aXNlbGVjdEZpZWxkSW5wdXQiLCJJbnRlZ2VyRmllbGRJbnB1dCIsIk51bWJlckZpZWxkSW5wdXQiLCJJbWFnZUZpZWxkSW5wdXQiLCJGaWxlRmllbGRJbnB1dCIsIkRhdGV0aW1lRmllbGRJbnB1dCIsIkRhdGVGaWVsZElucHV0IiwiQ2xvdWRJbWFnZUZpZWxkSW5wdXQiLCJCbG9ja3NGaWVsZElucHV0IiwiRG9jdW1lbnRGaWVsZElucHV0IiwiQ2hlY2tib3hGaWVsZElucHV0IiwiY3JlYXRlRWRpdG9yU2NoZW1hIiwiZ2V0RGVmYXVsdFZhbHVlIiwicGFyc2VUb0VkaXRvclN0YXRlIiwic2VyaWFsaXplRnJvbUVkaXRvclN0YXRlIiwicGFyc2VUb0VkaXRvclN0YXRlTURYIiwic2VyaWFsaXplRnJvbUVkaXRvclN0YXRlTURYIiwiRmllbGREYXRhRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJhc3NlcnRSZXF1aXJlZCIsInZhbGlkYXRpb24iLCJsYWJlbCIsImlzUmVxdWlyZWQiLCJiYXNpY0Zvcm1GaWVsZFdpdGhTaW1wbGVSZWFkZXJQYXJzZSIsIklucHV0IiwiZGVmYXVsdFZhbHVlIiwicGFyc2UiLCJzZXJpYWxpemUiLCJ2YWxpZGF0ZSIsInJlYWRlciIsImFycmF5VmFsdWVzVG9FbGVtZW50S2V5cyIsIldlYWtNYXAiLCJjb3VudGVyIiwiZ2V0S2V5c0ZvckFycmF5VmFsdWUiLCJBcnJheSIsImdldE5ld0FycmF5RWxlbWVudEtleSIsInNldEtleXNGb3JBcnJheVZhbHVlIiwiZWxlbWVudElkcyIsImdldEluaXRpYWxQcm9wc1ZhbHVlIiwiX2dldEluaXRpYWxQcm9wc1ZhbHVlIiwib2JqIiwiZ2V0SW5pdGlhbFByb3BzVmFsdWVGcm9tSW5pdGlhbGl6ZXIiLCJpbml0aWFsaXplciIsInVwZGF0ZVZhbHVlIiwidXBkYXRlciIsImN1cnJlbnRBcnJWYWwiLCJuZXdWYWwiLCJ1bmlxdWVLZXlzIiwiZWxlbWVudEtleSIsInByZXZLZXlzIiwicHJldlZhbHVlc0J5S2V5IiwiaWQiLCJnZXRWYWx1ZUF0UHJvcFBhdGgiLCJpbnB1dFBhdGgiLCJ0cmF2ZXJzZVByb3BzIiwidmlzaXRvciIsImNoaWxkUHJvcCIsImlkeCIsInRyYW5zZm9ybVByb3BzIiwidmlzaXRvcnMiLCJjb25kaXRpb25hbFZhbCIsImNvbmRpdGlvbmFsIiwicmVwbGFjZVZhbHVlQXRQcm9wUGF0aCIsIm5ld1ZhbHVlIiwibmV3UGF0aCIsImNvbmRpdGlvbmFsVmFsdWUiLCJwcmV2VmFsIiwiY3VycmVudGx5QWN0aXZlTWFya3MiLCJjdXJyZW50bHlEaXNhYmxlZE1hcmtzIiwiY3VycmVudExpbmsiLCJhZGRNYXJrVG9DaGlsZHJlbiIsImNiIiwid2FzUHJldmlvdXNseUFjdGl2ZSIsInNldExpbmtGb3JDaGlsZHJlbiIsImFkZE1hcmtzVG9DaGlsZHJlbiIsIm1hcmtzIiwibWFya3NUb1JlbW92ZSIsImZvcmNlRGlzYWJsZU1hcmtGb3JDaGlsZHJlbiIsIndhc1ByZXZpb3VzbHlEaXNhYmxlZCIsImdldElubGluZU5vZGVzIiwiVmFyaWFibGVDaGlsZEZpZWxkcyIsImZpbmRTaW5nbGVDaGlsZEZpZWxkIiwiX2ZpbmRDb25zdGFudENoaWxkRmllbGRzIiwiZXJyIiwicmVsYXRpdmVQYXRoIiwiY291bGRDb250YWluQ2hpbGRGaWVsZCIsImFzQ2hpbGRUYWciLCJjaGlsZCIsInBhdGhzIiwic2VlbiIsInNvbWUiLCJpbmxpbmVOb2RlRnJvbU1hcmtkb2MiLCJpbmxpbmVDaGlsZHJlbkZyb21NYXJrZG9jIiwiYXR0cmlidXRlcyIsInRhZyIsImlzQXJyYXkiLCJldmVyeSIsImlubGluZUZyb21NYXJrZG9jIiwidHJhbnNmb3JtZWROb2RlcyIsIm5leHROb2RlcyIsImxhc3ROb2RlIiwiX2xhc3ROb2RlIiwiZnJvbU1hcmtkb2MiLCJmcm9tTWFya2RvY05vZGUiLCJsYW5ndWFnZSIsInJlc3QiLCJfbm9kZSRjaGlsZHJlbiQiLCJsaXN0IiwiX2ltYWdlJGF0dHJpYnV0ZXMkdGl0Iiwic3JjIiwiZGVjb2RlVVJJIiwiYWx0IiwidGl0bGUiLCJ0ZXh0QWxpZ24iLCJoZWFkZXIiLCJzaW5nbGVDaGlsZEZpZWxkIiwibmV3QXR0cmlidXRlcyIsInRvQ2hpbGRyZW5BbmRQcm9wcyQxIiwicmVzdWx0aW5nQ2hpbGRyZW4iLCJwYXJlbnRQcm9wUGF0aCIsImFyZUFycmF5c0VxdWFsIiwibm9ybWFsaXplVGV4dEJhc2VkT25JbmxpbmVNYXJrc0FuZFNvZnRCcmVha3MiLCJoYXNTb2Z0QnJlYWtzIiwicG9zaXRpb24iLCJjaGFyYWN0ZXIiLCJub3JtYWxpemVJbmxpbmVCYXNlZE9uTGlua3MiLCJpbnNlcnRUZXh0Iiwibm9ybWFsaXplRWxlbWVudEJhc2VkT25Eb2N1bWVudEZlYXR1cmVzIiwicmVtb3ZlTm9kZXMiLCJ3aXRoRG9jdW1lbnRGZWF0dXJlc05vcm1hbGl6YXRpb24iLCJub3JtYWxpemVOb2RlIiwiZ2V0U3JjUHJlZml4IiwicHVibGljUGF0aCIsImRlc2VyaWFsaXplRmlsZXMiLCJvdGhlckZpbGVzIiwiZGVzZXJpYWxpemVQcm9wcyIsIl9yZWYiLCJnZXRTcmNQcmVmaXhGb3JJbWFnZUJsb2NrIiwiZmlsZW5hbWUiLCJmb3JtIiwiX290aGVyRmlsZXMkZ2V0Iiwic3VnZ2VzdGVkRmlsZW5hbWVQcmVmaXgiLCJhc3NldCIsInNlcmlhbGl6ZVByb3BzIiwicm9vdFZhbHVlIiwic2hvdWxkU3VnZ2VzdEZpbGVuYW1lUHJlZml4IiwiZXh0cmFGaWxlcyIsImZvcllhbWwiLCJnZXRQcm9wUGF0aFBvcnRpb24iLCJvdGhlciIsImV4dGVybmFsIiwiYWxsb3dlZERpcmVjdG9yaWVzIiwiZmlsZUNvbnRlbnRzIiwiX3NjaGVtYSIsIl8iLCJwb3J0aW9uIiwiQXN0IiwidG9JbmxpbmUiLCJ0b01hcmtkb2NJbmxpbmUiLCJtYXJrVG9NYXJrZG9jIiwiYm9sZCIsIml0YWxpYyIsInVuZGVybGluZSIsImtleWJvYXJkIiwic3RyaWtldGhyb3VnaCIsInN1YnNjcmlwdCIsInN1cGVyc2NyaXB0IiwiX2V4ZWMiLCJfZXhlYzIiLCJzcGxpdEJ5TmV3TGluZXMiLCJpbm5lciIsImxlYWRpbmdXaGl0ZXNwYWNlIiwiZXhlYyIsInRyYWlsaW5nV2hpdGVzcGFjZSIsInRyaW0iLCJ1bnNoaWZ0IiwidG9NYXJrZG9jRG9jdW1lbnQiLCJfY29uZmlnIiwidG9NYXJrZG9jIiwidG9DaGlsZHJlbkFuZFByb3BzIiwiY2hpbGRyZW5Bc01hcmtkb2MiLCJmaW5kIiwidmFsdWVBdFByb3BQYXRoIiwiY2hpbGROb2RlcyIsImlubmVyUHJvcFBhdGgiLCJudW0iLCJfY2hpbGROb2RlcyRnZXQiLCJuZXdDaGlsZHJlbkFzTWFya2RvYyIsIm1hcmtkb2NOb2RlIiwiYW5ub3RhdGlvbnMiLCJlbmNvZGVVUkkiLCJleHRyYUF0dHJpYnV0ZXMiLCJzZXJpYWxpemVkIiwiYXNzaWduIiwiX3RvTWFya2RvYyIsImhlYWQiLCJpc1ZvaWQiLCJsaXN0SXRlbUNvbnRlbnQiLCJpbmxpbmUiLCJuZXN0ZWRMaXN0IiwidmFsaWRhdGVUZXh0IiwibWluIiwibWF4IiwiZmllbGRMYWJlbCIsInNsdWdJbmZvIiwicyIsInNsdWdzIiwicGFyc2VBc05vcm1hbEZpZWxkIiwiZW1wdHlTZXQiLCJJbmZpbml0eSIsImRlc2NyaXB0aW9uIiwibXVsdGlsaW5lIiwicGFyc2VkIiwicGFyc2VXaXRoU2x1ZyIsIl92YWx1ZSIsImdsb2JhbFRoaXMiLCJQcmlzbSIsIm1hbnVhbCIsIl9zZWxmIiwibGFuZyIsInVuaXF1ZUlkIiwicGxhaW5UZXh0R3JhbW1hciIsImRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlciIsInV0aWwiLCJ0b2tlbnMiLCJUb2tlbiIsImFsaWFzIiwibyIsInByb3RvdHlwZSIsImNhbGwiLCJvYmpJZCIsImRlZmluZVByb3BlcnR5IiwiY2xvbmUiLCJkZWVwQ2xvbmUiLCJ2aXNpdGVkIiwiaGFzT3duUHJvcGVydHkiLCJmb3JFYWNoIiwidiIsImdldExhbmd1YWdlIiwibSIsImNsYXNzTmFtZSIsInRvTG93ZXJDYXNlIiwicGFyZW50RWxlbWVudCIsInNldExhbmd1YWdlIiwiUmVnRXhwIiwiY2xhc3NMaXN0IiwiY3VycmVudFNjcmlwdCIsImRvY3VtZW50Iiwic3RhY2siLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImlzQWN0aXZlIiwiZGVmYXVsdEFjdGl2YXRpb24iLCJubyIsImNvbnRhaW5zIiwibGFuZ3VhZ2VzIiwicGxhaW4iLCJwbGFpbnRleHQiLCJ0eHQiLCJleHRlbmQiLCJyZWRlZiIsImluc2VydEJlZm9yZSIsImluc2lkZSIsImJlZm9yZSIsImluc2VydCIsImdyYW1tYXIiLCJyZXQiLCJ0b2tlbiIsIm5ld1Rva2VuIiwib2xkIiwiREZTIiwiY2FsbGJhY2siLCJwcm9wZXJ0eSIsInByb3BlcnR5VHlwZSIsInBsdWdpbnMiLCJoaWdobGlnaHRBbGwiLCJhc3luYyIsImhpZ2hsaWdodEFsbFVuZGVyIiwiY29udGFpbmVyIiwiZW52Iiwic2VsZWN0b3IiLCJob29rcyIsInJ1biIsImVsZW1lbnRzIiwiYXBwbHkiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaGlnaGxpZ2h0RWxlbWVudCIsIm5vZGVOYW1lIiwidGV4dENvbnRlbnQiLCJpbnNlcnRIaWdobGlnaHRlZENvZGUiLCJoaWdobGlnaHRlZENvZGUiLCJpbm5lckhUTUwiLCJoYXNBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJXb3JrZXIiLCJ3b3JrZXIiLCJvbm1lc3NhZ2UiLCJldnQiLCJwb3N0TWVzc2FnZSIsImltbWVkaWF0ZUNsb3NlIiwiaGlnaGxpZ2h0IiwidG9rZW5pemUiLCJ0b2tlbkxpc3QiLCJMaW5rZWRMaXN0IiwiYWRkQWZ0ZXIiLCJtYXRjaEdyYW1tYXIiLCJ0b0FycmF5IiwiYWxsIiwiY2FsbGJhY2tzIiwibWF0Y2hlZFN0ciIsImUiLCJjbGFzc2VzIiwiYWxpYXNlcyIsIm1hdGNoUGF0dGVybiIsInBhdHRlcm4iLCJwb3MiLCJsb29rYmVoaW5kIiwibGFzdEluZGV4IiwibG9va2JlaGluZExlbmd0aCIsInN0YXJ0Tm9kZSIsInN0YXJ0UG9zIiwicmVtYXRjaCIsInBhdHRlcm5zIiwiaiIsImNhdXNlIiwicGF0dGVybk9iaiIsImdyZWVkeSIsImdsb2JhbCIsImZsYWdzIiwic291cmNlIiwiY3VycmVudE5vZGUiLCJuZXh0IiwidGFpbCIsInJlYWNoIiwicmVtb3ZlQ291bnQiLCJrIiwibWF0Y2hTdHIiLCJhZnRlciIsInJlbW92ZUZyb20iLCJwcmV2IiwicmVtb3ZlUmFuZ2UiLCJ3cmFwcGVkIiwibmVzdGVkUmVtYXRjaCIsIm5ld05vZGUiLCJhZGRFdmVudExpc3RlbmVyIiwiY2xvc2UiLCJzY3JpcHQiLCJoaWdobGlnaHRBdXRvbWF0aWNhbGx5Q2FsbGJhY2siLCJyZWFkeVN0YXRlIiwiZGVmZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzZXRUaW1lb3V0IiwibWFya3VwIiwiYWRkSW5saW5lZCIsInRhZ05hbWUiLCJpbmNsdWRlZENkYXRhSW5zaWRlIiwiZGVmIiwiYXR0ck5hbWUiLCJodG1sIiwibWF0aG1sIiwic3ZnIiwieG1sIiwic3NtbCIsImF0b20iLCJyc3MiLCJzdHJpbmciLCJjc3MiLCJhZGRBdHRyaWJ1dGUiLCJjbGlrZSIsImphdmFzY3JpcHQiLCJyZWdleCIsImpzIiwibWF0Y2hlcyIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwiTE9BRElOR19NRVNTQUdFIiwiRkFJTFVSRV9NRVNTQUdFIiwic3RhdHVzIiwiRkFJTFVSRV9FTVBUWV9NRVNTQUdFIiwiRVhURU5TSU9OUyIsIlNUQVRVU19BVFRSIiwiU1RBVFVTX0xPQURJTkciLCJTVEFUVVNfTE9BREVEIiwiU1RBVFVTX0ZBSUxFRCIsIlNFTEVDVE9SIiwibG9hZEZpbGUiLCJzdWNjZXNzIiwiZXJyb3IiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZXNwb25zZVRleHQiLCJzdGF0dXNUZXh0Iiwic2VuZCIsInBhcnNlUmFuZ2UiLCJOdW1iZXIiLCJjb21tYSIsInByZSIsImFwcGVuZENoaWxkIiwiY3JlYXRlRWxlbWVudCIsImdldEF0dHJpYnV0ZSIsImF1dG9sb2FkZXIiLCJsb2FkTGFuZ3VhZ2VzIiwibGluZXMiLCJNYXRoIiwiU3RyaW5nIiwiZmlsZUhpZ2hsaWdodCIsImxvZ2dlZCIsImNvbnNvbGUiLCJ3YXJuIiwiYXJndW1lbnRzIiwiYyIsImtleXdvcmQiLCJtb2ROYW1lIiwiY3BwIiwiYXJkdWlubyIsImlubyIsImVudlZhcnMiLCJjb21tYW5kQWZ0ZXJIZXJlZG9jIiwiaW5zaWRlU3RyaW5nIiwiYmFzaCIsImVudGl0eSIsInZhcmlhYmxlIiwidG9CZUNvcGllZCIsInNoIiwic2hlbGwiLCJyZXBsYWNlbWVudHMiLCJyZSIsIm5lc3RlZCIsImRlcHRoTG9nMiIsImtleXdvcmRLaW5kcyIsInR5cGVEZWNsYXJhdGlvbiIsImNvbnRleHR1YWwiLCJrZXl3b3Jkc1RvUGF0dGVybiIsIndvcmRzIiwidHlwZURlY2xhcmF0aW9uS2V5d29yZHMiLCJrZXl3b3JkcyIsIm5vblR5cGVLZXl3b3JkcyIsIm5vbkNvbnRleHR1YWxLZXl3b3JkcyIsImdlbmVyaWMiLCJuZXN0ZWRSb3VuZCIsImdlbmVyaWNOYW1lIiwiaWRlbnRpZmllciIsInR5cGVFeHByZXNzaW9uV2l0aG91dFR1cGxlIiwidHVwbGVFbGVtZW50IiwidHVwbGUiLCJ0eXBlRXhwcmVzc2lvbiIsInR5cGVJbnNpZGUiLCJyZWd1bGFyU3RyaW5nIiwidmVyYmF0aW1TdHJpbmciLCJjc2hhcnAiLCJyZWd1bGFyU3RyaW5nT3JDaGFyYWN0ZXIiLCJyZWd1bGFyU3RyaW5nQ2hhcmFjdGVyT3JDb21tZW50Iiwicm91bmRFeHByZXNzaW9uIiwiYXR0clRhcmdldCIsImF0dHIiLCJmb3JtYXRTdHJpbmciLCJtSW50ZXJwb2xhdGlvblJvdW5kIiwibUludGVycG9sYXRpb24iLCJzSW50ZXJwb2xhdGlvblJvdW5kIiwic0ludGVycG9sYXRpb24iLCJjcmVhdGVJbnRlcnBvbGF0aW9uSW5zaWRlIiwiaW50ZXJwb2xhdGlvbiIsImludGVycG9sYXRpb25Sb3VuZCIsImRvdG5ldCIsImNzIiwiZGlmZiIsIlBSRUZJWEVTIiwiZ28iLCJpbmkiLCJjbGFzc05hbWVQcmVmaXgiLCJqYXZhIiwiZnVuY3Rpb24iLCJuYW1lc3BhY2UiLCJzcGVjaWFsRXNjYXBlIiwiZXNjYXBlIiwiY2hhclNldCIsImNoYXJTZXRXaXRob3V0RG90IiwicmFuZ2VDaGFyIiwiZ3JvdXBOYW1lIiwiYnJhY2VzIiwic3ByZWFkIiwic3RyaW5naWZ5VG9rZW4iLCJ3YWxrVG9rZW5zIiwib3BlbmVkVGFncyIsIm5vdFRhZ05vckJyYWNlIiwicG9wIiwib3BlbmVkQnJhY2VzIiwicGxhaW5UZXh0Iiwic3BsaWNlIiwianNvbiIsIndlYm1hbmlmZXN0Iiwia290bGluIiwiaW50ZXJwb2xhdGlvbkluc2lkZSIsImt0Iiwia3RzIiwibGVzcyIsImx1YSIsIm1ha2VmaWxlIiwiYW5jaG9yT3JBbGlhcyIsInByb3BlcnRpZXMiLCJwbGFpbktleSIsImNyZWF0ZVZhbHVlUGF0dGVybiIsInlhbWwiLCJ5bWwiLCJjcmVhdGVJbmxpbmUiLCJ0YWJsZUNlbGwiLCJ0YWJsZVJvdyIsInRhYmxlTGluZSIsIm1hcmtkb3duIiwicHVuY3R1YXRpb24iLCJsIiwiY29kZUxhbmciLCJjb2RlQmxvY2siLCJjbHMiLCJEYXRlIiwidmFsdWVPZiIsImZsb29yIiwicmFuZG9tIiwiZWxlIiwiZ2V0RWxlbWVudEJ5SWQiLCJ0YWdQYXR0ZXJuIiwiS05PV05fRU5USVRZX05BTUVTIiwiZnJvbUNvZGVQb2ludCIsImZyb21DaGFyQ29kZSIsImtub3duIiwibWQiLCJvYmplY3RpdmVjIiwib2JqYyIsImJyYWNrZXRzIiwicGVybCIsImdldFBsYWNlaG9sZGVyIiwidG9VcHBlckNhc2UiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiYnVpbGRQbGFjZWhvbGRlcnMiLCJwbGFjZWhvbGRlclBhdHRlcm4iLCJyZXBsYWNlRmlsdGVyIiwidG9rZW5TdGFjayIsImluZGV4T2YiLCJ0b2tlbml6ZVBsYWNlaG9sZGVycyIsInQiLCJzdWJzdHJpbmciLCJtaWRkbGUiLCJyZXBsYWNlbWVudCIsImNvbW1lbnQiLCJjb25zdGFudCIsIm51bWJlciIsIm9wZXJhdG9yIiwicGhwIiwic3RyaW5nX2ludGVycG9sYXRpb24iLCJwaHBQYXR0ZXJuIiwicHl0aG9uIiwicHkiLCJyIiwicnVieSIsInBlcmNlbnRFeHByZXNzaW9uIiwic3ltYm9sTmFtZSIsInJiIiwibXVsdGlsaW5lQ29tbWVudCIsInJ1c3QiLCJzYXNzIiwiYXRydWxlIiwiaW1wb3J0YW50Iiwic2NzcyIsInNxbCIsInN3aWZ0IiwicnVsZSIsInRzIiwiYmFzaWMiLCJ2Ym5ldCIsImNhbm9uaWNhbE5hbWVUb0xhYmVsIiwibGFiZWxUb0Nhbm9uaWNhbE5hbWUiLCJsYW5ndWFnZVRvQ2Fub25pY2FsTmFtZSIsImFsaWFzZXNUb0Nhbm9uaWNhbE5hbWUiLCJjYW5vbmljYWxOYW1lIiwibGFuZ3VhZ2VzVG9BbGlhc2VzIiwibGFuZ3VhZ2VzV2l0aEFsaWFzZXMiLCJhbGlhc2VzVG9MYWJlbCIsImNvZGVCbG9ja1Nob3J0Y3V0UGF0dGVybiIsIndpdGhDb2RlQmxvY2siLCJpbnNlcnRCcmVhayIsImNvZGVCbG9ja1Nob3J0Y3V0IiwiYmxvY2siLCJfYWxpYXNlc1RvQ2Fub25pY2FsTmEiLCJsb2NhdGlvbkRvY3VtZW50RmVhdHVyZXMiLCJoaXN0b3J5IiwidW5kb3MiLCJvcGVyYXRpb25zIiwic2VsZWN0aW9uQmVmb3JlIiwic2VsZWN0aW9uIiwic2VsZWN0Iiwid3JhcE5vZGVzIiwiaXNDb2xsYXBzZWQiLCJlcXVhbHMiLCJzZXROb2RlcyIsImNoaWxkTm9kZSIsImZpbmRDaGlsZFByb3BQYXRoc0ZvclByb3AiLCJmaW5kQ2hpbGRQcm9wUGF0aHMiLCJwcm9wUGF0aHMiLCJnZXRBbmNlc3RvckNvbXBvbmVudEJsb2NrIiwiYW5jZXN0b3JFbnRyeSIsImlzSW5zaWRlIiwicHJvcCIsImFscmVhZHlOb3JtYWxpemVkVGhpbmdzIiwibm9ybWFsaXplTm9kZVdpdGhpbkNvbXBvbmVudFByb3AiLCJmaWVsZE9wdGlvbnMiLCJhbHJlYWR5Tm9ybWFsaXplZE5vZGVzIiwiV2Vha1NldCIsImRpZE5vcm1hbGl6YXRpb24iLCJjaGlsZHJlbkhhc0NoYW5nZWQiLCJjYW5TY2hlbWFDb250YWluQ2hpbGRGaWVsZCIsInF1ZXVlIiwiaW5uZXJQcm9wIiwiZG9lc1NjaGVtYU9ubHlFdmVyQ29udGFpbkFTaW5nbGVDaGlsZEZpZWxkIiwiaGFzRm91bmRDaGlsZEZpZWxkIiwiZmluZEFycmF5RmllbGRzV2l0aFNpbmdsZUNoaWxkRmllbGQiLCJpc0VtcHR5Q2hpbGRGaWVsZE5vZGUiLCJmaXJzdENoaWxkIiwid2l0aENvbXBvbmVudEJsb2NrcyIsImJsb2NrQ29tcG9uZW50cyIsIm1lbW9pemVkR2V0RG9jdW1lbnRGZWF0dXJlc0ZvckNoaWxkRmllbGQiLCJkZWxldGVCYWNrd2FyZCIsInVuaXQiLCJhbmNlc3RvckNvbXBvbmVudEJsb2NrIiwiaXNTdGFydCIsImNvbXBvbmVudFByb3BOb2RlIiwiY29tcG9uZW50UHJvcFBhdGgiLCJjb21wb25lbnRCbG9ja05vZGUiLCJjb21wb25lbnRCbG9ja1BhdGgiLCJpc0xhc3RQcm9wIiwicGFyYWdyYXBoTm9kZSIsInBhcmFncmFwaFBhdGgiLCJpc0xhc3RQYXJhZ3JhcGgiLCJtb3ZlIiwid2l0aG91dE5vcm1hbGl6aW5nIiwiYW5jZXN0b3JGaWVsZHMiLCJyZXZlcnNlIiwiZmluZEluZGV4IiwiaXRlbSIsImFycmF5RmllbGRJZHgiLCJhcnJheUZpZWxkIiwiaW5zZXJ0Tm9kZXMiLCJzcGxpdE5vZGVzIiwiYWx3YXlzIiwic3BsaXROb2RlUGF0aCIsInVwZGF0ZWRQcm9wcyIsImFkZE1pc3NpbmdGaWVsZHMiLCJub2Rlc1dpdGhpbiIsInN1YlBhdGgiLCJhcnJWYWwiLCJwcmV2S2V5c1NldCIsImFscmVhZHlVc2VkSW5kaWNpZXMiLCJuZXdLZXlzIiwiZ2V0TmV3S2V5IiwiaWR4RnJvbVZhbHVlIiwidHJhbnNmb3JtZWRQcm9wcyIsImlkeEluQ2hpbGRyZW5PZkJsb2NrIiwibm9kZVdpdGhpbiIsIm5ld1Byb3BQYXRoIiwibWlzc2luZ0tleXMiLCJmb3VuZFByb3BzIiwic3RyaW5naWZpZWRJbmxpbmVQcm9wUGF0aHMiLCJzdHJpbmdpZmllZFByb3BQYXRoIiwicHJvcEluZm8iLCJleHBlY3RlZEluZGV4IiwiZXhwZWN0ZWRDaGlsZE5vZGVUeXBlIiwidXBkYXRlZElubmVyVmFsdWUiLCJhcnJWYWx1ZSIsIm5ld0FyclZhbHVlIiwib2JqZWN0VmFsdWUiLCJoYXNDaGFuZ2VkIiwibmV3T2JqZWN0VmFsdWUiLCJpbm5lclZhbHVlIiwibmV3SW5uZXJWYWx1ZSIsInBhcmFncmFwaEVsZW1lbnQiLCJ3aXRoUGFyYWdyYXBocyIsImlzRWRpdG9yIiwid2l0aExheW91dHMiLCJhYm92ZU5vZGUiLCJhYm92ZVBhdGgiLCJsYXlvdXRBcmVhVG9SZW1vdmVQYXRoIiwibWFya2Rvd25MaW5rUGF0dGVybiIsIndpdGhMaW5rIiwiaXNJbmxpbmUiLCJzdGFydE9mQmxvY2siLCJzdGFydE9mQmxvY2tUb0VuZE9mU2hvcnRjdXRTdHJpbmciLCJhbmNlc3RvckNvbXBvbmVudENoaWxkRmllbGREb2N1bWVudEZlYXR1cmVzIiwibWF5YmVXaGl0ZXNwYWNlIiwibGlua1RleHQiLCJzdGFydE9mU2hvcnRjdXQiLCJzdGFydE9mTGlua1RleHQiLCJlbmRPZkxpbmtUZXh0IiwibmV4dE5vZGUiLCJsYXN0TWVyZ2FibGVMaW5rIiwiX2xhc3RNZXJnYWJsZUxpbmsiLCJmaXJzdExpbmtQYXRoIiwic2Vjb25kTGlua1BhdGgiLCJpc0xpc3RUeXBlIiwiaXNMaXN0Tm9kZSIsImdldEFuY2VzdG9yTGlzdCIsImxpc3RJdGVtIiwid2l0aExpc3QiLCJhbmNlc3Rvckxpc3QiLCJpc0VsZW1lbnRCZWluZ05vcm1hbGl6ZWRBTGlzdCIsIl9ub2RlJGNoaWxkcmVuIiwic2libGluZ05vZGVQYXRoIiwicHJldmlvdXNDaGlsZCIsInByZXZpb3VzIiwib3JkZXIiLCJnZXRSZWxhdGl2ZVJvd1BhdGgiLCJoYXNIZWFkIiwicm93SW5kZXgiLCJnZXRTZWxlY3RlZFRhYmxlQXJlYSIsIl9FZGl0b3IkYWJvdmUiLCJfZWRpdG9yJHNlbGVjdGlvbiIsIl9FZGl0b3IkYWJvdmUyIiwiX2VkaXRvciRzZWxlY3Rpb24yIiwiZWRnZXMiLCJ0YWJsZVBhdGgiLCJzaW5nbGVDZWxsIiwicm93IiwiY29sdW1uIiwiY2VsbCIsImNsb25lRGVzY2VuZGFudCIsIndpdGhUYWJsZSIsImRlbGV0ZUZyYWdtZW50IiwiZ2V0RnJhZ21lbnQiLCJpbnNlcnRGcmFnbWVudCIsImZyYWdtZW50Iiwic2VsZWN0ZWRUYWJsZUFyZWEiLCJuZXdSb3dzIiwiZXhpc3RpbmdCb2R5IiwibmV3Um93IiwiY2VsbEluZGV4IiwicmVsYXRpdmVDZWxsUGF0aCIsIm5ld0NlbGwiLCJjZWxsUGF0aCIsImNoaWxkSWR4Iiwic2V0U2VsZWN0aW9uIiwiX3RhYmxlJGNoaWxkcmVuJCIsImZpcnN0Iiwic2Vjb25kIiwiYm9keSIsImlzU2VsZWN0aW9uSW5IZWFkIiwiY29sdW1uTGVuZ3RoIiwiY29sdW1uSW5kZXgiLCJkaXJlY3Rpb24iLCJoZWFkT3JCb2R5IiwibWF4Um93SWR4IiwiaGFzV2hvbGVDb2x1bW5TZWxlY3RlZCIsImhhc1dob2xlUm93U2VsZWN0ZWQiLCJyb3dJZHgiLCJzZWxlY3Rpb25QYXRoIiwic2VsZWN0aW9uU3RhcnQiLCJkaWRVcGRhdGVUaGluZ3MiLCJjZWxsSWR4IiwibWF4Um93Q291bnQiLCJkaWRJbnNlcnQiLCJjcmVhdGVEb2N1bWVudEVkaXRvckZvck5vcm1hbGl6YXRpb24iLCJfY3JlYXRlRG9jdW1lbnRFZGl0b3IiLCJiYXNlRWRpdG9yIiwid2l0aEJsb2Nrc1NjaGVtYSIsIndpdGhWb2lkRWxlbWVudHMiLCJub2RlVHlwZSIsImluZm8iLCJkaWRVcGRhdGUiLCJoYW5kbGVOb2RlSW5JbnZhbGlkUG9zaXRpb24iLCJhbmNlc3RvclBhdGgiLCJjaGlsZE5vZGVJbmZvIiwiYW5jZXN0b3JOb2RlIiwicGFyZW50Tm9kZVR5cGUiLCJwYXJlbnROb2RlSW5mbyIsInRleHRFbmNvZGVyIiwidGV4dERlY29kZXIiLCJUZXh0RGVjb2RlciIsImRlZmF1bHRBbHRGaWVsZCIsImVtcHR5VGl0bGVGaWVsZCIsIm5vcm1hbGlzZURvY3VtZW50RmVhdHVyZXMiLCJfY29uZmlnJGZvcm1hdHRpbmciLCJfZm9ybWF0dGluZyRhbGlnbm1lbnQiLCJfZm9ybWF0dGluZyRhbGlnbm1lbnQyIiwiX2Zvcm1hdHRpbmckYmxvY2tUeXBlIiwiX2Zvcm1hdHRpbmckaW5saW5lTWFyIiwiX2Zvcm1hdHRpbmckaW5saW5lTWFyMiIsIl9mb3JtYXR0aW5nJGlubGluZU1hcjMiLCJfZm9ybWF0dGluZyRpbmxpbmVNYXI0IiwiX2Zvcm1hdHRpbmckaW5saW5lTWFyNSIsIl9mb3JtYXR0aW5nJGlubGluZU1hcjYiLCJfZm9ybWF0dGluZyRpbmxpbmVNYXI3IiwiX2Zvcm1hdHRpbmckaW5saW5lTWFyOCIsIl9mb3JtYXR0aW5nJGxpc3RUeXBlcyIsIl9mb3JtYXR0aW5nJGxpc3RUeXBlczIiLCJfaW1hZ2VzQ29uZmlnJHNjaGVtYSQiLCJfaW1hZ2VzQ29uZmlnJHNjaGVtYSIsIl9pbWFnZXNDb25maWckc2NoZW1hJDIiLCJfaW1hZ2VzQ29uZmlnJHNjaGVtYTIiLCJpbWFnZXNDb25maWciLCJfZm9ybWF0dGluZyRibG9ja1R5cGUyIiwiX29iaiRzY2hlbWEiLCJvcHQiLCJkb2N1bWVudCQxIiwiZG9jdW1lbnRGZWF0dXJlc0NvbmZpZyIsIm1hcmtkb2MiLCJkZWNvZGUiLCJub3JtYWxpemUiLCJmb3JjZSIsImZpbGUiLCIkIiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIkgiLCJJIiwiSiIsIksiLCJMIiwiTSIsIk4iLCJPIiwiUCIsIlEiLCJSIiwiUyIsIlQiLCJVIiwiViIsIlciLCJYIiwiWSIsIloiLCJhMCIsImExIiwiYTIiLCJhMyIsImE0IiwiYTUiLCJhNiIsImE3IiwiYTgiLCJhOSIsImFBIiwiYUIiLCJhQyIsImFEIiwiYUUiLCJhRiIsImFHIiwiYUgiLCJhSSIsImFhIiwiYWIiLCJhYyIsImFkIiwiYWUiLCJhZiIsImFnIiwiYWgiLCJhaSIsImFqIiwiYWsiLCJhbCIsImFtIiwiYW4iLCJhbyIsImFwIiwiYXEiLCJhciIsImFzIiwiYXUiLCJhdiIsImF3IiwiYXgiLCJheSIsImF6IiwiZiIsImciLCJoIiwicSIsInUiLCJ3IiwieSIsInoiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@keystatic/core/dist/index-04c3e71f.node.react-server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@keystatic/core/dist/index-d66ff99d.node.react-server.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@keystatic/core/dist/index-d66ff99d.node.react-server.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   i: () => (/* binding */ integer)\n/* harmony export */ });\n/* harmony import */ var _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-04c3e71f.node.react-server.js */ \"(rsc)/./node_modules/@keystatic/core/dist/index-04c3e71f.node.react-server.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n\n\nfunction validateInteger(validation, value, label) {\n    if (value !== null && (typeof value !== \"number\" || !Number.isInteger(value))) {\n        return `${label} must be a whole number`;\n    }\n    if (validation !== null && validation !== void 0 && validation.isRequired && value === null) {\n        return `${label} is required`;\n    }\n    if (value !== null) {\n        if ((validation === null || validation === void 0 ? void 0 : validation.min) !== undefined && value < validation.min) {\n            return `${label} must be at least ${validation.min}`;\n        }\n        if ((validation === null || validation === void 0 ? void 0 : validation.max) !== undefined && value > validation.max) {\n            return `${label} must be at most ${validation.max}`;\n        }\n    }\n}\nfunction integer({ label, defaultValue, validation, description }) {\n    return (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_0__.ae)({\n        label,\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_0__.az, {\n                label: label,\n                description: description,\n                validation: validation,\n                ...props\n            });\n        },\n        defaultValue () {\n            return defaultValue !== null && defaultValue !== void 0 ? defaultValue : null;\n        },\n        parse (value) {\n            if (value === undefined) {\n                return null;\n            }\n            if (typeof value === \"number\") {\n                return value;\n            }\n            throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_0__.ad(\"Must be a number\");\n        },\n        validate (value) {\n            const message = validateInteger(validation, value, label);\n            if (message !== undefined) {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_0__.ad(message);\n            }\n            (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_0__.ah)(value, validation, label);\n            return value;\n        },\n        serialize (value) {\n            return {\n                value: value === null ? undefined : value\n            };\n        }\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3QvaW5kZXgtZDY2ZmY5OWQubm9kZS5yZWFjdC1zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXVLO0FBQy9IO0FBRXhDLFNBQVNTLGdCQUFnQkMsVUFBVSxFQUFFQyxLQUFLLEVBQUVDLEtBQUs7SUFDL0MsSUFBSUQsVUFBVSxRQUFTLFFBQU9BLFVBQVUsWUFBWSxDQUFDRSxPQUFPQyxTQUFTLENBQUNILE1BQUssR0FBSTtRQUM3RSxPQUFPLENBQUMsRUFBRUMsTUFBTSx1QkFBdUIsQ0FBQztJQUMxQztJQUNBLElBQUlGLGVBQWUsUUFBUUEsZUFBZSxLQUFLLEtBQUtBLFdBQVdLLFVBQVUsSUFBSUosVUFBVSxNQUFNO1FBQzNGLE9BQU8sQ0FBQyxFQUFFQyxNQUFNLFlBQVksQ0FBQztJQUMvQjtJQUNBLElBQUlELFVBQVUsTUFBTTtRQUNsQixJQUFJLENBQUNELGVBQWUsUUFBUUEsZUFBZSxLQUFLLElBQUksS0FBSyxJQUFJQSxXQUFXTSxHQUFHLE1BQU1DLGFBQWFOLFFBQVFELFdBQVdNLEdBQUcsRUFBRTtZQUNwSCxPQUFPLENBQUMsRUFBRUosTUFBTSxrQkFBa0IsRUFBRUYsV0FBV00sR0FBRyxDQUFDLENBQUM7UUFDdEQ7UUFDQSxJQUFJLENBQUNOLGVBQWUsUUFBUUEsZUFBZSxLQUFLLElBQUksS0FBSyxJQUFJQSxXQUFXUSxHQUFHLE1BQU1ELGFBQWFOLFFBQVFELFdBQVdRLEdBQUcsRUFBRTtZQUNwSCxPQUFPLENBQUMsRUFBRU4sTUFBTSxpQkFBaUIsRUFBRUYsV0FBV1EsR0FBRyxDQUFDLENBQUM7UUFDckQ7SUFDRjtBQUNGO0FBRUEsU0FBU0MsUUFBUSxFQUNmUCxLQUFLLEVBQ0xRLFlBQVksRUFDWlYsVUFBVSxFQUNWVyxXQUFXLEVBQ1o7SUFDQyxPQUFPcEIsd0VBQW1DQSxDQUFDO1FBQ3pDVztRQUNBVSxPQUFNQyxLQUFLO1lBQ1QsT0FBTyxXQUFXLEdBQUVmLHNEQUFHQSxDQUFDTCxvRUFBaUJBLEVBQUU7Z0JBQ3pDUyxPQUFPQTtnQkFDUFMsYUFBYUE7Z0JBQ2JYLFlBQVlBO2dCQUNaLEdBQUdhLEtBQUs7WUFDVjtRQUNGO1FBQ0FIO1lBQ0UsT0FBT0EsaUJBQWlCLFFBQVFBLGlCQUFpQixLQUFLLElBQUlBLGVBQWU7UUFDM0U7UUFDQUksT0FBTWIsS0FBSztZQUNULElBQUlBLFVBQVVNLFdBQVc7Z0JBQ3ZCLE9BQU87WUFDVDtZQUNBLElBQUksT0FBT04sVUFBVSxVQUFVO2dCQUM3QixPQUFPQTtZQUNUO1lBQ0EsTUFBTSxJQUFJTixvRUFBY0EsQ0FBQztRQUMzQjtRQUNBb0IsVUFBU2QsS0FBSztZQUNaLE1BQU1lLFVBQVVqQixnQkFBZ0JDLFlBQVlDLE9BQU9DO1lBQ25ELElBQUljLFlBQVlULFdBQVc7Z0JBQ3pCLE1BQU0sSUFBSVosb0VBQWNBLENBQUNxQjtZQUMzQjtZQUNBbkIsd0VBQWNBLENBQUNJLE9BQU9ELFlBQVlFO1lBQ2xDLE9BQU9EO1FBQ1Q7UUFDQWdCLFdBQVVoQixLQUFLO1lBQ2IsT0FBTztnQkFDTEEsT0FBT0EsVUFBVSxPQUFPTSxZQUFZTjtZQUN0QztRQUNGO0lBQ0Y7QUFDRjtBQUV3QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BrZXlzdGF0aWMvdGVtcGxhdGVzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9Aa2V5c3RhdGljL2NvcmUvZGlzdC9pbmRleC1kNjZmZjk5ZC5ub2RlLnJlYWN0LXNlcnZlci5qcz82ZGE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFlIGFzIGJhc2ljRm9ybUZpZWxkV2l0aFNpbXBsZVJlYWRlclBhcnNlLCBheiBhcyBJbnRlZ2VyRmllbGRJbnB1dCwgYWQgYXMgRmllbGREYXRhRXJyb3IsIGFoIGFzIGFzc2VydFJlcXVpcmVkIH0gZnJvbSAnLi9pbmRleC0wNGMzZTcxZi5ub2RlLnJlYWN0LXNlcnZlci5qcyc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSW50ZWdlcih2YWxpZGF0aW9uLCB2YWx1ZSwgbGFiZWwpIHtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gYCR7bGFiZWx9IG11c3QgYmUgYSB3aG9sZSBudW1iZXJgO1xuICB9XG4gIGlmICh2YWxpZGF0aW9uICE9PSBudWxsICYmIHZhbGlkYXRpb24gIT09IHZvaWQgMCAmJiB2YWxpZGF0aW9uLmlzUmVxdWlyZWQgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gYCR7bGFiZWx9IGlzIHJlcXVpcmVkYDtcbiAgfVxuICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICBpZiAoKHZhbGlkYXRpb24gPT09IG51bGwgfHwgdmFsaWRhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsaWRhdGlvbi5taW4pICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPCB2YWxpZGF0aW9uLm1pbikge1xuICAgICAgcmV0dXJuIGAke2xhYmVsfSBtdXN0IGJlIGF0IGxlYXN0ICR7dmFsaWRhdGlvbi5taW59YDtcbiAgICB9XG4gICAgaWYgKCh2YWxpZGF0aW9uID09PSBudWxsIHx8IHZhbGlkYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbGlkYXRpb24ubWF4KSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlID4gdmFsaWRhdGlvbi5tYXgpIHtcbiAgICAgIHJldHVybiBgJHtsYWJlbH0gbXVzdCBiZSBhdCBtb3N0ICR7dmFsaWRhdGlvbi5tYXh9YDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZWdlcih7XG4gIGxhYmVsLFxuICBkZWZhdWx0VmFsdWUsXG4gIHZhbGlkYXRpb24sXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIHJldHVybiBiYXNpY0Zvcm1GaWVsZFdpdGhTaW1wbGVSZWFkZXJQYXJzZSh7XG4gICAgbGFiZWwsXG4gICAgSW5wdXQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KEludGVnZXJGaWVsZElucHV0LCB7XG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uLFxuICAgICAgICAuLi5wcm9wc1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlICE9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPT0gdm9pZCAwID8gZGVmYXVsdFZhbHVlIDogbnVsbDtcbiAgICB9LFxuICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcignTXVzdCBiZSBhIG51bWJlcicpO1xuICAgIH0sXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB2YWxpZGF0ZUludGVnZXIodmFsaWRhdGlvbiwgdmFsdWUsIGxhYmVsKTtcbiAgICAgIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0UmVxdWlyZWQodmFsdWUsIHZhbGlkYXRpb24sIGxhYmVsKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlID09PSBudWxsID8gdW5kZWZpbmVkIDogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IHsgaW50ZWdlciBhcyBpIH07XG4iXSwibmFtZXMiOlsiYWUiLCJiYXNpY0Zvcm1GaWVsZFdpdGhTaW1wbGVSZWFkZXJQYXJzZSIsImF6IiwiSW50ZWdlckZpZWxkSW5wdXQiLCJhZCIsIkZpZWxkRGF0YUVycm9yIiwiYWgiLCJhc3NlcnRSZXF1aXJlZCIsImpzeCIsInZhbGlkYXRlSW50ZWdlciIsInZhbGlkYXRpb24iLCJ2YWx1ZSIsImxhYmVsIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaXNSZXF1aXJlZCIsIm1pbiIsInVuZGVmaW5lZCIsIm1heCIsImludGVnZXIiLCJkZWZhdWx0VmFsdWUiLCJkZXNjcmlwdGlvbiIsIklucHV0IiwicHJvcHMiLCJwYXJzZSIsInZhbGlkYXRlIiwibWVzc2FnZSIsInNlcmlhbGl6ZSIsImkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@keystatic/core/dist/index-d66ff99d.node.react-server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@keystatic/core/dist/isValidURL-c29bb1bd.node.react-server.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@keystatic/core/dist/isValidURL-c29bb1bd.node.react-server.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   N: () => (/* binding */ NAVIGATION_DIVIDER_KEY),\n/* harmony export */   a: () => (/* binding */ collection),\n/* harmony export */   c: () => (/* binding */ config),\n/* harmony export */   i: () => (/* binding */ isValidURL),\n/* harmony export */   s: () => (/* binding */ singleton)\n/* harmony export */ });\n/* harmony import */ var _braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @braintree/sanitize-url */ \"(rsc)/./node_modules/@braintree/sanitize-url/dist/index.js\");\n\n// Common\n// ----------------------------------------------------------------------------\n// Interface\n// ----------------------------------------------------------------------------\nconst NAVIGATION_DIVIDER_KEY = \"---\";\n// Storage\n// ----------------------------------------------------------------------------\n// ============================================================================\n// Functions\n// ============================================================================\nfunction config(config) {\n    return config;\n}\nfunction collection(collection) {\n    return collection;\n}\nfunction singleton(collection) {\n    return collection;\n}\nfunction isValidURL(url) {\n    return url === (0,_braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_0__.sanitizeUrl)(url);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3QvaXNWYWxpZFVSTC1jMjliYjFiZC5ub2RlLnJlYWN0LXNlcnZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBc0Q7QUFFdEQsU0FBUztBQUNULCtFQUErRTtBQUUvRSxZQUFZO0FBQ1osK0VBQStFO0FBRS9FLE1BQU1DLHlCQUF5QjtBQUUvQixVQUFVO0FBQ1YsK0VBQStFO0FBRS9FLCtFQUErRTtBQUMvRSxZQUFZO0FBQ1osK0VBQStFO0FBRS9FLFNBQVNDLE9BQU9BLE1BQU07SUFDcEIsT0FBT0E7QUFDVDtBQUNBLFNBQVNDLFdBQVdBLFVBQVU7SUFDNUIsT0FBT0E7QUFDVDtBQUNBLFNBQVNDLFVBQVVELFVBQVU7SUFDM0IsT0FBT0E7QUFDVDtBQUVBLFNBQVNFLFdBQVdDLEdBQUc7SUFDckIsT0FBT0EsUUFBUU4sb0VBQVdBLENBQUNNO0FBQzdCO0FBRXNHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGtleXN0YXRpYy90ZW1wbGF0ZXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BrZXlzdGF0aWMvY29yZS9kaXN0L2lzVmFsaWRVUkwtYzI5YmIxYmQubm9kZS5yZWFjdC1zZXJ2ZXIuanM/NmQxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzYW5pdGl6ZVVybCB9IGZyb20gJ0BicmFpbnRyZWUvc2FuaXRpemUtdXJsJztcblxuLy8gQ29tbW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIEludGVyZmFjZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBOQVZJR0FUSU9OX0RJVklERVJfS0VZID0gJy0tLSc7XG5cbi8vIFN0b3JhZ2Vcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGNvbmZpZyhjb25maWcpIHtcbiAgcmV0dXJuIGNvbmZpZztcbn1cbmZ1bmN0aW9uIGNvbGxlY3Rpb24oY29sbGVjdGlvbikge1xuICByZXR1cm4gY29sbGVjdGlvbjtcbn1cbmZ1bmN0aW9uIHNpbmdsZXRvbihjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkVVJMKHVybCkge1xuICByZXR1cm4gdXJsID09PSBzYW5pdGl6ZVVybCh1cmwpO1xufVxuXG5leHBvcnQgeyBOQVZJR0FUSU9OX0RJVklERVJfS0VZIGFzIE4sIGNvbGxlY3Rpb24gYXMgYSwgY29uZmlnIGFzIGMsIGlzVmFsaWRVUkwgYXMgaSwgc2luZ2xldG9uIGFzIHMgfTtcbiJdLCJuYW1lcyI6WyJzYW5pdGl6ZVVybCIsIk5BVklHQVRJT05fRElWSURFUl9LRVkiLCJjb25maWciLCJjb2xsZWN0aW9uIiwic2luZ2xldG9uIiwiaXNWYWxpZFVSTCIsInVybCIsIk4iLCJhIiwiYyIsImkiLCJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@keystatic/core/dist/isValidURL-c29bb1bd.node.react-server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@keystatic/core/dist/keystatic-core-reader.node.react-server.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@keystatic/core/dist/keystatic-core-reader.node.react-server.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createReader: () => (/* binding */ createReader)\n/* harmony export */ });\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_fs_promises__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\n/* harmony import */ var _generic_0a163b6b_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./generic-0a163b6b.node.react-server.js */ \"(rsc)/./node_modules/@keystatic/core/dist/generic-0a163b6b.node.react-server.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index-04c3e71f.node.react-server.js */ \"(rsc)/./node_modules/@keystatic/core/dist/index-04c3e71f.node.react-server.js\");\n/* harmony import */ var emery_assertions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! emery/assertions */ \"(rsc)/./node_modules/emery/assertions/dist/emery-assertions.esm.js\");\n/* harmony import */ var emery__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! emery */ \"(rsc)/./node_modules/emery/dist/emery.esm.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var _emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @emotion/weak-memoize */ \"(rsc)/./node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js\");\n/* harmony import */ var decimal_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.mjs\");\n/* harmony import */ var _sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @sindresorhus/slugify */ \"(rsc)/./node_modules/@sindresorhus/slugify/index.js\");\n/* harmony import */ var _braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @braintree/sanitize-url */ \"(rsc)/./node_modules/@braintree/sanitize-url/dist/index.js\");\n/* harmony import */ var _error_formatting_ec352252_node_react_server_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./error-formatting-ec352252.node.react-server.js */ \"(rsc)/./node_modules/@keystatic/core/dist/error-formatting-ec352252.node.react-server.js\");\n/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! js-yaml */ \"(rsc)/./node_modules/js-yaml/dist/js-yaml.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction createReader(repoPath, config) {\n    const fs$1 = {\n        async fileExists (path$1) {\n            try {\n                await node_fs_promises__WEBPACK_IMPORTED_MODULE_1__.stat(node_path__WEBPACK_IMPORTED_MODULE_0__.join(repoPath, path$1));\n                return true;\n            } catch (err) {\n                if (err.code === \"ENOENT\") return false;\n                throw err;\n            }\n        },\n        async readdir (path$1) {\n            try {\n                const entries = await node_fs_promises__WEBPACK_IMPORTED_MODULE_1__.readdir(node_path__WEBPACK_IMPORTED_MODULE_0__.join(repoPath, path$1), {\n                    withFileTypes: true\n                });\n                const filtered = [];\n                for (const entry of entries){\n                    if (entry.isDirectory()) {\n                        filtered.push({\n                            name: entry.name,\n                            kind: \"directory\"\n                        });\n                    }\n                    if (entry.isFile()) {\n                        filtered.push({\n                            name: entry.name,\n                            kind: \"file\"\n                        });\n                    }\n                }\n                return filtered;\n            } catch (err) {\n                if (err.code === \"ENOENT\") return [];\n                throw err;\n            }\n        },\n        async readFile (path$1) {\n            try {\n                return await node_fs_promises__WEBPACK_IMPORTED_MODULE_1__.readFile(node_path__WEBPACK_IMPORTED_MODULE_0__.join(repoPath, path$1));\n            } catch (err) {\n                if (err.code === \"ENOENT\") return null;\n                throw err;\n            }\n        }\n    };\n    return {\n        collections: Object.fromEntries(Object.keys(config.collections || {}).map((key)=>[\n                key,\n                (0,_generic_0a163b6b_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.c)(key, config, fs$1)\n            ])),\n        singletons: Object.fromEntries(Object.keys(config.singletons || {}).map((key)=>[\n                key,\n                (0,_generic_0a163b6b_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.s)(key, config, fs$1)\n            ])),\n        repoPath,\n        config\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVhZGVyLm5vZGUucmVhY3Qtc2VydmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkI7QUFDSztBQUNvRTtBQUMzRTtBQUNvQjtBQUNyQjtBQUNYO0FBQ1c7QUFDWDtBQUNJO0FBQ0g7QUFDZTtBQUNYO0FBQ1c7QUFDRTtBQUN5QjtBQUN6QztBQUNGO0FBRWYsU0FBU00sYUFBYUMsUUFBUSxFQUFFQyxNQUFNO0lBQ3BDLE1BQU1DLE9BQU87UUFDWCxNQUFNQyxZQUFXQyxNQUFNO1lBQ3JCLElBQUk7Z0JBQ0YsTUFBTVYsa0RBQU8sQ0FBQ0QsMkNBQVMsQ0FBQ08sVUFBVUk7Z0JBQ2xDLE9BQU87WUFDVCxFQUFFLE9BQU9HLEtBQUs7Z0JBQ1osSUFBSUEsSUFBSUMsSUFBSSxLQUFLLFVBQVUsT0FBTztnQkFDbEMsTUFBTUQ7WUFDUjtRQUNGO1FBQ0EsTUFBTUUsU0FBUUwsTUFBTTtZQUNsQixJQUFJO2dCQUNGLE1BQU1NLFVBQVUsTUFBTWhCLHFEQUFVLENBQUNELDJDQUFTLENBQUNPLFVBQVVJLFNBQVM7b0JBQzVETyxlQUFlO2dCQUNqQjtnQkFDQSxNQUFNQyxXQUFXLEVBQUU7Z0JBQ25CLEtBQUssTUFBTUMsU0FBU0gsUUFBUztvQkFDM0IsSUFBSUcsTUFBTUMsV0FBVyxJQUFJO3dCQUN2QkYsU0FBU0csSUFBSSxDQUFDOzRCQUNaQyxNQUFNSCxNQUFNRyxJQUFJOzRCQUNoQkMsTUFBTTt3QkFDUjtvQkFDRjtvQkFDQSxJQUFJSixNQUFNSyxNQUFNLElBQUk7d0JBQ2xCTixTQUFTRyxJQUFJLENBQUM7NEJBQ1pDLE1BQU1ILE1BQU1HLElBQUk7NEJBQ2hCQyxNQUFNO3dCQUNSO29CQUNGO2dCQUNGO2dCQUNBLE9BQU9MO1lBQ1QsRUFBRSxPQUFPTCxLQUFLO2dCQUNaLElBQUlBLElBQUlDLElBQUksS0FBSyxVQUFVLE9BQU8sRUFBRTtnQkFDcEMsTUFBTUQ7WUFDUjtRQUNGO1FBQ0EsTUFBTVksVUFBU2YsTUFBTTtZQUNuQixJQUFJO2dCQUNGLE9BQU8sTUFBTVYsc0RBQVcsQ0FBQ0QsMkNBQVMsQ0FBQ08sVUFBVUk7WUFDL0MsRUFBRSxPQUFPRyxLQUFLO2dCQUNaLElBQUlBLElBQUlDLElBQUksS0FBSyxVQUFVLE9BQU87Z0JBQ2xDLE1BQU1EO1lBQ1I7UUFDRjtJQUNGO0lBQ0EsT0FBTztRQUNMYSxhQUFhQyxPQUFPQyxXQUFXLENBQUNELE9BQU9FLElBQUksQ0FBQ3RCLE9BQU9tQixXQUFXLElBQUksQ0FBQyxHQUFHSSxHQUFHLENBQUNDLENBQUFBLE1BQU87Z0JBQUNBO2dCQUFLN0IseUVBQWdCQSxDQUFDNkIsS0FBS3hCLFFBQVFDO2FBQU07UUFDM0h3QixZQUFZTCxPQUFPQyxXQUFXLENBQUNELE9BQU9FLElBQUksQ0FBQ3RCLE9BQU95QixVQUFVLElBQUksQ0FBQyxHQUFHRixHQUFHLENBQUNDLENBQUFBLE1BQU87Z0JBQUNBO2dCQUFLM0IseUVBQWVBLENBQUMyQixLQUFLeEIsUUFBUUM7YUFBTTtRQUN4SEY7UUFDQUM7SUFDRjtBQUNGO0FBRXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGtleXN0YXRpYy90ZW1wbGF0ZXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BrZXlzdGF0aWMvY29yZS9kaXN0L2tleXN0YXRpYy1jb3JlLXJlYWRlci5ub2RlLnJlYWN0LXNlcnZlci5qcz82MzkyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgZnMgZnJvbSAnbm9kZTpmcy9wcm9taXNlcyc7XG5pbXBvcnQgeyBjIGFzIGNvbGxlY3Rpb25SZWFkZXIsIHMgYXMgc2luZ2xldG9uUmVhZGVyIH0gZnJvbSAnLi9nZW5lcmljLTBhMTYzYjZiLm5vZGUucmVhY3Qtc2VydmVyLmpzJztcbmltcG9ydCAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0ICcuL2luZGV4LTA0YzNlNzFmLm5vZGUucmVhY3Qtc2VydmVyLmpzJztcbmltcG9ydCAnQG1hcmtkb2MvbWFya2RvYyc7XG5pbXBvcnQgJ3NsYXRlJztcbmltcG9ydCAnZW1lcnkvYXNzZXJ0aW9ucyc7XG5pbXBvcnQgJ2VtZXJ5JztcbmltcG9ydCAnanMtYmFzZTY0JztcbmltcG9ydCAnY3J5cHRvJztcbmltcG9ydCAnQGVtb3Rpb24vd2Vhay1tZW1vaXplJztcbmltcG9ydCAnZGVjaW1hbC5qcyc7XG5pbXBvcnQgJ0BzaW5kcmVzb3JodXMvc2x1Z2lmeSc7XG5pbXBvcnQgJ0BicmFpbnRyZWUvc2FuaXRpemUtdXJsJztcbmltcG9ydCAnLi9lcnJvci1mb3JtYXR0aW5nLWVjMzUyMjUyLm5vZGUucmVhY3Qtc2VydmVyLmpzJztcbmltcG9ydCAnanMteWFtbCc7XG5pbXBvcnQgJ3JlYWN0JztcblxuZnVuY3Rpb24gY3JlYXRlUmVhZGVyKHJlcG9QYXRoLCBjb25maWcpIHtcbiAgY29uc3QgZnMkMSA9IHtcbiAgICBhc3luYyBmaWxlRXhpc3RzKHBhdGgkMSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZnMuc3RhdChwYXRoLmpvaW4ocmVwb1BhdGgsIHBhdGgkMSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIHJlYWRkaXIocGF0aCQxKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgZnMucmVhZGRpcihwYXRoLmpvaW4ocmVwb1BhdGgsIHBhdGgkMSksIHtcbiAgICAgICAgICB3aXRoRmlsZVR5cGVzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgZmlsdGVyZWQucHVzaCh7XG4gICAgICAgICAgICAgIG5hbWU6IGVudHJ5Lm5hbWUsXG4gICAgICAgICAgICAgIGtpbmQ6ICdkaXJlY3RvcnknXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVudHJ5LmlzRmlsZSgpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKHtcbiAgICAgICAgICAgICAgbmFtZTogZW50cnkubmFtZSxcbiAgICAgICAgICAgICAga2luZDogJ2ZpbGUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVybiBbXTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgcmVhZEZpbGUocGF0aCQxKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZnMucmVhZEZpbGUocGF0aC5qb2luKHJlcG9QYXRoLCBwYXRoJDEpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBjb2xsZWN0aW9uczogT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5rZXlzKGNvbmZpZy5jb2xsZWN0aW9ucyB8fCB7fSkubWFwKGtleSA9PiBba2V5LCBjb2xsZWN0aW9uUmVhZGVyKGtleSwgY29uZmlnLCBmcyQxKV0pKSxcbiAgICBzaW5nbGV0b25zOiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmtleXMoY29uZmlnLnNpbmdsZXRvbnMgfHwge30pLm1hcChrZXkgPT4gW2tleSwgc2luZ2xldG9uUmVhZGVyKGtleSwgY29uZmlnLCBmcyQxKV0pKSxcbiAgICByZXBvUGF0aCxcbiAgICBjb25maWdcbiAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlUmVhZGVyIH07XG4iXSwibmFtZXMiOlsicGF0aCIsImZzIiwiYyIsImNvbGxlY3Rpb25SZWFkZXIiLCJzIiwic2luZ2xldG9uUmVhZGVyIiwiY3JlYXRlUmVhZGVyIiwicmVwb1BhdGgiLCJjb25maWciLCJmcyQxIiwiZmlsZUV4aXN0cyIsInBhdGgkMSIsInN0YXQiLCJqb2luIiwiZXJyIiwiY29kZSIsInJlYWRkaXIiLCJlbnRyaWVzIiwid2l0aEZpbGVUeXBlcyIsImZpbHRlcmVkIiwiZW50cnkiLCJpc0RpcmVjdG9yeSIsInB1c2giLCJuYW1lIiwia2luZCIsImlzRmlsZSIsInJlYWRGaWxlIiwiY29sbGVjdGlvbnMiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImtleXMiLCJtYXAiLCJrZXkiLCJzaW5nbGV0b25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@keystatic/core/dist/keystatic-core-reader.node.react-server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@keystatic/core/dist/keystatic-core.node.react-server.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@keystatic/core/dist/keystatic-core.node.react-server.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockWrapper: () => (/* binding */ BlockWrapper),\n/* harmony export */   NotEditable: () => (/* binding */ NotEditable),\n/* harmony export */   ToolbarSeparator: () => (/* binding */ ToolbarSeparator),\n/* harmony export */   collection: () => (/* reexport safe */ _isValidURL_c29bb1bd_node_react_server_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   component: () => (/* reexport safe */ _api_bcef1679_node_react_server_js__WEBPACK_IMPORTED_MODULE_1__.c),\n/* harmony export */   config: () => (/* reexport safe */ _isValidURL_c29bb1bd_node_react_server_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   fields: () => (/* binding */ index),\n/* harmony export */   singleton: () => (/* reexport safe */ _isValidURL_c29bb1bd_node_react_server_js__WEBPACK_IMPORTED_MODULE_0__.s)\n/* harmony export */ });\n/* harmony import */ var _isValidURL_c29bb1bd_node_react_server_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isValidURL-c29bb1bd.node.react-server.js */ \"(rsc)/./node_modules/@keystatic/core/dist/isValidURL-c29bb1bd.node.react-server.js\");\n/* harmony import */ var _api_bcef1679_node_react_server_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api-bcef1679.node.react-server.js */ \"(rsc)/./node_modules/@keystatic/core/dist/api-bcef1679.node.react-server.js\");\n/* harmony import */ var _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-04c3e71f.node.react-server.js */ \"(rsc)/./node_modules/@keystatic/core/dist/index-04c3e71f.node.react-server.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var _index_d66ff99d_node_react_server_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index-d66ff99d.node.react-server.js */ \"(rsc)/./node_modules/@keystatic/core/dist/index-d66ff99d.node.react-server.js\");\n/* harmony import */ var decimal_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.mjs\");\n/* harmony import */ var _sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sindresorhus/slugify */ \"(rsc)/./node_modules/@sindresorhus/slugify/index.js\");\n/* harmony import */ var emery__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! emery */ \"(rsc)/./node_modules/emery/dist/emery.esm.js\");\n/* harmony import */ var _braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @braintree/sanitize-url */ \"(rsc)/./node_modules/@braintree/sanitize-url/dist/index.js\");\n/* harmony import */ var emery_assertions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! emery/assertions */ \"(rsc)/./node_modules/emery/assertions/dist/emery-assertions.esm.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var _emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @emotion/weak-memoize */ \"(rsc)/./node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction array(element, opts) {\n    var _opts$label;\n    return {\n        kind: \"array\",\n        element,\n        label: (_opts$label = opts === null || opts === void 0 ? void 0 : opts.label) !== null && _opts$label !== void 0 ? _opts$label : \"Items\",\n        description: opts === null || opts === void 0 ? void 0 : opts.description,\n        itemLabel: opts === null || opts === void 0 ? void 0 : opts.itemLabel,\n        asChildTag: opts === null || opts === void 0 ? void 0 : opts.asChildTag,\n        slugField: opts === null || opts === void 0 ? void 0 : opts.slugField,\n        validation: opts === null || opts === void 0 ? void 0 : opts.validation\n    };\n}\nfunction checkbox({ label, defaultValue = false, description }) {\n    return (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ae)({\n        label,\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.af, {\n                ...props,\n                label: label,\n                description: description\n            });\n        },\n        defaultValue () {\n            return defaultValue;\n        },\n        parse (value) {\n            if (value === undefined) return defaultValue;\n            if (typeof value !== \"boolean\") {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be a boolean\");\n            }\n            return value;\n        },\n        validate (value) {\n            return value;\n        },\n        serialize (value) {\n            return {\n                value\n            };\n        }\n    });\n}\nfunction child(options) {\n    return {\n        kind: \"child\",\n        options: options.kind === \"block\" ? {\n            ...options,\n            dividers: options.dividers,\n            formatting: options.formatting === \"inherit\" ? {\n                blockTypes: \"inherit\",\n                headingLevels: \"inherit\",\n                inlineMarks: \"inherit\",\n                listTypes: \"inherit\",\n                alignment: \"inherit\",\n                softBreaks: \"inherit\"\n            } : options.formatting,\n            links: options.links,\n            images: options.images,\n            tables: options.tables,\n            componentBlocks: options.componentBlocks\n        } : {\n            kind: \"inline\",\n            placeholder: options.placeholder,\n            formatting: options.formatting === \"inherit\" ? {\n                inlineMarks: \"inherit\",\n                softBreaks: \"inherit\"\n            } : options.formatting,\n            links: options.links\n        }\n    };\n}\nfunction conditional(discriminant, values) {\n    return {\n        kind: \"conditional\",\n        discriminant,\n        values: values\n    };\n}\nfunction validateDate(validation, value, label) {\n    if (value !== null && !/^\\d{4}-\\d{2}-\\d{2}$/.test(value)) {\n        return `${label} is not a valid date`;\n    }\n    if (validation !== null && validation !== void 0 && validation.isRequired && value === null) {\n        return `${label} is required`;\n    }\n    if ((validation !== null && validation !== void 0 && validation.min || validation !== null && validation !== void 0 && validation.max) && value !== null) {\n        const date = new Date(value);\n        if ((validation === null || validation === void 0 ? void 0 : validation.min) !== undefined) {\n            const min = new Date(validation.min);\n            if (date < min) {\n                return `${label} must be after ${min.toLocaleDateString()}`;\n            }\n        }\n        if ((validation === null || validation === void 0 ? void 0 : validation.max) !== undefined) {\n            const max = new Date(validation.max);\n            if (date > max) {\n                return `${label} must be no later than ${max.toLocaleDateString()}`;\n            }\n        }\n    }\n}\nfunction date({ label, defaultValue, validation, description }) {\n    return (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ae)({\n        label,\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ag, {\n                validation: validation,\n                label: label,\n                description: description,\n                ...props\n            });\n        },\n        defaultValue () {\n            if (defaultValue === undefined) {\n                return null;\n            }\n            if (typeof defaultValue === \"string\") {\n                return defaultValue;\n            }\n            const today = new Date();\n            const year = today.getFullYear();\n            const month = String(today.getMonth() + 1).padStart(2, \"0\");\n            const day = String(today.getDate()).padStart(2, \"0\");\n            return `${year}-${month}-${day}`;\n        },\n        parse (value) {\n            if (value === undefined) {\n                return null;\n            }\n            if (typeof value !== \"string\") {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be a string\");\n            }\n            return value;\n        },\n        serialize (value) {\n            return {\n                value: value === null ? undefined : value\n            };\n        },\n        validate (value) {\n            const message = validateDate(validation, value, label);\n            if (message !== undefined) {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(message);\n            }\n            (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ah)(value, validation, label);\n            return value;\n        }\n    });\n}\nfunction validateDatetime(validation, value, label) {\n    if (value !== null && !/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}$/.test(value)) {\n        return `${label} is not a valid datetime`;\n    }\n    if (validation !== null && validation !== void 0 && validation.isRequired && value === null) {\n        return `${label} is required`;\n    }\n    if ((validation !== null && validation !== void 0 && validation.min || validation !== null && validation !== void 0 && validation.max) && value !== null) {\n        const datetime = new Date(value);\n        if ((validation === null || validation === void 0 ? void 0 : validation.min) !== undefined) {\n            const min = new Date(validation.min);\n            if (datetime < min) {\n                return `${label} must be after ${min.toISOString()}`;\n            }\n        }\n        if ((validation === null || validation === void 0 ? void 0 : validation.max) !== undefined) {\n            const max = new Date(validation.max);\n            if (datetime > max) {\n                return `${label} must be no later than ${max.toISOString()}`;\n            }\n        }\n    }\n}\nfunction datetime({ label, defaultValue, validation, description }) {\n    return (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ae)({\n        label,\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ai, {\n                validation: validation,\n                label: label,\n                description: description,\n                ...props\n            });\n        },\n        defaultValue () {\n            if (defaultValue === undefined) {\n                return null;\n            }\n            if (typeof defaultValue === \"string\") {\n                return defaultValue;\n            }\n            if (defaultValue.kind === \"now\") {\n                const now = new Date();\n                return now.toISOString();\n            }\n            return null;\n        },\n        parse (value) {\n            if (value === undefined) {\n                return null;\n            }\n            if (typeof value !== \"string\") {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be a string\");\n            }\n            return value;\n        },\n        serialize (value) {\n            return {\n                value: value === null ? undefined : value\n            };\n        },\n        validate (value) {\n            const message = validateDatetime(validation, value, label);\n            if (message !== undefined) {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(message);\n            }\n            (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ah)(value, validation, label);\n            return value;\n        }\n    });\n}\nfunction emptyDocument() {\n    return {\n        kind: \"form\",\n        formKind: \"content\",\n        Input () {\n            return null;\n        },\n        defaultValue () {\n            return null;\n        },\n        parse () {\n            return null;\n        },\n        contentExtension: \".mdoc\",\n        serialize () {\n            return {\n                value: undefined,\n                content: new Uint8Array(),\n                external: new Map(),\n                other: new Map()\n            };\n        },\n        validate (value) {\n            return value;\n        },\n        reader: {\n            parse () {\n                return null;\n            }\n        }\n    };\n}\nfunction empty() {\n    return (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ae)({\n        Input () {\n            return null;\n        },\n        defaultValue () {\n            return null;\n        },\n        parse () {\n            return null;\n        },\n        serialize () {\n            return {\n                value: undefined\n            };\n        },\n        validate (value) {\n            return value;\n        },\n        label: \"Empty\"\n    });\n}\nfunction image({ label, directory, validation, description, publicPath }) {\n    return {\n        kind: \"form\",\n        formKind: \"asset\",\n        label,\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.aj, {\n                label: label,\n                description: description,\n                validation: validation,\n                ...props\n            });\n        },\n        defaultValue () {\n            return null;\n        },\n        filename (value, args) {\n            if (typeof value === \"string\") {\n                return value.slice((0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ak)(publicPath, args.slug).length);\n            }\n            return undefined;\n        },\n        parse (value, args) {\n            var _value$match$, _value$match;\n            if (value === undefined) {\n                return null;\n            }\n            if (typeof value !== \"string\") {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be a string\");\n            }\n            if (args.asset === undefined) {\n                return null;\n            }\n            return {\n                data: args.asset,\n                filename: value.slice((0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ak)(publicPath, args.slug).length),\n                extension: (_value$match$ = (_value$match = value.match(/\\.([^.]+$)/)) === null || _value$match === void 0 ? void 0 : _value$match[1]) !== null && _value$match$ !== void 0 ? _value$match$ : \"\"\n            };\n        },\n        validate (value) {\n            (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ah)(value, validation, label);\n            return value;\n        },\n        serialize (value, args) {\n            if (value === null) {\n                return {\n                    value: undefined,\n                    asset: undefined\n                };\n            }\n            const filename = args.suggestedFilenamePrefix ? args.suggestedFilenamePrefix + \".\" + value.extension : value.filename;\n            return {\n                value: `${(0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ak)(publicPath, args.slug)}${filename}`,\n                asset: {\n                    filename,\n                    content: value.data\n                }\n            };\n        },\n        directory: directory ? (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.al)(directory) : undefined,\n        reader: {\n            parse (value) {\n                if (typeof value !== \"string\" && value !== undefined) {\n                    throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be a string\");\n                }\n                const val = value === undefined ? null : value;\n                (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ah)(val, validation, label);\n                return val;\n            }\n        }\n    };\n}\nfunction file({ label, directory, validation, description, publicPath }) {\n    return {\n        kind: \"form\",\n        formKind: \"asset\",\n        label,\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.am, {\n                label: label,\n                description: description,\n                validation: validation,\n                ...props\n            });\n        },\n        defaultValue () {\n            return null;\n        },\n        filename (value, args) {\n            if (typeof value === \"string\") {\n                return value.slice((0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ak)(publicPath, args.slug).length);\n            }\n            return undefined;\n        },\n        parse (value, args) {\n            var _value$match$, _value$match;\n            if (value === undefined) {\n                return null;\n            }\n            if (typeof value !== \"string\") {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be a string\");\n            }\n            if (args.asset === undefined) {\n                return null;\n            }\n            return {\n                data: args.asset,\n                filename: value.slice((0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ak)(publicPath, args.slug).length),\n                extension: (_value$match$ = (_value$match = value.match(/\\.([^.]+$)/)) === null || _value$match === void 0 ? void 0 : _value$match[1]) !== null && _value$match$ !== void 0 ? _value$match$ : \"\"\n            };\n        },\n        validate (value) {\n            (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ah)(value, validation, label);\n            return value;\n        },\n        serialize (value, args) {\n            if (value === null) {\n                return {\n                    value: undefined,\n                    asset: undefined\n                };\n            }\n            const filename = args.suggestedFilenamePrefix ? args.suggestedFilenamePrefix + \".\" + value.extension : value.filename;\n            return {\n                value: `${(0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ak)(publicPath, args.slug)}${filename}`,\n                asset: {\n                    filename,\n                    content: value.data\n                }\n            };\n        },\n        directory: directory ? (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.al)(directory) : undefined,\n        reader: {\n            parse (value) {\n                if (typeof value !== \"string\" && value !== undefined) {\n                    throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be a string\");\n                }\n                const val = value === undefined ? null : value;\n                (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ah)(val, validation, label);\n                return val;\n            }\n        }\n    };\n}\nfunction validateNumber(validation, value, step, label) {\n    if (value !== null && typeof value !== \"number\") {\n        return `${label} must be a number`;\n    }\n    if (validation !== null && validation !== void 0 && validation.isRequired && value === null) {\n        return `${label} is required`;\n    }\n    if (value !== null) {\n        if ((validation === null || validation === void 0 ? void 0 : validation.min) !== undefined && value < validation.min) {\n            return `${label} must be at least ${validation.min}`;\n        }\n        if ((validation === null || validation === void 0 ? void 0 : validation.max) !== undefined && value > validation.max) {\n            return `${label} must be at most ${validation.max}`;\n        }\n        if (step !== undefined && (validation === null || validation === void 0 ? void 0 : validation.validateStep) !== undefined && new decimal_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](value).mod(new decimal_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](step)).toNumber() !== 0) {\n            return `${label} must be a multiple of ${step}`;\n        }\n    }\n}\nfunction number({ label, defaultValue, step, validation, description }) {\n    return (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ae)({\n        label,\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.an, {\n                label: label,\n                description: description,\n                validation: validation,\n                step: step,\n                ...props\n            });\n        },\n        defaultValue () {\n            return defaultValue !== null && defaultValue !== void 0 ? defaultValue : null;\n        },\n        parse (value) {\n            if (value === undefined) {\n                return null;\n            }\n            if (typeof value === \"number\") {\n                return value;\n            }\n            throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be a number\");\n        },\n        validate (value) {\n            const message = validateNumber(validation, value, step, label);\n            if (message !== undefined) {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(message);\n            }\n            (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ah)(value, validation, label);\n            return value;\n        },\n        serialize (value) {\n            return {\n                value: value === null ? undefined : value\n            };\n        }\n    });\n}\nfunction multiselect({ label, options, defaultValue = [], description }) {\n    const valuesToOption = new Map(options.map((x)=>[\n            x.value,\n            x\n        ]));\n    const field = (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ae)({\n        label,\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ao, {\n                label: label,\n                description: description,\n                options: options,\n                ...props\n            });\n        },\n        defaultValue () {\n            return defaultValue;\n        },\n        parse (value) {\n            if (value === undefined) {\n                return [];\n            }\n            if (!Array.isArray(value)) {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be an array of options\");\n            }\n            if (!value.every((x)=>typeof x === \"string\" && valuesToOption.has(x))) {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(`Must be an array with one of ${options.map((x)=>x.value).join(\", \")}`);\n            }\n            return value;\n        },\n        validate (value) {\n            return value;\n        },\n        serialize (value) {\n            return {\n                value\n            };\n        }\n    });\n    return {\n        ...field,\n        options\n    };\n}\nfunction pathReference({ label, pattern, validation, description }) {\n    return (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ae)({\n        label,\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ap, {\n                label: label,\n                pattern: pattern,\n                description: description,\n                validation: validation,\n                ...props\n            });\n        },\n        defaultValue () {\n            return null;\n        },\n        parse (value) {\n            if (value === undefined) {\n                return null;\n            }\n            if (typeof value !== \"string\") {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be a string\");\n            }\n            return value;\n        },\n        validate (value) {\n            (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ah)(value, validation, label);\n            return value;\n        },\n        serialize (value) {\n            return {\n                value: value === null ? undefined : value\n            };\n        }\n    });\n}\nfunction relationship({ label, collection, validation, description }) {\n    return (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ae)({\n        label,\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.aq, {\n                label: label,\n                collection: collection,\n                description: description,\n                validation: validation,\n                ...props\n            });\n        },\n        defaultValue () {\n            return null;\n        },\n        parse (value) {\n            if (value === undefined) {\n                return null;\n            }\n            if (typeof value !== \"string\") {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be a string\");\n            }\n            return value;\n        },\n        validate (value) {\n            (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ah)(value, validation, label);\n            return value;\n        },\n        serialize (value) {\n            return {\n                value: value === null ? undefined : value\n            };\n        }\n    });\n}\nfunction select({ label, options, defaultValue, description }) {\n    const optionValuesSet = new Set(options.map((x)=>x.value));\n    if (!optionValuesSet.has(defaultValue)) {\n        throw new Error(`A defaultValue of ${defaultValue} was provided to a select field but it does not match the value of one of the options provided`);\n    }\n    const field = (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ae)({\n        label,\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ar, {\n                label: label,\n                options: options,\n                description: description,\n                ...props\n            });\n        },\n        defaultValue () {\n            return defaultValue;\n        },\n        parse (value) {\n            if (value === undefined) {\n                return defaultValue;\n            }\n            if (typeof value !== \"string\") {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be a string\");\n            }\n            if (!optionValuesSet.has(value)) {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be a valid option\");\n            }\n            return value;\n        },\n        validate (value) {\n            return value;\n        },\n        serialize (value) {\n            return {\n                value\n            };\n        }\n    });\n    return {\n        ...field,\n        options\n    };\n}\nfunction parseSlugFieldAsNormalField(value) {\n    if (value === undefined) {\n        return {\n            name: \"\",\n            slug: \"\"\n        };\n    }\n    if (typeof value !== \"object\") {\n        throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be an object\");\n    }\n    if (Object.keys(value).length !== 2) {\n        throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Unexpected keys\");\n    }\n    if (!(\"name\" in value) || !(\"slug\" in value)) {\n        throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Missing name or slug\");\n    }\n    if (typeof value.name !== \"string\") {\n        throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"name must be a string\");\n    }\n    if (typeof value.slug !== \"string\") {\n        throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"slug must be a string\");\n    }\n    return {\n        name: value.name,\n        slug: value.slug\n    };\n}\nfunction parseAsSlugField(value, slug) {\n    if (value === undefined) {\n        return {\n            name: \"\",\n            slug\n        };\n    }\n    if (typeof value !== \"string\") {\n        throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be a string\");\n    }\n    return {\n        name: value,\n        slug\n    };\n}\nfunction slug(args) {\n    var _args$slug, _args$name$defaultVal, _args$name$defaultVal2;\n    const naiveGenerateSlug = ((_args$slug = args.slug) === null || _args$slug === void 0 ? void 0 : _args$slug.generate) || _sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_6__;\n    const defaultValue = {\n        name: (_args$name$defaultVal = args.name.defaultValue) !== null && _args$name$defaultVal !== void 0 ? _args$name$defaultVal : \"\",\n        slug: naiveGenerateSlug((_args$name$defaultVal2 = args.name.defaultValue) !== null && _args$name$defaultVal2 !== void 0 ? _args$name$defaultVal2 : \"\")\n    };\n    function validate(value, { slugField } = {\n        slugField: undefined\n    }) {\n        var _args$name$validation, _args$name$validation2, _args$name$validation3, _args$name$validation4, _args$slug$validation, _args$slug2, _args$slug$validation2, _args$slug3, _args$slug$label, _args$slug4;\n        const nameMessage = (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.at)(value.name, (_args$name$validation = (_args$name$validation2 = args.name.validation) === null || _args$name$validation2 === void 0 || (_args$name$validation2 = _args$name$validation2.length) === null || _args$name$validation2 === void 0 ? void 0 : _args$name$validation2.min) !== null && _args$name$validation !== void 0 ? _args$name$validation : 0, (_args$name$validation3 = (_args$name$validation4 = args.name.validation) === null || _args$name$validation4 === void 0 || (_args$name$validation4 = _args$name$validation4.length) === null || _args$name$validation4 === void 0 ? void 0 : _args$name$validation4.max) !== null && _args$name$validation3 !== void 0 ? _args$name$validation3 : Infinity, args.name.label, undefined);\n        if (nameMessage !== undefined) {\n            throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(nameMessage);\n        }\n        const slugMessage = (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.at)(value.slug, (_args$slug$validation = (_args$slug2 = args.slug) === null || _args$slug2 === void 0 || (_args$slug2 = _args$slug2.validation) === null || _args$slug2 === void 0 || (_args$slug2 = _args$slug2.length) === null || _args$slug2 === void 0 ? void 0 : _args$slug2.min) !== null && _args$slug$validation !== void 0 ? _args$slug$validation : 1, (_args$slug$validation2 = (_args$slug3 = args.slug) === null || _args$slug3 === void 0 || (_args$slug3 = _args$slug3.validation) === null || _args$slug3 === void 0 || (_args$slug3 = _args$slug3.length) === null || _args$slug3 === void 0 ? void 0 : _args$slug3.max) !== null && _args$slug$validation2 !== void 0 ? _args$slug$validation2 : Infinity, (_args$slug$label = (_args$slug4 = args.slug) === null || _args$slug4 === void 0 ? void 0 : _args$slug4.label) !== null && _args$slug$label !== void 0 ? _args$slug$label : \"Slug\", slugField ? slugField : {\n            slugs: emptySet,\n            glob: \"*\"\n        });\n        if (slugMessage !== undefined) {\n            throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(slugMessage);\n        }\n        return value;\n    }\n    const emptySet = new Set();\n    return {\n        kind: \"form\",\n        formKind: \"slug\",\n        label: args.name.label,\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.as, {\n                args: args,\n                naiveGenerateSlug: naiveGenerateSlug,\n                defaultValue: defaultValue,\n                ...props\n            });\n        },\n        defaultValue () {\n            return defaultValue;\n        },\n        parse (value, args) {\n            if ((args === null || args === void 0 ? void 0 : args.slug) !== undefined) {\n                return parseAsSlugField(value, args.slug);\n            }\n            return parseSlugFieldAsNormalField(value);\n        },\n        validate,\n        serialize (value) {\n            return {\n                value\n            };\n        },\n        serializeWithSlug (value) {\n            return {\n                value: value.name,\n                slug: value.slug\n            };\n        },\n        reader: {\n            parse (value) {\n                const parsed = parseSlugFieldAsNormalField(value);\n                return validate(parsed);\n            },\n            parseWithSlug (value, args) {\n                return validate(parseAsSlugField(value, args.slug), {\n                    slugField: {\n                        glob: args.glob,\n                        slugs: emptySet\n                    }\n                }).name;\n            }\n        }\n    };\n}\nfunction validateUrl(validation, value, label) {\n    if (value !== null && (typeof value !== \"string\" || !(0,_isValidURL_c29bb1bd_node_react_server_js__WEBPACK_IMPORTED_MODULE_0__.i)(value))) {\n        return `${label} is not a valid URL`;\n    }\n    if (validation !== null && validation !== void 0 && validation.isRequired && value === null) {\n        return `${label} is required`;\n    }\n}\nfunction url({ label, defaultValue, validation, description }) {\n    return (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ae)({\n        label,\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.au, {\n                label: label,\n                description: description,\n                validation: validation,\n                ...props\n            });\n        },\n        defaultValue () {\n            return defaultValue || null;\n        },\n        parse (value) {\n            if (value === undefined) {\n                return null;\n            }\n            if (typeof value !== \"string\") {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(\"Must be a string\");\n            }\n            return value === \"\" ? null : value;\n        },\n        validate (value) {\n            const message = validateUrl(validation, value, label);\n            if (message !== undefined) {\n                throw new _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ad(message);\n            }\n            (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ah)(value, validation, label);\n            return value;\n        },\n        serialize (value) {\n            return {\n                value: value === null ? undefined : value\n            };\n        }\n    });\n}\nfunction blocks(blocks, opts) {\n    const entries = Object.entries(blocks);\n    if (!entries.length) {\n        throw new Error(\"fields.blocks must have at least one entry\");\n    }\n    const select$1 = select({\n        label: \"Kind\",\n        defaultValue: entries[0][0],\n        options: Object.entries(blocks).map(([key, { label }])=>({\n                label,\n                value: key\n            }))\n    });\n    const element = conditional(select$1, Object.fromEntries(entries.map(([key, { schema }])=>[\n            key,\n            schema\n        ])));\n    return {\n        ...array(element, {\n            label: opts.label,\n            description: opts.description,\n            validation: opts.validation,\n            itemLabel (props) {\n                const kind = props.discriminant;\n                const block = blocks[kind];\n                if (!block.itemLabel) return block.label;\n                return block.itemLabel(props.value);\n            }\n        }),\n        Input: _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.av\n    };\n}\nfunction cloudImage({ label, description, validation }) {\n    return {\n        ...(0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.o)({\n            src: (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.aw)({\n                label: \"URL\",\n                validation: {\n                    length: {\n                        min: validation !== null && validation !== void 0 && validation.isRequired ? 1 : 0\n                    }\n                }\n            }),\n            alt: (0,_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.aw)({\n                label: \"Alt text\"\n            }),\n            height: (0,_index_d66ff99d_node_react_server_js__WEBPACK_IMPORTED_MODULE_4__.i)({\n                label: \"Height\"\n            }),\n            width: (0,_index_d66ff99d_node_react_server_js__WEBPACK_IMPORTED_MODULE_4__.i)({\n                label: \"Width\"\n            })\n        }, {\n            label,\n            description\n        }),\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ax, {\n                ...props,\n                isRequired: validation === null || validation === void 0 ? void 0 : validation.isRequired\n            });\n        }\n    };\n}\nvar index = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    array: array,\n    checkbox: checkbox,\n    child: child,\n    conditional: conditional,\n    date: date,\n    datetime: datetime,\n    document: _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.ay,\n    emptyDocument: emptyDocument,\n    empty: empty,\n    image: image,\n    file: file,\n    integer: _index_d66ff99d_node_react_server_js__WEBPACK_IMPORTED_MODULE_4__.i,\n    number: number,\n    multiselect: multiselect,\n    object: _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.o,\n    pathReference: pathReference,\n    relationship: relationship,\n    select: select,\n    slug: slug,\n    text: _index_04c3e71f_node_react_server_js__WEBPACK_IMPORTED_MODULE_2__.aw,\n    url: url,\n    blocks: blocks,\n    cloudImage: cloudImage\n});\nfunction BlockWrapper() {}\nfunction NotEditable() {}\nfunction ToolbarSeparator() {}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3Qva2V5c3RhdGljLWNvcmUubm9kZS5yZWFjdC1zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkU7QUFDNkI7QUFDckM7QUFDK2Y7QUFDNWhCO0FBQzZCO0FBQ3BDO0FBQ1c7QUFDN0I7QUFDa0I7QUFDUDtBQUNYO0FBQ1c7QUFDUDtBQUNIO0FBQ2U7QUFFL0IsU0FBUzJELE1BQU1DLE9BQU8sRUFBRUMsSUFBSTtJQUMxQixJQUFJQztJQUNKLE9BQU87UUFDTEMsTUFBTTtRQUNOSDtRQUNBSSxPQUFPLENBQUNGLGNBQWNELFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLRyxLQUFLLE1BQU0sUUFBUUYsZ0JBQWdCLEtBQUssSUFBSUEsY0FBYztRQUNqSUcsYUFBYUosU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtJLFdBQVc7UUFDekVDLFdBQVdMLFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLSyxTQUFTO1FBQ3JFQyxZQUFZTixTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBS00sVUFBVTtRQUN2RUMsV0FBV1AsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtPLFNBQVM7UUFDckVDLFlBQVlSLFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLUSxVQUFVO0lBQ3pFO0FBQ0Y7QUFFQSxTQUFTQyxTQUFTLEVBQ2hCTixLQUFLLEVBQ0xPLGVBQWUsS0FBSyxFQUNwQk4sV0FBVyxFQUNaO0lBQ0MsT0FBT3ZELHdFQUFtQ0EsQ0FBQztRQUN6Q3NEO1FBQ0FRLE9BQU1DLEtBQUs7WUFDVCxPQUFPLFdBQVcsR0FBRWxCLHNEQUFHQSxDQUFDM0Msb0VBQWtCQSxFQUFFO2dCQUMxQyxHQUFHNkQsS0FBSztn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QUNSMEIsWUFBWTlCLGVBQWUsUUFBUUEsZUFBZSxLQUFLLElBQUksS0FBSyxJQUFJQSxXQUFXOEIsVUFBVTtZQUMzRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLElBQUlpSCxRQUFRLFdBQVcsR0FBRXpDLE9BQU8wQyxNQUFNLENBQUM7SUFDckNDLFdBQVc7SUFDWDNKLE9BQU9BO0lBQ1BXLFVBQVVBO0lBQ1ZTLE9BQU9BO0lBQ1BlLGFBQWFBO0lBQ2JRLE1BQU1BO0lBQ05jLFVBQVVBO0lBQ1Y5RCxVQUFVQSxvRUFBUUE7SUFDbEJpRSxlQUFlQTtJQUNmUyxPQUFPQTtJQUNQQyxPQUFPQTtJQUNQZ0IsTUFBTUE7SUFDTnpGLFNBQVNBLG1FQUFPQTtJQUNoQitGLFFBQVFBO0lBQ1JDLGFBQWFBO0lBQ2J4RyxRQUFRQSxtRUFBTUE7SUFDZGtILGVBQWVBO0lBQ2ZFLGNBQWNBO0lBQ2RDLFFBQVFBO0lBQ1I5QixNQUFNQTtJQUNOckYsTUFBTUEsb0VBQUlBO0lBQ1ZxSixLQUFLQTtJQUNMQyxRQUFRQTtJQUNSTyxZQUFZQTtBQUNkO0FBRUEsU0FBU1EsZ0JBQWdCO0FBQ3pCLFNBQVNDLGVBQWU7QUFDeEIsU0FBU0Msb0JBQW9CO0FBRTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGtleXN0YXRpYy90ZW1wbGF0ZXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BrZXlzdGF0aWMvY29yZS9kaXN0L2tleXN0YXRpYy1jb3JlLm5vZGUucmVhY3Qtc2VydmVyLmpzP2E5MjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaSBhcyBpc1ZhbGlkVVJMIH0gZnJvbSAnLi9pc1ZhbGlkVVJMLWMyOWJiMWJkLm5vZGUucmVhY3Qtc2VydmVyLmpzJztcbmV4cG9ydCB7IGEgYXMgY29sbGVjdGlvbiwgYyBhcyBjb25maWcsIHMgYXMgc2luZ2xldG9uIH0gZnJvbSAnLi9pc1ZhbGlkVVJMLWMyOWJiMWJkLm5vZGUucmVhY3Qtc2VydmVyLmpzJztcbmV4cG9ydCB7IGMgYXMgY29tcG9uZW50IH0gZnJvbSAnLi9hcGktYmNlZjE2Nzkubm9kZS5yZWFjdC1zZXJ2ZXIuanMnO1xuaW1wb3J0IHsgYWUgYXMgYmFzaWNGb3JtRmllbGRXaXRoU2ltcGxlUmVhZGVyUGFyc2UsIGFmIGFzIENoZWNrYm94RmllbGRJbnB1dCwgYWQgYXMgRmllbGREYXRhRXJyb3IsIGFnIGFzIERhdGVGaWVsZElucHV0LCBhaCBhcyBhc3NlcnRSZXF1aXJlZCwgYWkgYXMgRGF0ZXRpbWVGaWVsZElucHV0LCBhaiBhcyBJbWFnZUZpZWxkSW5wdXQsIGFrIGFzIGdldFNyY1ByZWZpeCwgYWwgYXMgZml4UGF0aCwgYW0gYXMgRmlsZUZpZWxkSW5wdXQsIGFuIGFzIE51bWJlckZpZWxkSW5wdXQsIGFvIGFzIE11bHRpc2VsZWN0RmllbGRJbnB1dCwgYXAgYXMgUGF0aFJlZmVyZW5jZUlucHV0LCBhcSBhcyBSZWxhdGlvbnNoaXBJbnB1dCwgYXIgYXMgU2VsZWN0RmllbGRJbnB1dCwgYXMgYXMgU2x1Z0ZpZWxkSW5wdXQsIGF0IGFzIHZhbGlkYXRlVGV4dCwgYXUgYXMgVXJsRmllbGRJbnB1dCwgYXYgYXMgQmxvY2tzRmllbGRJbnB1dCwgbyBhcyBvYmplY3QsIGF3IGFzIHRleHQsIGF4IGFzIENsb3VkSW1hZ2VGaWVsZElucHV0LCBheSBhcyBkb2N1bWVudCB9IGZyb20gJy4vaW5kZXgtMDRjM2U3MWYubm9kZS5yZWFjdC1zZXJ2ZXIuanMnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgaSBhcyBpbnRlZ2VyIH0gZnJvbSAnLi9pbmRleC1kNjZmZjk5ZC5ub2RlLnJlYWN0LXNlcnZlci5qcyc7XG5pbXBvcnQgRGVjaW1hbCBmcm9tICdkZWNpbWFsLmpzJztcbmltcG9ydCBzbHVnaWZ5IGZyb20gJ0BzaW5kcmVzb3JodXMvc2x1Z2lmeSc7XG5pbXBvcnQgJ2VtZXJ5JztcbmltcG9ydCAnQGJyYWludHJlZS9zYW5pdGl6ZS11cmwnO1xuaW1wb3J0ICdAbWFya2RvYy9tYXJrZG9jJztcbmltcG9ydCAnc2xhdGUnO1xuaW1wb3J0ICdlbWVyeS9hc3NlcnRpb25zJztcbmltcG9ydCAnanMtYmFzZTY0JztcbmltcG9ydCAnY3J5cHRvJztcbmltcG9ydCAnQGVtb3Rpb24vd2Vhay1tZW1vaXplJztcblxuZnVuY3Rpb24gYXJyYXkoZWxlbWVudCwgb3B0cykge1xuICB2YXIgX29wdHMkbGFiZWw7XG4gIHJldHVybiB7XG4gICAga2luZDogJ2FycmF5JyxcbiAgICBlbGVtZW50LFxuICAgIGxhYmVsOiAoX29wdHMkbGFiZWwgPSBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMubGFiZWwpICE9PSBudWxsICYmIF9vcHRzJGxhYmVsICE9PSB2b2lkIDAgPyBfb3B0cyRsYWJlbCA6ICdJdGVtcycsXG4gICAgZGVzY3JpcHRpb246IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5kZXNjcmlwdGlvbixcbiAgICBpdGVtTGFiZWw6IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5pdGVtTGFiZWwsXG4gICAgYXNDaGlsZFRhZzogb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmFzQ2hpbGRUYWcsXG4gICAgc2x1Z0ZpZWxkOiBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2x1Z0ZpZWxkLFxuICAgIHZhbGlkYXRpb246IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy52YWxpZGF0aW9uXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNoZWNrYm94KHtcbiAgbGFiZWwsXG4gIGRlZmF1bHRWYWx1ZSA9IGZhbHNlLFxuICBkZXNjcmlwdGlvblxufSkge1xuICByZXR1cm4gYmFzaWNGb3JtRmllbGRXaXRoU2ltcGxlUmVhZGVyUGFyc2Uoe1xuICAgIGxhYmVsLFxuICAgIElucHV0KHByb3BzKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2pzeChDaGVja2JveEZpZWxkSW5wdXQsIHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfSxcbiAgICBwYXJzZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKCdNdXN0IGJlIGEgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY2hpbGQob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6ICdjaGlsZCcsXG4gICAgb3B0aW9uczogb3B0aW9ucy5raW5kID09PSAnYmxvY2snID8ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGRpdmlkZXJzOiBvcHRpb25zLmRpdmlkZXJzLFxuICAgICAgZm9ybWF0dGluZzogb3B0aW9ucy5mb3JtYXR0aW5nID09PSAnaW5oZXJpdCcgPyB7XG4gICAgICAgIGJsb2NrVHlwZXM6ICdpbmhlcml0JyxcbiAgICAgICAgaGVhZGluZ0xldmVsczogJ2luaGVyaXQnLFxuICAgICAgICBpbmxpbmVNYXJrczogJ2luaGVyaXQnLFxuICAgICAgICBsaXN0VHlwZXM6ICdpbmhlcml0JyxcbiAgICAgICAgYWxpZ25tZW50OiAnaW5oZXJpdCcsXG4gICAgICAgIHNvZnRCcmVha3M6ICdpbmhlcml0J1xuICAgICAgfSA6IG9wdGlvbnMuZm9ybWF0dGluZyxcbiAgICAgIGxpbmtzOiBvcHRpb25zLmxpbmtzLFxuICAgICAgaW1hZ2VzOiBvcHRpb25zLmltYWdlcyxcbiAgICAgIHRhYmxlczogb3B0aW9ucy50YWJsZXMsXG4gICAgICBjb21wb25lbnRCbG9ja3M6IG9wdGlvbnMuY29tcG9uZW50QmxvY2tzXG4gICAgfSA6IHtcbiAgICAgIGtpbmQ6ICdpbmxpbmUnLFxuICAgICAgcGxhY2Vob2xkZXI6IG9wdGlvbnMucGxhY2Vob2xkZXIsXG4gICAgICBmb3JtYXR0aW5nOiBvcHRpb25zLmZvcm1hdHRpbmcgPT09ICdpbmhlcml0JyA/IHtcbiAgICAgICAgaW5saW5lTWFya3M6ICdpbmhlcml0JyxcbiAgICAgICAgc29mdEJyZWFrczogJ2luaGVyaXQnXG4gICAgICB9IDogb3B0aW9ucy5mb3JtYXR0aW5nLFxuICAgICAgbGlua3M6IG9wdGlvbnMubGlua3NcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbmRpdGlvbmFsKGRpc2NyaW1pbmFudCwgdmFsdWVzKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogJ2NvbmRpdGlvbmFsJyxcbiAgICBkaXNjcmltaW5hbnQsXG4gICAgdmFsdWVzOiB2YWx1ZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEYXRlKHZhbGlkYXRpb24sIHZhbHVlLCBsYWJlbCkge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgIS9eXFxkezR9LVxcZHsyfS1cXGR7Mn0kLy50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBgJHtsYWJlbH0gaXMgbm90IGEgdmFsaWQgZGF0ZWA7XG4gIH1cbiAgaWYgKHZhbGlkYXRpb24gIT09IG51bGwgJiYgdmFsaWRhdGlvbiAhPT0gdm9pZCAwICYmIHZhbGlkYXRpb24uaXNSZXF1aXJlZCAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBgJHtsYWJlbH0gaXMgcmVxdWlyZWRgO1xuICB9XG4gIGlmICgodmFsaWRhdGlvbiAhPT0gbnVsbCAmJiB2YWxpZGF0aW9uICE9PSB2b2lkIDAgJiYgdmFsaWRhdGlvbi5taW4gfHwgdmFsaWRhdGlvbiAhPT0gbnVsbCAmJiB2YWxpZGF0aW9uICE9PSB2b2lkIDAgJiYgdmFsaWRhdGlvbi5tYXgpICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICBpZiAoKHZhbGlkYXRpb24gPT09IG51bGwgfHwgdmFsaWRhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsaWRhdGlvbi5taW4pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG1pbiA9IG5ldyBEYXRlKHZhbGlkYXRpb24ubWluKTtcbiAgICAgIGlmIChkYXRlIDwgbWluKSB7XG4gICAgICAgIHJldHVybiBgJHtsYWJlbH0gbXVzdCBiZSBhZnRlciAke21pbi50b0xvY2FsZURhdGVTdHJpbmcoKX1gO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKHZhbGlkYXRpb24gPT09IG51bGwgfHwgdmFsaWRhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsaWRhdGlvbi5tYXgpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG1heCA9IG5ldyBEYXRlKHZhbGlkYXRpb24ubWF4KTtcbiAgICAgIGlmIChkYXRlID4gbWF4KSB7XG4gICAgICAgIHJldHVybiBgJHtsYWJlbH0gbXVzdCBiZSBubyBsYXRlciB0aGFuICR7bWF4LnRvTG9jYWxlRGF0ZVN0cmluZygpfWA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRhdGUoe1xuICBsYWJlbCxcbiAgZGVmYXVsdFZhbHVlLFxuICB2YWxpZGF0aW9uLFxuICBkZXNjcmlwdGlvblxufSkge1xuICByZXR1cm4gYmFzaWNGb3JtRmllbGRXaXRoU2ltcGxlUmVhZGVyUGFyc2Uoe1xuICAgIGxhYmVsLFxuICAgIElucHV0KHByb3BzKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2pzeChEYXRlRmllbGRJbnB1dCwge1xuICAgICAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uLFxuICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgLi4ucHJvcHNcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB5ZWFyID0gdG9kYXkuZ2V0RnVsbFllYXIoKTtcbiAgICAgIGNvbnN0IG1vbnRoID0gU3RyaW5nKHRvZGF5LmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgY29uc3QgZGF5ID0gU3RyaW5nKHRvZGF5LmdldERhdGUoKSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgIHJldHVybiBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1gO1xuICAgIH0sXG4gICAgcGFyc2UodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKCdNdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHZhbHVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB2YWxpZGF0ZURhdGUodmFsaWRhdGlvbiwgdmFsdWUsIGxhYmVsKTtcbiAgICAgIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0UmVxdWlyZWQodmFsdWUsIHZhbGlkYXRpb24sIGxhYmVsKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURhdGV0aW1lKHZhbGlkYXRpb24sIHZhbHVlLCBsYWJlbCkge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgIS9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfSQvLnRlc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGAke2xhYmVsfSBpcyBub3QgYSB2YWxpZCBkYXRldGltZWA7XG4gIH1cbiAgaWYgKHZhbGlkYXRpb24gIT09IG51bGwgJiYgdmFsaWRhdGlvbiAhPT0gdm9pZCAwICYmIHZhbGlkYXRpb24uaXNSZXF1aXJlZCAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBgJHtsYWJlbH0gaXMgcmVxdWlyZWRgO1xuICB9XG4gIGlmICgodmFsaWRhdGlvbiAhPT0gbnVsbCAmJiB2YWxpZGF0aW9uICE9PSB2b2lkIDAgJiYgdmFsaWRhdGlvbi5taW4gfHwgdmFsaWRhdGlvbiAhPT0gbnVsbCAmJiB2YWxpZGF0aW9uICE9PSB2b2lkIDAgJiYgdmFsaWRhdGlvbi5tYXgpICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgY29uc3QgZGF0ZXRpbWUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgaWYgKCh2YWxpZGF0aW9uID09PSBudWxsIHx8IHZhbGlkYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbGlkYXRpb24ubWluKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBtaW4gPSBuZXcgRGF0ZSh2YWxpZGF0aW9uLm1pbik7XG4gICAgICBpZiAoZGF0ZXRpbWUgPCBtaW4pIHtcbiAgICAgICAgcmV0dXJuIGAke2xhYmVsfSBtdXN0IGJlIGFmdGVyICR7bWluLnRvSVNPU3RyaW5nKCl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCh2YWxpZGF0aW9uID09PSBudWxsIHx8IHZhbGlkYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbGlkYXRpb24ubWF4KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBtYXggPSBuZXcgRGF0ZSh2YWxpZGF0aW9uLm1heCk7XG4gICAgICBpZiAoZGF0ZXRpbWUgPiBtYXgpIHtcbiAgICAgICAgcmV0dXJuIGAke2xhYmVsfSBtdXN0IGJlIG5vIGxhdGVyIHRoYW4gJHttYXgudG9JU09TdHJpbmcoKX1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRldGltZSh7XG4gIGxhYmVsLFxuICBkZWZhdWx0VmFsdWUsXG4gIHZhbGlkYXRpb24sXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIHJldHVybiBiYXNpY0Zvcm1GaWVsZFdpdGhTaW1wbGVSZWFkZXJQYXJzZSh7XG4gICAgbGFiZWwsXG4gICAgSW5wdXQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KERhdGV0aW1lRmllbGRJbnB1dCwge1xuICAgICAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uLFxuICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgLi4ucHJvcHNcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlLmtpbmQgPT09ICdub3cnKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHJldHVybiBub3cudG9JU09TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgcGFyc2UodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKCdNdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHZhbHVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB2YWxpZGF0ZURhdGV0aW1lKHZhbGlkYXRpb24sIHZhbHVlLCBsYWJlbCk7XG4gICAgICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydFJlcXVpcmVkKHZhbHVlLCB2YWxpZGF0aW9uLCBsYWJlbCk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZW1wdHlEb2N1bWVudCgpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiAnZm9ybScsXG4gICAgZm9ybUtpbmQ6ICdjb250ZW50JyxcbiAgICBJbnB1dCgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBwYXJzZSgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgY29udGVudEV4dGVuc2lvbjogJy5tZG9jJyxcbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZW50OiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBleHRlcm5hbDogbmV3IE1hcCgpLFxuICAgICAgICBvdGhlcjogbmV3IE1hcCgpXG4gICAgICB9O1xuICAgIH0sXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlYWRlcjoge1xuICAgICAgcGFyc2UoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gIHJldHVybiBiYXNpY0Zvcm1GaWVsZFdpdGhTaW1wbGVSZWFkZXJQYXJzZSh7XG4gICAgSW5wdXQoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgcGFyc2UoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfSxcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgbGFiZWw6ICdFbXB0eSdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGltYWdlKHtcbiAgbGFiZWwsXG4gIGRpcmVjdG9yeSxcbiAgdmFsaWRhdGlvbixcbiAgZGVzY3JpcHRpb24sXG4gIHB1YmxpY1BhdGhcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiAnZm9ybScsXG4gICAgZm9ybUtpbmQ6ICdhc3NldCcsXG4gICAgbGFiZWwsXG4gICAgSW5wdXQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KEltYWdlRmllbGRJbnB1dCwge1xuICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgdmFsaWRhdGlvbjogdmFsaWRhdGlvbixcbiAgICAgICAgLi4ucHJvcHNcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmaWxlbmFtZSh2YWx1ZSwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKGdldFNyY1ByZWZpeChwdWJsaWNQYXRoLCBhcmdzLnNsdWcpLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgcGFyc2UodmFsdWUsIGFyZ3MpIHtcbiAgICAgIHZhciBfdmFsdWUkbWF0Y2gkLCBfdmFsdWUkbWF0Y2g7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcignTXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ3MuYXNzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGFyZ3MuYXNzZXQsXG4gICAgICAgIGZpbGVuYW1lOiB2YWx1ZS5zbGljZShnZXRTcmNQcmVmaXgocHVibGljUGF0aCwgYXJncy5zbHVnKS5sZW5ndGgpLFxuICAgICAgICBleHRlbnNpb246IChfdmFsdWUkbWF0Y2gkID0gKF92YWx1ZSRtYXRjaCA9IHZhbHVlLm1hdGNoKC9cXC4oW14uXSskKS8pKSA9PT0gbnVsbCB8fCBfdmFsdWUkbWF0Y2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92YWx1ZSRtYXRjaFsxXSkgIT09IG51bGwgJiYgX3ZhbHVlJG1hdGNoJCAhPT0gdm9pZCAwID8gX3ZhbHVlJG1hdGNoJCA6ICcnXG4gICAgICB9O1xuICAgIH0sXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgIGFzc2VydFJlcXVpcmVkKHZhbHVlLCB2YWxpZGF0aW9uLCBsYWJlbCk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBzZXJpYWxpemUodmFsdWUsIGFyZ3MpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgYXNzZXQ6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgZmlsZW5hbWUgPSBhcmdzLnN1Z2dlc3RlZEZpbGVuYW1lUHJlZml4ID8gYXJncy5zdWdnZXN0ZWRGaWxlbmFtZVByZWZpeCArICcuJyArIHZhbHVlLmV4dGVuc2lvbiA6IHZhbHVlLmZpbGVuYW1lO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGAke2dldFNyY1ByZWZpeChwdWJsaWNQYXRoLCBhcmdzLnNsdWcpfSR7ZmlsZW5hbWV9YCxcbiAgICAgICAgYXNzZXQ6IHtcbiAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICBjb250ZW50OiB2YWx1ZS5kYXRhXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBkaXJlY3Rvcnk6IGRpcmVjdG9yeSA/IGZpeFBhdGgoZGlyZWN0b3J5KSA6IHVuZGVmaW5lZCxcbiAgICByZWFkZXI6IHtcbiAgICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ011c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWwgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHZhbHVlO1xuICAgICAgICBhc3NlcnRSZXF1aXJlZCh2YWwsIHZhbGlkYXRpb24sIGxhYmVsKTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbGUoe1xuICBsYWJlbCxcbiAgZGlyZWN0b3J5LFxuICB2YWxpZGF0aW9uLFxuICBkZXNjcmlwdGlvbixcbiAgcHVibGljUGF0aFxufSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6ICdmb3JtJyxcbiAgICBmb3JtS2luZDogJ2Fzc2V0JyxcbiAgICBsYWJlbCxcbiAgICBJbnB1dChwcm9wcykge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goRmlsZUZpZWxkSW5wdXQsIHtcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgIHZhbGlkYXRpb246IHZhbGlkYXRpb24sXG4gICAgICAgIC4uLnByb3BzXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZmlsZW5hbWUodmFsdWUsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5zbGljZShnZXRTcmNQcmVmaXgocHVibGljUGF0aCwgYXJncy5zbHVnKS5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIHBhcnNlKHZhbHVlLCBhcmdzKSB7XG4gICAgICB2YXIgX3ZhbHVlJG1hdGNoJCwgX3ZhbHVlJG1hdGNoO1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ011c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmdzLmFzc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBhcmdzLmFzc2V0LFxuICAgICAgICBmaWxlbmFtZTogdmFsdWUuc2xpY2UoZ2V0U3JjUHJlZml4KHB1YmxpY1BhdGgsIGFyZ3Muc2x1ZykubGVuZ3RoKSxcbiAgICAgICAgZXh0ZW5zaW9uOiAoX3ZhbHVlJG1hdGNoJCA9IChfdmFsdWUkbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXFwuKFteLl0rJCkvKSkgPT09IG51bGwgfHwgX3ZhbHVlJG1hdGNoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdmFsdWUkbWF0Y2hbMV0pICE9PSBudWxsICYmIF92YWx1ZSRtYXRjaCQgIT09IHZvaWQgMCA/IF92YWx1ZSRtYXRjaCQgOiAnJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICBhc3NlcnRSZXF1aXJlZCh2YWx1ZSwgdmFsaWRhdGlvbiwgbGFiZWwpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2VyaWFsaXplKHZhbHVlLCBhcmdzKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGFzc2V0OiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbGVuYW1lID0gYXJncy5zdWdnZXN0ZWRGaWxlbmFtZVByZWZpeCA/IGFyZ3Muc3VnZ2VzdGVkRmlsZW5hbWVQcmVmaXggKyAnLicgKyB2YWx1ZS5leHRlbnNpb24gOiB2YWx1ZS5maWxlbmFtZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBgJHtnZXRTcmNQcmVmaXgocHVibGljUGF0aCwgYXJncy5zbHVnKX0ke2ZpbGVuYW1lfWAsXG4gICAgICAgIGFzc2V0OiB7XG4gICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgY29udGVudDogdmFsdWUuZGF0YVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgZGlyZWN0b3J5OiBkaXJlY3RvcnkgPyBmaXhQYXRoKGRpcmVjdG9yeSkgOiB1bmRlZmluZWQsXG4gICAgcmVhZGVyOiB7XG4gICAgICBwYXJzZSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKCdNdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2YWx1ZTtcbiAgICAgICAgYXNzZXJ0UmVxdWlyZWQodmFsLCB2YWxpZGF0aW9uLCBsYWJlbCk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcih2YWxpZGF0aW9uLCB2YWx1ZSwgc3RlcCwgbGFiZWwpIHtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gYCR7bGFiZWx9IG11c3QgYmUgYSBudW1iZXJgO1xuICB9XG4gIGlmICh2YWxpZGF0aW9uICE9PSBudWxsICYmIHZhbGlkYXRpb24gIT09IHZvaWQgMCAmJiB2YWxpZGF0aW9uLmlzUmVxdWlyZWQgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gYCR7bGFiZWx9IGlzIHJlcXVpcmVkYDtcbiAgfVxuICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICBpZiAoKHZhbGlkYXRpb24gPT09IG51bGwgfHwgdmFsaWRhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsaWRhdGlvbi5taW4pICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPCB2YWxpZGF0aW9uLm1pbikge1xuICAgICAgcmV0dXJuIGAke2xhYmVsfSBtdXN0IGJlIGF0IGxlYXN0ICR7dmFsaWRhdGlvbi5taW59YDtcbiAgICB9XG4gICAgaWYgKCh2YWxpZGF0aW9uID09PSBudWxsIHx8IHZhbGlkYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbGlkYXRpb24ubWF4KSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlID4gdmFsaWRhdGlvbi5tYXgpIHtcbiAgICAgIHJldHVybiBgJHtsYWJlbH0gbXVzdCBiZSBhdCBtb3N0ICR7dmFsaWRhdGlvbi5tYXh9YDtcbiAgICB9XG4gICAgaWYgKHN0ZXAgIT09IHVuZGVmaW5lZCAmJiAodmFsaWRhdGlvbiA9PT0gbnVsbCB8fCB2YWxpZGF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWxpZGF0aW9uLnZhbGlkYXRlU3RlcCkgIT09IHVuZGVmaW5lZCAmJiBuZXcgRGVjaW1hbCh2YWx1ZSkubW9kKG5ldyBEZWNpbWFsKHN0ZXApKS50b051bWJlcigpICE9PSAwKSB7XG4gICAgICByZXR1cm4gYCR7bGFiZWx9IG11c3QgYmUgYSBtdWx0aXBsZSBvZiAke3N0ZXB9YDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbnVtYmVyKHtcbiAgbGFiZWwsXG4gIGRlZmF1bHRWYWx1ZSxcbiAgc3RlcCxcbiAgdmFsaWRhdGlvbixcbiAgZGVzY3JpcHRpb25cbn0pIHtcbiAgcmV0dXJuIGJhc2ljRm9ybUZpZWxkV2l0aFNpbXBsZVJlYWRlclBhcnNlKHtcbiAgICBsYWJlbCxcbiAgICBJbnB1dChwcm9wcykge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goTnVtYmVyRmllbGRJbnB1dCwge1xuICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgdmFsaWRhdGlvbjogdmFsaWRhdGlvbixcbiAgICAgICAgc3RlcDogc3RlcCxcbiAgICAgICAgLi4ucHJvcHNcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgIT09IHZvaWQgMCA/IGRlZmF1bHRWYWx1ZSA6IG51bGw7XG4gICAgfSxcbiAgICBwYXJzZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ011c3QgYmUgYSBudW1iZXInKTtcbiAgICB9LFxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gdmFsaWRhdGVOdW1iZXIodmFsaWRhdGlvbiwgdmFsdWUsIHN0ZXAsIGxhYmVsKTtcbiAgICAgIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0UmVxdWlyZWQodmFsdWUsIHZhbGlkYXRpb24sIGxhYmVsKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlID09PSBudWxsID8gdW5kZWZpbmVkIDogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbXVsdGlzZWxlY3Qoe1xuICBsYWJlbCxcbiAgb3B0aW9ucyxcbiAgZGVmYXVsdFZhbHVlID0gW10sXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIGNvbnN0IHZhbHVlc1RvT3B0aW9uID0gbmV3IE1hcChvcHRpb25zLm1hcCh4ID0+IFt4LnZhbHVlLCB4XSkpO1xuICBjb25zdCBmaWVsZCA9IGJhc2ljRm9ybUZpZWxkV2l0aFNpbXBsZVJlYWRlclBhcnNlKHtcbiAgICBsYWJlbCxcbiAgICBJbnB1dChwcm9wcykge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goTXVsdGlzZWxlY3RGaWVsZElucHV0LCB7XG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAuLi5wcm9wc1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH0sXG4gICAgcGFyc2UodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKCdNdXN0IGJlIGFuIGFycmF5IG9mIG9wdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsdWUuZXZlcnkoeCA9PiB0eXBlb2YgeCA9PT0gJ3N0cmluZycgJiYgdmFsdWVzVG9PcHRpb24uaGFzKHgpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoYE11c3QgYmUgYW4gYXJyYXkgd2l0aCBvbmUgb2YgJHtvcHRpb25zLm1hcCh4ID0+IHgudmFsdWUpLmpvaW4oJywgJyl9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLmZpZWxkLFxuICAgIG9wdGlvbnNcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGF0aFJlZmVyZW5jZSh7XG4gIGxhYmVsLFxuICBwYXR0ZXJuLFxuICB2YWxpZGF0aW9uLFxuICBkZXNjcmlwdGlvblxufSkge1xuICByZXR1cm4gYmFzaWNGb3JtRmllbGRXaXRoU2ltcGxlUmVhZGVyUGFyc2Uoe1xuICAgIGxhYmVsLFxuICAgIElucHV0KHByb3BzKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2pzeChQYXRoUmVmZXJlbmNlSW5wdXQsIHtcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuLFxuICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgIHZhbGlkYXRpb246IHZhbGlkYXRpb24sXG4gICAgICAgIC4uLnByb3BzXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgcGFyc2UodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKCdNdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgYXNzZXJ0UmVxdWlyZWQodmFsdWUsIHZhbGlkYXRpb24sIGxhYmVsKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlID09PSBudWxsID8gdW5kZWZpbmVkIDogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVsYXRpb25zaGlwKHtcbiAgbGFiZWwsXG4gIGNvbGxlY3Rpb24sXG4gIHZhbGlkYXRpb24sXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIHJldHVybiBiYXNpY0Zvcm1GaWVsZFdpdGhTaW1wbGVSZWFkZXJQYXJzZSh7XG4gICAgbGFiZWwsXG4gICAgSW5wdXQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFJlbGF0aW9uc2hpcElucHV0LCB7XG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbiAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uLFxuICAgICAgICAuLi5wcm9wc1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcignTXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgIGFzc2VydFJlcXVpcmVkKHZhbHVlLCB2YWxpZGF0aW9uLCBsYWJlbCk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdCh7XG4gIGxhYmVsLFxuICBvcHRpb25zLFxuICBkZWZhdWx0VmFsdWUsXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIGNvbnN0IG9wdGlvblZhbHVlc1NldCA9IG5ldyBTZXQob3B0aW9ucy5tYXAoeCA9PiB4LnZhbHVlKSk7XG4gIGlmICghb3B0aW9uVmFsdWVzU2V0LmhhcyhkZWZhdWx0VmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBIGRlZmF1bHRWYWx1ZSBvZiAke2RlZmF1bHRWYWx1ZX0gd2FzIHByb3ZpZGVkIHRvIGEgc2VsZWN0IGZpZWxkIGJ1dCBpdCBkb2VzIG5vdCBtYXRjaCB0aGUgdmFsdWUgb2Ygb25lIG9mIHRoZSBvcHRpb25zIHByb3ZpZGVkYCk7XG4gIH1cbiAgY29uc3QgZmllbGQgPSBiYXNpY0Zvcm1GaWVsZFdpdGhTaW1wbGVSZWFkZXJQYXJzZSh7XG4gICAgbGFiZWwsXG4gICAgSW5wdXQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFNlbGVjdEZpZWxkSW5wdXQsIHtcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgIC4uLnByb3BzXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfSxcbiAgICBwYXJzZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcignTXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25WYWx1ZXNTZXQuaGFzKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ011c3QgYmUgYSB2YWxpZCBvcHRpb24nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uZmllbGQsXG4gICAgb3B0aW9uc1xuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVNsdWdGaWVsZEFzTm9ybWFsRmllbGQodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJycsXG4gICAgICBzbHVnOiAnJ1xuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ011c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ1VuZXhwZWN0ZWQga2V5cycpO1xuICB9XG4gIGlmICghKCduYW1lJyBpbiB2YWx1ZSkgfHwgISgnc2x1ZycgaW4gdmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKCdNaXNzaW5nIG5hbWUgb3Igc2x1ZycpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ25hbWUgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUuc2x1ZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ3NsdWcgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogdmFsdWUubmFtZSxcbiAgICBzbHVnOiB2YWx1ZS5zbHVnXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUFzU2x1Z0ZpZWxkKHZhbHVlLCBzbHVnKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICcnLFxuICAgICAgc2x1Z1xuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ011c3QgYmUgYSBzdHJpbmcnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6IHZhbHVlLFxuICAgIHNsdWdcbiAgfTtcbn1cbmZ1bmN0aW9uIHNsdWcoYXJncykge1xuICB2YXIgX2FyZ3Mkc2x1ZywgX2FyZ3MkbmFtZSRkZWZhdWx0VmFsLCBfYXJncyRuYW1lJGRlZmF1bHRWYWwyO1xuICBjb25zdCBuYWl2ZUdlbmVyYXRlU2x1ZyA9ICgoX2FyZ3Mkc2x1ZyA9IGFyZ3Muc2x1ZykgPT09IG51bGwgfHwgX2FyZ3Mkc2x1ZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FyZ3Mkc2x1Zy5nZW5lcmF0ZSkgfHwgc2x1Z2lmeTtcbiAgY29uc3QgZGVmYXVsdFZhbHVlID0ge1xuICAgIG5hbWU6IChfYXJncyRuYW1lJGRlZmF1bHRWYWwgPSBhcmdzLm5hbWUuZGVmYXVsdFZhbHVlKSAhPT0gbnVsbCAmJiBfYXJncyRuYW1lJGRlZmF1bHRWYWwgIT09IHZvaWQgMCA/IF9hcmdzJG5hbWUkZGVmYXVsdFZhbCA6ICcnLFxuICAgIHNsdWc6IG5haXZlR2VuZXJhdGVTbHVnKChfYXJncyRuYW1lJGRlZmF1bHRWYWwyID0gYXJncy5uYW1lLmRlZmF1bHRWYWx1ZSkgIT09IG51bGwgJiYgX2FyZ3MkbmFtZSRkZWZhdWx0VmFsMiAhPT0gdm9pZCAwID8gX2FyZ3MkbmFtZSRkZWZhdWx0VmFsMiA6ICcnKVxuICB9O1xuICBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSwge1xuICAgIHNsdWdGaWVsZFxuICB9ID0ge1xuICAgIHNsdWdGaWVsZDogdW5kZWZpbmVkXG4gIH0pIHtcbiAgICB2YXIgX2FyZ3MkbmFtZSR2YWxpZGF0aW9uLCBfYXJncyRuYW1lJHZhbGlkYXRpb24yLCBfYXJncyRuYW1lJHZhbGlkYXRpb24zLCBfYXJncyRuYW1lJHZhbGlkYXRpb240LCBfYXJncyRzbHVnJHZhbGlkYXRpb24sIF9hcmdzJHNsdWcyLCBfYXJncyRzbHVnJHZhbGlkYXRpb24yLCBfYXJncyRzbHVnMywgX2FyZ3Mkc2x1ZyRsYWJlbCwgX2FyZ3Mkc2x1ZzQ7XG4gICAgY29uc3QgbmFtZU1lc3NhZ2UgPSB2YWxpZGF0ZVRleHQodmFsdWUubmFtZSwgKF9hcmdzJG5hbWUkdmFsaWRhdGlvbiA9IChfYXJncyRuYW1lJHZhbGlkYXRpb24yID0gYXJncy5uYW1lLnZhbGlkYXRpb24pID09PSBudWxsIHx8IF9hcmdzJG5hbWUkdmFsaWRhdGlvbjIgPT09IHZvaWQgMCB8fCAoX2FyZ3MkbmFtZSR2YWxpZGF0aW9uMiA9IF9hcmdzJG5hbWUkdmFsaWRhdGlvbjIubGVuZ3RoKSA9PT0gbnVsbCB8fCBfYXJncyRuYW1lJHZhbGlkYXRpb24yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYXJncyRuYW1lJHZhbGlkYXRpb24yLm1pbikgIT09IG51bGwgJiYgX2FyZ3MkbmFtZSR2YWxpZGF0aW9uICE9PSB2b2lkIDAgPyBfYXJncyRuYW1lJHZhbGlkYXRpb24gOiAwLCAoX2FyZ3MkbmFtZSR2YWxpZGF0aW9uMyA9IChfYXJncyRuYW1lJHZhbGlkYXRpb240ID0gYXJncy5uYW1lLnZhbGlkYXRpb24pID09PSBudWxsIHx8IF9hcmdzJG5hbWUkdmFsaWRhdGlvbjQgPT09IHZvaWQgMCB8fCAoX2FyZ3MkbmFtZSR2YWxpZGF0aW9uNCA9IF9hcmdzJG5hbWUkdmFsaWRhdGlvbjQubGVuZ3RoKSA9PT0gbnVsbCB8fCBfYXJncyRuYW1lJHZhbGlkYXRpb240ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYXJncyRuYW1lJHZhbGlkYXRpb240Lm1heCkgIT09IG51bGwgJiYgX2FyZ3MkbmFtZSR2YWxpZGF0aW9uMyAhPT0gdm9pZCAwID8gX2FyZ3MkbmFtZSR2YWxpZGF0aW9uMyA6IEluZmluaXR5LCBhcmdzLm5hbWUubGFiZWwsIHVuZGVmaW5lZCk7XG4gICAgaWYgKG5hbWVNZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcihuYW1lTWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IHNsdWdNZXNzYWdlID0gdmFsaWRhdGVUZXh0KHZhbHVlLnNsdWcsIChfYXJncyRzbHVnJHZhbGlkYXRpb24gPSAoX2FyZ3Mkc2x1ZzIgPSBhcmdzLnNsdWcpID09PSBudWxsIHx8IF9hcmdzJHNsdWcyID09PSB2b2lkIDAgfHwgKF9hcmdzJHNsdWcyID0gX2FyZ3Mkc2x1ZzIudmFsaWRhdGlvbikgPT09IG51bGwgfHwgX2FyZ3Mkc2x1ZzIgPT09IHZvaWQgMCB8fCAoX2FyZ3Mkc2x1ZzIgPSBfYXJncyRzbHVnMi5sZW5ndGgpID09PSBudWxsIHx8IF9hcmdzJHNsdWcyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYXJncyRzbHVnMi5taW4pICE9PSBudWxsICYmIF9hcmdzJHNsdWckdmFsaWRhdGlvbiAhPT0gdm9pZCAwID8gX2FyZ3Mkc2x1ZyR2YWxpZGF0aW9uIDogMSwgKF9hcmdzJHNsdWckdmFsaWRhdGlvbjIgPSAoX2FyZ3Mkc2x1ZzMgPSBhcmdzLnNsdWcpID09PSBudWxsIHx8IF9hcmdzJHNsdWczID09PSB2b2lkIDAgfHwgKF9hcmdzJHNsdWczID0gX2FyZ3Mkc2x1ZzMudmFsaWRhdGlvbikgPT09IG51bGwgfHwgX2FyZ3Mkc2x1ZzMgPT09IHZvaWQgMCB8fCAoX2FyZ3Mkc2x1ZzMgPSBfYXJncyRzbHVnMy5sZW5ndGgpID09PSBudWxsIHx8IF9hcmdzJHNsdWczID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYXJncyRzbHVnMy5tYXgpICE9PSBudWxsICYmIF9hcmdzJHNsdWckdmFsaWRhdGlvbjIgIT09IHZvaWQgMCA/IF9hcmdzJHNsdWckdmFsaWRhdGlvbjIgOiBJbmZpbml0eSwgKF9hcmdzJHNsdWckbGFiZWwgPSAoX2FyZ3Mkc2x1ZzQgPSBhcmdzLnNsdWcpID09PSBudWxsIHx8IF9hcmdzJHNsdWc0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYXJncyRzbHVnNC5sYWJlbCkgIT09IG51bGwgJiYgX2FyZ3Mkc2x1ZyRsYWJlbCAhPT0gdm9pZCAwID8gX2FyZ3Mkc2x1ZyRsYWJlbCA6ICdTbHVnJywgc2x1Z0ZpZWxkID8gc2x1Z0ZpZWxkIDoge1xuICAgICAgc2x1Z3M6IGVtcHR5U2V0LFxuICAgICAgZ2xvYjogJyonXG4gICAgfSk7XG4gICAgaWYgKHNsdWdNZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcihzbHVnTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBjb25zdCBlbXB0eVNldCA9IG5ldyBTZXQoKTtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiAnZm9ybScsXG4gICAgZm9ybUtpbmQ6ICdzbHVnJyxcbiAgICBsYWJlbDogYXJncy5uYW1lLmxhYmVsLFxuICAgIElucHV0KHByb3BzKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2pzeChTbHVnRmllbGRJbnB1dCwge1xuICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICBuYWl2ZUdlbmVyYXRlU2x1ZzogbmFpdmVHZW5lcmF0ZVNsdWcsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgICAgICAuLi5wcm9wc1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH0sXG4gICAgcGFyc2UodmFsdWUsIGFyZ3MpIHtcbiAgICAgIGlmICgoYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLnNsdWcpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQXNTbHVnRmllbGQodmFsdWUsIGFyZ3Muc2x1Zyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VTbHVnRmllbGRBc05vcm1hbEZpZWxkKHZhbHVlKTtcbiAgICB9LFxuICAgIHZhbGlkYXRlLFxuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBzZXJpYWxpemVXaXRoU2x1Zyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLm5hbWUsXG4gICAgICAgIHNsdWc6IHZhbHVlLnNsdWdcbiAgICAgIH07XG4gICAgfSxcbiAgICByZWFkZXI6IHtcbiAgICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlU2x1Z0ZpZWxkQXNOb3JtYWxGaWVsZCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwYXJzZWQpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlV2l0aFNsdWcodmFsdWUsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHBhcnNlQXNTbHVnRmllbGQodmFsdWUsIGFyZ3Muc2x1ZyksIHtcbiAgICAgICAgICBzbHVnRmllbGQ6IHtcbiAgICAgICAgICAgIGdsb2I6IGFyZ3MuZ2xvYixcbiAgICAgICAgICAgIHNsdWdzOiBlbXB0eVNldFxuICAgICAgICAgIH1cbiAgICAgICAgfSkubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVXJsKHZhbGlkYXRpb24sIHZhbHVlLCBsYWJlbCkge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIWlzVmFsaWRVUkwodmFsdWUpKSkge1xuICAgIHJldHVybiBgJHtsYWJlbH0gaXMgbm90IGEgdmFsaWQgVVJMYDtcbiAgfVxuICBpZiAodmFsaWRhdGlvbiAhPT0gbnVsbCAmJiB2YWxpZGF0aW9uICE9PSB2b2lkIDAgJiYgdmFsaWRhdGlvbi5pc1JlcXVpcmVkICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGAke2xhYmVsfSBpcyByZXF1aXJlZGA7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXJsKHtcbiAgbGFiZWwsXG4gIGRlZmF1bHRWYWx1ZSxcbiAgdmFsaWRhdGlvbixcbiAgZGVzY3JpcHRpb25cbn0pIHtcbiAgcmV0dXJuIGJhc2ljRm9ybUZpZWxkV2l0aFNpbXBsZVJlYWRlclBhcnNlKHtcbiAgICBsYWJlbCxcbiAgICBJbnB1dChwcm9wcykge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goVXJsRmllbGRJbnB1dCwge1xuICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgdmFsaWRhdGlvbjogdmFsaWRhdGlvbixcbiAgICAgICAgLi4ucHJvcHNcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xuICAgIH0sXG4gICAgcGFyc2UodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKCdNdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6IHZhbHVlO1xuICAgIH0sXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB2YWxpZGF0ZVVybCh2YWxpZGF0aW9uLCB2YWx1ZSwgbGFiZWwpO1xuICAgICAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBhc3NlcnRSZXF1aXJlZCh2YWx1ZSwgdmFsaWRhdGlvbiwgbGFiZWwpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUgPT09IG51bGwgPyB1bmRlZmluZWQgOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBibG9ja3MoYmxvY2tzLCBvcHRzKSB7XG4gIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhibG9ja3MpO1xuICBpZiAoIWVudHJpZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZHMuYmxvY2tzIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgZW50cnknKTtcbiAgfVxuICBjb25zdCBzZWxlY3QkMSA9IHNlbGVjdCh7XG4gICAgbGFiZWw6ICdLaW5kJyxcbiAgICBkZWZhdWx0VmFsdWU6IGVudHJpZXNbMF1bMF0sXG4gICAgb3B0aW9uczogT2JqZWN0LmVudHJpZXMoYmxvY2tzKS5tYXAoKFtrZXksIHtcbiAgICAgIGxhYmVsXG4gICAgfV0pID0+ICh7XG4gICAgICBsYWJlbCxcbiAgICAgIHZhbHVlOiBrZXlcbiAgICB9KSlcbiAgfSk7XG4gIGNvbnN0IGVsZW1lbnQgPSBjb25kaXRpb25hbChzZWxlY3QkMSwgT2JqZWN0LmZyb21FbnRyaWVzKGVudHJpZXMubWFwKChba2V5LCB7XG4gICAgc2NoZW1hXG4gIH1dKSA9PiBba2V5LCBzY2hlbWFdKSkpO1xuICByZXR1cm4ge1xuICAgIC4uLmFycmF5KGVsZW1lbnQsIHtcbiAgICAgIGxhYmVsOiBvcHRzLmxhYmVsLFxuICAgICAgZGVzY3JpcHRpb246IG9wdHMuZGVzY3JpcHRpb24sXG4gICAgICB2YWxpZGF0aW9uOiBvcHRzLnZhbGlkYXRpb24sXG4gICAgICBpdGVtTGFiZWwocHJvcHMpIHtcbiAgICAgICAgY29uc3Qga2luZCA9IHByb3BzLmRpc2NyaW1pbmFudDtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBibG9ja3Nba2luZF07XG4gICAgICAgIGlmICghYmxvY2suaXRlbUxhYmVsKSByZXR1cm4gYmxvY2subGFiZWw7XG4gICAgICAgIHJldHVybiBibG9jay5pdGVtTGFiZWwocHJvcHMudmFsdWUpO1xuICAgICAgfVxuICAgIH0pLFxuICAgIElucHV0OiBCbG9ja3NGaWVsZElucHV0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsb3VkSW1hZ2Uoe1xuICBsYWJlbCxcbiAgZGVzY3JpcHRpb24sXG4gIHZhbGlkYXRpb25cbn0pIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5vYmplY3Qoe1xuICAgICAgc3JjOiB0ZXh0KHtcbiAgICAgICAgbGFiZWw6ICdVUkwnLFxuICAgICAgICB2YWxpZGF0aW9uOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBtaW46IHZhbGlkYXRpb24gIT09IG51bGwgJiYgdmFsaWRhdGlvbiAhPT0gdm9pZCAwICYmIHZhbGlkYXRpb24uaXNSZXF1aXJlZCA/IDEgOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGFsdDogdGV4dCh7XG4gICAgICAgIGxhYmVsOiAnQWx0IHRleHQnXG4gICAgICB9KSxcbiAgICAgIGhlaWdodDogaW50ZWdlcih7XG4gICAgICAgIGxhYmVsOiAnSGVpZ2h0J1xuICAgICAgfSksXG4gICAgICB3aWR0aDogaW50ZWdlcih7XG4gICAgICAgIGxhYmVsOiAnV2lkdGgnXG4gICAgICB9KVxuICAgIH0sIHtcbiAgICAgIGxhYmVsLFxuICAgICAgZGVzY3JpcHRpb25cbiAgICB9KSxcbiAgICBJbnB1dChwcm9wcykge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goQ2xvdWRJbWFnZUZpZWxkSW5wdXQsIHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIGlzUmVxdWlyZWQ6IHZhbGlkYXRpb24gPT09IG51bGwgfHwgdmFsaWRhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsaWRhdGlvbi5pc1JlcXVpcmVkXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBpbmRleCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhcnJheTogYXJyYXksXG4gIGNoZWNrYm94OiBjaGVja2JveCxcbiAgY2hpbGQ6IGNoaWxkLFxuICBjb25kaXRpb25hbDogY29uZGl0aW9uYWwsXG4gIGRhdGU6IGRhdGUsXG4gIGRhdGV0aW1lOiBkYXRldGltZSxcbiAgZG9jdW1lbnQ6IGRvY3VtZW50LFxuICBlbXB0eURvY3VtZW50OiBlbXB0eURvY3VtZW50LFxuICBlbXB0eTogZW1wdHksXG4gIGltYWdlOiBpbWFnZSxcbiAgZmlsZTogZmlsZSxcbiAgaW50ZWdlcjogaW50ZWdlcixcbiAgbnVtYmVyOiBudW1iZXIsXG4gIG11bHRpc2VsZWN0OiBtdWx0aXNlbGVjdCxcbiAgb2JqZWN0OiBvYmplY3QsXG4gIHBhdGhSZWZlcmVuY2U6IHBhdGhSZWZlcmVuY2UsXG4gIHJlbGF0aW9uc2hpcDogcmVsYXRpb25zaGlwLFxuICBzZWxlY3Q6IHNlbGVjdCxcbiAgc2x1Zzogc2x1ZyxcbiAgdGV4dDogdGV4dCxcbiAgdXJsOiB1cmwsXG4gIGJsb2NrczogYmxvY2tzLFxuICBjbG91ZEltYWdlOiBjbG91ZEltYWdlXG59KTtcblxuZnVuY3Rpb24gQmxvY2tXcmFwcGVyKCkge31cbmZ1bmN0aW9uIE5vdEVkaXRhYmxlKCkge31cbmZ1bmN0aW9uIFRvb2xiYXJTZXBhcmF0b3IoKSB7fVxuXG5leHBvcnQgeyBCbG9ja1dyYXBwZXIsIE5vdEVkaXRhYmxlLCBUb29sYmFyU2VwYXJhdG9yLCBpbmRleCBhcyBmaWVsZHMgfTtcbiJdLCJuYW1lcyI6WyJpIiwiaXNWYWxpZFVSTCIsImEiLCJjb2xsZWN0aW9uIiwiYyIsImNvbmZpZyIsInMiLCJzaW5nbGV0b24iLCJjb21wb25lbnQiLCJhZSIsImJhc2ljRm9ybUZpZWxkV2l0aFNpbXBsZVJlYWRlclBhcnNlIiwiYWYiLCJDaGVja2JveEZpZWxkSW5wdXQiLCJhZCIsIkZpZWxkRGF0YUVycm9yIiwiYWciLCJEYXRlRmllbGRJbnB1dCIsImFoIiwiYXNzZXJ0UmVxdWlyZWQiLCJhaSIsIkRhdGV0aW1lRmllbGRJbnB1dCIsImFqIiwiSW1hZ2VGaWVsZElucHV0IiwiYWsiLCJnZXRTcmNQcmVmaXgiLCJhbCIsImZpeFBhdGgiLCJhbSIsIkZpbGVGaWVsZElucHV0IiwiYW4iLCJOdW1iZXJGaWVsZElucHV0IiwiYW8iLCJNdWx0aXNlbGVjdEZpZWxkSW5wdXQiLCJhcCIsIlBhdGhSZWZlcmVuY2VJbnB1dCIsImFxIiwiUmVsYXRpb25zaGlwSW5wdXQiLCJhciIsIlNlbGVjdEZpZWxkSW5wdXQiLCJhcyIsIlNsdWdGaWVsZElucHV0IiwiYXQiLCJ2YWxpZGF0ZVRleHQiLCJhdSIsIlVybEZpZWxkSW5wdXQiLCJhdiIsIkJsb2Nrc0ZpZWxkSW5wdXQiLCJvIiwib2JqZWN0IiwiYXciLCJ0ZXh0IiwiYXgiLCJDbG91ZEltYWdlRmllbGRJbnB1dCIsImF5IiwiZG9jdW1lbnQiLCJqc3giLCJpbnRlZ2VyIiwiRGVjaW1hbCIsInNsdWdpZnkiLCJhcnJheSIsImVsZW1lbnQiLCJvcHRzIiwiX29wdHMkbGFiZWwiLCJraW5kIiwibGFiZWwiLCJkZXNjcmlwdGlvbiIsIml0ZW1MYWJlbCIsImFzQ2hpbGRUYWciLCJzbHVnRmllbGQiLCJ2YWxpZGF0aW9uIiwiY2hlY2tib3giLCJkZWZhdWx0VmFsdWUiLCJJbnB1dCIsInByb3BzIiwicGFyc2UiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsInZhbGlkYXRlIiwic2VyaWFsaXplIiwiY2hpbGQiLCJvcHRpb25zIiwiZGl2aWRlcnMiLCJmb3JtYXR0aW5nIiwiYmxvY2tUeXBlcyIsImhlYWRpbmdMZXZlbHMiLCJpbmxpbmVNYXJrcyIsImxpc3RUeXBlcyIsImFsaWdubWVudCIsInNvZnRCcmVha3MiLCJsaW5rcyIsImltYWdlcyIsInRhYmxlcyIsImNvbXBvbmVudEJsb2NrcyIsInBsYWNlaG9sZGVyIiwiY29uZGl0aW9uYWwiLCJkaXNjcmltaW5hbnQiLCJ2YWx1ZXMiLCJ2YWxpZGF0ZURhdGUiLCJ0ZXN0IiwiaXNSZXF1aXJlZCIsIm1pbiIsIm1heCIsImRhdGUiLCJEYXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwidG9kYXkiLCJ5ZWFyIiwiZ2V0RnVsbFllYXIiLCJtb250aCIsIlN0cmluZyIsImdldE1vbnRoIiwicGFkU3RhcnQiLCJkYXkiLCJnZXREYXRlIiwibWVzc2FnZSIsInZhbGlkYXRlRGF0ZXRpbWUiLCJkYXRldGltZSIsInRvSVNPU3RyaW5nIiwibm93IiwiZW1wdHlEb2N1bWVudCIsImZvcm1LaW5kIiwiY29udGVudEV4dGVuc2lvbiIsImNvbnRlbnQiLCJVaW50OEFycmF5IiwiZXh0ZXJuYWwiLCJNYXAiLCJvdGhlciIsInJlYWRlciIsImVtcHR5IiwiaW1hZ2UiLCJkaXJlY3RvcnkiLCJwdWJsaWNQYXRoIiwiZmlsZW5hbWUiLCJhcmdzIiwic2xpY2UiLCJzbHVnIiwibGVuZ3RoIiwiX3ZhbHVlJG1hdGNoJCIsIl92YWx1ZSRtYXRjaCIsImFzc2V0IiwiZGF0YSIsImV4dGVuc2lvbiIsIm1hdGNoIiwic3VnZ2VzdGVkRmlsZW5hbWVQcmVmaXgiLCJ2YWwiLCJmaWxlIiwidmFsaWRhdGVOdW1iZXIiLCJzdGVwIiwidmFsaWRhdGVTdGVwIiwibW9kIiwidG9OdW1iZXIiLCJudW1iZXIiLCJtdWx0aXNlbGVjdCIsInZhbHVlc1RvT3B0aW9uIiwibWFwIiwieCIsImZpZWxkIiwiQXJyYXkiLCJpc0FycmF5IiwiZXZlcnkiLCJoYXMiLCJqb2luIiwicGF0aFJlZmVyZW5jZSIsInBhdHRlcm4iLCJyZWxhdGlvbnNoaXAiLCJzZWxlY3QiLCJvcHRpb25WYWx1ZXNTZXQiLCJTZXQiLCJFcnJvciIsInBhcnNlU2x1Z0ZpZWxkQXNOb3JtYWxGaWVsZCIsIm5hbWUiLCJPYmplY3QiLCJrZXlzIiwicGFyc2VBc1NsdWdGaWVsZCIsIl9hcmdzJHNsdWciLCJfYXJncyRuYW1lJGRlZmF1bHRWYWwiLCJfYXJncyRuYW1lJGRlZmF1bHRWYWwyIiwibmFpdmVHZW5lcmF0ZVNsdWciLCJnZW5lcmF0ZSIsIl9hcmdzJG5hbWUkdmFsaWRhdGlvbiIsIl9hcmdzJG5hbWUkdmFsaWRhdGlvbjIiLCJfYXJncyRuYW1lJHZhbGlkYXRpb24zIiwiX2FyZ3MkbmFtZSR2YWxpZGF0aW9uNCIsIl9hcmdzJHNsdWckdmFsaWRhdGlvbiIsIl9hcmdzJHNsdWcyIiwiX2FyZ3Mkc2x1ZyR2YWxpZGF0aW9uMiIsIl9hcmdzJHNsdWczIiwiX2FyZ3Mkc2x1ZyRsYWJlbCIsIl9hcmdzJHNsdWc0IiwibmFtZU1lc3NhZ2UiLCJJbmZpbml0eSIsInNsdWdNZXNzYWdlIiwic2x1Z3MiLCJlbXB0eVNldCIsImdsb2IiLCJzZXJpYWxpemVXaXRoU2x1ZyIsInBhcnNlZCIsInBhcnNlV2l0aFNsdWciLCJ2YWxpZGF0ZVVybCIsInVybCIsImJsb2NrcyIsImVudHJpZXMiLCJzZWxlY3QkMSIsImtleSIsImZyb21FbnRyaWVzIiwic2NoZW1hIiwiYmxvY2siLCJjbG91ZEltYWdlIiwic3JjIiwiYWx0IiwiaGVpZ2h0Iiwid2lkdGgiLCJpbmRleCIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsIkJsb2NrV3JhcHBlciIsIk5vdEVkaXRhYmxlIiwiVG9vbGJhclNlcGFyYXRvciIsImZpZWxkcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@keystatic/core/dist/keystatic-core.node.react-server.js\n");

/***/ })

};
;