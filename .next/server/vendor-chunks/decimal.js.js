"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/decimal.js";
exports.ids = ["vendor-chunks/decimal.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/decimal.js/decimal.mjs":
/*!*********************************************!*\
  !*** ./node_modules/decimal.js/decimal.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decimal: () => (/* binding */ Decimal),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\r\n *  decimal.js v10.4.3\r\n *  An arbitrary-precision Decimal type for JavaScript.\r\n *  https://github.com/MikeMcl/decimal.js\r\n *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *  MIT Licence\r\n */ // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\n// The maximum exponent magnitude.\n// The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\nvar EXP_LIMIT = 9e15, // The limit on the value of `precision`, and on the value of the first argument to\n// `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\nMAX_DIGITS = 1e9, // Base conversion alphabet.\nNUMERALS = \"0123456789abcdef\", // The natural logarithm of 10 (1025 digits).\nLN10 = \"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058\", // Pi (1025 digits).\nPI = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789\", // The initial configuration properties of the Decimal constructor.\nDEFAULTS = {\n    // These values must be integers within the stated ranges (inclusive).\n    // Most of these values can be changed at run-time using the `Decimal.config` method.\n    // The maximum number of significant digits of the result of a calculation or base conversion.\n    // E.g. `Decimal.config({ precision: 20 });`\n    precision: 20,\n    // The rounding mode used when rounding to `precision`.\n    //\n    // ROUND_UP         0 Away from zero.\n    // ROUND_DOWN       1 Towards zero.\n    // ROUND_CEIL       2 Towards +Infinity.\n    // ROUND_FLOOR      3 Towards -Infinity.\n    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n    //\n    // E.g.\n    // `Decimal.rounding = 4;`\n    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\n    rounding: 4,\n    // The modulo mode used when calculating the modulus: a mod n.\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\n    // The remainder (r) is calculated as: r = a - n * q.\n    //\n    // UP         0 The remainder is positive if the dividend is negative, else is negative.\n    // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\n    // FLOOR      3 The remainder has the same sign as the divisor (Python %).\n    // HALF_EVEN  6 The IEEE 754 remainder function.\n    // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\n    //\n    // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\n    // division (9) are commonly used for the modulus operation. The other rounding modes can also\n    // be used, but they may not give useful results.\n    modulo: 1,\n    // The exponent value at and beneath which `toString` returns exponential notation.\n    // JavaScript numbers: -7\n    toExpNeg: -7,\n    // The exponent value at and above which `toString` returns exponential notation.\n    // JavaScript numbers: 21\n    toExpPos: 21,\n    // The minimum exponent value, beneath which underflow to zero occurs.\n    // JavaScript numbers: -324  (5e-324)\n    minE: -EXP_LIMIT,\n    // The maximum exponent value, above which overflow to Infinity occurs.\n    // JavaScript numbers: 308  (1.7976931348623157e+308)\n    maxE: EXP_LIMIT,\n    // Whether to use cryptographically-secure random number generation, if available.\n    crypto: false // true/false\n}, // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\ninexact, quadrant, external = true, decimalError = \"[DecimalError] \", invalidArgument = decimalError + \"Invalid argument: \", precisionLimitExceeded = decimalError + \"Precision limit exceeded\", cryptoUnavailable = decimalError + \"crypto unavailable\", tag = \"[object Decimal]\", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i, isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i, isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i, isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, // Decimal.prototype object\nP = {\n    toStringTag: tag\n};\n// Decimal prototype methods\n/*\r\n *  absoluteValue             abs\r\n *  ceil\r\n *  clampedTo                 clamp\r\n *  comparedTo                cmp\r\n *  cosine                    cos\r\n *  cubeRoot                  cbrt\r\n *  decimalPlaces             dp\r\n *  dividedBy                 div\r\n *  dividedToIntegerBy        divToInt\r\n *  equals                    eq\r\n *  floor\r\n *  greaterThan               gt\r\n *  greaterThanOrEqualTo      gte\r\n *  hyperbolicCosine          cosh\r\n *  hyperbolicSine            sinh\r\n *  hyperbolicTangent         tanh\r\n *  inverseCosine             acos\r\n *  inverseHyperbolicCosine   acosh\r\n *  inverseHyperbolicSine     asinh\r\n *  inverseHyperbolicTangent  atanh\r\n *  inverseSine               asin\r\n *  inverseTangent            atan\r\n *  isFinite\r\n *  isInteger                 isInt\r\n *  isNaN\r\n *  isNegative                isNeg\r\n *  isPositive                isPos\r\n *  isZero\r\n *  lessThan                  lt\r\n *  lessThanOrEqualTo         lte\r\n *  logarithm                 log\r\n *  [maximum]                 [max]\r\n *  [minimum]                 [min]\r\n *  minus                     sub\r\n *  modulo                    mod\r\n *  naturalExponential        exp\r\n *  naturalLogarithm          ln\r\n *  negated                   neg\r\n *  plus                      add\r\n *  precision                 sd\r\n *  round\r\n *  sine                      sin\r\n *  squareRoot                sqrt\r\n *  tangent                   tan\r\n *  times                     mul\r\n *  toBinary\r\n *  toDecimalPlaces           toDP\r\n *  toExponential\r\n *  toFixed\r\n *  toFraction\r\n *  toHexadecimal             toHex\r\n *  toNearest\r\n *  toNumber\r\n *  toOctal\r\n *  toPower                   pow\r\n *  toPrecision\r\n *  toSignificantDigits       toSD\r\n *  toString\r\n *  truncated                 trunc\r\n *  valueOf                   toJSON\r\n */ /*\r\n * Return a new Decimal whose value is the absolute value of this Decimal.\r\n *\r\n */ P.absoluteValue = P.abs = function() {\n    var x = new this.constructor(this);\n    if (x.s < 0) x.s = 1;\n    return finalise(x);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n * direction of positive Infinity.\r\n *\r\n */ P.ceil = function() {\n    return finalise(new this.constructor(this), this.e + 1, 2);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal clamped to the range\r\n * delineated by `min` and `max`.\r\n *\r\n * min {number|string|Decimal}\r\n * max {number|string|Decimal}\r\n *\r\n */ P.clampedTo = P.clamp = function(min, max) {\n    var k, x = this, Ctor = x.constructor;\n    min = new Ctor(min);\n    max = new Ctor(max);\n    if (!min.s || !max.s) return new Ctor(NaN);\n    if (min.gt(max)) throw Error(invalidArgument + max);\n    k = x.cmp(min);\n    return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);\n};\n/*\r\n * Return\r\n *   1    if the value of this Decimal is greater than the value of `y`,\r\n *  -1    if the value of this Decimal is less than the value of `y`,\r\n *   0    if they have the same value,\r\n *   NaN  if the value of either Decimal is NaN.\r\n *\r\n */ P.comparedTo = P.cmp = function(y) {\n    var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;\n    // Either NaN or ±Infinity?\n    if (!xd || !yd) {\n        return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\n    }\n    // Either zero?\n    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\n    // Signs differ?\n    if (xs !== ys) return xs;\n    // Compare exponents.\n    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\n    xdL = xd.length;\n    ydL = yd.length;\n    // Compare digit by digit.\n    for(i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i){\n        if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\n    }\n    // Compare lengths.\n    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\n};\n/*\r\n * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * cos(0)         = 1\r\n * cos(-0)        = 1\r\n * cos(Infinity)  = NaN\r\n * cos(-Infinity) = NaN\r\n * cos(NaN)       = NaN\r\n *\r\n */ P.cosine = P.cos = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.d) return new Ctor(NaN);\n    // cos(0) = cos(-0) = 1\n    if (!x.d[0]) return new Ctor(1);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n    Ctor.rounding = 1;\n    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\n};\n/*\r\n *\r\n * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n *  cbrt(0)  =  0\r\n *  cbrt(-0) = -0\r\n *  cbrt(1)  =  1\r\n *  cbrt(-1) = -1\r\n *  cbrt(N)  =  N\r\n *  cbrt(-I) = -I\r\n *  cbrt(I)  =  I\r\n *\r\n * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n *\r\n */ P.cubeRoot = P.cbrt = function() {\n    var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\n    external = false;\n    // Initial estimate.\n    s = x.s * mathpow(x.s * x, 1 / 3);\n    // Math.cbrt underflow/overflow?\n    // Pass x to Math.pow as integer, then adjust the exponent of the result.\n    if (!s || Math.abs(s) == 1 / 0) {\n        n = digitsToString(x.d);\n        e = x.e;\n        // Adjust n exponent so it is a multiple of 3 away from x exponent.\n        if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? \"0\" : \"00\";\n        s = mathpow(n, 1 / 3);\n        // Rarely, e may be one less than the result exponent value.\n        e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\n        if (s == 1 / 0) {\n            n = \"5e\" + e;\n        } else {\n            n = s.toExponential();\n            n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n        }\n        r = new Ctor(n);\n        r.s = x.s;\n    } else {\n        r = new Ctor(s.toString());\n    }\n    sd = (e = Ctor.precision) + 3;\n    // Halley's method.\n    // TODO? Compare Newton's method.\n    for(;;){\n        t = r;\n        t3 = t.times(t).times(t);\n        t3plusx = t3.plus(x);\n        r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\n        // TODO? Replace with for-loop and checkRoundingDigits.\n        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n            n = n.slice(sd - 3, sd + 1);\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\n            // , i.e. approaching a rounding boundary, continue the iteration.\n            if (n == \"9999\" || !rep && n == \"4999\") {\n                // On the first iteration only, check to see if rounding up gives the exact result as the\n                // nines may infinitely repeat.\n                if (!rep) {\n                    finalise(t, e + 1, 0);\n                    if (t.times(t).times(t).eq(x)) {\n                        r = t;\n                        break;\n                    }\n                }\n                sd += 4;\n                rep = 1;\n            } else {\n                // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\n                // If not, then there are further digits and m will be truthy.\n                if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n                    // Truncate to the first rounding digit.\n                    finalise(r, e + 1, 1);\n                    m = !r.times(r).times(r).eq(x);\n                }\n                break;\n            }\n        }\n    }\n    external = true;\n    return finalise(r, e, Ctor.rounding, m);\n};\n/*\r\n * Return the number of decimal places of the value of this Decimal.\r\n *\r\n */ P.decimalPlaces = P.dp = function() {\n    var w, d = this.d, n = NaN;\n    if (d) {\n        w = d.length - 1;\n        n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\n        // Subtract the number of trailing zeros of the last word.\n        w = d[w];\n        if (w) for(; w % 10 == 0; w /= 10)n--;\n        if (n < 0) n = 0;\n    }\n    return n;\n};\n/*\r\n *  n / 0 = I\r\n *  n / N = N\r\n *  n / I = 0\r\n *  0 / n = 0\r\n *  0 / 0 = N\r\n *  0 / N = N\r\n *  0 / I = 0\r\n *  N / n = N\r\n *  N / 0 = N\r\n *  N / N = N\r\n *  N / I = N\r\n *  I / n = I\r\n *  I / 0 = I\r\n *  I / N = N\r\n *  I / I = N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */ P.dividedBy = P.div = function(y) {\n    return divide(this, new this.constructor(y));\n};\n/*\r\n * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */ P.dividedToIntegerBy = P.divToInt = function(y) {\n    var x = this, Ctor = x.constructor;\n    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\n};\n/*\r\n * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n *\r\n */ P.equals = P.eq = function(y) {\n    return this.cmp(y) === 0;\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n * direction of negative Infinity.\r\n *\r\n */ P.floor = function() {\n    return finalise(new this.constructor(this), this.e + 1, 3);\n};\n/*\r\n * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n * false.\r\n *\r\n */ P.greaterThan = P.gt = function(y) {\n    return this.cmp(y) > 0;\n};\n/*\r\n * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n * otherwise return false.\r\n *\r\n */ P.greaterThanOrEqualTo = P.gte = function(y) {\n    var k = this.cmp(y);\n    return k == 1 || k === 0;\n};\n/*\r\n * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [1, Infinity]\r\n *\r\n * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n *\r\n * cosh(0)         = 1\r\n * cosh(-0)        = 1\r\n * cosh(Infinity)  = Infinity\r\n * cosh(-Infinity) = Infinity\r\n * cosh(NaN)       = NaN\r\n *\r\n *  x        time taken (ms)   result\r\n * 1000      9                 9.8503555700852349694e+433\r\n * 10000     25                4.4034091128314607936e+4342\r\n * 100000    171               1.4033316802130615897e+43429\r\n * 1000000   3817              1.5166076984010437725e+434294\r\n * 10000000  abandoned after 2 minute wait\r\n *\r\n * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n *\r\n */ P.hyperbolicCosine = P.cosh = function() {\n    var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);\n    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\n    if (x.isZero()) return one;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n    Ctor.rounding = 1;\n    len = x.d.length;\n    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\n    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\n    // Estimate the optimum number of times to use the argument reduction.\n    // TODO? Estimation reused from cosine() and may not be optimal here.\n    if (len < 32) {\n        k = Math.ceil(len / 3);\n        n = (1 / tinyPow(4, k)).toString();\n    } else {\n        k = 16;\n        n = \"2.3283064365386962890625e-10\";\n    }\n    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\n    // Reverse argument reduction\n    var cosh2_x, i = k, d8 = new Ctor(8);\n    for(; i--;){\n        cosh2_x = x.times(x);\n        x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\n    }\n    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\n/*\r\n * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n *\r\n * sinh(0)         = 0\r\n * sinh(-0)        = -0\r\n * sinh(Infinity)  = Infinity\r\n * sinh(-Infinity) = -Infinity\r\n * sinh(NaN)       = NaN\r\n *\r\n * x        time taken (ms)\r\n * 10       2 ms\r\n * 100      5 ms\r\n * 1000     14 ms\r\n * 10000    82 ms\r\n * 100000   886 ms            1.4033316802130615897e+43429\r\n * 200000   2613 ms\r\n * 300000   5407 ms\r\n * 400000   8824 ms\r\n * 500000   13026 ms          8.7080643612718084129e+217146\r\n * 1000000  48543 ms\r\n *\r\n * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n *\r\n */ P.hyperbolicSine = P.sinh = function() {\n    var k, pr, rm, len, x = this, Ctor = x.constructor;\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n    Ctor.rounding = 1;\n    len = x.d.length;\n    if (len < 3) {\n        x = taylorSeries(Ctor, 2, x, x, true);\n    } else {\n        // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\n        // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\n        // 3 multiplications and 1 addition\n        // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\n        // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\n        // 4 multiplications and 2 additions\n        // Estimate the optimum number of times to use the argument reduction.\n        k = 1.4 * Math.sqrt(len);\n        k = k > 16 ? 16 : k | 0;\n        x = x.times(1 / tinyPow(5, k));\n        x = taylorSeries(Ctor, 2, x, x, true);\n        // Reverse argument reduction\n        var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n        for(; k--;){\n            sinh2_x = x.times(x);\n            x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\n        }\n    }\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(x, pr, rm, true);\n};\n/*\r\n * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * tanh(x) = sinh(x) / cosh(x)\r\n *\r\n * tanh(0)         = 0\r\n * tanh(-0)        = -0\r\n * tanh(Infinity)  = 1\r\n * tanh(-Infinity) = -1\r\n * tanh(NaN)       = NaN\r\n *\r\n */ P.hyperbolicTangent = P.tanh = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(x.s);\n    if (x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + 7;\n    Ctor.rounding = 1;\n    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\n};\n/*\r\n * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n * this Decimal.\r\n *\r\n * Domain: [-1, 1]\r\n * Range: [0, pi]\r\n *\r\n * acos(x) = pi/2 - asin(x)\r\n *\r\n * acos(0)       = pi/2\r\n * acos(-0)      = pi/2\r\n * acos(1)       = 0\r\n * acos(-1)      = pi\r\n * acos(1/2)     = pi/3\r\n * acos(-1/2)    = 2*pi/3\r\n * acos(|x| > 1) = NaN\r\n * acos(NaN)     = NaN\r\n *\r\n */ P.inverseCosine = P.acos = function() {\n    var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;\n    if (k !== -1) {\n        return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);\n    }\n    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\n    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\n    Ctor.precision = pr + 6;\n    Ctor.rounding = 1;\n    x = x.asin();\n    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return halfPi.minus(x);\n};\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n * value of this Decimal.\r\n *\r\n * Domain: [1, Infinity]\r\n * Range: [0, Infinity]\r\n *\r\n * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n *\r\n * acosh(x < 1)     = NaN\r\n * acosh(NaN)       = NaN\r\n * acosh(Infinity)  = Infinity\r\n * acosh(-Infinity) = NaN\r\n * acosh(0)         = NaN\r\n * acosh(-0)        = NaN\r\n * acosh(1)         = 0\r\n * acosh(-1)        = NaN\r\n *\r\n */ P.inverseHyperbolicCosine = P.acosh = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\n    if (!x.isFinite()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\n    Ctor.rounding = 1;\n    external = false;\n    x = x.times(x).minus(1).sqrt().plus(x);\n    external = true;\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.ln();\n};\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n * of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n *\r\n * asinh(NaN)       = NaN\r\n * asinh(Infinity)  = Infinity\r\n * asinh(-Infinity) = -Infinity\r\n * asinh(0)         = 0\r\n * asinh(-0)        = -0\r\n *\r\n */ P.inverseHyperbolicSine = P.asinh = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\n    Ctor.rounding = 1;\n    external = false;\n    x = x.times(x).plus(1).sqrt().plus(x);\n    external = true;\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.ln();\n};\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n * value of this Decimal.\r\n *\r\n * Domain: [-1, 1]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n *\r\n * atanh(|x| > 1)   = NaN\r\n * atanh(NaN)       = NaN\r\n * atanh(Infinity)  = NaN\r\n * atanh(-Infinity) = NaN\r\n * atanh(0)         = 0\r\n * atanh(-0)        = -0\r\n * atanh(1)         = Infinity\r\n * atanh(-1)        = -Infinity\r\n *\r\n */ P.inverseHyperbolicTangent = P.atanh = function() {\n    var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(NaN);\n    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    xsd = x.sd();\n    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\n    Ctor.precision = wpr = xsd - x.e;\n    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\n    Ctor.precision = pr + 4;\n    Ctor.rounding = 1;\n    x = x.ln();\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.times(0.5);\n};\n/*\r\n * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi/2, pi/2]\r\n *\r\n * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n *\r\n * asin(0)       = 0\r\n * asin(-0)      = -0\r\n * asin(1/2)     = pi/6\r\n * asin(-1/2)    = -pi/6\r\n * asin(1)       = pi/2\r\n * asin(-1)      = -pi/2\r\n * asin(|x| > 1) = NaN\r\n * asin(NaN)     = NaN\r\n *\r\n * TODO? Compare performance of Taylor series.\r\n *\r\n */ P.inverseSine = P.asin = function() {\n    var halfPi, k, pr, rm, x = this, Ctor = x.constructor;\n    if (x.isZero()) return new Ctor(x);\n    k = x.abs().cmp(1);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    if (k !== -1) {\n        // |x| is 1\n        if (k === 0) {\n            halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n            halfPi.s = x.s;\n            return halfPi;\n        }\n        // |x| > 1 or x is NaN\n        return new Ctor(NaN);\n    }\n    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\n    Ctor.precision = pr + 6;\n    Ctor.rounding = 1;\n    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.times(2);\n};\n/*\r\n * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n * of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi/2, pi/2]\r\n *\r\n * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n *\r\n * atan(0)         = 0\r\n * atan(-0)        = -0\r\n * atan(1)         = pi/4\r\n * atan(-1)        = -pi/4\r\n * atan(Infinity)  = pi/2\r\n * atan(-Infinity) = -pi/2\r\n * atan(NaN)       = NaN\r\n *\r\n */ P.inverseTangent = P.atan = function() {\n    var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;\n    if (!x.isFinite()) {\n        if (!x.s) return new Ctor(NaN);\n        if (pr + 4 <= PI_PRECISION) {\n            r = getPi(Ctor, pr + 4, rm).times(0.5);\n            r.s = x.s;\n            return r;\n        }\n    } else if (x.isZero()) {\n        return new Ctor(x);\n    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\n        r = getPi(Ctor, pr + 4, rm).times(0.25);\n        r.s = x.s;\n        return r;\n    }\n    Ctor.precision = wpr = pr + 10;\n    Ctor.rounding = 1;\n    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\n    // Argument reduction\n    // Ensure |x| < 0.42\n    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\n    k = Math.min(28, wpr / LOG_BASE + 2 | 0);\n    for(i = k; i; --i)x = x.div(x.times(x).plus(1).sqrt().plus(1));\n    external = false;\n    j = Math.ceil(wpr / LOG_BASE);\n    n = 1;\n    x2 = x.times(x);\n    r = new Ctor(x);\n    px = x;\n    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\n    for(; i !== -1;){\n        px = px.times(x2);\n        t = r.minus(px.div(n += 2));\n        px = px.times(x2);\n        r = t.plus(px.div(n += 2));\n        if (r.d[j] !== void 0) for(i = j; r.d[i] === t.d[i] && i--;);\n    }\n    if (k) r = r.times(2 << k - 1);\n    external = true;\n    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\n/*\r\n * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n *\r\n */ P.isFinite = function() {\n    return !!this.d;\n};\n/*\r\n * Return true if the value of this Decimal is an integer, otherwise return false.\r\n *\r\n */ P.isInteger = P.isInt = function() {\n    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\n};\n/*\r\n * Return true if the value of this Decimal is NaN, otherwise return false.\r\n *\r\n */ P.isNaN = function() {\n    return !this.s;\n};\n/*\r\n * Return true if the value of this Decimal is negative, otherwise return false.\r\n *\r\n */ P.isNegative = P.isNeg = function() {\n    return this.s < 0;\n};\n/*\r\n * Return true if the value of this Decimal is positive, otherwise return false.\r\n *\r\n */ P.isPositive = P.isPos = function() {\n    return this.s > 0;\n};\n/*\r\n * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n *\r\n */ P.isZero = function() {\n    return !!this.d && this.d[0] === 0;\n};\n/*\r\n * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n *\r\n */ P.lessThan = P.lt = function(y) {\n    return this.cmp(y) < 0;\n};\n/*\r\n * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n *\r\n */ P.lessThanOrEqualTo = P.lte = function(y) {\n    return this.cmp(y) < 1;\n};\n/*\r\n * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * If no base is specified, return log[10](arg).\r\n *\r\n * log[base](arg) = ln(arg) / ln(base)\r\n *\r\n * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n * otherwise:\r\n *\r\n * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n *\r\n * log[-b](a)       = NaN\r\n * log[0](a)        = NaN\r\n * log[1](a)        = NaN\r\n * log[NaN](a)      = NaN\r\n * log[Infinity](a) = NaN\r\n * log[b](0)        = -Infinity\r\n * log[b](-0)       = -Infinity\r\n * log[b](-a)       = NaN\r\n * log[b](1)        = 0\r\n * log[b](Infinity) = Infinity\r\n * log[b](NaN)      = NaN\r\n *\r\n * [base] {number|string|Decimal} The base of the logarithm.\r\n *\r\n */ P.logarithm = P.log = function(base) {\n    var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;\n    // Default base is 10.\n    if (base == null) {\n        base = new Ctor(10);\n        isBase10 = true;\n    } else {\n        base = new Ctor(base);\n        d = base.d;\n        // Return NaN if base is negative, or non-finite, or is 0 or 1.\n        if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\n        isBase10 = base.eq(10);\n    }\n    d = arg.d;\n    // Is arg negative, non-finite, 0 or 1?\n    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\n        return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\n    }\n    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\n    // integer power of 10.\n    if (isBase10) {\n        if (d.length > 1) {\n            inf = true;\n        } else {\n            for(k = d[0]; k % 10 === 0;)k /= 10;\n            inf = k !== 1;\n        }\n    }\n    external = false;\n    sd = pr + guard;\n    num = naturalLogarithm(arg, sd);\n    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n    // The result will have 5 rounding digits.\n    r = divide(num, denominator, sd, 1);\n    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\n    // calculate 10 further digits.\n    //\n    // If the result is known to have an infinite decimal expansion, repeat this until it is clear\n    // that the result is above or below the boundary. Otherwise, if after calculating the 10\n    // further digits, the last 14 are nines, round up and assume the result is exact.\n    // Also assume the result is exact if the last 14 are zero.\n    //\n    // Example of a result that will be incorrectly rounded:\n    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\n    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\n    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\n    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\n    // place is still 2.6.\n    if (checkRoundingDigits(r.d, k = pr, rm)) {\n        do {\n            sd += 10;\n            num = naturalLogarithm(arg, sd);\n            denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n            r = divide(num, denominator, sd, 1);\n            if (!inf) {\n                // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\n                if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\n                    r = finalise(r, pr + 1, 0);\n                }\n                break;\n            }\n        }while (checkRoundingDigits(r.d, k += 10, rm));\n    }\n    external = true;\n    return finalise(r, pr, rm);\n};\n/*\r\n * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\nP.max = function () {\r\n  Array.prototype.push.call(arguments, this);\r\n  return maxOrMin(this.constructor, arguments, 'lt');\r\n};\r\n */ /*\r\n * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\nP.min = function () {\r\n  Array.prototype.push.call(arguments, this);\r\n  return maxOrMin(this.constructor, arguments, 'gt');\r\n};\r\n */ /*\r\n *  n - 0 = n\r\n *  n - N = N\r\n *  n - I = -I\r\n *  0 - n = -n\r\n *  0 - 0 = 0\r\n *  0 - N = N\r\n *  0 - I = -I\r\n *  N - n = N\r\n *  N - 0 = N\r\n *  N - N = N\r\n *  N - I = N\r\n *  I - n = I\r\n *  I - 0 = I\r\n *  I - N = N\r\n *  I - I = N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */ P.minus = P.sub = function(y) {\n    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;\n    y = new Ctor(y);\n    // If either is not finite...\n    if (!x.d || !y.d) {\n        // Return NaN if either is NaN.\n        if (!x.s || !y.s) y = new Ctor(NaN);\n        else if (x.d) y.s = -y.s;\n        else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\n        return y;\n    }\n    // If signs differ...\n    if (x.s != y.s) {\n        y.s = -y.s;\n        return x.plus(y);\n    }\n    xd = x.d;\n    yd = y.d;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    // If either is zero...\n    if (!xd[0] || !yd[0]) {\n        // Return y negated if x is zero and y is non-zero.\n        if (yd[0]) y.s = -y.s;\n        else if (xd[0]) y = new Ctor(x);\n        else return new Ctor(rm === 3 ? -0 : 0);\n        return external ? finalise(y, pr, rm) : y;\n    }\n    // x and y are finite, non-zero numbers with the same sign.\n    // Calculate base 1e7 exponents.\n    e = mathfloor(y.e / LOG_BASE);\n    xe = mathfloor(x.e / LOG_BASE);\n    xd = xd.slice();\n    k = xe - e;\n    // If base 1e7 exponents differ...\n    if (k) {\n        xLTy = k < 0;\n        if (xLTy) {\n            d = xd;\n            k = -k;\n            len = yd.length;\n        } else {\n            d = yd;\n            e = xe;\n            len = xd.length;\n        }\n        // Numbers with massively different exponents would result in a very high number of\n        // zeros needing to be prepended, but this can be avoided while still ensuring correct\n        // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\n        i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\n        if (k > i) {\n            k = i;\n            d.length = 1;\n        }\n        // Prepend zeros to equalise exponents.\n        d.reverse();\n        for(i = k; i--;)d.push(0);\n        d.reverse();\n    // Base 1e7 exponents equal.\n    } else {\n        // Check digits to determine which is the bigger number.\n        i = xd.length;\n        len = yd.length;\n        xLTy = i < len;\n        if (xLTy) len = i;\n        for(i = 0; i < len; i++){\n            if (xd[i] != yd[i]) {\n                xLTy = xd[i] < yd[i];\n                break;\n            }\n        }\n        k = 0;\n    }\n    if (xLTy) {\n        d = xd;\n        xd = yd;\n        yd = d;\n        y.s = -y.s;\n    }\n    len = xd.length;\n    // Append zeros to `xd` if shorter.\n    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\n    for(i = yd.length - len; i > 0; --i)xd[len++] = 0;\n    // Subtract yd from xd.\n    for(i = yd.length; i > k;){\n        if (xd[--i] < yd[i]) {\n            for(j = i; j && xd[--j] === 0;)xd[j] = BASE - 1;\n            --xd[j];\n            xd[i] += BASE;\n        }\n        xd[i] -= yd[i];\n    }\n    // Remove trailing zeros.\n    for(; xd[--len] === 0;)xd.pop();\n    // Remove leading zeros and adjust exponent accordingly.\n    for(; xd[0] === 0; xd.shift())--e;\n    // Zero?\n    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\n    y.d = xd;\n    y.e = getBase10Exponent(xd, e);\n    return external ? finalise(y, pr, rm) : y;\n};\n/*\r\n *   n % 0 =  N\r\n *   n % N =  N\r\n *   n % I =  n\r\n *   0 % n =  0\r\n *  -0 % n = -0\r\n *   0 % 0 =  N\r\n *   0 % N =  N\r\n *   0 % I =  0\r\n *   N % n =  N\r\n *   N % 0 =  N\r\n *   N % N =  N\r\n *   N % I =  N\r\n *   I % n =  N\r\n *   I % 0 =  N\r\n *   I % N =  N\r\n *   I % I =  N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * The result depends on the modulo mode.\r\n *\r\n */ P.modulo = P.mod = function(y) {\n    var q, x = this, Ctor = x.constructor;\n    y = new Ctor(y);\n    // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.\n    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\n    // Return x if y is ±Infinity or x is ±0.\n    if (!y.d || x.d && !x.d[0]) {\n        return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\n    }\n    // Prevent rounding of intermediate calculations.\n    external = false;\n    if (Ctor.modulo == 9) {\n        // Euclidian division: q = sign(y) * floor(x / abs(y))\n        // result = x - q * y    where  0 <= result < abs(y)\n        q = divide(x, y.abs(), 0, 3, 1);\n        q.s *= y.s;\n    } else {\n        q = divide(x, y, 0, Ctor.modulo, 1);\n    }\n    q = q.times(y);\n    external = true;\n    return x.minus(q);\n};\n/*\r\n * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */ P.naturalExponential = P.exp = function() {\n    return naturalExponential(this);\n};\n/*\r\n * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n * rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */ P.naturalLogarithm = P.ln = function() {\n    return naturalLogarithm(this);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n * -1.\r\n *\r\n */ P.negated = P.neg = function() {\n    var x = new this.constructor(this);\n    x.s = -x.s;\n    return finalise(x);\n};\n/*\r\n *  n + 0 = n\r\n *  n + N = N\r\n *  n + I = I\r\n *  0 + n = n\r\n *  0 + 0 = 0\r\n *  0 + N = N\r\n *  0 + I = I\r\n *  N + n = N\r\n *  N + 0 = N\r\n *  N + N = N\r\n *  N + I = N\r\n *  I + n = I\r\n *  I + 0 = I\r\n *  I + N = N\r\n *  I + I = I\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */ P.plus = P.add = function(y) {\n    var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;\n    y = new Ctor(y);\n    // If either is not finite...\n    if (!x.d || !y.d) {\n        // Return NaN if either is NaN.\n        if (!x.s || !y.s) y = new Ctor(NaN);\n        else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\n        return y;\n    }\n    // If signs differ...\n    if (x.s != y.s) {\n        y.s = -y.s;\n        return x.minus(y);\n    }\n    xd = x.d;\n    yd = y.d;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    // If either is zero...\n    if (!xd[0] || !yd[0]) {\n        // Return x if y is zero.\n        // Return y if y is non-zero.\n        if (!yd[0]) y = new Ctor(x);\n        return external ? finalise(y, pr, rm) : y;\n    }\n    // x and y are finite, non-zero numbers with the same sign.\n    // Calculate base 1e7 exponents.\n    k = mathfloor(x.e / LOG_BASE);\n    e = mathfloor(y.e / LOG_BASE);\n    xd = xd.slice();\n    i = k - e;\n    // If base 1e7 exponents differ...\n    if (i) {\n        if (i < 0) {\n            d = xd;\n            i = -i;\n            len = yd.length;\n        } else {\n            d = yd;\n            e = k;\n            len = xd.length;\n        }\n        // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\n        k = Math.ceil(pr / LOG_BASE);\n        len = k > len ? k + 1 : len + 1;\n        if (i > len) {\n            i = len;\n            d.length = 1;\n        }\n        // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\n        d.reverse();\n        for(; i--;)d.push(0);\n        d.reverse();\n    }\n    len = xd.length;\n    i = yd.length;\n    // If yd is longer than xd, swap xd and yd so xd points to the longer array.\n    if (len - i < 0) {\n        i = len;\n        d = yd;\n        yd = xd;\n        xd = d;\n    }\n    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\n    for(carry = 0; i;){\n        carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\n        xd[i] %= BASE;\n    }\n    if (carry) {\n        xd.unshift(carry);\n        ++e;\n    }\n    // Remove trailing zeros.\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n    for(len = xd.length; xd[--len] == 0;)xd.pop();\n    y.d = xd;\n    y.e = getBase10Exponent(xd, e);\n    return external ? finalise(y, pr, rm) : y;\n};\n/*\r\n * Return the number of significant digits of the value of this Decimal.\r\n *\r\n * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n *\r\n */ P.precision = P.sd = function(z) {\n    var k, x = this;\n    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\n    if (x.d) {\n        k = getPrecision(x.d);\n        if (z && x.e + 1 > k) k = x.e + 1;\n    } else {\n        k = NaN;\n    }\n    return k;\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n * rounding mode `rounding`.\r\n *\r\n */ P.round = function() {\n    var x = this, Ctor = x.constructor;\n    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\n};\n/*\r\n * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * sin(x) = x - x^3/3! + x^5/5! - ...\r\n *\r\n * sin(0)         = 0\r\n * sin(-0)        = -0\r\n * sin(Infinity)  = NaN\r\n * sin(-Infinity) = NaN\r\n * sin(NaN)       = NaN\r\n *\r\n */ P.sine = P.sin = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(NaN);\n    if (x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n    Ctor.rounding = 1;\n    x = sine(Ctor, toLessThanHalfPi(Ctor, x));\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\n};\n/*\r\n * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n *  sqrt(-n) =  N\r\n *  sqrt(N)  =  N\r\n *  sqrt(-I) =  N\r\n *  sqrt(I)  =  I\r\n *  sqrt(0)  =  0\r\n *  sqrt(-0) = -0\r\n *\r\n */ P.squareRoot = P.sqrt = function() {\n    var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;\n    // Negative/NaN/Infinity/zero?\n    if (s !== 1 || !d || !d[0]) {\n        return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\n    }\n    external = false;\n    // Initial estimate.\n    s = Math.sqrt(+x);\n    // Math.sqrt underflow/overflow?\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\n    if (s == 0 || s == 1 / 0) {\n        n = digitsToString(d);\n        if ((n.length + e) % 2 == 0) n += \"0\";\n        s = Math.sqrt(n);\n        e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\n        if (s == 1 / 0) {\n            n = \"5e\" + e;\n        } else {\n            n = s.toExponential();\n            n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n        }\n        r = new Ctor(n);\n    } else {\n        r = new Ctor(s.toString());\n    }\n    sd = (e = Ctor.precision) + 3;\n    // Newton-Raphson iteration.\n    for(;;){\n        t = r;\n        r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\n        // TODO? Replace with for-loop and checkRoundingDigits.\n        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n            n = n.slice(sd - 3, sd + 1);\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\n            // 4999, i.e. approaching a rounding boundary, continue the iteration.\n            if (n == \"9999\" || !rep && n == \"4999\") {\n                // On the first iteration only, check to see if rounding up gives the exact result as the\n                // nines may infinitely repeat.\n                if (!rep) {\n                    finalise(t, e + 1, 0);\n                    if (t.times(t).eq(x)) {\n                        r = t;\n                        break;\n                    }\n                }\n                sd += 4;\n                rep = 1;\n            } else {\n                // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\n                // If not, then there are further digits and m will be truthy.\n                if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n                    // Truncate to the first rounding digit.\n                    finalise(r, e + 1, 1);\n                    m = !r.times(r).eq(x);\n                }\n                break;\n            }\n        }\n    }\n    external = true;\n    return finalise(r, e, Ctor.rounding, m);\n};\n/*\r\n * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * tan(0)         = 0\r\n * tan(-0)        = -0\r\n * tan(Infinity)  = NaN\r\n * tan(-Infinity) = NaN\r\n * tan(NaN)       = NaN\r\n *\r\n */ P.tangent = P.tan = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(NaN);\n    if (x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + 10;\n    Ctor.rounding = 1;\n    x = x.sin();\n    x.s = 1;\n    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\n};\n/*\r\n *  n * 0 = 0\r\n *  n * N = N\r\n *  n * I = I\r\n *  0 * n = 0\r\n *  0 * 0 = 0\r\n *  0 * N = N\r\n *  0 * I = N\r\n *  N * n = N\r\n *  N * 0 = N\r\n *  N * N = N\r\n *  N * I = N\r\n *  I * n = I\r\n *  I * 0 = N\r\n *  I * N = N\r\n *  I * I = I\r\n *\r\n * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n */ P.times = P.mul = function(y) {\n    var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;\n    y.s *= x.s;\n    // If either is NaN, ±Infinity or ±0...\n    if (!xd || !xd[0] || !yd || !yd[0]) {\n        return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);\n    }\n    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\n    xdL = xd.length;\n    ydL = yd.length;\n    // Ensure xd points to the longer array.\n    if (xdL < ydL) {\n        r = xd;\n        xd = yd;\n        yd = r;\n        rL = xdL;\n        xdL = ydL;\n        ydL = rL;\n    }\n    // Initialise the result array with zeros.\n    r = [];\n    rL = xdL + ydL;\n    for(i = rL; i--;)r.push(0);\n    // Multiply!\n    for(i = ydL; --i >= 0;){\n        carry = 0;\n        for(k = xdL + i; k > i;){\n            t = r[k] + yd[i] * xd[k - i - 1] + carry;\n            r[k--] = t % BASE | 0;\n            carry = t / BASE | 0;\n        }\n        r[k] = (r[k] + carry) % BASE | 0;\n    }\n    // Remove trailing zeros.\n    for(; !r[--rL];)r.pop();\n    if (carry) ++e;\n    else r.shift();\n    y.d = r;\n    y.e = getBase10Exponent(r, e);\n    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\n};\n/*\r\n * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toBinary = function(sd, rm) {\n    return toStringBinary(this, 2, sd, rm);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n *\r\n * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toDecimalPlaces = P.toDP = function(dp, rm) {\n    var x = this, Ctor = x.constructor;\n    x = new Ctor(x);\n    if (dp === void 0) return x;\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0) rm = Ctor.rounding;\n    else checkInt32(rm, 0, 8);\n    return finalise(x, dp + x.e + 1, rm);\n};\n/*\r\n * Return a string representing the value of this Decimal in exponential notation rounded to\r\n * `dp` fixed decimal places using rounding mode `rounding`.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toExponential = function(dp, rm) {\n    var str, x = this, Ctor = x.constructor;\n    if (dp === void 0) {\n        str = finiteToString(x, true);\n    } else {\n        checkInt32(dp, 0, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n        x = finalise(new Ctor(x), dp + 1, rm);\n        str = finiteToString(x, true, dp + 1);\n    }\n    return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\n/*\r\n * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n * omitted.\r\n *\r\n * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n * (-0).toFixed(3) is '0.000'.\r\n * (-0.5).toFixed(0) is '-0'.\r\n *\r\n */ P.toFixed = function(dp, rm) {\n    var str, y, x = this, Ctor = x.constructor;\n    if (dp === void 0) {\n        str = finiteToString(x);\n    } else {\n        checkInt32(dp, 0, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n        y = finalise(new Ctor(x), dp + x.e + 1, rm);\n        str = finiteToString(y, false, dp + y.e + 1);\n    }\n    // To determine whether to add the minus sign look at the value before it was rounded,\n    // i.e. look at `x` rather than `y`.\n    return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\n/*\r\n * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n * numerator and an integer denominator.\r\n *\r\n * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n * value necessary to represent the number exactly.\r\n *\r\n * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n *\r\n */ P.toFraction = function(maxD) {\n    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;\n    if (!xd) return new Ctor(x);\n    n1 = d0 = new Ctor(1);\n    d1 = n0 = new Ctor(0);\n    d = new Ctor(d1);\n    e = d.e = getPrecision(xd) - x.e - 1;\n    k = e % LOG_BASE;\n    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\n    if (maxD == null) {\n        // d is 10**e, the minimum max-denominator needed.\n        maxD = e > 0 ? d : n1;\n    } else {\n        n = new Ctor(maxD);\n        if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\n        maxD = n.gt(d) ? e > 0 ? d : n1 : n;\n    }\n    external = false;\n    n = new Ctor(digitsToString(xd));\n    pr = Ctor.precision;\n    Ctor.precision = e = xd.length * LOG_BASE * 2;\n    for(;;){\n        q = divide(n, d, 0, 1, 1);\n        d2 = d0.plus(q.times(d1));\n        if (d2.cmp(maxD) == 1) break;\n        d0 = d1;\n        d1 = d2;\n        d2 = n1;\n        n1 = n0.plus(q.times(d2));\n        n0 = d2;\n        d2 = d;\n        d = n.minus(q.times(d2));\n        n = d2;\n    }\n    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\n    n0 = n0.plus(d2.times(n1));\n    d0 = d0.plus(d2.times(d1));\n    n0.s = n1.s = x.s;\n    // Determine which fraction is closer to x, n0/d0 or n1/d1?\n    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [\n        n1,\n        d1\n    ] : [\n        n0,\n        d0\n    ];\n    Ctor.precision = pr;\n    external = true;\n    return r;\n};\n/*\r\n * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toHexadecimal = P.toHex = function(sd, rm) {\n    return toStringBinary(this, 16, sd, rm);\n};\n/*\r\n * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding\r\n * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.\r\n *\r\n * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n * or `y` is NaN, in which case the return value will be also be NaN.\r\n *\r\n * The return value is not affected by the value of `precision`.\r\n *\r\n * y {number|string|Decimal} The magnitude to round to a multiple of.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * 'toNearest() rounding mode not an integer: {rm}'\r\n * 'toNearest() rounding mode out of range: {rm}'\r\n *\r\n */ P.toNearest = function(y, rm) {\n    var x = this, Ctor = x.constructor;\n    x = new Ctor(x);\n    if (y == null) {\n        // If x is not finite, return x.\n        if (!x.d) return x;\n        y = new Ctor(1);\n        rm = Ctor.rounding;\n    } else {\n        y = new Ctor(y);\n        if (rm === void 0) {\n            rm = Ctor.rounding;\n        } else {\n            checkInt32(rm, 0, 8);\n        }\n        // If x is not finite, return x if y is not NaN, else NaN.\n        if (!x.d) return y.s ? x : y;\n        // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\n        if (!y.d) {\n            if (y.s) y.s = x.s;\n            return y;\n        }\n    }\n    // If y is not zero, calculate the nearest multiple of y to x.\n    if (y.d[0]) {\n        external = false;\n        x = divide(x, y, 0, rm, 1).times(y);\n        external = true;\n        finalise(x);\n    // If y is zero, return zero with the sign of x.\n    } else {\n        y.s = x.s;\n        x = y;\n    }\n    return x;\n};\n/*\r\n * Return the value of this Decimal converted to a number primitive.\r\n * Zero keeps its sign.\r\n *\r\n */ P.toNumber = function() {\n    return +this;\n};\n/*\r\n * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toOctal = function(sd, rm) {\n    return toStringBinary(this, 8, sd, rm);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n * to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * ECMAScript compliant.\r\n *\r\n *   pow(x, NaN)                           = NaN\r\n *   pow(x, ±0)                            = 1\r\n\r\n *   pow(NaN, non-zero)                    = NaN\r\n *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n *   pow(abs(x) > 1, -Infinity)            = +0\r\n *   pow(abs(x) == 1, ±Infinity)           = NaN\r\n *   pow(abs(x) < 1, +Infinity)            = +0\r\n *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n *   pow(+Infinity, y > 0)                 = +Infinity\r\n *   pow(+Infinity, y < 0)                 = +0\r\n *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n *   pow(-Infinity, even integer > 0)      = +Infinity\r\n *   pow(-Infinity, odd integer < 0)       = -0\r\n *   pow(-Infinity, even integer < 0)      = +0\r\n *   pow(+0, y > 0)                        = +0\r\n *   pow(+0, y < 0)                        = +Infinity\r\n *   pow(-0, odd integer > 0)              = -0\r\n *   pow(-0, even integer > 0)             = +0\r\n *   pow(-0, odd integer < 0)              = -Infinity\r\n *   pow(-0, even integer < 0)             = +Infinity\r\n *   pow(finite x < 0, finite non-integer) = NaN\r\n *\r\n * For non-integer or very large exponents pow(x, y) is calculated using\r\n *\r\n *   x^y = exp(y*ln(x))\r\n *\r\n * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n * probability of an incorrectly rounded result\r\n * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n * i.e. 1 in 250,000,000,000,000\r\n *\r\n * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n *\r\n * y {number|string|Decimal} The power to which to raise this Decimal.\r\n *\r\n */ P.toPower = P.pow = function(y) {\n    var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));\n    // Either ±Infinity, NaN or ±0?\n    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));\n    x = new Ctor(x);\n    if (x.eq(1)) return x;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    if (y.eq(1)) return finalise(x, pr, rm);\n    // y exponent\n    e = mathfloor(y.e / LOG_BASE);\n    // If y is a small integer use the 'exponentiation by squaring' algorithm.\n    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\n        r = intPow(Ctor, x, k, pr);\n        return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\n    }\n    s = x.s;\n    // if x is negative\n    if (s < 0) {\n        // if y is not an integer\n        if (e < y.d.length - 1) return new Ctor(NaN);\n        // Result is positive if x is negative and the last digit of integer y is even.\n        if ((y.d[e] & 1) == 0) s = 1;\n        // if x.eq(-1)\n        if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\n            x.s = s;\n            return x;\n        }\n    }\n    // Estimate result exponent.\n    // x^y = 10^e,  where e = y * log10(x)\n    // log10(x) = log10(x_significand) + x_exponent\n    // log10(x_significand) = ln(x_significand) / ln(10)\n    k = mathpow(+x, yn);\n    e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log(\"0.\" + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + \"\").e;\n    // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\n    // Overflow/underflow?\n    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);\n    external = false;\n    Ctor.rounding = x.s = 1;\n    // Estimate the extra guard digits needed to ensure five correct rounding digits from\n    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\n    // new Decimal(2.32456).pow('2087987436534566.46411')\n    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\n    k = Math.min(12, (e + \"\").length);\n    // r = x^y = exp(y*ln(x))\n    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\n    // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)\n    if (r.d) {\n        // Truncate to the required precision plus five rounding digits.\n        r = finalise(r, pr + 5, 1);\n        // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\n        // the result.\n        if (checkRoundingDigits(r.d, pr, rm)) {\n            e = pr + 10;\n            // Truncate to the increased precision plus five rounding digits.\n            r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\n            // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\n            if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\n                r = finalise(r, pr + 1, 0);\n            }\n        }\n    }\n    r.s = s;\n    external = true;\n    Ctor.rounding = rm;\n    return finalise(r, pr, rm);\n};\n/*\r\n * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n * the integer part of the value in normal notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toPrecision = function(sd, rm) {\n    var str, x = this, Ctor = x.constructor;\n    if (sd === void 0) {\n        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n    } else {\n        checkInt32(sd, 1, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n        x = finalise(new Ctor(x), sd, rm);\n        str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\n    }\n    return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n * omitted.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * 'toSD() digits out of range: {sd}'\r\n * 'toSD() digits not an integer: {sd}'\r\n * 'toSD() rounding mode not an integer: {rm}'\r\n * 'toSD() rounding mode out of range: {rm}'\r\n *\r\n */ P.toSignificantDigits = P.toSD = function(sd, rm) {\n    var x = this, Ctor = x.constructor;\n    if (sd === void 0) {\n        sd = Ctor.precision;\n        rm = Ctor.rounding;\n    } else {\n        checkInt32(sd, 1, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n    }\n    return finalise(new Ctor(x), sd, rm);\n};\n/*\r\n * Return a string representing the value of this Decimal.\r\n *\r\n * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n *\r\n */ P.toString = function() {\n    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n    return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n *\r\n */ P.truncated = P.trunc = function() {\n    return finalise(new this.constructor(this), this.e + 1, 1);\n};\n/*\r\n * Return a string representing the value of this Decimal.\r\n * Unlike `toString`, negative zero will include the minus sign.\r\n *\r\n */ P.valueOf = P.toJSON = function() {\n    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n    return x.isNeg() ? \"-\" + str : str;\n};\n// Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\n/*\r\n *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n *                           finiteToString, naturalExponential, naturalLogarithm\r\n *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n *  convertBase              toStringBinary, parseOther\r\n *  cos                      P.cos\r\n *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n *                           taylorSeries, atan2, parseOther\r\n *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n *                           naturalLogarithm, ceil, floor, round, trunc\r\n *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n *                           toStringBinary\r\n *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n *  getLn10                  P.logarithm, naturalLogarithm\r\n *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n *  getPrecision             P.precision, P.toFraction\r\n *  getZeroString            digitsToString, finiteToString\r\n *  intPow                   P.toPower, parseOther\r\n *  isOdd                    toLessThanHalfPi\r\n *  maxOrMin                 max, min\r\n *  naturalExponential       P.naturalExponential, P.toPower\r\n *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n *                           P.toPower, naturalExponential\r\n *  nonFiniteToString        finiteToString, toStringBinary\r\n *  parseDecimal             Decimal\r\n *  parseOther               Decimal\r\n *  sin                      P.sin\r\n *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n *  toLessThanHalfPi         P.cos, P.sin\r\n *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n *  truncate                 intPow\r\n *\r\n *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n *                           naturalLogarithm, config, parseOther, random, Decimal\r\n */ function digitsToString(d) {\n    var i, k, ws, indexOfLastWord = d.length - 1, str = \"\", w = d[0];\n    if (indexOfLastWord > 0) {\n        str += w;\n        for(i = 1; i < indexOfLastWord; i++){\n            ws = d[i] + \"\";\n            k = LOG_BASE - ws.length;\n            if (k) str += getZeroString(k);\n            str += ws;\n        }\n        w = d[i];\n        ws = w + \"\";\n        k = LOG_BASE - ws.length;\n        if (k) str += getZeroString(k);\n    } else if (w === 0) {\n        return \"0\";\n    }\n    // Remove trailing zeros of last w.\n    for(; w % 10 === 0;)w /= 10;\n    return str + w;\n}\nfunction checkInt32(i, min, max) {\n    if (i !== ~~i || i < min || i > max) {\n        throw Error(invalidArgument + i);\n    }\n}\n/*\r\n * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n * `repeating == null` if caller is `log` or `pow`,\r\n * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n */ function checkRoundingDigits(d, i, rm, repeating) {\n    var di, k, r, rd;\n    // Get the length of the first word of the array d.\n    for(k = d[0]; k >= 10; k /= 10)--i;\n    // Is the rounding digit in the first word of d?\n    if (--i < 0) {\n        i += LOG_BASE;\n        di = 0;\n    } else {\n        di = Math.ceil((i + 1) / LOG_BASE);\n        i %= LOG_BASE;\n    }\n    // i is the index (0 - 6) of the rounding digit.\n    // E.g. if within the word 3487563 the first rounding digit is 5,\n    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\n    k = mathpow(10, LOG_BASE - i);\n    rd = d[di] % k | 0;\n    if (repeating == null) {\n        if (i < 3) {\n            if (i == 0) rd = rd / 100 | 0;\n            else if (i == 1) rd = rd / 10 | 0;\n            r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\n        } else {\n            r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\n        }\n    } else {\n        if (i < 4) {\n            if (i == 0) rd = rd / 1000 | 0;\n            else if (i == 1) rd = rd / 100 | 0;\n            else if (i == 2) rd = rd / 10 | 0;\n            r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\n        } else {\n            r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\n        }\n    }\n    return r;\n}\n// Convert string of `baseIn` to an array of numbers of `baseOut`.\n// Eg. convertBase('255', 10, 16) returns [15, 15].\n// Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\nfunction convertBase(str, baseIn, baseOut) {\n    var j, arr = [\n        0\n    ], arrL, i = 0, strL = str.length;\n    for(; i < strL;){\n        for(arrL = arr.length; arrL--;)arr[arrL] *= baseIn;\n        arr[0] += NUMERALS.indexOf(str.charAt(i++));\n        for(j = 0; j < arr.length; j++){\n            if (arr[j] > baseOut - 1) {\n                if (arr[j + 1] === void 0) arr[j + 1] = 0;\n                arr[j + 1] += arr[j] / baseOut | 0;\n                arr[j] %= baseOut;\n            }\n        }\n    }\n    return arr.reverse();\n}\n/*\r\n * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n * |x| < pi/2\r\n *\r\n */ function cosine(Ctor, x) {\n    var k, len, y;\n    if (x.isZero()) return x;\n    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\n    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\n    // Estimate the optimum number of times to use the argument reduction.\n    len = x.d.length;\n    if (len < 32) {\n        k = Math.ceil(len / 3);\n        y = (1 / tinyPow(4, k)).toString();\n    } else {\n        k = 16;\n        y = \"2.3283064365386962890625e-10\";\n    }\n    Ctor.precision += k;\n    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\n    // Reverse argument reduction\n    for(var i = k; i--;){\n        var cos2x = x.times(x);\n        x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\n    }\n    Ctor.precision -= k;\n    return x;\n}\n/*\r\n * Perform division in the specified base.\r\n */ var divide = function() {\n    // Assumes non-zero x and k, and hence non-zero result.\n    function multiplyInteger(x, k, base) {\n        var temp, carry = 0, i = x.length;\n        for(x = x.slice(); i--;){\n            temp = x[i] * k + carry;\n            x[i] = temp % base | 0;\n            carry = temp / base | 0;\n        }\n        if (carry) x.unshift(carry);\n        return x;\n    }\n    function compare(a, b, aL, bL) {\n        var i, r;\n        if (aL != bL) {\n            r = aL > bL ? 1 : -1;\n        } else {\n            for(i = r = 0; i < aL; i++){\n                if (a[i] != b[i]) {\n                    r = a[i] > b[i] ? 1 : -1;\n                    break;\n                }\n            }\n        }\n        return r;\n    }\n    function subtract(a, b, aL, base) {\n        var i = 0;\n        // Subtract b from a.\n        for(; aL--;){\n            a[aL] -= i;\n            i = a[aL] < b[aL] ? 1 : 0;\n            a[aL] = i * base + a[aL] - b[aL];\n        }\n        // Remove leading zeros.\n        for(; !a[0] && a.length > 1;)a.shift();\n    }\n    return function(x, y, pr, rm, dp, base) {\n        var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;\n        // Either NaN, Infinity or 0?\n        if (!xd || !xd[0] || !yd || !yd[0]) {\n            return new Ctor(!x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.\n            xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\n        }\n        if (base) {\n            logBase = 1;\n            e = x.e - y.e;\n        } else {\n            base = BASE;\n            logBase = LOG_BASE;\n            e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\n        }\n        yL = yd.length;\n        xL = xd.length;\n        q = new Ctor(sign);\n        qd = q.d = [];\n        // Result exponent may be one less than e.\n        // The digit array of a Decimal from toStringBinary may have trailing zeros.\n        for(i = 0; yd[i] == (xd[i] || 0); i++);\n        if (yd[i] > (xd[i] || 0)) e--;\n        if (pr == null) {\n            sd = pr = Ctor.precision;\n            rm = Ctor.rounding;\n        } else if (dp) {\n            sd = pr + (x.e - y.e) + 1;\n        } else {\n            sd = pr;\n        }\n        if (sd < 0) {\n            qd.push(1);\n            more = true;\n        } else {\n            // Convert precision in number of base 10 digits to base 1e7 digits.\n            sd = sd / logBase + 2 | 0;\n            i = 0;\n            // divisor < 1e7\n            if (yL == 1) {\n                k = 0;\n                yd = yd[0];\n                sd++;\n                // k is the carry.\n                for(; (i < xL || k) && sd--; i++){\n                    t = k * base + (xd[i] || 0);\n                    qd[i] = t / yd | 0;\n                    k = t % yd | 0;\n                }\n                more = k || i < xL;\n            // divisor >= 1e7\n            } else {\n                // Normalise xd and yd so highest order digit of yd is >= base/2\n                k = base / (yd[0] + 1) | 0;\n                if (k > 1) {\n                    yd = multiplyInteger(yd, k, base);\n                    xd = multiplyInteger(xd, k, base);\n                    yL = yd.length;\n                    xL = xd.length;\n                }\n                xi = yL;\n                rem = xd.slice(0, yL);\n                remL = rem.length;\n                // Add zeros to make remainder as long as divisor.\n                for(; remL < yL;)rem[remL++] = 0;\n                yz = yd.slice();\n                yz.unshift(0);\n                yd0 = yd[0];\n                if (yd[1] >= base / 2) ++yd0;\n                do {\n                    k = 0;\n                    // Compare divisor and remainder.\n                    cmp = compare(yd, rem, yL, remL);\n                    // If divisor < remainder.\n                    if (cmp < 0) {\n                        // Calculate trial digit, k.\n                        rem0 = rem[0];\n                        if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\n                        // k will be how many times the divisor goes into the current remainder.\n                        k = rem0 / yd0 | 0;\n                        //  Algorithm:\n                        //  1. product = divisor * trial digit (k)\n                        //  2. if product > remainder: product -= divisor, k--\n                        //  3. remainder -= product\n                        //  4. if product was < remainder at 2:\n                        //    5. compare new remainder and divisor\n                        //    6. If remainder > divisor: remainder -= divisor, k++\n                        if (k > 1) {\n                            if (k >= base) k = base - 1;\n                            // product = divisor * trial digit.\n                            prod = multiplyInteger(yd, k, base);\n                            prodL = prod.length;\n                            remL = rem.length;\n                            // Compare product and remainder.\n                            cmp = compare(prod, rem, prodL, remL);\n                            // product > remainder.\n                            if (cmp == 1) {\n                                k--;\n                                // Subtract divisor from product.\n                                subtract(prod, yL < prodL ? yz : yd, prodL, base);\n                            }\n                        } else {\n                            // cmp is -1.\n                            // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\n                            // to avoid it. If k is 1 there is a need to compare yd and rem again below.\n                            if (k == 0) cmp = k = 1;\n                            prod = yd.slice();\n                        }\n                        prodL = prod.length;\n                        if (prodL < remL) prod.unshift(0);\n                        // Subtract product from remainder.\n                        subtract(rem, prod, remL, base);\n                        // If product was < previous remainder.\n                        if (cmp == -1) {\n                            remL = rem.length;\n                            // Compare divisor and new remainder.\n                            cmp = compare(yd, rem, yL, remL);\n                            // If divisor < new remainder, subtract divisor from remainder.\n                            if (cmp < 1) {\n                                k++;\n                                // Subtract divisor from remainder.\n                                subtract(rem, yL < remL ? yz : yd, remL, base);\n                            }\n                        }\n                        remL = rem.length;\n                    } else if (cmp === 0) {\n                        k++;\n                        rem = [\n                            0\n                        ];\n                    } // if cmp === 1, k will be 0\n                    // Add the next digit, k, to the result array.\n                    qd[i++] = k;\n                    // Update the remainder.\n                    if (cmp && rem[0]) {\n                        rem[remL++] = xd[xi] || 0;\n                    } else {\n                        rem = [\n                            xd[xi]\n                        ];\n                        remL = 1;\n                    }\n                }while ((xi++ < xL || rem[0] !== void 0) && sd--);\n                more = rem[0] !== void 0;\n            }\n            // Leading zero?\n            if (!qd[0]) qd.shift();\n        }\n        // logBase is 1 when divide is being used for base conversion.\n        if (logBase == 1) {\n            q.e = e;\n            inexact = more;\n        } else {\n            // To calculate q.e, first get the number of digits of qd[0].\n            for(i = 1, k = qd[0]; k >= 10; k /= 10)i++;\n            q.e = i + e * logBase - 1;\n            finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\n        }\n        return q;\n    };\n}();\n/*\r\n * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n * Check for over/under-flow.\r\n */ function finalise(x, sd, rm, isTruncated) {\n    var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;\n    // Don't round if sd is null or undefined.\n    out: if (sd != null) {\n        xd = x.d;\n        // Infinity/NaN.\n        if (!xd) return x;\n        // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\n        // w: the word of xd containing rd, a base 1e7 number.\n        // xdi: the index of w within xd.\n        // digits: the number of digits of w.\n        // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\n        // they had leading zeros)\n        // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\n        // Get the length of the first word of the digits array xd.\n        for(digits = 1, k = xd[0]; k >= 10; k /= 10)digits++;\n        i = sd - digits;\n        // Is the rounding digit in the first word of xd?\n        if (i < 0) {\n            i += LOG_BASE;\n            j = sd;\n            w = xd[xdi = 0];\n            // Get the rounding digit at index j of w.\n            rd = w / mathpow(10, digits - j - 1) % 10 | 0;\n        } else {\n            xdi = Math.ceil((i + 1) / LOG_BASE);\n            k = xd.length;\n            if (xdi >= k) {\n                if (isTruncated) {\n                    // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\n                    for(; k++ <= xdi;)xd.push(0);\n                    w = rd = 0;\n                    digits = 1;\n                    i %= LOG_BASE;\n                    j = i - LOG_BASE + 1;\n                } else {\n                    break out;\n                }\n            } else {\n                w = k = xd[xdi];\n                // Get the number of digits of w.\n                for(digits = 1; k >= 10; k /= 10)digits++;\n                // Get the index of rd within w.\n                i %= LOG_BASE;\n                // Get the index of rd within w, adjusted for leading zeros.\n                // The number of leading zeros of w is given by LOG_BASE - digits.\n                j = i - LOG_BASE + digits;\n                // Get the rounding digit at index j of w.\n                rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\n            }\n        }\n        // Are there any non-zero digits after the rounding digit?\n        isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\n        // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\n        // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\n        // will give 714.\n        roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n        if (sd < 1 || !xd[0]) {\n            xd.length = 0;\n            if (roundUp) {\n                // Convert sd to decimal places.\n                sd -= x.e + 1;\n                // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n                xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\n                x.e = -sd || 0;\n            } else {\n                // Zero.\n                xd[0] = x.e = 0;\n            }\n            return x;\n        }\n        // Remove excess digits.\n        if (i == 0) {\n            xd.length = xdi;\n            k = 1;\n            xdi--;\n        } else {\n            xd.length = xdi + 1;\n            k = mathpow(10, LOG_BASE - i);\n            // E.g. 56700 becomes 56000 if 7 is the rounding digit.\n            // j > 0 means i > number of leading zeros of w.\n            xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\n        }\n        if (roundUp) {\n            for(;;){\n                // Is the digit to be rounded up in the first word of xd?\n                if (xdi == 0) {\n                    // i will be the length of xd[0] before k is added.\n                    for(i = 1, j = xd[0]; j >= 10; j /= 10)i++;\n                    j = xd[0] += k;\n                    for(k = 1; j >= 10; j /= 10)k++;\n                    // if i != k the length has increased.\n                    if (i != k) {\n                        x.e++;\n                        if (xd[0] == BASE) xd[0] = 1;\n                    }\n                    break;\n                } else {\n                    xd[xdi] += k;\n                    if (xd[xdi] != BASE) break;\n                    xd[xdi--] = 0;\n                    k = 1;\n                }\n            }\n        }\n        // Remove trailing zeros.\n        for(i = xd.length; xd[--i] === 0;)xd.pop();\n    }\n    if (external) {\n        // Overflow?\n        if (x.e > Ctor.maxE) {\n            // Infinity.\n            x.d = null;\n            x.e = NaN;\n        // Underflow?\n        } else if (x.e < Ctor.minE) {\n            // Zero.\n            x.e = 0;\n            x.d = [\n                0\n            ];\n        // Ctor.underflow = true;\n        } // else Ctor.underflow = false;\n    }\n    return x;\n}\nfunction finiteToString(x, isExp, sd) {\n    if (!x.isFinite()) return nonFiniteToString(x);\n    var k, e = x.e, str = digitsToString(x.d), len = str.length;\n    if (isExp) {\n        if (sd && (k = sd - len) > 0) {\n            str = str.charAt(0) + \".\" + str.slice(1) + getZeroString(k);\n        } else if (len > 1) {\n            str = str.charAt(0) + \".\" + str.slice(1);\n        }\n        str = str + (x.e < 0 ? \"e\" : \"e+\") + x.e;\n    } else if (e < 0) {\n        str = \"0.\" + getZeroString(-e - 1) + str;\n        if (sd && (k = sd - len) > 0) str += getZeroString(k);\n    } else if (e >= len) {\n        str += getZeroString(e + 1 - len);\n        if (sd && (k = sd - e - 1) > 0) str = str + \".\" + getZeroString(k);\n    } else {\n        if ((k = e + 1) < len) str = str.slice(0, k) + \".\" + str.slice(k);\n        if (sd && (k = sd - len) > 0) {\n            if (e + 1 === len) str += \".\";\n            str += getZeroString(k);\n        }\n    }\n    return str;\n}\n// Calculate the base 10 exponent from the base 1e7 exponent.\nfunction getBase10Exponent(digits, e) {\n    var w = digits[0];\n    // Add the number of digits of the first word of the digits array.\n    for(e *= LOG_BASE; w >= 10; w /= 10)e++;\n    return e;\n}\nfunction getLn10(Ctor, sd, pr) {\n    if (sd > LN10_PRECISION) {\n        // Reset global state in case the exception is caught.\n        external = true;\n        if (pr) Ctor.precision = pr;\n        throw Error(precisionLimitExceeded);\n    }\n    return finalise(new Ctor(LN10), sd, 1, true);\n}\nfunction getPi(Ctor, sd, rm) {\n    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\n    return finalise(new Ctor(PI), sd, rm, true);\n}\nfunction getPrecision(digits) {\n    var w = digits.length - 1, len = w * LOG_BASE + 1;\n    w = digits[w];\n    // If non-zero...\n    if (w) {\n        // Subtract the number of trailing zeros of the last word.\n        for(; w % 10 == 0; w /= 10)len--;\n        // Add the number of digits of the first word.\n        for(w = digits[0]; w >= 10; w /= 10)len++;\n    }\n    return len;\n}\nfunction getZeroString(k) {\n    var zs = \"\";\n    for(; k--;)zs += \"0\";\n    return zs;\n}\n/*\r\n * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n * integer of type number.\r\n *\r\n * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n *\r\n */ function intPow(Ctor, x, n, pr) {\n    var isTruncated, r = new Ctor(1), // Max n of 9007199254740991 takes 53 loop iterations.\n    // Maximum digits array length; leaves [28, 34] guard digits.\n    k = Math.ceil(pr / LOG_BASE + 4);\n    external = false;\n    for(;;){\n        if (n % 2) {\n            r = r.times(x);\n            if (truncate(r.d, k)) isTruncated = true;\n        }\n        n = mathfloor(n / 2);\n        if (n === 0) {\n            // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\n            n = r.d.length - 1;\n            if (isTruncated && r.d[n] === 0) ++r.d[n];\n            break;\n        }\n        x = x.times(x);\n        truncate(x.d, k);\n    }\n    external = true;\n    return r;\n}\nfunction isOdd(n) {\n    return n.d[n.d.length - 1] & 1;\n}\n/*\r\n * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.\r\n */ function maxOrMin(Ctor, args, ltgt) {\n    var y, x = new Ctor(args[0]), i = 0;\n    for(; ++i < args.length;){\n        y = new Ctor(args[i]);\n        if (!y.s) {\n            x = y;\n            break;\n        } else if (x[ltgt](y)) {\n            x = y;\n        }\n    }\n    return x;\n}\n/*\r\n * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n * digits.\r\n *\r\n * Taylor/Maclaurin series.\r\n *\r\n * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n *\r\n * Argument reduction:\r\n *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n *   exp(x) = exp(x / 2^k)^(2^k)\r\n *\r\n * Previously, the argument was initially reduced by\r\n * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n * found to be slower than just dividing repeatedly by 32 as above.\r\n *\r\n * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n *\r\n *  exp(Infinity)  = Infinity\r\n *  exp(-Infinity) = 0\r\n *  exp(NaN)       = NaN\r\n *  exp(±0)        = 1\r\n *\r\n *  exp(x) is non-terminating for any finite, non-zero x.\r\n *\r\n *  The result will always be correctly rounded.\r\n *\r\n */ function naturalExponential(x, sd) {\n    var denominator, guard, j, pow, sum, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n    // 0/NaN/Infinity?\n    if (!x.d || !x.d[0] || x.e > 17) {\n        return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);\n    }\n    if (sd == null) {\n        external = false;\n        wpr = pr;\n    } else {\n        wpr = sd;\n    }\n    t = new Ctor(0.03125);\n    // while abs(x) >= 0.1\n    while(x.e > -2){\n        // x = x / 2^5\n        x = x.times(t);\n        k += 5;\n    }\n    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\n    // necessary to ensure the first 4 rounding digits are correct.\n    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\n    wpr += guard;\n    denominator = pow = sum = new Ctor(1);\n    Ctor.precision = wpr;\n    for(;;){\n        pow = finalise(pow.times(x), wpr, 1);\n        denominator = denominator.times(++i);\n        t = sum.plus(divide(pow, denominator, wpr, 1));\n        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\n            j = k;\n            while(j--)sum = finalise(sum.times(sum), wpr, 1);\n            // Check to see if the first 4 rounding digits are [49]999.\n            // If so, repeat the summation with a higher precision, otherwise\n            // e.g. with precision: 18, rounding: 1\n            // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\n            // `wpr - guard` is the index of first rounding digit.\n            if (sd == null) {\n                if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\n                    Ctor.precision = wpr += 10;\n                    denominator = pow = t = new Ctor(1);\n                    i = 0;\n                    rep++;\n                } else {\n                    return finalise(sum, Ctor.precision = pr, rm, external = true);\n                }\n            } else {\n                Ctor.precision = pr;\n                return sum;\n            }\n        }\n        sum = t;\n    }\n}\n/*\r\n * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n * digits.\r\n *\r\n *  ln(-n)        = NaN\r\n *  ln(0)         = -Infinity\r\n *  ln(-0)        = -Infinity\r\n *  ln(1)         = 0\r\n *  ln(Infinity)  = Infinity\r\n *  ln(-Infinity) = NaN\r\n *  ln(NaN)       = NaN\r\n *\r\n *  ln(n) (n != 1) is non-terminating.\r\n *\r\n */ function naturalLogarithm(y, sd) {\n    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n    // Is x negative or Infinity, NaN, 0 or 1?\n    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\n        return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\n    }\n    if (sd == null) {\n        external = false;\n        wpr = pr;\n    } else {\n        wpr = sd;\n    }\n    Ctor.precision = wpr += guard;\n    c = digitsToString(xd);\n    c0 = c.charAt(0);\n    if (Math.abs(e = x.e) < 1.5e15) {\n        // Argument reduction.\n        // The series converges faster the closer the argument is to 1, so using\n        // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\n        // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\n        // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\n        // later be divided by this number, then separate out the power of 10 using\n        // ln(a*10^b) = ln(a) + b*ln(10).\n        // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\n        //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\n        // max n is 6 (gives 0.7 - 1.3)\n        while(c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3){\n            x = x.times(y);\n            c = digitsToString(x.d);\n            c0 = c.charAt(0);\n            n++;\n        }\n        e = x.e;\n        if (c0 > 1) {\n            x = new Ctor(\"0.\" + c);\n            e++;\n        } else {\n            x = new Ctor(c0 + \".\" + c.slice(1));\n        }\n    } else {\n        // The argument reduction method above may result in overflow if the argument y is a massive\n        // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\n        // function using ln(x*10^e) = ln(x) + e*ln(10).\n        t = getLn10(Ctor, wpr + 2, pr).times(e + \"\");\n        x = naturalLogarithm(new Ctor(c0 + \".\" + c.slice(1)), wpr - guard).plus(t);\n        Ctor.precision = pr;\n        return sd == null ? finalise(x, pr, rm, external = true) : x;\n    }\n    // x1 is x reduced to a value near 1.\n    x1 = x;\n    // Taylor series.\n    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\n    // where x = (y - 1)/(y + 1)    (|x| < 1)\n    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\n    x2 = finalise(x.times(x), wpr, 1);\n    denominator = 3;\n    for(;;){\n        numerator = finalise(numerator.times(x2), wpr, 1);\n        t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\n        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\n            sum = sum.times(2);\n            // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\n            // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\n            if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + \"\"));\n            sum = divide(sum, new Ctor(n), wpr, 1);\n            // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\n            // been repeated previously) and the first 4 rounding digits 9999?\n            // If so, restart the summation with a higher precision, otherwise\n            // e.g. with precision: 12, rounding: 1\n            // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\n            // `wpr - guard` is the index of first rounding digit.\n            if (sd == null) {\n                if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\n                    Ctor.precision = wpr += guard;\n                    t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\n                    x2 = finalise(x.times(x), wpr, 1);\n                    denominator = rep = 1;\n                } else {\n                    return finalise(sum, Ctor.precision = pr, rm, external = true);\n                }\n            } else {\n                Ctor.precision = pr;\n                return sum;\n            }\n        }\n        sum = t;\n        denominator += 2;\n    }\n}\n// ±Infinity, NaN.\nfunction nonFiniteToString(x) {\n    // Unsigned.\n    return String(x.s * x.s / 0);\n}\n/*\r\n * Parse the value of a new Decimal `x` from string `str`.\r\n */ function parseDecimal(x, str) {\n    var e, i, len;\n    // Decimal point?\n    if ((e = str.indexOf(\".\")) > -1) str = str.replace(\".\", \"\");\n    // Exponential form?\n    if ((i = str.search(/e/i)) > 0) {\n        // Determine exponent.\n        if (e < 0) e = i;\n        e += +str.slice(i + 1);\n        str = str.substring(0, i);\n    } else if (e < 0) {\n        // Integer.\n        e = str.length;\n    }\n    // Determine leading zeros.\n    for(i = 0; str.charCodeAt(i) === 48; i++);\n    // Determine trailing zeros.\n    for(len = str.length; str.charCodeAt(len - 1) === 48; --len);\n    str = str.slice(i, len);\n    if (str) {\n        len -= i;\n        x.e = e = e - i - 1;\n        x.d = [];\n        // Transform base\n        // e is the base 10 exponent.\n        // i is where to slice str to get the first word of the digits array.\n        i = (e + 1) % LOG_BASE;\n        if (e < 0) i += LOG_BASE;\n        if (i < len) {\n            if (i) x.d.push(+str.slice(0, i));\n            for(len -= LOG_BASE; i < len;)x.d.push(+str.slice(i, i += LOG_BASE));\n            str = str.slice(i);\n            i = LOG_BASE - str.length;\n        } else {\n            i -= len;\n        }\n        for(; i--;)str += \"0\";\n        x.d.push(+str);\n        if (external) {\n            // Overflow?\n            if (x.e > x.constructor.maxE) {\n                // Infinity.\n                x.d = null;\n                x.e = NaN;\n            // Underflow?\n            } else if (x.e < x.constructor.minE) {\n                // Zero.\n                x.e = 0;\n                x.d = [\n                    0\n                ];\n            // x.constructor.underflow = true;\n            } // else x.constructor.underflow = false;\n        }\n    } else {\n        // Zero.\n        x.e = 0;\n        x.d = [\n            0\n        ];\n    }\n    return x;\n}\n/*\r\n * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n */ function parseOther(x, str) {\n    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\n    if (str.indexOf(\"_\") > -1) {\n        str = str.replace(/(\\d)_(?=\\d)/g, \"$1\");\n        if (isDecimal.test(str)) return parseDecimal(x, str);\n    } else if (str === \"Infinity\" || str === \"NaN\") {\n        if (!+str) x.s = NaN;\n        x.e = NaN;\n        x.d = null;\n        return x;\n    }\n    if (isHex.test(str)) {\n        base = 16;\n        str = str.toLowerCase();\n    } else if (isBinary.test(str)) {\n        base = 2;\n    } else if (isOctal.test(str)) {\n        base = 8;\n    } else {\n        throw Error(invalidArgument + str);\n    }\n    // Is there a binary exponent part?\n    i = str.search(/p/i);\n    if (i > 0) {\n        p = +str.slice(i + 1);\n        str = str.substring(2, i);\n    } else {\n        str = str.slice(2);\n    }\n    // Convert `str` as an integer then divide the result by `base` raised to a power such that the\n    // fraction part will be restored.\n    i = str.indexOf(\".\");\n    isFloat = i >= 0;\n    Ctor = x.constructor;\n    if (isFloat) {\n        str = str.replace(\".\", \"\");\n        len = str.length;\n        i = len - i;\n        // log[10](16) = 1.2041... , log[10](88) = 1.9444....\n        divisor = intPow(Ctor, new Ctor(base), i, i * 2);\n    }\n    xd = convertBase(str, base, BASE);\n    xe = xd.length - 1;\n    // Remove trailing zeros.\n    for(i = xe; xd[i] === 0; --i)xd.pop();\n    if (i < 0) return new Ctor(x.s * 0);\n    x.e = getBase10Exponent(xd, xe);\n    x.d = xd;\n    external = false;\n    // At what precision to perform the division to ensure exact conversion?\n    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\n    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\n    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\n    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\n    // Therefore using 4 * the number of digits of str will always be enough.\n    if (isFloat) x = divide(x, divisor, len * 4);\n    // Multiply by the binary exponent part if present.\n    if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\n    external = true;\n    return x;\n}\n/*\r\n * sin(x) = x - x^3/3! + x^5/5! - ...\r\n * |x| < pi/2\r\n *\r\n */ function sine(Ctor, x) {\n    var k, len = x.d.length;\n    if (len < 3) {\n        return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);\n    }\n    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\n    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\n    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\n    // Estimate the optimum number of times to use the argument reduction.\n    k = 1.4 * Math.sqrt(len);\n    k = k > 16 ? 16 : k | 0;\n    x = x.times(1 / tinyPow(5, k));\n    x = taylorSeries(Ctor, 2, x, x);\n    // Reverse argument reduction\n    var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n    for(; k--;){\n        sin2_x = x.times(x);\n        x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\n    }\n    return x;\n}\n// Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\nfunction taylorSeries(Ctor, n, x, y, isHyperbolic) {\n    var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);\n    external = false;\n    x2 = x.times(x);\n    u = new Ctor(y);\n    for(;;){\n        t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\n        u = isHyperbolic ? y.plus(t) : y.minus(t);\n        y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\n        t = u.plus(y);\n        if (t.d[k] !== void 0) {\n            for(j = k; t.d[j] === u.d[j] && j--;);\n            if (j == -1) break;\n        }\n        j = u;\n        u = y;\n        y = t;\n        t = j;\n        i++;\n    }\n    external = true;\n    t.d.length = k + 1;\n    return t;\n}\n// Exponent e must be positive and non-zero.\nfunction tinyPow(b, e) {\n    var n = b;\n    while(--e)n *= b;\n    return n;\n}\n// Return the absolute value of `x` reduced to less than or equal to half pi.\nfunction toLessThanHalfPi(Ctor, x) {\n    var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);\n    x = x.abs();\n    if (x.lte(halfPi)) {\n        quadrant = isNeg ? 4 : 1;\n        return x;\n    }\n    t = x.divToInt(pi);\n    if (t.isZero()) {\n        quadrant = isNeg ? 3 : 2;\n    } else {\n        x = x.minus(t.times(pi));\n        // 0 <= x < pi\n        if (x.lte(halfPi)) {\n            quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;\n            return x;\n        }\n        quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;\n    }\n    return x.minus(pi).abs();\n}\n/*\r\n * Return the value of Decimal `x` as a string in base `baseOut`.\r\n *\r\n * If the optional `sd` argument is present include a binary exponent suffix.\r\n */ function toStringBinary(x, baseOut, sd, rm) {\n    var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;\n    if (isExp) {\n        checkInt32(sd, 1, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n    } else {\n        sd = Ctor.precision;\n        rm = Ctor.rounding;\n    }\n    if (!x.isFinite()) {\n        str = nonFiniteToString(x);\n    } else {\n        str = finiteToString(x);\n        i = str.indexOf(\".\");\n        // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\n        // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\n        // minBinaryExponent = floor(decimalExponent * log[2](10))\n        // log[2](10) = 3.321928094887362347870319429489390175864\n        if (isExp) {\n            base = 2;\n            if (baseOut == 16) {\n                sd = sd * 4 - 3;\n            } else if (baseOut == 8) {\n                sd = sd * 3 - 2;\n            }\n        } else {\n            base = baseOut;\n        }\n        // Convert the number as an integer then divide the result by its base raised to a power such\n        // that the fraction part will be restored.\n        // Non-integer.\n        if (i >= 0) {\n            str = str.replace(\".\", \"\");\n            y = new Ctor(1);\n            y.e = str.length - i;\n            y.d = convertBase(finiteToString(y), 10, base);\n            y.e = y.d.length;\n        }\n        xd = convertBase(str, 10, base);\n        e = len = xd.length;\n        // Remove trailing zeros.\n        for(; xd[--len] == 0;)xd.pop();\n        if (!xd[0]) {\n            str = isExp ? \"0p+0\" : \"0\";\n        } else {\n            if (i < 0) {\n                e--;\n            } else {\n                x = new Ctor(x);\n                x.d = xd;\n                x.e = e;\n                x = divide(x, y, sd, rm, 0, base);\n                xd = x.d;\n                e = x.e;\n                roundUp = inexact;\n            }\n            // The rounding digit, i.e. the digit after the digit that may be rounded up.\n            i = xd[sd];\n            k = base / 2;\n            roundUp = roundUp || xd[sd + 1] !== void 0;\n            roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));\n            xd.length = sd;\n            if (roundUp) {\n                // Rounding up may mean the previous digit has to be rounded up and so on.\n                for(; ++xd[--sd] > base - 1;){\n                    xd[sd] = 0;\n                    if (!sd) {\n                        ++e;\n                        xd.unshift(1);\n                    }\n                }\n            }\n            // Determine trailing zeros.\n            for(len = xd.length; !xd[len - 1]; --len);\n            // E.g. [4, 11, 15] becomes 4bf.\n            for(i = 0, str = \"\"; i < len; i++)str += NUMERALS.charAt(xd[i]);\n            // Add binary exponent suffix?\n            if (isExp) {\n                if (len > 1) {\n                    if (baseOut == 16 || baseOut == 8) {\n                        i = baseOut == 16 ? 4 : 3;\n                        for(--len; len % i; len++)str += \"0\";\n                        xd = convertBase(str, base, baseOut);\n                        for(len = xd.length; !xd[len - 1]; --len);\n                        // xd[0] will always be be 1\n                        for(i = 1, str = \"1.\"; i < len; i++)str += NUMERALS.charAt(xd[i]);\n                    } else {\n                        str = str.charAt(0) + \".\" + str.slice(1);\n                    }\n                }\n                str = str + (e < 0 ? \"p\" : \"p+\") + e;\n            } else if (e < 0) {\n                for(; ++e;)str = \"0\" + str;\n                str = \"0.\" + str;\n            } else {\n                if (++e > len) for(e -= len; e--;)str += \"0\";\n                else if (e < len) str = str.slice(0, e) + \".\" + str.slice(e);\n            }\n        }\n        str = (baseOut == 16 ? \"0x\" : baseOut == 2 ? \"0b\" : baseOut == 8 ? \"0o\" : \"\") + str;\n    }\n    return x.s < 0 ? \"-\" + str : str;\n}\n// Does not strip trailing zeros.\nfunction truncate(arr, len) {\n    if (arr.length > len) {\n        arr.length = len;\n        return true;\n    }\n}\n// Decimal methods\n/*\r\n *  abs\r\n *  acos\r\n *  acosh\r\n *  add\r\n *  asin\r\n *  asinh\r\n *  atan\r\n *  atanh\r\n *  atan2\r\n *  cbrt\r\n *  ceil\r\n *  clamp\r\n *  clone\r\n *  config\r\n *  cos\r\n *  cosh\r\n *  div\r\n *  exp\r\n *  floor\r\n *  hypot\r\n *  ln\r\n *  log\r\n *  log2\r\n *  log10\r\n *  max\r\n *  min\r\n *  mod\r\n *  mul\r\n *  pow\r\n *  random\r\n *  round\r\n *  set\r\n *  sign\r\n *  sin\r\n *  sinh\r\n *  sqrt\r\n *  sub\r\n *  sum\r\n *  tan\r\n *  tanh\r\n *  trunc\r\n */ /*\r\n * Return a new Decimal whose value is the absolute value of `x`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function abs(x) {\n    return new this(x).abs();\n}\n/*\r\n * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function acos(x) {\n    return new this(x).acos();\n}\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function acosh(x) {\n    return new this(x).acosh();\n}\n/*\r\n * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */ function add(x, y) {\n    return new this(x).plus(y);\n}\n/*\r\n * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function asin(x) {\n    return new this(x).asin();\n}\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function asinh(x) {\n    return new this(x).asinh();\n}\n/*\r\n * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function atan(x) {\n    return new this(x).atan();\n}\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function atanh(x) {\n    return new this(x).atanh();\n}\n/*\r\n * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi, pi]\r\n *\r\n * y {number|string|Decimal} The y-coordinate.\r\n * x {number|string|Decimal} The x-coordinate.\r\n *\r\n * atan2(±0, -0)               = ±pi\r\n * atan2(±0, +0)               = ±0\r\n * atan2(±0, -x)               = ±pi for x > 0\r\n * atan2(±0, x)                = ±0 for x > 0\r\n * atan2(-y, ±0)               = -pi/2 for y > 0\r\n * atan2(y, ±0)                = pi/2 for y > 0\r\n * atan2(±y, -Infinity)        = ±pi for finite y > 0\r\n * atan2(±y, +Infinity)        = ±0 for finite y > 0\r\n * atan2(±Infinity, x)         = ±pi/2 for finite x\r\n * atan2(±Infinity, -Infinity) = ±3*pi/4\r\n * atan2(±Infinity, +Infinity) = ±pi/4\r\n * atan2(NaN, x) = NaN\r\n * atan2(y, NaN) = NaN\r\n *\r\n */ function atan2(y, x) {\n    y = new this(y);\n    x = new this(x);\n    var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;\n    // Either NaN\n    if (!y.s || !x.s) {\n        r = new this(NaN);\n    // Both ±Infinity\n    } else if (!y.d && !x.d) {\n        r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\n        r.s = y.s;\n    // x is ±Infinity or y is ±0\n    } else if (!x.d || y.isZero()) {\n        r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\n        r.s = y.s;\n    // y is ±Infinity or x is ±0\n    } else if (!y.d || x.isZero()) {\n        r = getPi(this, wpr, 1).times(0.5);\n        r.s = y.s;\n    // Both non-zero and finite\n    } else if (x.s < 0) {\n        this.precision = wpr;\n        this.rounding = 1;\n        r = this.atan(divide(y, x, wpr, 1));\n        x = getPi(this, wpr, 1);\n        this.precision = pr;\n        this.rounding = rm;\n        r = y.s < 0 ? r.minus(x) : r.plus(x);\n    } else {\n        r = this.atan(divide(y, x, wpr, 1));\n    }\n    return r;\n}\n/*\r\n * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function cbrt(x) {\n    return new this(x).cbrt();\n}\n/*\r\n * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function ceil(x) {\n    return finalise(x = new this(x), x.e + 1, 2);\n}\n/*\r\n * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.\r\n *\r\n * x {number|string|Decimal}\r\n * min {number|string|Decimal}\r\n * max {number|string|Decimal}\r\n *\r\n */ function clamp(x, min, max) {\n    return new this(x).clamp(min, max);\n}\n/*\r\n * Configure global settings for a Decimal constructor.\r\n *\r\n * `obj` is an object with one or more of the following properties,\r\n *\r\n *   precision  {number}\r\n *   rounding   {number}\r\n *   toExpNeg   {number}\r\n *   toExpPos   {number}\r\n *   maxE       {number}\r\n *   minE       {number}\r\n *   modulo     {number}\r\n *   crypto     {boolean|number}\r\n *   defaults   {true}\r\n *\r\n * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n *\r\n */ function config(obj) {\n    if (!obj || typeof obj !== \"object\") throw Error(decimalError + \"Object expected\");\n    var i, p, v, useDefaults = obj.defaults === true, ps = [\n        \"precision\",\n        1,\n        MAX_DIGITS,\n        \"rounding\",\n        0,\n        8,\n        \"toExpNeg\",\n        -EXP_LIMIT,\n        0,\n        \"toExpPos\",\n        0,\n        EXP_LIMIT,\n        \"maxE\",\n        0,\n        EXP_LIMIT,\n        \"minE\",\n        -EXP_LIMIT,\n        0,\n        \"modulo\",\n        0,\n        9\n    ];\n    for(i = 0; i < ps.length; i += 3){\n        if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];\n        if ((v = obj[p]) !== void 0) {\n            if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\n            else throw Error(invalidArgument + p + \": \" + v);\n        }\n    }\n    if (p = \"crypto\", useDefaults) this[p] = DEFAULTS[p];\n    if ((v = obj[p]) !== void 0) {\n        if (v === true || v === false || v === 0 || v === 1) {\n            if (v) {\n                if (typeof crypto != \"undefined\" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n                    this[p] = true;\n                } else {\n                    throw Error(cryptoUnavailable);\n                }\n            } else {\n                this[p] = false;\n            }\n        } else {\n            throw Error(invalidArgument + p + \": \" + v);\n        }\n    }\n    return this;\n}\n/*\r\n * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function cos(x) {\n    return new this(x).cos();\n}\n/*\r\n * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function cosh(x) {\n    return new this(x).cosh();\n}\n/*\r\n * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n * constructor.\r\n *\r\n */ function clone(obj) {\n    var i, p, ps;\n    /*\r\n   * The Decimal constructor and exported function.\r\n   * Return a new Decimal instance.\r\n   *\r\n   * v {number|string|Decimal} A numeric value.\r\n   *\r\n   */ function Decimal(v) {\n        var e, i, t, x = this;\n        // Decimal called without new.\n        if (!(x instanceof Decimal)) return new Decimal(v);\n        // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\n        // which points to Object.\n        x.constructor = Decimal;\n        // Duplicate.\n        if (isDecimalInstance(v)) {\n            x.s = v.s;\n            if (external) {\n                if (!v.d || v.e > Decimal.maxE) {\n                    // Infinity.\n                    x.e = NaN;\n                    x.d = null;\n                } else if (v.e < Decimal.minE) {\n                    // Zero.\n                    x.e = 0;\n                    x.d = [\n                        0\n                    ];\n                } else {\n                    x.e = v.e;\n                    x.d = v.d.slice();\n                }\n            } else {\n                x.e = v.e;\n                x.d = v.d ? v.d.slice() : v.d;\n            }\n            return;\n        }\n        t = typeof v;\n        if (t === \"number\") {\n            if (v === 0) {\n                x.s = 1 / v < 0 ? -1 : 1;\n                x.e = 0;\n                x.d = [\n                    0\n                ];\n                return;\n            }\n            if (v < 0) {\n                v = -v;\n                x.s = -1;\n            } else {\n                x.s = 1;\n            }\n            // Fast path for small integers.\n            if (v === ~~v && v < 1e7) {\n                for(e = 0, i = v; i >= 10; i /= 10)e++;\n                if (external) {\n                    if (e > Decimal.maxE) {\n                        x.e = NaN;\n                        x.d = null;\n                    } else if (e < Decimal.minE) {\n                        x.e = 0;\n                        x.d = [\n                            0\n                        ];\n                    } else {\n                        x.e = e;\n                        x.d = [\n                            v\n                        ];\n                    }\n                } else {\n                    x.e = e;\n                    x.d = [\n                        v\n                    ];\n                }\n                return;\n            // Infinity, NaN.\n            } else if (v * 0 !== 0) {\n                if (!v) x.s = NaN;\n                x.e = NaN;\n                x.d = null;\n                return;\n            }\n            return parseDecimal(x, v.toString());\n        } else if (t !== \"string\") {\n            throw Error(invalidArgument + v);\n        }\n        // Minus sign?\n        if ((i = v.charCodeAt(0)) === 45) {\n            v = v.slice(1);\n            x.s = -1;\n        } else {\n            // Plus sign?\n            if (i === 43) v = v.slice(1);\n            x.s = 1;\n        }\n        return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\n    }\n    Decimal.prototype = P;\n    Decimal.ROUND_UP = 0;\n    Decimal.ROUND_DOWN = 1;\n    Decimal.ROUND_CEIL = 2;\n    Decimal.ROUND_FLOOR = 3;\n    Decimal.ROUND_HALF_UP = 4;\n    Decimal.ROUND_HALF_DOWN = 5;\n    Decimal.ROUND_HALF_EVEN = 6;\n    Decimal.ROUND_HALF_CEIL = 7;\n    Decimal.ROUND_HALF_FLOOR = 8;\n    Decimal.EUCLID = 9;\n    Decimal.config = Decimal.set = config;\n    Decimal.clone = clone;\n    Decimal.isDecimal = isDecimalInstance;\n    Decimal.abs = abs;\n    Decimal.acos = acos;\n    Decimal.acosh = acosh; // ES6\n    Decimal.add = add;\n    Decimal.asin = asin;\n    Decimal.asinh = asinh; // ES6\n    Decimal.atan = atan;\n    Decimal.atanh = atanh; // ES6\n    Decimal.atan2 = atan2;\n    Decimal.cbrt = cbrt; // ES6\n    Decimal.ceil = ceil;\n    Decimal.clamp = clamp;\n    Decimal.cos = cos;\n    Decimal.cosh = cosh; // ES6\n    Decimal.div = div;\n    Decimal.exp = exp;\n    Decimal.floor = floor;\n    Decimal.hypot = hypot; // ES6\n    Decimal.ln = ln;\n    Decimal.log = log;\n    Decimal.log10 = log10; // ES6\n    Decimal.log2 = log2; // ES6\n    Decimal.max = max;\n    Decimal.min = min;\n    Decimal.mod = mod;\n    Decimal.mul = mul;\n    Decimal.pow = pow;\n    Decimal.random = random;\n    Decimal.round = round;\n    Decimal.sign = sign; // ES6\n    Decimal.sin = sin;\n    Decimal.sinh = sinh; // ES6\n    Decimal.sqrt = sqrt;\n    Decimal.sub = sub;\n    Decimal.sum = sum;\n    Decimal.tan = tan;\n    Decimal.tanh = tanh; // ES6\n    Decimal.trunc = trunc; // ES6\n    if (obj === void 0) obj = {};\n    if (obj) {\n        if (obj.defaults !== true) {\n            ps = [\n                \"precision\",\n                \"rounding\",\n                \"toExpNeg\",\n                \"toExpPos\",\n                \"maxE\",\n                \"minE\",\n                \"modulo\",\n                \"crypto\"\n            ];\n            for(i = 0; i < ps.length;)if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\n        }\n    }\n    Decimal.config(obj);\n    return Decimal;\n}\n/*\r\n * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */ function div(x, y) {\n    return new this(x).div(y);\n}\n/*\r\n * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} The power to which to raise the base of the natural log.\r\n *\r\n */ function exp(x) {\n    return new this(x).exp();\n}\n/*\r\n * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function floor(x) {\n    return finalise(x = new this(x), x.e + 1, 3);\n}\n/*\r\n * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n * rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */ function hypot() {\n    var i, n, t = new this(0);\n    external = false;\n    for(i = 0; i < arguments.length;){\n        n = new this(arguments[i++]);\n        if (!n.d) {\n            if (n.s) {\n                external = true;\n                return new this(1 / 0);\n            }\n            t = n;\n        } else if (t.d) {\n            t = t.plus(n.times(n));\n        }\n    }\n    external = true;\n    return t.sqrt();\n}\n/*\r\n * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),\r\n * otherwise return false.\r\n *\r\n */ function isDecimalInstance(obj) {\n    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;\n}\n/*\r\n * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function ln(x) {\n    return new this(x).ln();\n}\n/*\r\n * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * log[y](x)\r\n *\r\n * x {number|string|Decimal} The argument of the logarithm.\r\n * y {number|string|Decimal} The base of the logarithm.\r\n *\r\n */ function log(x, y) {\n    return new this(x).log(y);\n}\n/*\r\n * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function log2(x) {\n    return new this(x).log(2);\n}\n/*\r\n * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function log10(x) {\n    return new this(x).log(10);\n}\n/*\r\n * Return a new Decimal whose value is the maximum of the arguments.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */ function max() {\n    return maxOrMin(this, arguments, \"lt\");\n}\n/*\r\n * Return a new Decimal whose value is the minimum of the arguments.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */ function min() {\n    return maxOrMin(this, arguments, \"gt\");\n}\n/*\r\n * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */ function mod(x, y) {\n    return new this(x).mod(y);\n}\n/*\r\n * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */ function mul(x, y) {\n    return new this(x).mul(y);\n}\n/*\r\n * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} The base.\r\n * y {number|string|Decimal} The exponent.\r\n *\r\n */ function pow(x, y) {\n    return new this(x).pow(y);\n}\n/*\r\n * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n * are produced).\r\n *\r\n * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n *\r\n */ function random(sd) {\n    var d, e, k, n, i = 0, r = new this(1), rd = [];\n    if (sd === void 0) sd = this.precision;\n    else checkInt32(sd, 1, MAX_DIGITS);\n    k = Math.ceil(sd / LOG_BASE);\n    if (!this.crypto) {\n        for(; i < k;)rd[i++] = Math.random() * 1e7 | 0;\n    // Browsers supporting crypto.getRandomValues.\n    } else if (crypto.getRandomValues) {\n        d = crypto.getRandomValues(new Uint32Array(k));\n        for(; i < k;){\n            n = d[i];\n            // 0 <= n < 4294967296\n            // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\n            if (n >= 4.29e9) {\n                d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\n            } else {\n                // 0 <= n <= 4289999999\n                // 0 <= (n % 1e7) <= 9999999\n                rd[i++] = n % 1e7;\n            }\n        }\n    // Node.js supporting crypto.randomBytes.\n    } else if (crypto.randomBytes) {\n        // buffer\n        d = crypto.randomBytes(k *= 4);\n        for(; i < k;){\n            // 0 <= n < 2147483648\n            n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);\n            // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\n            if (n >= 2.14e9) {\n                crypto.randomBytes(4).copy(d, i);\n            } else {\n                // 0 <= n <= 2139999999\n                // 0 <= (n % 1e7) <= 9999999\n                rd.push(n % 1e7);\n                i += 4;\n            }\n        }\n        i = k / 4;\n    } else {\n        throw Error(cryptoUnavailable);\n    }\n    k = rd[--i];\n    sd %= LOG_BASE;\n    // Convert trailing digits to zeros according to sd.\n    if (k && sd) {\n        n = mathpow(10, LOG_BASE - sd);\n        rd[i] = (k / n | 0) * n;\n    }\n    // Remove trailing words which are zero.\n    for(; rd[i] === 0; i--)rd.pop();\n    // Zero?\n    if (i < 0) {\n        e = 0;\n        rd = [\n            0\n        ];\n    } else {\n        e = -1;\n        // Remove leading words which are zero and adjust exponent accordingly.\n        for(; rd[0] === 0; e -= LOG_BASE)rd.shift();\n        // Count the digits of the first word of rd to determine leading zeros.\n        for(k = 1, n = rd[0]; n >= 10; n /= 10)k++;\n        // Adjust the exponent for leading zeros of the first word of rd.\n        if (k < LOG_BASE) e -= LOG_BASE - k;\n    }\n    r.e = e;\n    r.d = rd;\n    return r;\n}\n/*\r\n * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n *\r\n * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function round(x) {\n    return finalise(x = new this(x), x.e + 1, this.rounding);\n}\n/*\r\n * Return\r\n *   1    if x > 0,\r\n *  -1    if x < 0,\r\n *   0    if x is 0,\r\n *  -0    if x is -0,\r\n *   NaN  otherwise\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function sign(x) {\n    x = new this(x);\n    return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;\n}\n/*\r\n * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function sin(x) {\n    return new this(x).sin();\n}\n/*\r\n * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function sinh(x) {\n    return new this(x).sinh();\n}\n/*\r\n * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function sqrt(x) {\n    return new this(x).sqrt();\n}\n/*\r\n * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */ function sub(x, y) {\n    return new this(x).sub(y);\n}\n/*\r\n * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * Only the result is rounded, not the intermediate calculations.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */ function sum() {\n    var i = 0, args = arguments, x = new this(args[i]);\n    external = false;\n    for(; x.s && ++i < args.length;)x = x.plus(args[i]);\n    external = true;\n    return finalise(x, this.precision, this.rounding);\n}\n/*\r\n * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function tan(x) {\n    return new this(x).tan();\n}\n/*\r\n * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function tanh(x) {\n    return new this(x).tanh();\n}\n/*\r\n * Return a new Decimal whose value is `x` truncated to an integer.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function trunc(x) {\n    return finalise(x = new this(x), x.e + 1, 1);\n}\nP[Symbol.for(\"nodejs.util.inspect.custom\")] = P.toString;\nP[Symbol.toStringTag] = \"Decimal\";\n// Create and configure initial Decimal constructor.\nvar Decimal = P.constructor = clone(DEFAULTS);\n// Create the internal constants from their string values.\nLN10 = new Decimal(LN10);\nPI = new Decimal(PI);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Decimal);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGVjaW1hbC5qcy9kZWNpbWFsLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7Q0FNQyxHQUdELGtHQUFrRztBQUdoRyxrQ0FBa0M7QUFDbEMsdUVBQXVFO0FBQ3pFLElBQUlBLFlBQVksTUFFZCxtRkFBbUY7QUFDbkYsMEZBQTBGO0FBQzFGQyxhQUFhLEtBRWIsNEJBQTRCO0FBQzVCQyxXQUFXLG9CQUVYLDZDQUE2QztBQUM3Q0MsT0FBTyxzZ0NBRVAsb0JBQW9CO0FBQ3BCQyxLQUFLLHNnQ0FHTCxtRUFBbUU7QUFDbkVDLFdBQVc7SUFFVCxzRUFBc0U7SUFDdEUscUZBQXFGO0lBRXJGLDhGQUE4RjtJQUM5Riw0Q0FBNEM7SUFDNUNDLFdBQVc7SUFFWCx1REFBdUQ7SUFDdkQsRUFBRTtJQUNGLHFDQUFxQztJQUNyQyxtQ0FBbUM7SUFDbkMsd0NBQXdDO0lBQ3hDLHdDQUF3QztJQUN4QyxvRUFBb0U7SUFDcEUsc0VBQXNFO0lBQ3RFLHdGQUF3RjtJQUN4RixtRkFBbUY7SUFDbkYsbUZBQW1GO0lBQ25GLEVBQUU7SUFDRixPQUFPO0lBQ1AsMEJBQTBCO0lBQzFCLDhDQUE4QztJQUM5Q0MsVUFBVTtJQUVWLDhEQUE4RDtJQUM5RCx1RkFBdUY7SUFDdkYscURBQXFEO0lBQ3JELEVBQUU7SUFDRix3RkFBd0Y7SUFDeEYsK0VBQStFO0lBQy9FLDBFQUEwRTtJQUMxRSxnREFBZ0Q7SUFDaEQscUZBQXFGO0lBQ3JGLEVBQUU7SUFDRiwwRkFBMEY7SUFDMUYsOEZBQThGO0lBQzlGLGlEQUFpRDtJQUNqREMsUUFBUTtJQUVSLG1GQUFtRjtJQUNuRix5QkFBeUI7SUFDekJDLFVBQVUsQ0FBQztJQUVYLGlGQUFpRjtJQUNqRix5QkFBeUI7SUFDekJDLFVBQVc7SUFFWCxzRUFBc0U7SUFDdEUscUNBQXFDO0lBQ3JDQyxNQUFNLENBQUNYO0lBRVAsdUVBQXVFO0lBQ3ZFLHFEQUFxRDtJQUNyRFksTUFBTVo7SUFFTixrRkFBa0Y7SUFD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QUFLLElBQUk0UixRQUFRNVI7QUFFakIsaUVBQWU0UixPQUFPQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGtleXN0YXRpYy90ZW1wbGF0ZXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2RlY2ltYWwuanMvZGVjaW1hbC5tanM/YzUzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuICogIGRlY2ltYWwuanMgdjEwLjQuM1xyXG4gKiAgQW4gYXJiaXRyYXJ5LXByZWNpc2lvbiBEZWNpbWFsIHR5cGUgZm9yIEphdmFTY3JpcHQuXHJcbiAqICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9kZWNpbWFsLmpzXHJcbiAqICBDb3B5cmlnaHQgKGMpIDIwMjIgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICogIE1JVCBMaWNlbmNlXHJcbiAqL1xyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICBFRElUQUJMRSBERUZBVUxUUyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblxyXG5cclxuICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCBtYWduaXR1ZGUuXHJcbiAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBgdG9FeHBOZWdgLCBgdG9FeHBQb3NgLCBgbWluRWAgYW5kIGBtYXhFYC5cclxudmFyIEVYUF9MSU1JVCA9IDllMTUsICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOWUxNVxyXG5cclxuICAvLyBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIGBwcmVjaXNpb25gLCBhbmQgb24gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBhcmd1bWVudCB0b1xyXG4gIC8vIGB0b0RlY2ltYWxQbGFjZXNgLCBgdG9FeHBvbmVudGlhbGAsIGB0b0ZpeGVkYCwgYHRvUHJlY2lzaW9uYCBhbmQgYHRvU2lnbmlmaWNhbnREaWdpdHNgLlxyXG4gIE1BWF9ESUdJVFMgPSAxZTksICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAxZTlcclxuXHJcbiAgLy8gQmFzZSBjb252ZXJzaW9uIGFscGhhYmV0LlxyXG4gIE5VTUVSQUxTID0gJzAxMjM0NTY3ODlhYmNkZWYnLFxyXG5cclxuICAvLyBUaGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgMTAgKDEwMjUgZGlnaXRzKS5cclxuICBMTjEwID0gJzIuMzAyNTg1MDkyOTk0MDQ1Njg0MDE3OTkxNDU0Njg0MzY0MjA3NjAxMTAxNDg4NjI4NzcyOTc2MDMzMzI3OTAwOTY3NTcyNjA5Njc3MzUyNDgwMjM1OTk3MjA1MDg5NTk4Mjk4MzQxOTY3Nzg0MDQyMjg2MjQ4NjMzNDA5NTI1NDY1MDgyODA2NzU2NjY2Mjg3MzY5MDk4NzgxNjg5NDgyOTA3MjA4MzI1NTU0NjgwODQzNzk5ODk0ODI2MjMzMTk4NTI4MzkzNTA1MzA4OTY1Mzc3NzMyNjI4ODQ2MTYzMzY2MjIyMjg3Njk4MjE5ODg2NzQ2NTQzNjY3NDc0NDA0MjQzMjc0MzY1MTU1MDQ4OTM0MzE0OTM5MzkxNDc5NjE5NDA0NDAwMjIyMTA1MTAxNzE0MTc0ODAwMzY4ODA4NDAxMjY0NzA4MDY4NTU2Nzc0MzIxNjIyODM1NTIyMDExNDgwNDY2MzcxNTY1OTEyMTM3MzQ1MDc0Nzg1Njk0NzY4MzQ2MzYxNjc5MjEwMTgwNjQ0NTA3MDY0ODAwMDI3NzUwMjY4NDkxNjc0NjU1MDU4Njg1NjkzNTY3MzQyMDY3MDU4MTEzNjQyOTIyNDU1NDQwNTc1ODkyNTcyNDIwODI0MTMxNDY5NTY4OTAxNjc1ODk0MDI1Njc3NjMxMTM1NjkxOTI5MjAzMzM3NjU4NzE0MTY2MDIzMDEwNTcwMzA4OTYzNDU3MjA3NTQ0MDM3MDg0NzQ2OTk0MDE2ODI2OTI4MjgwODQ4MTE4NDI4OTMxNDg0ODUyNDk0ODY0NDg3MTkyNzgwOTY3NjI3MTI3NTc3NTM5NzAyNzY2ODYwNTk1MjQ5NjcxNjY3NDE4MzQ4NTcwNDQyMjUwNzE5Nzk2NTAwNDcxNDk1MTA1MDQ5MjIxNDc3NjU2NzYzNjkzODY2Mjk3Njk3OTUyMjExMDcxODI2NDU0OTczNDc3MjY2MjQyNTcwOTQyOTMyMjU4Mjc5ODUwMjU4NTUwOTc4NTI2NTM4MzIwNzYwNjcyNjMxNzE2NDMwOTUwNTk5NTA4NzgwNzUyMzcxMDMzMzEwMTE5Nzg1NzU0NzMzMTU0MTQyMTgwODQyNzU0Mzg2MzU5MTc3ODExNzA1NDMwOTgyNzQ4MjM4NTA0NTY0ODAxOTA5NTYxMDI5OTI5MTgyNDMxODIzNzUyNTM1NzcwOTc1MDUzOTU2NTE4NzY5NzUxMDM3NDk3MDg4ODY5MjE4MDIwNTE4OTMzOTUwNzIzODUzOTIwNTE0NDYzNDE5NzI2NTI4NzI4Njk2NTExMDg2MjU3MTQ5MjE5ODg0OTk3ODc0ODg3Mzc3MTM0NTY4NjIwOTE2NzA1OCcsXHJcblxyXG4gIC8vIFBpICgxMDI1IGRpZ2l0cykuXHJcbiAgUEkgPSAnMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjA5NzQ5NDQ1OTIzMDc4MTY0MDYyODYyMDg5OTg2MjgwMzQ4MjUzNDIxMTcwNjc5ODIxNDgwODY1MTMyODIzMDY2NDcwOTM4NDQ2MDk1NTA1ODIyMzE3MjUzNTk0MDgxMjg0ODExMTc0NTAyODQxMDI3MDE5Mzg1MjExMDU1NTk2NDQ2MjI5NDg5NTQ5MzAzODE5NjQ0Mjg4MTA5NzU2NjU5MzM0NDYxMjg0NzU2NDgyMzM3ODY3ODMxNjUyNzEyMDE5MDkxNDU2NDg1NjY5MjM0NjAzNDg2MTA0NTQzMjY2NDgyMTMzOTM2MDcyNjAyNDkxNDEyNzM3MjQ1ODcwMDY2MDYzMTU1ODgxNzQ4ODE1MjA5MjA5NjI4MjkyNTQwOTE3MTUzNjQzNjc4OTI1OTAzNjAwMTEzMzA1MzA1NDg4MjA0NjY1MjEzODQxNDY5NTE5NDE1MTE2MDk0MzMwNTcyNzAzNjU3NTk1OTE5NTMwOTIxODYxMTczODE5MzI2MTE3OTMxMDUxMTg1NDgwNzQ0NjIzNzk5NjI3NDk1NjczNTE4ODU3NTI3MjQ4OTEyMjc5MzgxODMwMTE5NDkxMjk4MzM2NzMzNjI0NDA2NTY2NDMwODYwMjEzOTQ5NDYzOTUyMjQ3MzcxOTA3MDIxNzk4NjA5NDM3MDI3NzA1MzkyMTcxNzYyOTMxNzY3NTIzODQ2NzQ4MTg0Njc2Njk0MDUxMzIwMDA1NjgxMjcxNDUyNjM1NjA4Mjc3ODU3NzEzNDI3NTc3ODk2MDkxNzM2MzcxNzg3MjE0Njg0NDA5MDEyMjQ5NTM0MzAxNDY1NDk1ODUzNzEwNTA3OTIyNzk2ODkyNTg5MjM1NDIwMTk5NTYxMTIxMjkwMjE5NjA4NjQwMzQ0MTgxNTk4MTM2Mjk3NzQ3NzEzMDk5NjA1MTg3MDcyMTEzNDk5OTk5OTgzNzI5NzgwNDk5NTEwNTk3MzE3MzI4MTYwOTYzMTg1OTUwMjQ0NTk0NTUzNDY5MDgzMDI2NDI1MjIzMDgyNTMzNDQ2ODUwMzUyNjE5MzExODgxNzEwMTAwMDMxMzc4Mzg3NTI4ODY1ODc1MzMyMDgzODE0MjA2MTcxNzc2NjkxNDczMDM1OTgyNTM0OTA0Mjg3NTU0Njg3MzExNTk1NjI4NjM4ODIzNTM3ODc1OTM3NTE5NTc3ODE4NTc3ODA1MzIxNzEyMjY4MDY2MTMwMDE5Mjc4NzY2MTExOTU5MDkyMTY0MjAxOTg5MzgwOTUyNTcyMDEwNjU0ODU4NjMyNzg5JyxcclxuXHJcblxyXG4gIC8vIFRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyBvZiB0aGUgRGVjaW1hbCBjb25zdHJ1Y3Rvci5cclxuICBERUZBVUxUUyA9IHtcclxuXHJcbiAgICAvLyBUaGVzZSB2YWx1ZXMgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIHN0YXRlZCByYW5nZXMgKGluY2x1c2l2ZSkuXHJcbiAgICAvLyBNb3N0IG9mIHRoZXNlIHZhbHVlcyBjYW4gYmUgY2hhbmdlZCBhdCBydW4tdGltZSB1c2luZyB0aGUgYERlY2ltYWwuY29uZmlnYCBtZXRob2QuXHJcblxyXG4gICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIGEgY2FsY3VsYXRpb24gb3IgYmFzZSBjb252ZXJzaW9uLlxyXG4gICAgLy8gRS5nLiBgRGVjaW1hbC5jb25maWcoeyBwcmVjaXNpb246IDIwIH0pO2BcclxuICAgIHByZWNpc2lvbjogMjAsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gTUFYX0RJR0lUU1xyXG5cclxuICAgIC8vIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byBgcHJlY2lzaW9uYC5cclxuICAgIC8vXHJcbiAgICAvLyBST1VORF9VUCAgICAgICAgIDAgQXdheSBmcm9tIHplcm8uXHJcbiAgICAvLyBST1VORF9ET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxyXG4gICAgLy8gUk9VTkRfQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgLy8gUk9VTkRfRkxPT1IgICAgICAzIFRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgLy8gUk9VTkRfSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cclxuICAgIC8vIFJPVU5EX0hBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgIC8vIFJPVU5EX0hBTEZfRVZFTiAgNiBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyBldmVuIG5laWdoYm91ci5cclxuICAgIC8vIFJPVU5EX0hBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAvLyBST1VORF9IQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgLy9cclxuICAgIC8vIEUuZy5cclxuICAgIC8vIGBEZWNpbWFsLnJvdW5kaW5nID0gNDtgXHJcbiAgICAvLyBgRGVjaW1hbC5yb3VuZGluZyA9IERlY2ltYWwuUk9VTkRfSEFMRl9VUDtgXHJcbiAgICByb3VuZGluZzogNCwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDhcclxuXHJcbiAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgLy8gVGhlIHF1b3RpZW50IChxID0gYSAvIG4pIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAvLyBUaGUgcmVtYWluZGVyIChyKSBpcyBjYWxjdWxhdGVkIGFzOiByID0gYSAtIG4gKiBxLlxyXG4gICAgLy9cclxuICAgIC8vIFVQICAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgIC8vIERPV04gICAgICAgMSBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpZGVuZCAoSmF2YVNjcmlwdCAlKS5cclxuICAgIC8vIEZMT09SICAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAvLyBIQUxGX0VWRU4gIDYgVGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgIC8vIEVVQ0xJRCAgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuIEFsd2F5cyBwb3NpdGl2ZS5cclxuICAgIC8vXHJcbiAgICAvLyBUcnVuY2F0ZWQgZGl2aXNpb24gKDEpLCBmbG9vcmVkIGRpdmlzaW9uICgzKSwgdGhlIElFRUUgNzU0IHJlbWFpbmRlciAoNiksIGFuZCBFdWNsaWRpYW5cclxuICAgIC8vIGRpdmlzaW9uICg5KSBhcmUgY29tbW9ubHkgdXNlZCBmb3IgdGhlIG1vZHVsdXMgb3BlcmF0aW9uLiBUaGUgb3RoZXIgcm91bmRpbmcgbW9kZXMgY2FuIGFsc29cclxuICAgIC8vIGJlIHVzZWQsIGJ1dCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cclxuICAgIG1vZHVsbzogMSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYmVuZWF0aCB3aGljaCBgdG9TdHJpbmdgIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAvLyBKYXZhU2NyaXB0IG51bWJlcnM6IC03XHJcbiAgICB0b0V4cE5lZzogLTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1FWFBfTElNSVRcclxuXHJcbiAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIGB0b1N0cmluZ2AgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgIC8vIEphdmFTY3JpcHQgbnVtYmVyczogMjFcclxuICAgIHRvRXhwUG9zOiAgMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gRVhQX0xJTUlUXHJcblxyXG4gICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgLy8gSmF2YVNjcmlwdCBudW1iZXJzOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgbWluRTogLUVYUF9MSU1JVCwgICAgICAgICAgICAgICAgICAgICAgLy8gLTEgdG8gLUVYUF9MSU1JVFxyXG5cclxuICAgIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IHZhbHVlLCBhYm92ZSB3aGljaCBvdmVyZmxvdyB0byBJbmZpbml0eSBvY2N1cnMuXHJcbiAgICAvLyBKYXZhU2NyaXB0IG51bWJlcnM6IDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgbWF4RTogRVhQX0xJTUlULCAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBFWFBfTElNSVRcclxuXHJcbiAgICAvLyBXaGV0aGVyIHRvIHVzZSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uLCBpZiBhdmFpbGFibGUuXHJcbiAgICBjcnlwdG86IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlL2ZhbHNlXHJcbiAgfSxcclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFTkQgT0YgRURJVEFCTEUgREVGQVVMVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cclxuXHJcbiAgaW5leGFjdCwgcXVhZHJhbnQsXHJcbiAgZXh0ZXJuYWwgPSB0cnVlLFxyXG5cclxuICBkZWNpbWFsRXJyb3IgPSAnW0RlY2ltYWxFcnJvcl0gJyxcclxuICBpbnZhbGlkQXJndW1lbnQgPSBkZWNpbWFsRXJyb3IgKyAnSW52YWxpZCBhcmd1bWVudDogJyxcclxuICBwcmVjaXNpb25MaW1pdEV4Y2VlZGVkID0gZGVjaW1hbEVycm9yICsgJ1ByZWNpc2lvbiBsaW1pdCBleGNlZWRlZCcsXHJcbiAgY3J5cHRvVW5hdmFpbGFibGUgPSBkZWNpbWFsRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyxcclxuICB0YWcgPSAnW29iamVjdCBEZWNpbWFsXScsXHJcblxyXG4gIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcbiAgbWF0aHBvdyA9IE1hdGgucG93LFxyXG5cclxuICBpc0JpbmFyeSA9IC9eMGIoWzAxXSsoXFwuWzAxXSopP3xcXC5bMDFdKykocFsrLV0/XFxkKyk/JC9pLFxyXG4gIGlzSGV4ID0gL14weChbMC05YS1mXSsoXFwuWzAtOWEtZl0qKT98XFwuWzAtOWEtZl0rKShwWystXT9cXGQrKT8kL2ksXHJcbiAgaXNPY3RhbCA9IC9eMG8oWzAtN10rKFxcLlswLTddKik/fFxcLlswLTddKykocFsrLV0/XFxkKyk/JC9pLFxyXG4gIGlzRGVjaW1hbCA9IC9eKFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaSxcclxuXHJcbiAgQkFTRSA9IDFlNyxcclxuICBMT0dfQkFTRSA9IDcsXHJcbiAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXHJcblxyXG4gIExOMTBfUFJFQ0lTSU9OID0gTE4xMC5sZW5ndGggLSAxLFxyXG4gIFBJX1BSRUNJU0lPTiA9IFBJLmxlbmd0aCAtIDEsXHJcblxyXG4gIC8vIERlY2ltYWwucHJvdG90eXBlIG9iamVjdFxyXG4gIFAgPSB7IHRvU3RyaW5nVGFnOiB0YWcgfTtcclxuXHJcblxyXG4vLyBEZWNpbWFsIHByb3RvdHlwZSBtZXRob2RzXHJcblxyXG5cclxuLypcclxuICogIGFic29sdXRlVmFsdWUgICAgICAgICAgICAgYWJzXHJcbiAqICBjZWlsXHJcbiAqICBjbGFtcGVkVG8gICAgICAgICAgICAgICAgIGNsYW1wXHJcbiAqICBjb21wYXJlZFRvICAgICAgICAgICAgICAgIGNtcFxyXG4gKiAgY29zaW5lICAgICAgICAgICAgICAgICAgICBjb3NcclxuICogIGN1YmVSb290ICAgICAgICAgICAgICAgICAgY2JydFxyXG4gKiAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgICBkcFxyXG4gKiAgZGl2aWRlZEJ5ICAgICAgICAgICAgICAgICBkaXZcclxuICogIGRpdmlkZWRUb0ludGVnZXJCeSAgICAgICAgZGl2VG9JbnRcclxuICogIGVxdWFscyAgICAgICAgICAgICAgICAgICAgZXFcclxuICogIGZsb29yXHJcbiAqICBncmVhdGVyVGhhbiAgICAgICAgICAgICAgIGd0XHJcbiAqICBncmVhdGVyVGhhbk9yRXF1YWxUbyAgICAgIGd0ZVxyXG4gKiAgaHlwZXJib2xpY0Nvc2luZSAgICAgICAgICBjb3NoXHJcbiAqICBoeXBlcmJvbGljU2luZSAgICAgICAgICAgIHNpbmhcclxuICogIGh5cGVyYm9saWNUYW5nZW50ICAgICAgICAgdGFuaFxyXG4gKiAgaW52ZXJzZUNvc2luZSAgICAgICAgICAgICBhY29zXHJcbiAqICBpbnZlcnNlSHlwZXJib2xpY0Nvc2luZSAgIGFjb3NoXHJcbiAqICBpbnZlcnNlSHlwZXJib2xpY1NpbmUgICAgIGFzaW5oXHJcbiAqICBpbnZlcnNlSHlwZXJib2xpY1RhbmdlbnQgIGF0YW5oXHJcbiAqICBpbnZlcnNlU2luZSAgICAgICAgICAgICAgIGFzaW5cclxuICogIGludmVyc2VUYW5nZW50ICAgICAgICAgICAgYXRhblxyXG4gKiAgaXNGaW5pdGVcclxuICogIGlzSW50ZWdlciAgICAgICAgICAgICAgICAgaXNJbnRcclxuICogIGlzTmFOXHJcbiAqICBpc05lZ2F0aXZlICAgICAgICAgICAgICAgIGlzTmVnXHJcbiAqICBpc1Bvc2l0aXZlICAgICAgICAgICAgICAgIGlzUG9zXHJcbiAqICBpc1plcm9cclxuICogIGxlc3NUaGFuICAgICAgICAgICAgICAgICAgbHRcclxuICogIGxlc3NUaGFuT3JFcXVhbFRvICAgICAgICAgbHRlXHJcbiAqICBsb2dhcml0aG0gICAgICAgICAgICAgICAgIGxvZ1xyXG4gKiAgW21heGltdW1dICAgICAgICAgICAgICAgICBbbWF4XVxyXG4gKiAgW21pbmltdW1dICAgICAgICAgICAgICAgICBbbWluXVxyXG4gKiAgbWludXMgICAgICAgICAgICAgICAgICAgICBzdWJcclxuICogIG1vZHVsbyAgICAgICAgICAgICAgICAgICAgbW9kXHJcbiAqICBuYXR1cmFsRXhwb25lbnRpYWwgICAgICAgIGV4cFxyXG4gKiAgbmF0dXJhbExvZ2FyaXRobSAgICAgICAgICBsblxyXG4gKiAgbmVnYXRlZCAgICAgICAgICAgICAgICAgICBuZWdcclxuICogIHBsdXMgICAgICAgICAgICAgICAgICAgICAgYWRkXHJcbiAqICBwcmVjaXNpb24gICAgICAgICAgICAgICAgIHNkXHJcbiAqICByb3VuZFxyXG4gKiAgc2luZSAgICAgICAgICAgICAgICAgICAgICBzaW5cclxuICogIHNxdWFyZVJvb3QgICAgICAgICAgICAgICAgc3FydFxyXG4gKiAgdGFuZ2VudCAgICAgICAgICAgICAgICAgICB0YW5cclxuICogIHRpbWVzICAgICAgICAgICAgICAgICAgICAgbXVsXHJcbiAqICB0b0JpbmFyeVxyXG4gKiAgdG9EZWNpbWFsUGxhY2VzICAgICAgICAgICB0b0RQXHJcbiAqICB0b0V4cG9uZW50aWFsXHJcbiAqICB0b0ZpeGVkXHJcbiAqICB0b0ZyYWN0aW9uXHJcbiAqICB0b0hleGFkZWNpbWFsICAgICAgICAgICAgIHRvSGV4XHJcbiAqICB0b05lYXJlc3RcclxuICogIHRvTnVtYmVyXHJcbiAqICB0b09jdGFsXHJcbiAqICB0b1Bvd2VyICAgICAgICAgICAgICAgICAgIHBvd1xyXG4gKiAgdG9QcmVjaXNpb25cclxuICogIHRvU2lnbmlmaWNhbnREaWdpdHMgICAgICAgdG9TRFxyXG4gKiAgdG9TdHJpbmdcclxuICogIHRydW5jYXRlZCAgICAgICAgICAgICAgICAgdHJ1bmNcclxuICogIHZhbHVlT2YgICAgICAgICAgICAgICAgICAgdG9KU09OXHJcbiAqL1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqL1xyXG5QLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgeCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xyXG4gIGlmICh4LnMgPCAwKSB4LnMgPSAxO1xyXG4gIHJldHVybiBmaW5hbGlzZSh4KTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJvdW5kZWQgdG8gYSB3aG9sZSBudW1iZXIgaW4gdGhlXHJcbiAqIGRpcmVjdGlvbiBvZiBwb3NpdGl2ZSBJbmZpbml0eS5cclxuICpcclxuICovXHJcblAuY2VpbCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gZmluYWxpc2UobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyksIHRoaXMuZSArIDEsIDIpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgY2xhbXBlZCB0byB0aGUgcmFuZ2VcclxuICogZGVsaW5lYXRlZCBieSBgbWluYCBhbmQgYG1heGAuXHJcbiAqXHJcbiAqIG1pbiB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKiBtYXgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcblAuY2xhbXBlZFRvID0gUC5jbGFtcCA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xyXG4gIHZhciBrLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuICBtaW4gPSBuZXcgQ3RvcihtaW4pO1xyXG4gIG1heCA9IG5ldyBDdG9yKG1heCk7XHJcbiAgaWYgKCFtaW4ucyB8fCAhbWF4LnMpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG4gIGlmIChtaW4uZ3QobWF4KSkgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgbWF4KTtcclxuICBrID0geC5jbXAobWluKTtcclxuICByZXR1cm4gayA8IDAgPyBtaW4gOiB4LmNtcChtYXgpID4gMCA/IG1heCA6IG5ldyBDdG9yKHgpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVyblxyXG4gKiAgIDEgICAgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIGB5YCxcclxuICogIC0xICAgIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBgeWAsXHJcbiAqICAgMCAgICBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUsXHJcbiAqICAgTmFOICBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIERlY2ltYWwgaXMgTmFOLlxyXG4gKlxyXG4gKi9cclxuUC5jb21wYXJlZFRvID0gUC5jbXAgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBpLCBqLCB4ZEwsIHlkTCxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgeGQgPSB4LmQsXHJcbiAgICB5ZCA9ICh5ID0gbmV3IHguY29uc3RydWN0b3IoeSkpLmQsXHJcbiAgICB4cyA9IHgucyxcclxuICAgIHlzID0geS5zO1xyXG5cclxuICAvLyBFaXRoZXIgTmFOIG9yIMKxSW5maW5pdHk/XHJcbiAgaWYgKCF4ZCB8fCAheWQpIHtcclxuICAgIHJldHVybiAheHMgfHwgIXlzID8gTmFOIDogeHMgIT09IHlzID8geHMgOiB4ZCA9PT0geWQgPyAwIDogIXhkIF4geHMgPCAwID8gMSA6IC0xO1xyXG4gIH1cclxuXHJcbiAgLy8gRWl0aGVyIHplcm8/XHJcbiAgaWYgKCF4ZFswXSB8fCAheWRbMF0pIHJldHVybiB4ZFswXSA/IHhzIDogeWRbMF0gPyAteXMgOiAwO1xyXG5cclxuICAvLyBTaWducyBkaWZmZXI/XHJcbiAgaWYgKHhzICE9PSB5cykgcmV0dXJuIHhzO1xyXG5cclxuICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICBpZiAoeC5lICE9PSB5LmUpIHJldHVybiB4LmUgPiB5LmUgXiB4cyA8IDAgPyAxIDogLTE7XHJcblxyXG4gIHhkTCA9IHhkLmxlbmd0aDtcclxuICB5ZEwgPSB5ZC5sZW5ndGg7XHJcblxyXG4gIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgZm9yIChpID0gMCwgaiA9IHhkTCA8IHlkTCA/IHhkTCA6IHlkTDsgaSA8IGo7ICsraSkge1xyXG4gICAgaWYgKHhkW2ldICE9PSB5ZFtpXSkgcmV0dXJuIHhkW2ldID4geWRbaV0gXiB4cyA8IDAgPyAxIDogLTE7XHJcbiAgfVxyXG5cclxuICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgcmV0dXJuIHhkTCA9PT0geWRMID8gMCA6IHhkTCA+IHlkTCBeIHhzIDwgMCA/IDEgOiAtMTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgY29zaW5lIG9mIHRoZSB2YWx1ZSBpbiByYWRpYW5zIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICogUmFuZ2U6IFstMSwgMV1cclxuICpcclxuICogY29zKDApICAgICAgICAgPSAxXHJcbiAqIGNvcygtMCkgICAgICAgID0gMVxyXG4gKiBjb3MoSW5maW5pdHkpICA9IE5hTlxyXG4gKiBjb3MoLUluZmluaXR5KSA9IE5hTlxyXG4gKiBjb3MoTmFOKSAgICAgICA9IE5hTlxyXG4gKlxyXG4gKi9cclxuUC5jb3NpbmUgPSBQLmNvcyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcHIsIHJtLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKCF4LmQpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG5cclxuICAvLyBjb3MoMCkgPSBjb3MoLTApID0gMVxyXG4gIGlmICgheC5kWzBdKSByZXR1cm4gbmV3IEN0b3IoMSk7XHJcblxyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyBMT0dfQkFTRTtcclxuICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgeCA9IGNvc2luZShDdG9yLCB0b0xlc3NUaGFuSGFsZlBpKEN0b3IsIHgpKTtcclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZShxdWFkcmFudCA9PSAyIHx8IHF1YWRyYW50ID09IDMgPyB4Lm5lZygpIDogeCwgcHIsIHJtLCB0cnVlKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgY3ViZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwsIHJvdW5kZWQgdG9cclxuICogYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogIGNicnQoMCkgID0gIDBcclxuICogIGNicnQoLTApID0gLTBcclxuICogIGNicnQoMSkgID0gIDFcclxuICogIGNicnQoLTEpID0gLTFcclxuICogIGNicnQoTikgID0gIE5cclxuICogIGNicnQoLUkpID0gLUlcclxuICogIGNicnQoSSkgID0gIElcclxuICpcclxuICogTWF0aC5jYnJ0KHgpID0gKHggPCAwID8gLU1hdGgucG93KC14LCAxLzMpIDogTWF0aC5wb3coeCwgMS8zKSlcclxuICpcclxuICovXHJcblAuY3ViZVJvb3QgPSBQLmNicnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGUsIG0sIG4sIHIsIHJlcCwgcywgc2QsIHQsIHQzLCB0M3BsdXN4LFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKCF4LmlzRmluaXRlKCkgfHwgeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgcyA9IHgucyAqIG1hdGhwb3coeC5zICogeCwgMSAvIDMpO1xyXG5cclxuICAgLy8gTWF0aC5jYnJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgLy8gUGFzcyB4IHRvIE1hdGgucG93IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gIGlmICghcyB8fCBNYXRoLmFicyhzKSA9PSAxIC8gMCkge1xyXG4gICAgbiA9IGRpZ2l0c1RvU3RyaW5nKHguZCk7XHJcbiAgICBlID0geC5lO1xyXG5cclxuICAgIC8vIEFkanVzdCBuIGV4cG9uZW50IHNvIGl0IGlzIGEgbXVsdGlwbGUgb2YgMyBhd2F5IGZyb20geCBleHBvbmVudC5cclxuICAgIGlmIChzID0gKGUgLSBuLmxlbmd0aCArIDEpICUgMykgbiArPSAocyA9PSAxIHx8IHMgPT0gLTIgPyAnMCcgOiAnMDAnKTtcclxuICAgIHMgPSBtYXRocG93KG4sIDEgLyAzKTtcclxuXHJcbiAgICAvLyBSYXJlbHksIGUgbWF5IGJlIG9uZSBsZXNzIHRoYW4gdGhlIHJlc3VsdCBleHBvbmVudCB2YWx1ZS5cclxuICAgIGUgPSBtYXRoZmxvb3IoKGUgKyAxKSAvIDMpIC0gKGUgJSAzID09IChlIDwgMCA/IC0xIDogMikpO1xyXG5cclxuICAgIGlmIChzID09IDEgLyAwKSB7XHJcbiAgICAgIG4gPSAnNWUnICsgZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKCdlJykgKyAxKSArIGU7XHJcbiAgICB9XHJcblxyXG4gICAgciA9IG5ldyBDdG9yKG4pO1xyXG4gICAgci5zID0geC5zO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByID0gbmV3IEN0b3Iocy50b1N0cmluZygpKTtcclxuICB9XHJcblxyXG4gIHNkID0gKGUgPSBDdG9yLnByZWNpc2lvbikgKyAzO1xyXG5cclxuICAvLyBIYWxsZXkncyBtZXRob2QuXHJcbiAgLy8gVE9ETz8gQ29tcGFyZSBOZXd0b24ncyBtZXRob2QuXHJcbiAgZm9yICg7Oykge1xyXG4gICAgdCA9IHI7XHJcbiAgICB0MyA9IHQudGltZXModCkudGltZXModCk7XHJcbiAgICB0M3BsdXN4ID0gdDMucGx1cyh4KTtcclxuICAgIHIgPSBkaXZpZGUodDNwbHVzeC5wbHVzKHgpLnRpbWVzKHQpLCB0M3BsdXN4LnBsdXModDMpLCBzZCArIDIsIDEpO1xyXG5cclxuICAgIC8vIFRPRE8/IFJlcGxhY2Ugd2l0aCBmb3ItbG9vcCBhbmQgY2hlY2tSb3VuZGluZ0RpZ2l0cy5cclxuICAgIGlmIChkaWdpdHNUb1N0cmluZyh0LmQpLnNsaWNlKDAsIHNkKSA9PT0gKG4gPSBkaWdpdHNUb1N0cmluZyhyLmQpKS5zbGljZSgwLCBzZCkpIHtcclxuICAgICAgbiA9IG4uc2xpY2Uoc2QgLSAzLCBzZCArIDEpO1xyXG5cclxuICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzIGFyZSA5OTk5IG9yIDQ5OTlcclxuICAgICAgLy8gLCBpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnksIGNvbnRpbnVlIHRoZSBpdGVyYXRpb24uXHJcbiAgICAgIGlmIChuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknKSB7XHJcblxyXG4gICAgICAgIC8vIE9uIHRoZSBmaXJzdCBpdGVyYXRpb24gb25seSwgY2hlY2sgdG8gc2VlIGlmIHJvdW5kaW5nIHVwIGdpdmVzIHRoZSBleGFjdCByZXN1bHQgYXMgdGhlXHJcbiAgICAgICAgLy8gbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgIGlmICghcmVwKSB7XHJcbiAgICAgICAgICBmaW5hbGlzZSh0LCBlICsgMSwgMCk7XHJcblxyXG4gICAgICAgICAgaWYgKHQudGltZXModCkudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2QgKz0gNDtcclxuICAgICAgICByZXAgPSAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGFuIGV4YWN0IHJlc3VsdC5cclxuICAgICAgICAvLyBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgIGZpbmFsaXNlKHIsIGUgKyAxLCAxKTtcclxuICAgICAgICAgIG0gPSAhci50aW1lcyhyKS50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZShyLCBlLCBDdG9yLnJvdW5kaW5nLCBtKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKi9cclxuUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgdyxcclxuICAgIGQgPSB0aGlzLmQsXHJcbiAgICBuID0gTmFOO1xyXG5cclxuICBpZiAoZCkge1xyXG4gICAgdyA9IGQubGVuZ3RoIC0gMTtcclxuICAgIG4gPSAodyAtIG1hdGhmbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCB3b3JkLlxyXG4gICAgdyA9IGRbd107XHJcbiAgICBpZiAodykgZm9yICg7IHcgJSAxMCA9PSAwOyB3IC89IDEwKSBuLS07XHJcbiAgICBpZiAobiA8IDApIG4gPSAwO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG47XHJcbn07XHJcblxyXG5cclxuLypcclxuICogIG4gLyAwID0gSVxyXG4gKiAgbiAvIE4gPSBOXHJcbiAqICBuIC8gSSA9IDBcclxuICogIDAgLyBuID0gMFxyXG4gKiAgMCAvIDAgPSBOXHJcbiAqICAwIC8gTiA9IE5cclxuICogIDAgLyBJID0gMFxyXG4gKiAgTiAvIG4gPSBOXHJcbiAqICBOIC8gMCA9IE5cclxuICogIE4gLyBOID0gTlxyXG4gKiAgTiAvIEkgPSBOXHJcbiAqICBJIC8gbiA9IElcclxuICogIEkgLyAwID0gSVxyXG4gKiAgSSAvIE4gPSBOXHJcbiAqICBJIC8gSSA9IE5cclxuICpcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBkaXZpZGVkIGJ5IGB5YCwgcm91bmRlZCB0b1xyXG4gKiBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKi9cclxuUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgcmV0dXJuIGRpdmlkZSh0aGlzLCBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih5KSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGludGVnZXIgcGFydCBvZiBkaXZpZGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsXHJcbiAqIGJ5IHRoZSB2YWx1ZSBvZiBgeWAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICovXHJcblAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5kaXZUb0ludCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcbiAgcmV0dXJuIGZpbmFsaXNlKGRpdmlkZSh4LCBuZXcgQ3Rvcih5KSwgMCwgMSwgMSksIEN0b3IucHJlY2lzaW9uLCBDdG9yLnJvdW5kaW5nKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBgeWAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmVxdWFscyA9IFAuZXEgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiB0aGlzLmNtcCh5KSA9PT0gMDtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJvdW5kZWQgdG8gYSB3aG9sZSBudW1iZXIgaW4gdGhlXHJcbiAqIGRpcmVjdGlvbiBvZiBuZWdhdGl2ZSBJbmZpbml0eS5cclxuICpcclxuICovXHJcblAuZmxvb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCB0aGlzLmUgKyAxLCAzKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgYHlgLCBvdGhlcndpc2UgcmV0dXJuXHJcbiAqIGZhbHNlLlxyXG4gKlxyXG4gKi9cclxuUC5ncmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiB0aGlzLmNtcCh5KSA+IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIGB5YCxcclxuICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICpcclxuICovXHJcblAuZ3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIGsgPSB0aGlzLmNtcCh5KTtcclxuICByZXR1cm4gayA9PSAxIHx8IGsgPT09IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGh5cGVyYm9saWMgY29zaW5lIG9mIHRoZSB2YWx1ZSBpbiByYWRpYW5zIG9mIHRoaXNcclxuICogRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICogUmFuZ2U6IFsxLCBJbmZpbml0eV1cclxuICpcclxuICogY29zaCh4KSA9IDEgKyB4XjIvMiEgKyB4XjQvNCEgKyB4XjYvNiEgKyAuLi5cclxuICpcclxuICogY29zaCgwKSAgICAgICAgID0gMVxyXG4gKiBjb3NoKC0wKSAgICAgICAgPSAxXHJcbiAqIGNvc2goSW5maW5pdHkpICA9IEluZmluaXR5XHJcbiAqIGNvc2goLUluZmluaXR5KSA9IEluZmluaXR5XHJcbiAqIGNvc2goTmFOKSAgICAgICA9IE5hTlxyXG4gKlxyXG4gKiAgeCAgICAgICAgdGltZSB0YWtlbiAobXMpICAgcmVzdWx0XHJcbiAqIDEwMDAgICAgICA5ICAgICAgICAgICAgICAgICA5Ljg1MDM1NTU3MDA4NTIzNDk2OTRlKzQzM1xyXG4gKiAxMDAwMCAgICAgMjUgICAgICAgICAgICAgICAgNC40MDM0MDkxMTI4MzE0NjA3OTM2ZSs0MzQyXHJcbiAqIDEwMDAwMCAgICAxNzEgICAgICAgICAgICAgICAxLjQwMzMzMTY4MDIxMzA2MTU4OTdlKzQzNDI5XHJcbiAqIDEwMDAwMDAgICAzODE3ICAgICAgICAgICAgICAxLjUxNjYwNzY5ODQwMTA0Mzc3MjVlKzQzNDI5NFxyXG4gKiAxMDAwMDAwMCAgYWJhbmRvbmVkIGFmdGVyIDIgbWludXRlIHdhaXRcclxuICpcclxuICogVE9ETz8gQ29tcGFyZSBwZXJmb3JtYW5jZSBvZiBjb3NoKHgpID0gMC41ICogKGV4cCh4KSArIGV4cCgteCkpXHJcbiAqXHJcbiAqL1xyXG5QLmh5cGVyYm9saWNDb3NpbmUgPSBQLmNvc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGssIG4sIHByLCBybSwgbGVuLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgIG9uZSA9IG5ldyBDdG9yKDEpO1xyXG5cclxuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKHgucyA/IDEgLyAwIDogTmFOKTtcclxuICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIG9uZTtcclxuXHJcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KHguZSwgeC5zZCgpKSArIDQ7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcbiAgbGVuID0geC5kLmxlbmd0aDtcclxuXHJcbiAgLy8gQXJndW1lbnQgcmVkdWN0aW9uOiBjb3MoNHgpID0gMSAtIDhjb3NeMih4KSArIDhjb3NeNCh4KSArIDFcclxuICAvLyBpLmUuIGNvcyh4KSA9IDEgLSBjb3NeMih4LzQpKDggLSA4Y29zXjIoeC80KSlcclxuXHJcbiAgLy8gRXN0aW1hdGUgdGhlIG9wdGltdW0gbnVtYmVyIG9mIHRpbWVzIHRvIHVzZSB0aGUgYXJndW1lbnQgcmVkdWN0aW9uLlxyXG4gIC8vIFRPRE8/IEVzdGltYXRpb24gcmV1c2VkIGZyb20gY29zaW5lKCkgYW5kIG1heSBub3QgYmUgb3B0aW1hbCBoZXJlLlxyXG4gIGlmIChsZW4gPCAzMikge1xyXG4gICAgayA9IE1hdGguY2VpbChsZW4gLyAzKTtcclxuICAgIG4gPSAoMSAvIHRpbnlQb3coNCwgaykpLnRvU3RyaW5nKCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGsgPSAxNjtcclxuICAgIG4gPSAnMi4zMjgzMDY0MzY1Mzg2OTYyODkwNjI1ZS0xMCc7XHJcbiAgfVxyXG5cclxuICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDEsIHgudGltZXMobiksIG5ldyBDdG9yKDEpLCB0cnVlKTtcclxuXHJcbiAgLy8gUmV2ZXJzZSBhcmd1bWVudCByZWR1Y3Rpb25cclxuICB2YXIgY29zaDJfeCxcclxuICAgIGkgPSBrLFxyXG4gICAgZDggPSBuZXcgQ3Rvcig4KTtcclxuICBmb3IgKDsgaS0tOykge1xyXG4gICAgY29zaDJfeCA9IHgudGltZXMoeCk7XHJcbiAgICB4ID0gb25lLm1pbnVzKGNvc2gyX3gudGltZXMoZDgubWludXMoY29zaDJfeC50aW1lcyhkOCkpKSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmluYWxpc2UoeCwgQ3Rvci5wcmVjaXNpb24gPSBwciwgQ3Rvci5yb3VuZGluZyA9IHJtLCB0cnVlKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaHlwZXJib2xpYyBzaW5lIG9mIHRoZSB2YWx1ZSBpbiByYWRpYW5zIG9mIHRoaXNcclxuICogRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICogUmFuZ2U6IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gKlxyXG4gKiBzaW5oKHgpID0geCArIHheMy8zISArIHheNS81ISArIHheNy83ISArIC4uLlxyXG4gKlxyXG4gKiBzaW5oKDApICAgICAgICAgPSAwXHJcbiAqIHNpbmgoLTApICAgICAgICA9IC0wXHJcbiAqIHNpbmgoSW5maW5pdHkpICA9IEluZmluaXR5XHJcbiAqIHNpbmgoLUluZmluaXR5KSA9IC1JbmZpbml0eVxyXG4gKiBzaW5oKE5hTikgICAgICAgPSBOYU5cclxuICpcclxuICogeCAgICAgICAgdGltZSB0YWtlbiAobXMpXHJcbiAqIDEwICAgICAgIDIgbXNcclxuICogMTAwICAgICAgNSBtc1xyXG4gKiAxMDAwICAgICAxNCBtc1xyXG4gKiAxMDAwMCAgICA4MiBtc1xyXG4gKiAxMDAwMDAgICA4ODYgbXMgICAgICAgICAgICAxLjQwMzMzMTY4MDIxMzA2MTU4OTdlKzQzNDI5XHJcbiAqIDIwMDAwMCAgIDI2MTMgbXNcclxuICogMzAwMDAwICAgNTQwNyBtc1xyXG4gKiA0MDAwMDAgICA4ODI0IG1zXHJcbiAqIDUwMDAwMCAgIDEzMDI2IG1zICAgICAgICAgIDguNzA4MDY0MzYxMjcxODA4NDEyOWUrMjE3MTQ2XHJcbiAqIDEwMDAwMDAgIDQ4NTQzIG1zXHJcbiAqXHJcbiAqIFRPRE8/IENvbXBhcmUgcGVyZm9ybWFuY2Ugb2Ygc2luaCh4KSA9IDAuNSAqIChleHAoeCkgLSBleHAoLXgpKVxyXG4gKlxyXG4gKi9cclxuUC5oeXBlcmJvbGljU2luZSA9IFAuc2luaCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaywgcHIsIHJtLCBsZW4sXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICBpZiAoIXguaXNGaW5pdGUoKSB8fCB4LmlzWmVybygpKSByZXR1cm4gbmV3IEN0b3IoeCk7XHJcblxyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyA0O1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG4gIGxlbiA9IHguZC5sZW5ndGg7XHJcblxyXG4gIGlmIChsZW4gPCAzKSB7XHJcbiAgICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgsIHRydWUpO1xyXG4gIH0gZWxzZSB7XHJcblxyXG4gICAgLy8gQWx0ZXJuYXRpdmUgYXJndW1lbnQgcmVkdWN0aW9uOiBzaW5oKDN4KSA9IHNpbmgoeCkoMyArIDRzaW5oXjIoeCkpXHJcbiAgICAvLyBpLmUuIHNpbmgoeCkgPSBzaW5oKHgvMykoMyArIDRzaW5oXjIoeC8zKSlcclxuICAgIC8vIDMgbXVsdGlwbGljYXRpb25zIGFuZCAxIGFkZGl0aW9uXHJcblxyXG4gICAgLy8gQXJndW1lbnQgcmVkdWN0aW9uOiBzaW5oKDV4KSA9IHNpbmgoeCkoNSArIHNpbmheMih4KSgyMCArIDE2c2luaF4yKHgpKSlcclxuICAgIC8vIGkuZS4gc2luaCh4KSA9IHNpbmgoeC81KSg1ICsgc2luaF4yKHgvNSkoMjAgKyAxNnNpbmheMih4LzUpKSlcclxuICAgIC8vIDQgbXVsdGlwbGljYXRpb25zIGFuZCAyIGFkZGl0aW9uc1xyXG5cclxuICAgIC8vIEVzdGltYXRlIHRoZSBvcHRpbXVtIG51bWJlciBvZiB0aW1lcyB0byB1c2UgdGhlIGFyZ3VtZW50IHJlZHVjdGlvbi5cclxuICAgIGsgPSAxLjQgKiBNYXRoLnNxcnQobGVuKTtcclxuICAgIGsgPSBrID4gMTYgPyAxNiA6IGsgfCAwO1xyXG5cclxuICAgIHggPSB4LnRpbWVzKDEgLyB0aW55UG93KDUsIGspKTtcclxuICAgIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCwgdHJ1ZSk7XHJcblxyXG4gICAgLy8gUmV2ZXJzZSBhcmd1bWVudCByZWR1Y3Rpb25cclxuICAgIHZhciBzaW5oMl94LFxyXG4gICAgICBkNSA9IG5ldyBDdG9yKDUpLFxyXG4gICAgICBkMTYgPSBuZXcgQ3RvcigxNiksXHJcbiAgICAgIGQyMCA9IG5ldyBDdG9yKDIwKTtcclxuICAgIGZvciAoOyBrLS07KSB7XHJcbiAgICAgIHNpbmgyX3ggPSB4LnRpbWVzKHgpO1xyXG4gICAgICB4ID0geC50aW1lcyhkNS5wbHVzKHNpbmgyX3gudGltZXMoZDE2LnRpbWVzKHNpbmgyX3gpLnBsdXMoZDIwKSkpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICByZXR1cm4gZmluYWxpc2UoeCwgcHIsIHJtLCB0cnVlKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaHlwZXJib2xpYyB0YW5nZW50IG9mIHRoZSB2YWx1ZSBpbiByYWRpYW5zIG9mIHRoaXNcclxuICogRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICogUmFuZ2U6IFstMSwgMV1cclxuICpcclxuICogdGFuaCh4KSA9IHNpbmgoeCkgLyBjb3NoKHgpXHJcbiAqXHJcbiAqIHRhbmgoMCkgICAgICAgICA9IDBcclxuICogdGFuaCgtMCkgICAgICAgID0gLTBcclxuICogdGFuaChJbmZpbml0eSkgID0gMVxyXG4gKiB0YW5oKC1JbmZpbml0eSkgPSAtMVxyXG4gKiB0YW5oKE5hTikgICAgICAgPSBOYU5cclxuICpcclxuICovXHJcblAuaHlwZXJib2xpY1RhbmdlbnQgPSBQLnRhbmggPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHByLCBybSxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmICgheC5pc0Zpbml0ZSgpKSByZXR1cm4gbmV3IEN0b3IoeC5zKTtcclxuICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgNztcclxuICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgcmV0dXJuIGRpdmlkZSh4LnNpbmgoKSwgeC5jb3NoKCksIEN0b3IucHJlY2lzaW9uID0gcHIsIEN0b3Iucm91bmRpbmcgPSBybSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGFyY2Nvc2luZSAoaW52ZXJzZSBjb3NpbmUpIGluIHJhZGlhbnMgb2YgdGhlIHZhbHVlIG9mXHJcbiAqIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLTEsIDFdXHJcbiAqIFJhbmdlOiBbMCwgcGldXHJcbiAqXHJcbiAqIGFjb3MoeCkgPSBwaS8yIC0gYXNpbih4KVxyXG4gKlxyXG4gKiBhY29zKDApICAgICAgID0gcGkvMlxyXG4gKiBhY29zKC0wKSAgICAgID0gcGkvMlxyXG4gKiBhY29zKDEpICAgICAgID0gMFxyXG4gKiBhY29zKC0xKSAgICAgID0gcGlcclxuICogYWNvcygxLzIpICAgICA9IHBpLzNcclxuICogYWNvcygtMS8yKSAgICA9IDIqcGkvM1xyXG4gKiBhY29zKHx4fCA+IDEpID0gTmFOXHJcbiAqIGFjb3MoTmFOKSAgICAgPSBOYU5cclxuICpcclxuICovXHJcblAuaW52ZXJzZUNvc2luZSA9IFAuYWNvcyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaGFsZlBpLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgIGsgPSB4LmFicygpLmNtcCgxKSxcclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb24sXHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcblxyXG4gIGlmIChrICE9PSAtMSkge1xyXG4gICAgcmV0dXJuIGsgPT09IDBcclxuICAgICAgLy8gfHh8IGlzIDFcclxuICAgICAgPyB4LmlzTmVnKCkgPyBnZXRQaShDdG9yLCBwciwgcm0pIDogbmV3IEN0b3IoMClcclxuICAgICAgLy8gfHh8ID4gMSBvciB4IGlzIE5hTlxyXG4gICAgICA6IG5ldyBDdG9yKE5hTik7XHJcbiAgfVxyXG5cclxuICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XHJcblxyXG4gIC8vIFRPRE8/IFNwZWNpYWwgY2FzZSBhY29zKDAuNSkgPSBwaS8zIGFuZCBhY29zKC0wLjUpID0gMipwaS8zXHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyA2O1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICB4ID0geC5hc2luKCk7XHJcbiAgaGFsZlBpID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC41KTtcclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gIHJldHVybiBoYWxmUGkubWludXMoeCk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGludmVyc2Ugb2YgdGhlIGh5cGVyYm9saWMgY29zaW5lIGluIHJhZGlhbnMgb2YgdGhlXHJcbiAqIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbMSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbMCwgSW5maW5pdHldXHJcbiAqXHJcbiAqIGFjb3NoKHgpID0gbG4oeCArIHNxcnQoeF4yIC0gMSkpXHJcbiAqXHJcbiAqIGFjb3NoKHggPCAxKSAgICAgPSBOYU5cclxuICogYWNvc2goTmFOKSAgICAgICA9IE5hTlxyXG4gKiBhY29zaChJbmZpbml0eSkgID0gSW5maW5pdHlcclxuICogYWNvc2goLUluZmluaXR5KSA9IE5hTlxyXG4gKiBhY29zaCgwKSAgICAgICAgID0gTmFOXHJcbiAqIGFjb3NoKC0wKSAgICAgICAgPSBOYU5cclxuICogYWNvc2goMSkgICAgICAgICA9IDBcclxuICogYWNvc2goLTEpICAgICAgICA9IE5hTlxyXG4gKlxyXG4gKi9cclxuUC5pbnZlcnNlSHlwZXJib2xpY0Nvc2luZSA9IFAuYWNvc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHByLCBybSxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmICh4Lmx0ZSgxKSkgcmV0dXJuIG5ldyBDdG9yKHguZXEoMSkgPyAwIDogTmFOKTtcclxuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoTWF0aC5hYnMoeC5lKSwgeC5zZCgpKSArIDQ7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgeCA9IHgudGltZXMoeCkubWludXMoMSkuc3FydCgpLnBsdXMoeCk7XHJcblxyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgcmV0dXJuIHgubG4oKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaHlwZXJib2xpYyBzaW5lIGluIHJhZGlhbnMgb2YgdGhlIHZhbHVlXHJcbiAqIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICogUmFuZ2U6IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gKlxyXG4gKiBhc2luaCh4KSA9IGxuKHggKyBzcXJ0KHheMiArIDEpKVxyXG4gKlxyXG4gKiBhc2luaChOYU4pICAgICAgID0gTmFOXHJcbiAqIGFzaW5oKEluZmluaXR5KSAgPSBJbmZpbml0eVxyXG4gKiBhc2luaCgtSW5maW5pdHkpID0gLUluZmluaXR5XHJcbiAqIGFzaW5oKDApICAgICAgICAgPSAwXHJcbiAqIGFzaW5oKC0wKSAgICAgICAgPSAtMFxyXG4gKlxyXG4gKi9cclxuUC5pbnZlcnNlSHlwZXJib2xpY1NpbmUgPSBQLmFzaW5oID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBwciwgcm0sXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICBpZiAoIXguaXNGaW5pdGUoKSB8fCB4LmlzWmVybygpKSByZXR1cm4gbmV3IEN0b3IoeCk7XHJcblxyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyAyICogTWF0aC5tYXgoTWF0aC5hYnMoeC5lKSwgeC5zZCgpKSArIDY7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgeCA9IHgudGltZXMoeCkucGx1cygxKS5zcXJ0KCkucGx1cyh4KTtcclxuXHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICByZXR1cm4geC5sbigpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBpbnZlcnNlIG9mIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgaW4gcmFkaWFucyBvZiB0aGVcclxuICogdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKiBEb21haW46IFstMSwgMV1cclxuICogUmFuZ2U6IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gKlxyXG4gKiBhdGFuaCh4KSA9IDAuNSAqIGxuKCgxICsgeCkgLyAoMSAtIHgpKVxyXG4gKlxyXG4gKiBhdGFuaCh8eHwgPiAxKSAgID0gTmFOXHJcbiAqIGF0YW5oKE5hTikgICAgICAgPSBOYU5cclxuICogYXRhbmgoSW5maW5pdHkpICA9IE5hTlxyXG4gKiBhdGFuaCgtSW5maW5pdHkpID0gTmFOXHJcbiAqIGF0YW5oKDApICAgICAgICAgPSAwXHJcbiAqIGF0YW5oKC0wKSAgICAgICAgPSAtMFxyXG4gKiBhdGFuaCgxKSAgICAgICAgID0gSW5maW5pdHlcclxuICogYXRhbmgoLTEpICAgICAgICA9IC1JbmZpbml0eVxyXG4gKlxyXG4gKi9cclxuUC5pbnZlcnNlSHlwZXJib2xpY1RhbmdlbnQgPSBQLmF0YW5oID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBwciwgcm0sIHdwciwgeHNkLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG4gIGlmICh4LmUgPj0gMCkgcmV0dXJuIG5ldyBDdG9yKHguYWJzKCkuZXEoMSkgPyB4LnMgLyAwIDogeC5pc1plcm8oKSA/IHggOiBOYU4pO1xyXG5cclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICB4c2QgPSB4LnNkKCk7XHJcblxyXG4gIGlmIChNYXRoLm1heCh4c2QsIHByKSA8IDIgKiAteC5lIC0gMSkgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBwciwgcm0sIHRydWUpO1xyXG5cclxuICBDdG9yLnByZWNpc2lvbiA9IHdwciA9IHhzZCAtIHguZTtcclxuXHJcbiAgeCA9IGRpdmlkZSh4LnBsdXMoMSksIG5ldyBDdG9yKDEpLm1pbnVzKHgpLCB3cHIgKyBwciwgMSk7XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyA0O1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICB4ID0geC5sbigpO1xyXG5cclxuICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgcmV0dXJuIHgudGltZXMoMC41KTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjc2luZSAoaW52ZXJzZSBzaW5lKSBpbiByYWRpYW5zIG9mIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAqIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbLXBpLzIsIHBpLzJdXHJcbiAqXHJcbiAqIGFzaW4oeCkgPSAyKmF0YW4oeC8oMSArIHNxcnQoMSAtIHheMikpKVxyXG4gKlxyXG4gKiBhc2luKDApICAgICAgID0gMFxyXG4gKiBhc2luKC0wKSAgICAgID0gLTBcclxuICogYXNpbigxLzIpICAgICA9IHBpLzZcclxuICogYXNpbigtMS8yKSAgICA9IC1waS82XHJcbiAqIGFzaW4oMSkgICAgICAgPSBwaS8yXHJcbiAqIGFzaW4oLTEpICAgICAgPSAtcGkvMlxyXG4gKiBhc2luKHx4fCA+IDEpID0gTmFOXHJcbiAqIGFzaW4oTmFOKSAgICAgPSBOYU5cclxuICpcclxuICogVE9ETz8gQ29tcGFyZSBwZXJmb3JtYW5jZSBvZiBUYXlsb3Igc2VyaWVzLlxyXG4gKlxyXG4gKi9cclxuUC5pbnZlcnNlU2luZSA9IFAuYXNpbiA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaGFsZlBpLCBrLFxyXG4gICAgcHIsIHJtLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgayA9IHguYWJzKCkuY21wKDEpO1xyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICBpZiAoayAhPT0gLTEpIHtcclxuXHJcbiAgICAvLyB8eHwgaXMgMVxyXG4gICAgaWYgKGsgPT09IDApIHtcclxuICAgICAgaGFsZlBpID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC41KTtcclxuICAgICAgaGFsZlBpLnMgPSB4LnM7XHJcbiAgICAgIHJldHVybiBoYWxmUGk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gfHh8ID4gMSBvciB4IGlzIE5hTlxyXG4gICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPPyBTcGVjaWFsIGNhc2UgYXNpbigxLzIpID0gcGkvNiBhbmQgYXNpbigtMS8yKSA9IC1waS82XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyA2O1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICB4ID0geC5kaXYobmV3IEN0b3IoMSkubWludXMoeC50aW1lcyh4KSkuc3FydCgpLnBsdXMoMSkpLmF0YW4oKTtcclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gIHJldHVybiB4LnRpbWVzKDIpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmN0YW5nZW50IChpbnZlcnNlIHRhbmdlbnQpIGluIHJhZGlhbnMgb2YgdGhlIHZhbHVlXHJcbiAqIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICogUmFuZ2U6IFstcGkvMiwgcGkvMl1cclxuICpcclxuICogYXRhbih4KSA9IHggLSB4XjMvMyArIHheNS81IC0geF43LzcgKyAuLi5cclxuICpcclxuICogYXRhbigwKSAgICAgICAgID0gMFxyXG4gKiBhdGFuKC0wKSAgICAgICAgPSAtMFxyXG4gKiBhdGFuKDEpICAgICAgICAgPSBwaS80XHJcbiAqIGF0YW4oLTEpICAgICAgICA9IC1waS80XHJcbiAqIGF0YW4oSW5maW5pdHkpICA9IHBpLzJcclxuICogYXRhbigtSW5maW5pdHkpID0gLXBpLzJcclxuICogYXRhbihOYU4pICAgICAgID0gTmFOXHJcbiAqXHJcbiAqL1xyXG5QLmludmVyc2VUYW5nZW50ID0gUC5hdGFuID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBpLCBqLCBrLCBuLCBweCwgdCwgciwgd3ByLCB4MixcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uLFxyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICBpZiAoIXguaXNGaW5pdGUoKSkge1xyXG4gICAgaWYgKCF4LnMpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG4gICAgaWYgKHByICsgNCA8PSBQSV9QUkVDSVNJT04pIHtcclxuICAgICAgciA9IGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XHJcbiAgICAgIHIucyA9IHgucztcclxuICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICh4LmlzWmVybygpKSB7XHJcbiAgICByZXR1cm4gbmV3IEN0b3IoeCk7XHJcbiAgfSBlbHNlIGlmICh4LmFicygpLmVxKDEpICYmIHByICsgNCA8PSBQSV9QUkVDSVNJT04pIHtcclxuICAgIHIgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjI1KTtcclxuICAgIHIucyA9IHgucztcclxuICAgIHJldHVybiByO1xyXG4gIH1cclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgPSBwciArIDEwO1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICAvLyBUT0RPPyBpZiAoeCA+PSAxICYmIHByIDw9IFBJX1BSRUNJU0lPTikgYXRhbih4KSA9IGhhbGZQaSAqIHgucyAtIGF0YW4oMSAvIHgpO1xyXG5cclxuICAvLyBBcmd1bWVudCByZWR1Y3Rpb25cclxuICAvLyBFbnN1cmUgfHh8IDwgMC40MlxyXG4gIC8vIGF0YW4oeCkgPSAyICogYXRhbih4IC8gKDEgKyBzcXJ0KDEgKyB4XjIpKSlcclxuXHJcbiAgayA9IE1hdGgubWluKDI4LCB3cHIgLyBMT0dfQkFTRSArIDIgfCAwKTtcclxuXHJcbiAgZm9yIChpID0gazsgaTsgLS1pKSB4ID0geC5kaXYoeC50aW1lcyh4KS5wbHVzKDEpLnNxcnQoKS5wbHVzKDEpKTtcclxuXHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgaiA9IE1hdGguY2VpbCh3cHIgLyBMT0dfQkFTRSk7XHJcbiAgbiA9IDE7XHJcbiAgeDIgPSB4LnRpbWVzKHgpO1xyXG4gIHIgPSBuZXcgQ3Rvcih4KTtcclxuICBweCA9IHg7XHJcblxyXG4gIC8vIGF0YW4oeCkgPSB4IC0geF4zLzMgKyB4XjUvNSAtIHheNy83ICsgLi4uXHJcbiAgZm9yICg7IGkgIT09IC0xOykge1xyXG4gICAgcHggPSBweC50aW1lcyh4Mik7XHJcbiAgICB0ID0gci5taW51cyhweC5kaXYobiArPSAyKSk7XHJcblxyXG4gICAgcHggPSBweC50aW1lcyh4Mik7XHJcbiAgICByID0gdC5wbHVzKHB4LmRpdihuICs9IDIpKTtcclxuXHJcbiAgICBpZiAoci5kW2pdICE9PSB2b2lkIDApIGZvciAoaSA9IGo7IHIuZFtpXSA9PT0gdC5kW2ldICYmIGktLTspO1xyXG4gIH1cclxuXHJcbiAgaWYgKGspIHIgPSByLnRpbWVzKDIgPDwgKGsgLSAxKSk7XHJcblxyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIEN0b3IucHJlY2lzaW9uID0gcHIsIEN0b3Iucm91bmRpbmcgPSBybSwgdHJ1ZSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiAhIXRoaXMuZDtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmlzSW50ZWdlciA9IFAuaXNJbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuICEhdGhpcy5kICYmIG1hdGhmbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkgPiB0aGlzLmQubGVuZ3RoIC0gMjtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIE5hTiwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICpcclxuICovXHJcblAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuICF0aGlzLnM7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICpcclxuICovXHJcblAuaXNOZWdhdGl2ZSA9IFAuaXNOZWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMucyA8IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBwb3NpdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICpcclxuICovXHJcblAuaXNQb3NpdGl2ZSA9IFAuaXNQb3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMucyA+IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gKlxyXG4gKi9cclxuUC5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuICEhdGhpcy5kICYmIHRoaXMuZFswXSA9PT0gMDtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGxlc3MgdGhhbiBgeWAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmxlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgcmV0dXJuIHRoaXMuY21wKHkpIDwgMDtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgeWAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmxlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiB0aGlzLmNtcCh5KSA8IDE7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRoZSBsb2dhcml0aG0gb2YgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCB0byB0aGUgc3BlY2lmaWVkIGJhc2UsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogSWYgbm8gYmFzZSBpcyBzcGVjaWZpZWQsIHJldHVybiBsb2dbMTBdKGFyZykuXHJcbiAqXHJcbiAqIGxvZ1tiYXNlXShhcmcpID0gbG4oYXJnKSAvIGxuKGJhc2UpXHJcbiAqXHJcbiAqIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgY29ycmVjdGx5IHJvdW5kZWQgaWYgdGhlIGJhc2Ugb2YgdGhlIGxvZyBpcyAxMCwgYW5kICdhbG1vc3QgYWx3YXlzJ1xyXG4gKiBvdGhlcndpc2U6XHJcbiAqXHJcbiAqIERlcGVuZGluZyBvbiB0aGUgcm91bmRpbmcgbW9kZSwgdGhlIHJlc3VsdCBtYXkgYmUgaW5jb3JyZWN0bHkgcm91bmRlZCBpZiB0aGUgZmlyc3QgZmlmdGVlblxyXG4gKiByb3VuZGluZyBkaWdpdHMgYXJlIFs0OV05OTk5OTk5OTk5OTk5OSBvciBbNTBdMDAwMDAwMDAwMDAwMDAuIEluIHRoYXQgY2FzZSwgdGhlIG1heGltdW0gZXJyb3JcclxuICogYmV0d2VlbiB0aGUgcmVzdWx0IGFuZCB0aGUgY29ycmVjdGx5IHJvdW5kZWQgcmVzdWx0IHdpbGwgYmUgb25lIHVscCAodW5pdCBpbiB0aGUgbGFzdCBwbGFjZSkuXHJcbiAqXHJcbiAqIGxvZ1stYl0oYSkgICAgICAgPSBOYU5cclxuICogbG9nWzBdKGEpICAgICAgICA9IE5hTlxyXG4gKiBsb2dbMV0oYSkgICAgICAgID0gTmFOXHJcbiAqIGxvZ1tOYU5dKGEpICAgICAgPSBOYU5cclxuICogbG9nW0luZmluaXR5XShhKSA9IE5hTlxyXG4gKiBsb2dbYl0oMCkgICAgICAgID0gLUluZmluaXR5XHJcbiAqIGxvZ1tiXSgtMCkgICAgICAgPSAtSW5maW5pdHlcclxuICogbG9nW2JdKC1hKSAgICAgICA9IE5hTlxyXG4gKiBsb2dbYl0oMSkgICAgICAgID0gMFxyXG4gKiBsb2dbYl0oSW5maW5pdHkpID0gSW5maW5pdHlcclxuICogbG9nW2JdKE5hTikgICAgICA9IE5hTlxyXG4gKlxyXG4gKiBbYmFzZV0ge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIGJhc2Ugb2YgdGhlIGxvZ2FyaXRobS5cclxuICpcclxuICovXHJcblAubG9nYXJpdGhtID0gUC5sb2cgPSBmdW5jdGlvbiAoYmFzZSkge1xyXG4gIHZhciBpc0Jhc2UxMCwgZCwgZGVub21pbmF0b3IsIGssIGluZiwgbnVtLCBzZCwgcixcclxuICAgIGFyZyA9IHRoaXMsXHJcbiAgICBDdG9yID0gYXJnLmNvbnN0cnVjdG9yLFxyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbixcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZyxcclxuICAgIGd1YXJkID0gNTtcclxuXHJcbiAgLy8gRGVmYXVsdCBiYXNlIGlzIDEwLlxyXG4gIGlmIChiYXNlID09IG51bGwpIHtcclxuICAgIGJhc2UgPSBuZXcgQ3RvcigxMCk7XHJcbiAgICBpc0Jhc2UxMCA9IHRydWU7XHJcbiAgfSBlbHNlIHtcclxuICAgIGJhc2UgPSBuZXcgQ3RvcihiYXNlKTtcclxuICAgIGQgPSBiYXNlLmQ7XHJcblxyXG4gICAgLy8gUmV0dXJuIE5hTiBpZiBiYXNlIGlzIG5lZ2F0aXZlLCBvciBub24tZmluaXRlLCBvciBpcyAwIG9yIDEuXHJcbiAgICBpZiAoYmFzZS5zIDwgMCB8fCAhZCB8fCAhZFswXSB8fCBiYXNlLmVxKDEpKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuXHJcbiAgICBpc0Jhc2UxMCA9IGJhc2UuZXEoMTApO1xyXG4gIH1cclxuXHJcbiAgZCA9IGFyZy5kO1xyXG5cclxuICAvLyBJcyBhcmcgbmVnYXRpdmUsIG5vbi1maW5pdGUsIDAgb3IgMT9cclxuICBpZiAoYXJnLnMgPCAwIHx8ICFkIHx8ICFkWzBdIHx8IGFyZy5lcSgxKSkge1xyXG4gICAgcmV0dXJuIG5ldyBDdG9yKGQgJiYgIWRbMF0gPyAtMSAvIDAgOiBhcmcucyAhPSAxID8gTmFOIDogZCA/IDAgOiAxIC8gMCk7XHJcbiAgfVxyXG5cclxuICAvLyBUaGUgcmVzdWx0IHdpbGwgaGF2ZSBhIG5vbi10ZXJtaW5hdGluZyBkZWNpbWFsIGV4cGFuc2lvbiBpZiBiYXNlIGlzIDEwIGFuZCBhcmcgaXMgbm90IGFuXHJcbiAgLy8gaW50ZWdlciBwb3dlciBvZiAxMC5cclxuICBpZiAoaXNCYXNlMTApIHtcclxuICAgIGlmIChkLmxlbmd0aCA+IDEpIHtcclxuICAgICAgaW5mID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvciAoayA9IGRbMF07IGsgJSAxMCA9PT0gMDspIGsgLz0gMTA7XHJcbiAgICAgIGluZiA9IGsgIT09IDE7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gIHNkID0gcHIgKyBndWFyZDtcclxuICBudW0gPSBuYXR1cmFsTG9nYXJpdGhtKGFyZywgc2QpO1xyXG4gIGRlbm9taW5hdG9yID0gaXNCYXNlMTAgPyBnZXRMbjEwKEN0b3IsIHNkICsgMTApIDogbmF0dXJhbExvZ2FyaXRobShiYXNlLCBzZCk7XHJcblxyXG4gIC8vIFRoZSByZXN1bHQgd2lsbCBoYXZlIDUgcm91bmRpbmcgZGlnaXRzLlxyXG4gIHIgPSBkaXZpZGUobnVtLCBkZW5vbWluYXRvciwgc2QsIDEpO1xyXG5cclxuICAvLyBJZiBhdCBhIHJvdW5kaW5nIGJvdW5kYXJ5LCBpLmUuIHRoZSByZXN1bHQncyByb3VuZGluZyBkaWdpdHMgYXJlIFs0OV05OTk5IG9yIFs1MF0wMDAwLFxyXG4gIC8vIGNhbGN1bGF0ZSAxMCBmdXJ0aGVyIGRpZ2l0cy5cclxuICAvL1xyXG4gIC8vIElmIHRoZSByZXN1bHQgaXMga25vd24gdG8gaGF2ZSBhbiBpbmZpbml0ZSBkZWNpbWFsIGV4cGFuc2lvbiwgcmVwZWF0IHRoaXMgdW50aWwgaXQgaXMgY2xlYXJcclxuICAvLyB0aGF0IHRoZSByZXN1bHQgaXMgYWJvdmUgb3IgYmVsb3cgdGhlIGJvdW5kYXJ5LiBPdGhlcndpc2UsIGlmIGFmdGVyIGNhbGN1bGF0aW5nIHRoZSAxMFxyXG4gIC8vIGZ1cnRoZXIgZGlnaXRzLCB0aGUgbGFzdCAxNCBhcmUgbmluZXMsIHJvdW5kIHVwIGFuZCBhc3N1bWUgdGhlIHJlc3VsdCBpcyBleGFjdC5cclxuICAvLyBBbHNvIGFzc3VtZSB0aGUgcmVzdWx0IGlzIGV4YWN0IGlmIHRoZSBsYXN0IDE0IGFyZSB6ZXJvLlxyXG4gIC8vXHJcbiAgLy8gRXhhbXBsZSBvZiBhIHJlc3VsdCB0aGF0IHdpbGwgYmUgaW5jb3JyZWN0bHkgcm91bmRlZDpcclxuICAvLyBsb2dbMTA0ODU3Nl0oNDUwMzU5OTYyNzM3MDUwMikgPSAyLjYwMDAwMDAwMDAwMDAwMDA5NjEwMjc5NTExNDQ0NzQ2Li4uXHJcbiAgLy8gVGhlIGFib3ZlIHJlc3VsdCBjb3JyZWN0bHkgcm91bmRlZCB1c2luZyBST1VORF9DRUlMIHRvIDEgZGVjaW1hbCBwbGFjZSBzaG91bGQgYmUgMi43LCBidXQgaXRcclxuICAvLyB3aWxsIGJlIGdpdmVuIGFzIDIuNiBhcyB0aGVyZSBhcmUgMTUgemVyb3MgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHJlcXVlc3RlZCBkZWNpbWFsIHBsYWNlLCBzb1xyXG4gIC8vIHRoZSBleGFjdCByZXN1bHQgd291bGQgYmUgYXNzdW1lZCB0byBiZSAyLjYsIHdoaWNoIHJvdW5kZWQgdXNpbmcgUk9VTkRfQ0VJTCB0byAxIGRlY2ltYWxcclxuICAvLyBwbGFjZSBpcyBzdGlsbCAyLjYuXHJcbiAgaWYgKGNoZWNrUm91bmRpbmdEaWdpdHMoci5kLCBrID0gcHIsIHJtKSkge1xyXG5cclxuICAgIGRvIHtcclxuICAgICAgc2QgKz0gMTA7XHJcbiAgICAgIG51bSA9IG5hdHVyYWxMb2dhcml0aG0oYXJnLCBzZCk7XHJcbiAgICAgIGRlbm9taW5hdG9yID0gaXNCYXNlMTAgPyBnZXRMbjEwKEN0b3IsIHNkICsgMTApIDogbmF0dXJhbExvZ2FyaXRobShiYXNlLCBzZCk7XHJcbiAgICAgIHIgPSBkaXZpZGUobnVtLCBkZW5vbWluYXRvciwgc2QsIDEpO1xyXG5cclxuICAgICAgaWYgKCFpbmYpIHtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIDE0IG5pbmVzIGZyb20gdGhlIDJuZCByb3VuZGluZyBkaWdpdCwgYXMgdGhlIGZpcnN0IG1heSBiZSA0LlxyXG4gICAgICAgIGlmICgrZGlnaXRzVG9TdHJpbmcoci5kKS5zbGljZShrICsgMSwgayArIDE1KSArIDEgPT0gMWUxNCkge1xyXG4gICAgICAgICAgciA9IGZpbmFsaXNlKHIsIHByICsgMSwgMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfSB3aGlsZSAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhyLmQsIGsgKz0gMTAsIHJtKSk7XHJcbiAgfVxyXG5cclxuICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZShyLCBwciwgcm0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMgYW5kIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG5QLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICBBcnJheS5wcm90b3R5cGUucHVzaC5jYWxsKGFyZ3VtZW50cywgdGhpcyk7XHJcbiAgcmV0dXJuIG1heE9yTWluKHRoaXMuY29uc3RydWN0b3IsIGFyZ3VtZW50cywgJ2x0Jyk7XHJcbn07XHJcbiAqL1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMgYW5kIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG5QLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICBBcnJheS5wcm90b3R5cGUucHVzaC5jYWxsKGFyZ3VtZW50cywgdGhpcyk7XHJcbiAgcmV0dXJuIG1heE9yTWluKHRoaXMuY29uc3RydWN0b3IsIGFyZ3VtZW50cywgJ2d0Jyk7XHJcbn07XHJcbiAqL1xyXG5cclxuXHJcbi8qXHJcbiAqICBuIC0gMCA9IG5cclxuICogIG4gLSBOID0gTlxyXG4gKiAgbiAtIEkgPSAtSVxyXG4gKiAgMCAtIG4gPSAtblxyXG4gKiAgMCAtIDAgPSAwXHJcbiAqICAwIC0gTiA9IE5cclxuICogIDAgLSBJID0gLUlcclxuICogIE4gLSBuID0gTlxyXG4gKiAgTiAtIDAgPSBOXHJcbiAqICBOIC0gTiA9IE5cclxuICogIE4gLSBJID0gTlxyXG4gKiAgSSAtIG4gPSBJXHJcbiAqICBJIC0gMCA9IElcclxuICogIEkgLSBOID0gTlxyXG4gKiAgSSAtIEkgPSBOXHJcbiAqXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgbWludXMgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqL1xyXG5QLm1pbnVzID0gUC5zdWIgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBkLCBlLCBpLCBqLCBrLCBsZW4sIHByLCBybSwgeGQsIHhlLCB4TFR5LCB5ZCxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIHkgPSBuZXcgQ3Rvcih5KTtcclxuXHJcbiAgLy8gSWYgZWl0aGVyIGlzIG5vdCBmaW5pdGUuLi5cclxuICBpZiAoIXguZCB8fCAheS5kKSB7XHJcblxyXG4gICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgaWYgKCF4LnMgfHwgIXkucykgeSA9IG5ldyBDdG9yKE5hTik7XHJcblxyXG4gICAgLy8gUmV0dXJuIHkgbmVnYXRlZCBpZiB4IGlzIGZpbml0ZSBhbmQgeSBpcyDCsUluZmluaXR5LlxyXG4gICAgZWxzZSBpZiAoeC5kKSB5LnMgPSAteS5zO1xyXG5cclxuICAgIC8vIFJldHVybiB4IGlmIHkgaXMgZmluaXRlIGFuZCB4IGlzIMKxSW5maW5pdHkuXHJcbiAgICAvLyBSZXR1cm4geCBpZiBib3RoIGFyZSDCsUluZmluaXR5IHdpdGggZGlmZmVyZW50IHNpZ25zLlxyXG4gICAgLy8gUmV0dXJuIE5hTiBpZiBib3RoIGFyZSDCsUluZmluaXR5IHdpdGggdGhlIHNhbWUgc2lnbi5cclxuICAgIGVsc2UgeSA9IG5ldyBDdG9yKHkuZCB8fCB4LnMgIT09IHkucyA/IHggOiBOYU4pO1xyXG5cclxuICAgIHJldHVybiB5O1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgc2lnbnMgZGlmZmVyLi4uXHJcbiAgaWYgKHgucyAhPSB5LnMpIHtcclxuICAgIHkucyA9IC15LnM7XHJcbiAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gIH1cclxuXHJcbiAgeGQgPSB4LmQ7XHJcbiAgeWQgPSB5LmQ7XHJcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICBybSA9IEN0b3Iucm91bmRpbmc7XHJcblxyXG4gIC8vIElmIGVpdGhlciBpcyB6ZXJvLi4uXHJcbiAgaWYgKCF4ZFswXSB8fCAheWRbMF0pIHtcclxuXHJcbiAgICAvLyBSZXR1cm4geSBuZWdhdGVkIGlmIHggaXMgemVybyBhbmQgeSBpcyBub24temVyby5cclxuICAgIGlmICh5ZFswXSkgeS5zID0gLXkucztcclxuXHJcbiAgICAvLyBSZXR1cm4geCBpZiB5IGlzIHplcm8gYW5kIHggaXMgbm9uLXplcm8uXHJcbiAgICBlbHNlIGlmICh4ZFswXSkgeSA9IG5ldyBDdG9yKHgpO1xyXG5cclxuICAgIC8vIFJldHVybiB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAvLyBGcm9tIElFRUUgNzU0ICgyMDA4KSA2LjM6IDAgLSAwID0gLTAgLSAtMCA9IC0wIHdoZW4gcm91bmRpbmcgdG8gLUluZmluaXR5LlxyXG4gICAgZWxzZSByZXR1cm4gbmV3IEN0b3Iocm0gPT09IDMgPyAtMCA6IDApO1xyXG5cclxuICAgIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xyXG4gIH1cclxuXHJcbiAgLy8geCBhbmQgeSBhcmUgZmluaXRlLCBub24temVybyBudW1iZXJzIHdpdGggdGhlIHNhbWUgc2lnbi5cclxuXHJcbiAgLy8gQ2FsY3VsYXRlIGJhc2UgMWU3IGV4cG9uZW50cy5cclxuICBlID0gbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICB4ZSA9IG1hdGhmbG9vcih4LmUgLyBMT0dfQkFTRSk7XHJcblxyXG4gIHhkID0geGQuc2xpY2UoKTtcclxuICBrID0geGUgLSBlO1xyXG5cclxuICAvLyBJZiBiYXNlIDFlNyBleHBvbmVudHMgZGlmZmVyLi4uXHJcbiAgaWYgKGspIHtcclxuICAgIHhMVHkgPSBrIDwgMDtcclxuXHJcbiAgICBpZiAoeExUeSkge1xyXG4gICAgICBkID0geGQ7XHJcbiAgICAgIGsgPSAtaztcclxuICAgICAgbGVuID0geWQubGVuZ3RoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZCA9IHlkO1xyXG4gICAgICBlID0geGU7XHJcbiAgICAgIGxlbiA9IHhkLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOdW1iZXJzIHdpdGggbWFzc2l2ZWx5IGRpZmZlcmVudCBleHBvbmVudHMgd291bGQgcmVzdWx0IGluIGEgdmVyeSBoaWdoIG51bWJlciBvZlxyXG4gICAgLy8gemVyb3MgbmVlZGluZyB0byBiZSBwcmVwZW5kZWQsIGJ1dCB0aGlzIGNhbiBiZSBhdm9pZGVkIHdoaWxlIHN0aWxsIGVuc3VyaW5nIGNvcnJlY3RcclxuICAgIC8vIHJvdW5kaW5nIGJ5IGxpbWl0aW5nIHRoZSBudW1iZXIgb2YgemVyb3MgdG8gYE1hdGguY2VpbChwciAvIExPR19CQVNFKSArIDJgLlxyXG4gICAgaSA9IE1hdGgubWF4KE1hdGguY2VpbChwciAvIExPR19CQVNFKSwgbGVuKSArIDI7XHJcblxyXG4gICAgaWYgKGsgPiBpKSB7XHJcbiAgICAgIGsgPSBpO1xyXG4gICAgICBkLmxlbmd0aCA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICBkLnJldmVyc2UoKTtcclxuICAgIGZvciAoaSA9IGs7IGktLTspIGQucHVzaCgwKTtcclxuICAgIGQucmV2ZXJzZSgpO1xyXG5cclxuICAvLyBCYXNlIDFlNyBleHBvbmVudHMgZXF1YWwuXHJcbiAgfSBlbHNlIHtcclxuXHJcbiAgICAvLyBDaGVjayBkaWdpdHMgdG8gZGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG5cclxuICAgIGkgPSB4ZC5sZW5ndGg7XHJcbiAgICBsZW4gPSB5ZC5sZW5ndGg7XHJcbiAgICB4TFR5ID0gaSA8IGxlbjtcclxuICAgIGlmICh4TFR5KSBsZW4gPSBpO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBpZiAoeGRbaV0gIT0geWRbaV0pIHtcclxuICAgICAgICB4TFR5ID0geGRbaV0gPCB5ZFtpXTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGsgPSAwO1xyXG4gIH1cclxuXHJcbiAgaWYgKHhMVHkpIHtcclxuICAgIGQgPSB4ZDtcclxuICAgIHhkID0geWQ7XHJcbiAgICB5ZCA9IGQ7XHJcbiAgICB5LnMgPSAteS5zO1xyXG4gIH1cclxuXHJcbiAgbGVuID0geGQubGVuZ3RoO1xyXG5cclxuICAvLyBBcHBlbmQgemVyb3MgdG8gYHhkYCBpZiBzaG9ydGVyLlxyXG4gIC8vIERvbid0IGFkZCB6ZXJvcyB0byBgeWRgIGlmIHNob3J0ZXIgYXMgc3VidHJhY3Rpb24gb25seSBuZWVkcyB0byBzdGFydCBhdCBgeWRgIGxlbmd0aC5cclxuICBmb3IgKGkgPSB5ZC5sZW5ndGggLSBsZW47IGkgPiAwOyAtLWkpIHhkW2xlbisrXSA9IDA7XHJcblxyXG4gIC8vIFN1YnRyYWN0IHlkIGZyb20geGQuXHJcbiAgZm9yIChpID0geWQubGVuZ3RoOyBpID4gazspIHtcclxuXHJcbiAgICBpZiAoeGRbLS1pXSA8IHlkW2ldKSB7XHJcbiAgICAgIGZvciAoaiA9IGk7IGogJiYgeGRbLS1qXSA9PT0gMDspIHhkW2pdID0gQkFTRSAtIDE7XHJcbiAgICAgIC0teGRbal07XHJcbiAgICAgIHhkW2ldICs9IEJBU0U7XHJcbiAgICB9XHJcblxyXG4gICAgeGRbaV0gLT0geWRbaV07XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgZm9yICg7IHhkWy0tbGVuXSA9PT0gMDspIHhkLnBvcCgpO1xyXG5cclxuICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gIGZvciAoOyB4ZFswXSA9PT0gMDsgeGQuc2hpZnQoKSkgLS1lO1xyXG5cclxuICAvLyBaZXJvP1xyXG4gIGlmICgheGRbMF0pIHJldHVybiBuZXcgQ3RvcihybSA9PT0gMyA/IC0wIDogMCk7XHJcblxyXG4gIHkuZCA9IHhkO1xyXG4gIHkuZSA9IGdldEJhc2UxMEV4cG9uZW50KHhkLCBlKTtcclxuXHJcbiAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgcHIsIHJtKSA6IHk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogICBuICUgMCA9ICBOXHJcbiAqICAgbiAlIE4gPSAgTlxyXG4gKiAgIG4gJSBJID0gIG5cclxuICogICAwICUgbiA9ICAwXHJcbiAqICAtMCAlIG4gPSAtMFxyXG4gKiAgIDAgJSAwID0gIE5cclxuICogICAwICUgTiA9ICBOXHJcbiAqICAgMCAlIEkgPSAgMFxyXG4gKiAgIE4gJSBuID0gIE5cclxuICogICBOICUgMCA9ICBOXHJcbiAqICAgTiAlIE4gPSAgTlxyXG4gKiAgIE4gJSBJID0gIE5cclxuICogICBJICUgbiA9ICBOXHJcbiAqICAgSSAlIDAgPSAgTlxyXG4gKiAgIEkgJSBOID0gIE5cclxuICogICBJICUgSSA9ICBOXHJcbiAqXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgbW9kdWxvIGB5YCwgcm91bmRlZCB0b1xyXG4gKiBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiBUaGUgcmVzdWx0IGRlcGVuZHMgb24gdGhlIG1vZHVsbyBtb2RlLlxyXG4gKlxyXG4gKi9cclxuUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIHEsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICB5ID0gbmV3IEN0b3IoeSk7XHJcblxyXG4gIC8vIFJldHVybiBOYU4gaWYgeCBpcyDCsUluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgwrEwLlxyXG4gIGlmICgheC5kIHx8ICF5LnMgfHwgeS5kICYmICF5LmRbMF0pIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG5cclxuICAvLyBSZXR1cm4geCBpZiB5IGlzIMKxSW5maW5pdHkgb3IgeCBpcyDCsTAuXHJcbiAgaWYgKCF5LmQgfHwgeC5kICYmICF4LmRbMF0pIHtcclxuICAgIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgQ3Rvci5wcmVjaXNpb24sIEN0b3Iucm91bmRpbmcpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHJldmVudCByb3VuZGluZyBvZiBpbnRlcm1lZGlhdGUgY2FsY3VsYXRpb25zLlxyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gIGlmIChDdG9yLm1vZHVsbyA9PSA5KSB7XHJcblxyXG4gICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAvLyByZXN1bHQgPSB4IC0gcSAqIHkgICAgd2hlcmUgIDAgPD0gcmVzdWx0IDwgYWJzKHkpXHJcbiAgICBxID0gZGl2aWRlKHgsIHkuYWJzKCksIDAsIDMsIDEpO1xyXG4gICAgcS5zICo9IHkucztcclxuICB9IGVsc2Uge1xyXG4gICAgcSA9IGRpdmlkZSh4LCB5LCAwLCBDdG9yLm1vZHVsbywgMSk7XHJcbiAgfVxyXG5cclxuICBxID0gcS50aW1lcyh5KTtcclxuXHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICByZXR1cm4geC5taW51cyhxKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbmF0dXJhbCBleHBvbmVudGlhbCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLFxyXG4gKiBpLmUuIHRoZSBiYXNlIGUgcmFpc2VkIHRvIHRoZSBwb3dlciB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqL1xyXG5QLm5hdHVyYWxFeHBvbmVudGlhbCA9IFAuZXhwID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBuYXR1cmFsRXhwb25lbnRpYWwodGhpcyk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwsXHJcbiAqIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICovXHJcblAubmF0dXJhbExvZ2FyaXRobSA9IFAubG4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIG5hdHVyYWxMb2dhcml0aG0odGhpcyk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBuZWdhdGVkLCBpLmUuIGFzIGlmIG11bHRpcGxpZWQgYnlcclxuICogLTEuXHJcbiAqXHJcbiAqL1xyXG5QLm5lZ2F0ZWQgPSBQLm5lZyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgeCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xyXG4gIHgucyA9IC14LnM7XHJcbiAgcmV0dXJuIGZpbmFsaXNlKHgpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqICBuICsgMCA9IG5cclxuICogIG4gKyBOID0gTlxyXG4gKiAgbiArIEkgPSBJXHJcbiAqICAwICsgbiA9IG5cclxuICogIDAgKyAwID0gMFxyXG4gKiAgMCArIE4gPSBOXHJcbiAqICAwICsgSSA9IElcclxuICogIE4gKyBuID0gTlxyXG4gKiAgTiArIDAgPSBOXHJcbiAqICBOICsgTiA9IE5cclxuICogIE4gKyBJID0gTlxyXG4gKiAgSSArIG4gPSBJXHJcbiAqICBJICsgMCA9IElcclxuICogIEkgKyBOID0gTlxyXG4gKiAgSSArIEkgPSBJXHJcbiAqXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcGx1cyBgeWAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICovXHJcblAucGx1cyA9IFAuYWRkID0gZnVuY3Rpb24gKHkpIHtcclxuICB2YXIgY2FycnksIGQsIGUsIGksIGssIGxlbiwgcHIsIHJtLCB4ZCwgeWQsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICB5ID0gbmV3IEN0b3IoeSk7XHJcblxyXG4gIC8vIElmIGVpdGhlciBpcyBub3QgZmluaXRlLi4uXHJcbiAgaWYgKCF4LmQgfHwgIXkuZCkge1xyXG5cclxuICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTi5cclxuICAgIGlmICgheC5zIHx8ICF5LnMpIHkgPSBuZXcgQ3RvcihOYU4pO1xyXG5cclxuICAgIC8vIFJldHVybiB4IGlmIHkgaXMgZmluaXRlIGFuZCB4IGlzIMKxSW5maW5pdHkuXHJcbiAgICAvLyBSZXR1cm4geCBpZiBib3RoIGFyZSDCsUluZmluaXR5IHdpdGggdGhlIHNhbWUgc2lnbi5cclxuICAgIC8vIFJldHVybiBOYU4gaWYgYm90aCBhcmUgwrFJbmZpbml0eSB3aXRoIGRpZmZlcmVudCBzaWducy5cclxuICAgIC8vIFJldHVybiB5IGlmIHggaXMgZmluaXRlIGFuZCB5IGlzIMKxSW5maW5pdHkuXHJcbiAgICBlbHNlIGlmICgheC5kKSB5ID0gbmV3IEN0b3IoeS5kIHx8IHgucyA9PT0geS5zID8geCA6IE5hTik7XHJcblxyXG4gICAgcmV0dXJuIHk7XHJcbiAgfVxyXG5cclxuICAgLy8gSWYgc2lnbnMgZGlmZmVyLi4uXHJcbiAgaWYgKHgucyAhPSB5LnMpIHtcclxuICAgIHkucyA9IC15LnM7XHJcbiAgICByZXR1cm4geC5taW51cyh5KTtcclxuICB9XHJcblxyXG4gIHhkID0geC5kO1xyXG4gIHlkID0geS5kO1xyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICAvLyBJZiBlaXRoZXIgaXMgemVyby4uLlxyXG4gIGlmICgheGRbMF0gfHwgIXlkWzBdKSB7XHJcblxyXG4gICAgLy8gUmV0dXJuIHggaWYgeSBpcyB6ZXJvLlxyXG4gICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVyby5cclxuICAgIGlmICgheWRbMF0pIHkgPSBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcclxuICB9XHJcblxyXG4gIC8vIHggYW5kIHkgYXJlIGZpbml0ZSwgbm9uLXplcm8gbnVtYmVycyB3aXRoIHRoZSBzYW1lIHNpZ24uXHJcblxyXG4gIC8vIENhbGN1bGF0ZSBiYXNlIDFlNyBleHBvbmVudHMuXHJcbiAgayA9IG1hdGhmbG9vcih4LmUgLyBMT0dfQkFTRSk7XHJcbiAgZSA9IG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcblxyXG4gIHhkID0geGQuc2xpY2UoKTtcclxuICBpID0gayAtIGU7XHJcblxyXG4gIC8vIElmIGJhc2UgMWU3IGV4cG9uZW50cyBkaWZmZXIuLi5cclxuICBpZiAoaSkge1xyXG5cclxuICAgIGlmIChpIDwgMCkge1xyXG4gICAgICBkID0geGQ7XHJcbiAgICAgIGkgPSAtaTtcclxuICAgICAgbGVuID0geWQubGVuZ3RoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZCA9IHlkO1xyXG4gICAgICBlID0gaztcclxuICAgICAgbGVuID0geGQubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExpbWl0IG51bWJlciBvZiB6ZXJvcyBwcmVwZW5kZWQgdG8gbWF4KGNlaWwocHIgLyBMT0dfQkFTRSksIGxlbikgKyAxLlxyXG4gICAgayA9IE1hdGguY2VpbChwciAvIExPR19CQVNFKTtcclxuICAgIGxlbiA9IGsgPiBsZW4gPyBrICsgMSA6IGxlbiArIDE7XHJcblxyXG4gICAgaWYgKGkgPiBsZW4pIHtcclxuICAgICAgaSA9IGxlbjtcclxuICAgICAgZC5sZW5ndGggPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBOb3RlOiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgIGQucmV2ZXJzZSgpO1xyXG4gICAgZm9yICg7IGktLTspIGQucHVzaCgwKTtcclxuICAgIGQucmV2ZXJzZSgpO1xyXG4gIH1cclxuXHJcbiAgbGVuID0geGQubGVuZ3RoO1xyXG4gIGkgPSB5ZC5sZW5ndGg7XHJcblxyXG4gIC8vIElmIHlkIGlzIGxvbmdlciB0aGFuIHhkLCBzd2FwIHhkIGFuZCB5ZCBzbyB4ZCBwb2ludHMgdG8gdGhlIGxvbmdlciBhcnJheS5cclxuICBpZiAobGVuIC0gaSA8IDApIHtcclxuICAgIGkgPSBsZW47XHJcbiAgICBkID0geWQ7XHJcbiAgICB5ZCA9IHhkO1xyXG4gICAgeGQgPSBkO1xyXG4gIH1cclxuXHJcbiAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWQubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGQgY2FuIGJlIGxlZnQgYXMgdGhleSBhcmUuXHJcbiAgZm9yIChjYXJyeSA9IDA7IGk7KSB7XHJcbiAgICBjYXJyeSA9ICh4ZFstLWldID0geGRbaV0gKyB5ZFtpXSArIGNhcnJ5KSAvIEJBU0UgfCAwO1xyXG4gICAgeGRbaV0gJT0gQkFTRTtcclxuICB9XHJcblxyXG4gIGlmIChjYXJyeSkge1xyXG4gICAgeGQudW5zaGlmdChjYXJyeSk7XHJcbiAgICArK2U7XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG4gIGZvciAobGVuID0geGQubGVuZ3RoOyB4ZFstLWxlbl0gPT0gMDspIHhkLnBvcCgpO1xyXG5cclxuICB5LmQgPSB4ZDtcclxuICB5LmUgPSBnZXRCYXNlMTBFeHBvbmVudCh4ZCwgZSk7XHJcblxyXG4gIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKiBbel0ge2Jvb2xlYW58bnVtYmVyfSBXaGV0aGVyIHRvIGNvdW50IGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvczogdHJ1ZSwgZmFsc2UsIDEgb3IgMC5cclxuICpcclxuICovXHJcblAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uICh6KSB7XHJcbiAgdmFyIGssXHJcbiAgICB4ID0gdGhpcztcclxuXHJcbiAgaWYgKHogIT09IHZvaWQgMCAmJiB6ICE9PSAhIXogJiYgeiAhPT0gMSAmJiB6ICE9PSAwKSB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyB6KTtcclxuXHJcbiAgaWYgKHguZCkge1xyXG4gICAgayA9IGdldFByZWNpc2lvbih4LmQpO1xyXG4gICAgaWYgKHogJiYgeC5lICsgMSA+IGspIGsgPSB4LmUgKyAxO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBrID0gTmFOO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGs7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByb3VuZGVkIHRvIGEgd2hvbGUgbnVtYmVyIHVzaW5nXHJcbiAqIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICovXHJcblAucm91bmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgeC5lICsgMSwgQ3Rvci5yb3VuZGluZyk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHNpbmUgb2YgdGhlIHZhbHVlIGluIHJhZGlhbnMgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gKiBSYW5nZTogWy0xLCAxXVxyXG4gKlxyXG4gKiBzaW4oeCkgPSB4IC0geF4zLzMhICsgeF41LzUhIC0gLi4uXHJcbiAqXHJcbiAqIHNpbigwKSAgICAgICAgID0gMFxyXG4gKiBzaW4oLTApICAgICAgICA9IC0wXHJcbiAqIHNpbihJbmZpbml0eSkgID0gTmFOXHJcbiAqIHNpbigtSW5maW5pdHkpID0gTmFOXHJcbiAqIHNpbihOYU4pICAgICAgID0gTmFOXHJcbiAqXHJcbiAqL1xyXG5QLnNpbmUgPSBQLnNpbiA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcHIsIHJtLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG4gIGlmICh4LmlzWmVybygpKSByZXR1cm4gbmV3IEN0b3IoeCk7XHJcblxyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyBMT0dfQkFTRTtcclxuICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgeCA9IHNpbmUoQ3RvciwgdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSk7XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICByZXR1cm4gZmluYWxpc2UocXVhZHJhbnQgPiAyID8geC5uZWcoKSA6IHgsIHByLCBybSwgdHJ1ZSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoaXMgRGVjaW1hbCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiAgc3FydCgtbikgPSAgTlxyXG4gKiAgc3FydChOKSAgPSAgTlxyXG4gKiAgc3FydCgtSSkgPSAgTlxyXG4gKiAgc3FydChJKSAgPSAgSVxyXG4gKiAgc3FydCgwKSAgPSAgMFxyXG4gKiAgc3FydCgtMCkgPSAtMFxyXG4gKlxyXG4gKi9cclxuUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtLCBuLCBzZCwgciwgcmVwLCB0LFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBkID0geC5kLFxyXG4gICAgZSA9IHguZSxcclxuICAgIHMgPSB4LnMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XHJcbiAgaWYgKHMgIT09IDEgfHwgIWQgfHwgIWRbMF0pIHtcclxuICAgIHJldHVybiBuZXcgQ3RvcighcyB8fCBzIDwgMCAmJiAoIWQgfHwgZFswXSkgPyBOYU4gOiBkID8geCA6IDEgLyAwKTtcclxuICB9XHJcblxyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgcyA9IE1hdGguc3FydCgreCk7XHJcblxyXG4gIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcclxuICAgIG4gPSBkaWdpdHNUb1N0cmluZyhkKTtcclxuXHJcbiAgICBpZiAoKG4ubGVuZ3RoICsgZSkgJSAyID09IDApIG4gKz0gJzAnO1xyXG4gICAgcyA9IE1hdGguc3FydChuKTtcclxuICAgIGUgPSBtYXRoZmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcclxuXHJcbiAgICBpZiAocyA9PSAxIC8gMCkge1xyXG4gICAgICBuID0gJzVlJyArIGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgfVxyXG5cclxuICAgIHIgPSBuZXcgQ3RvcihuKTtcclxuICB9IGVsc2Uge1xyXG4gICAgciA9IG5ldyBDdG9yKHMudG9TdHJpbmcoKSk7XHJcbiAgfVxyXG5cclxuICBzZCA9IChlID0gQ3Rvci5wcmVjaXNpb24pICsgMztcclxuXHJcbiAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gIGZvciAoOzspIHtcclxuICAgIHQgPSByO1xyXG4gICAgciA9IHQucGx1cyhkaXZpZGUoeCwgdCwgc2QgKyAyLCAxKSkudGltZXMoMC41KTtcclxuXHJcbiAgICAvLyBUT0RPPyBSZXBsYWNlIHdpdGggZm9yLWxvb3AgYW5kIGNoZWNrUm91bmRpbmdEaWdpdHMuXHJcbiAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCBzZCkgPT09IChuID0gZGlnaXRzVG9TdHJpbmcoci5kKSkuc2xpY2UoMCwgc2QpKSB7XHJcbiAgICAgIG4gPSBuLnNsaWNlKHNkIC0gMywgc2QgKyAxKTtcclxuXHJcbiAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0cyBhcmUgOTk5OSBvclxyXG4gICAgICAvLyA0OTk5LCBpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnksIGNvbnRpbnVlIHRoZSBpdGVyYXRpb24uXHJcbiAgICAgIGlmIChuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknKSB7XHJcblxyXG4gICAgICAgIC8vIE9uIHRoZSBmaXJzdCBpdGVyYXRpb24gb25seSwgY2hlY2sgdG8gc2VlIGlmIHJvdW5kaW5nIHVwIGdpdmVzIHRoZSBleGFjdCByZXN1bHQgYXMgdGhlXHJcbiAgICAgICAgLy8gbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgIGlmICghcmVwKSB7XHJcbiAgICAgICAgICBmaW5hbGlzZSh0LCBlICsgMSwgMCk7XHJcblxyXG4gICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2QgKz0gNDtcclxuICAgICAgICByZXAgPSAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGFuIGV4YWN0IHJlc3VsdC5cclxuICAgICAgICAvLyBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgIGZpbmFsaXNlKHIsIGUgKyAxLCAxKTtcclxuICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZShyLCBlLCBDdG9yLnJvdW5kaW5nLCBtKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdGFuZ2VudCBvZiB0aGUgdmFsdWUgaW4gcmFkaWFucyBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICpcclxuICogdGFuKDApICAgICAgICAgPSAwXHJcbiAqIHRhbigtMCkgICAgICAgID0gLTBcclxuICogdGFuKEluZmluaXR5KSAgPSBOYU5cclxuICogdGFuKC1JbmZpbml0eSkgPSBOYU5cclxuICogdGFuKE5hTikgICAgICAgPSBOYU5cclxuICpcclxuICovXHJcblAudGFuZ2VudCA9IFAudGFuID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBwciwgcm0sXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcbiAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDEwO1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICB4ID0geC5zaW4oKTtcclxuICB4LnMgPSAxO1xyXG4gIHggPSBkaXZpZGUoeCwgbmV3IEN0b3IoMSkubWludXMoeC50aW1lcyh4KSkuc3FydCgpLCBwciArIDEwLCAwKTtcclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZShxdWFkcmFudCA9PSAyIHx8IHF1YWRyYW50ID09IDQgPyB4Lm5lZygpIDogeCwgcHIsIHJtLCB0cnVlKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiAgbiAqIDAgPSAwXHJcbiAqICBuICogTiA9IE5cclxuICogIG4gKiBJID0gSVxyXG4gKiAgMCAqIG4gPSAwXHJcbiAqICAwICogMCA9IDBcclxuICogIDAgKiBOID0gTlxyXG4gKiAgMCAqIEkgPSBOXHJcbiAqICBOICogbiA9IE5cclxuICogIE4gKiAwID0gTlxyXG4gKiAgTiAqIE4gPSBOXHJcbiAqICBOICogSSA9IE5cclxuICogIEkgKiBuID0gSVxyXG4gKiAgSSAqIDAgPSBOXHJcbiAqICBJICogTiA9IE5cclxuICogIEkgKiBJID0gSVxyXG4gKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGlzIERlY2ltYWwgdGltZXMgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqL1xyXG5QLnRpbWVzID0gUC5tdWwgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBjYXJyeSwgZSwgaSwgaywgciwgckwsIHQsIHhkTCwgeWRMLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgIHhkID0geC5kLFxyXG4gICAgeWQgPSAoeSA9IG5ldyBDdG9yKHkpKS5kO1xyXG5cclxuICB5LnMgKj0geC5zO1xyXG5cclxuICAgLy8gSWYgZWl0aGVyIGlzIE5hTiwgwrFJbmZpbml0eSBvciDCsTAuLi5cclxuICBpZiAoIXhkIHx8ICF4ZFswXSB8fCAheWQgfHwgIXlkWzBdKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBDdG9yKCF5LnMgfHwgeGQgJiYgIXhkWzBdICYmICF5ZCB8fCB5ZCAmJiAheWRbMF0gJiYgIXhkXHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBpcyBOYU4uXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgeCBpcyDCsTAgYW5kIHkgaXMgwrFJbmZpbml0eSwgb3IgeSBpcyDCsTAgYW5kIHggaXMgwrFJbmZpbml0eS5cclxuICAgICAgPyBOYU5cclxuXHJcbiAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgIDogIXhkIHx8ICF5ZCA/IHkucyAvIDAgOiB5LnMgKiAwKTtcclxuICB9XHJcblxyXG4gIGUgPSBtYXRoZmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICB4ZEwgPSB4ZC5sZW5ndGg7XHJcbiAgeWRMID0geWQubGVuZ3RoO1xyXG5cclxuICAvLyBFbnN1cmUgeGQgcG9pbnRzIHRvIHRoZSBsb25nZXIgYXJyYXkuXHJcbiAgaWYgKHhkTCA8IHlkTCkge1xyXG4gICAgciA9IHhkO1xyXG4gICAgeGQgPSB5ZDtcclxuICAgIHlkID0gcjtcclxuICAgIHJMID0geGRMO1xyXG4gICAgeGRMID0geWRMO1xyXG4gICAgeWRMID0gckw7XHJcbiAgfVxyXG5cclxuICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICByID0gW107XHJcbiAgckwgPSB4ZEwgKyB5ZEw7XHJcbiAgZm9yIChpID0gckw7IGktLTspIHIucHVzaCgwKTtcclxuXHJcbiAgLy8gTXVsdGlwbHkhXHJcbiAgZm9yIChpID0geWRMOyAtLWkgPj0gMDspIHtcclxuICAgIGNhcnJ5ID0gMDtcclxuICAgIGZvciAoayA9IHhkTCArIGk7IGsgPiBpOykge1xyXG4gICAgICB0ID0gcltrXSArIHlkW2ldICogeGRbayAtIGkgLSAxXSArIGNhcnJ5O1xyXG4gICAgICByW2stLV0gPSB0ICUgQkFTRSB8IDA7XHJcbiAgICAgIGNhcnJ5ID0gdCAvIEJBU0UgfCAwO1xyXG4gICAgfVxyXG5cclxuICAgIHJba10gPSAocltrXSArIGNhcnJ5KSAlIEJBU0UgfCAwO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gIGZvciAoOyAhclstLXJMXTspIHIucG9wKCk7XHJcblxyXG4gIGlmIChjYXJyeSkgKytlO1xyXG4gIGVsc2Ugci5zaGlmdCgpO1xyXG5cclxuICB5LmQgPSByO1xyXG4gIHkuZSA9IGdldEJhc2UxMEV4cG9uZW50KHIsIGUpO1xyXG5cclxuICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBDdG9yLnByZWNpc2lvbiwgQ3Rvci5yb3VuZGluZykgOiB5O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpbiBiYXNlIDIsIHJvdW5kIHRvIGBzZGAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYC5cclxuICpcclxuICogSWYgdGhlIG9wdGlvbmFsIGBzZGAgYXJndW1lbnQgaXMgcHJlc2VudCB0aGVuIHJldHVybiBiaW5hcnkgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAqXHJcbiAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqL1xyXG5QLnRvQmluYXJ5ID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCAyLCBzZCwgcm0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcm91bmRlZCB0byBhIG1heGltdW0gb2YgYGRwYFxyXG4gKiBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIGBybWAgb3IgYHJvdW5kaW5nYCBpZiBgcm1gIGlzIG9taXR0ZWQuXHJcbiAqXHJcbiAqIElmIGBkcGAgaXMgb21pdHRlZCwgcmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gKlxyXG4gKi9cclxuUC50b0RlY2ltYWxQbGFjZXMgPSBQLnRvRFAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIHggPSBuZXcgQ3Rvcih4KTtcclxuICBpZiAoZHAgPT09IHZvaWQgMCkgcmV0dXJuIHg7XHJcblxyXG4gIGNoZWNrSW50MzIoZHAsIDAsIE1BWF9ESUdJVFMpO1xyXG5cclxuICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gIGVsc2UgY2hlY2tJbnQzMihybSwgMCwgOCk7XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZSh4LCBkcCArIHguZSArIDEsIHJtKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gcm91bmRlZCB0b1xyXG4gKiBgZHBgIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gKlxyXG4gKi9cclxuUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gIHZhciBzdHIsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICBpZiAoZHAgPT09IHZvaWQgMCkge1xyXG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgdHJ1ZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNoZWNrSW50MzIoZHAsIDAsIE1BWF9ESUdJVFMpO1xyXG5cclxuICAgIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG5cclxuICAgIHggPSBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgZHAgKyAxLCBybSk7XHJcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB0cnVlLCBkcCArIDEpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/ICctJyArIHN0ciA6IHN0cjtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaW4gbm9ybWFsIChmaXhlZC1wb2ludCkgbm90YXRpb24gdG9cclxuICogYGRwYCBmaXhlZCBkZWNpbWFsIHBsYWNlcyBhbmQgcm91bmRlZCB1c2luZyByb3VuZGluZyBtb2RlIGBybWAgb3IgYHJvdW5kaW5nYCBpZiBgcm1gIGlzXHJcbiAqIG9taXR0ZWQuXHJcbiAqXHJcbiAqIEFzIHdpdGggSmF2YVNjcmlwdCBudW1iZXJzLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLCBidXQgZS5nLiAoLTAuMDAwMDEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICpcclxuICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gKlxyXG4gKiAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLCBidXQgKC0wLjEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICogKC0wKS50b0ZpeGVkKDEpIGlzICcwLjAnLCBidXQgKC0wLjAxKS50b0ZpeGVkKDEpIGlzICctMC4wJy5cclxuICogKC0wKS50b0ZpeGVkKDMpIGlzICcwLjAwMCcuXHJcbiAqICgtMC41KS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAqXHJcbiAqL1xyXG5QLnRvRml4ZWQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgdmFyIHN0ciwgeSxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmIChkcCA9PT0gdm9pZCAwKSB7XHJcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4KTtcclxuICB9IGVsc2Uge1xyXG4gICAgY2hlY2tJbnQzMihkcCwgMCwgTUFYX0RJR0lUUyk7XHJcblxyXG4gICAgaWYgKHJtID09PSB2b2lkIDApIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIGVsc2UgY2hlY2tJbnQzMihybSwgMCwgOCk7XHJcblxyXG4gICAgeSA9IGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBkcCArIHguZSArIDEsIHJtKTtcclxuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHksIGZhbHNlLCBkcCArIHkuZSArIDEpO1xyXG4gIH1cclxuXHJcbiAgLy8gVG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gYWRkIHRoZSBtaW51cyBzaWduIGxvb2sgYXQgdGhlIHZhbHVlIGJlZm9yZSBpdCB3YXMgcm91bmRlZCxcclxuICAvLyBpLmUuIGxvb2sgYXQgYHhgIHJhdGhlciB0aGFuIGB5YC5cclxuICByZXR1cm4geC5pc05lZygpICYmICF4LmlzWmVybygpID8gJy0nICsgc3RyIDogc3RyO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBhcyBhIHNpbXBsZSBmcmFjdGlvbiB3aXRoIGFuIGludGVnZXJcclxuICogbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLlxyXG4gKlxyXG4gKiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkIG1heGltdW1cclxuICogZGVub21pbmF0b3IuIElmIGEgbWF4aW11bSBkZW5vbWluYXRvciBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgZGVub21pbmF0b3Igd2lsbCBiZSB0aGUgbG93ZXN0XHJcbiAqIHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gKlxyXG4gKiBbbWF4RF0ge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gTWF4aW11bSBkZW5vbWluYXRvci4gSW50ZWdlciA+PSAxIGFuZCA8IEluZmluaXR5LlxyXG4gKlxyXG4gKi9cclxuUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1heEQpIHtcclxuICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgaywgbiwgbjAsIG4xLCBwciwgcSwgcixcclxuICAgIHggPSB0aGlzLFxyXG4gICAgeGQgPSB4LmQsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKCF4ZCkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICBuMSA9IGQwID0gbmV3IEN0b3IoMSk7XHJcbiAgZDEgPSBuMCA9IG5ldyBDdG9yKDApO1xyXG5cclxuICBkID0gbmV3IEN0b3IoZDEpO1xyXG4gIGUgPSBkLmUgPSBnZXRQcmVjaXNpb24oeGQpIC0geC5lIC0gMTtcclxuICBrID0gZSAlIExPR19CQVNFO1xyXG4gIGQuZFswXSA9IG1hdGhwb3coMTAsIGsgPCAwID8gTE9HX0JBU0UgKyBrIDogayk7XHJcblxyXG4gIGlmIChtYXhEID09IG51bGwpIHtcclxuXHJcbiAgICAvLyBkIGlzIDEwKiplLCB0aGUgbWluaW11bSBtYXgtZGVub21pbmF0b3IgbmVlZGVkLlxyXG4gICAgbWF4RCA9IGUgPiAwID8gZCA6IG4xO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBuID0gbmV3IEN0b3IobWF4RCk7XHJcbiAgICBpZiAoIW4uaXNJbnQoKSB8fCBuLmx0KG4xKSkgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgbik7XHJcbiAgICBtYXhEID0gbi5ndChkKSA/IChlID4gMCA/IGQgOiBuMSkgOiBuO1xyXG4gIH1cclxuXHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICBuID0gbmV3IEN0b3IoZGlnaXRzVG9TdHJpbmcoeGQpKTtcclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIEN0b3IucHJlY2lzaW9uID0gZSA9IHhkLmxlbmd0aCAqIExPR19CQVNFICogMjtcclxuXHJcbiAgZm9yICg7OykgIHtcclxuICAgIHEgPSBkaXZpZGUobiwgZCwgMCwgMSwgMSk7XHJcbiAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xyXG4gICAgaWYgKGQyLmNtcChtYXhEKSA9PSAxKSBicmVhaztcclxuICAgIGQwID0gZDE7XHJcbiAgICBkMSA9IGQyO1xyXG4gICAgZDIgPSBuMTtcclxuICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyKSk7XHJcbiAgICBuMCA9IGQyO1xyXG4gICAgZDIgPSBkO1xyXG4gICAgZCA9IG4ubWludXMocS50aW1lcyhkMikpO1xyXG4gICAgbiA9IGQyO1xyXG4gIH1cclxuXHJcbiAgZDIgPSBkaXZpZGUobWF4RC5taW51cyhkMCksIGQxLCAwLCAxLCAxKTtcclxuICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcclxuICBkMCA9IGQwLnBsdXMoZDIudGltZXMoZDEpKTtcclxuICBuMC5zID0gbjEucyA9IHgucztcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMT9cclxuICByID0gZGl2aWRlKG4xLCBkMSwgZSwgMSkubWludXMoeCkuYWJzKCkuY21wKGRpdmlkZShuMCwgZDAsIGUsIDEpLm1pbnVzKHgpLmFicygpKSA8IDFcclxuICAgICAgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGluIGJhc2UgMTYsIHJvdW5kIHRvIGBzZGAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYC5cclxuICpcclxuICogSWYgdGhlIG9wdGlvbmFsIGBzZGAgYXJndW1lbnQgaXMgcHJlc2VudCB0aGVuIHJldHVybiBiaW5hcnkgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAqXHJcbiAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqL1xyXG5QLnRvSGV4YWRlY2ltYWwgPSBQLnRvSGV4ID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCAxNiwgc2QsIHJtKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm5zIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5lYXJlc3QgbXVsdGlwbGUgb2YgYHlgIGluIHRoZSBkaXJlY3Rpb24gb2Ygcm91bmRpbmdcclxuICogbW9kZSBgcm1gLCBvciBgRGVjaW1hbC5yb3VuZGluZ2AgaWYgYHJtYCBpcyBvbWl0dGVkLCB0byB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYWx3YXlzIGhhdmUgdGhlIHNhbWUgc2lnbiBhcyB0aGlzIERlY2ltYWwsIHVubGVzcyBlaXRoZXIgdGhpcyBEZWNpbWFsXHJcbiAqIG9yIGB5YCBpcyBOYU4sIGluIHdoaWNoIGNhc2UgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIGFsc28gYmUgTmFOLlxyXG4gKlxyXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdmFsdWUgb2YgYHByZWNpc2lvbmAuXHJcbiAqXHJcbiAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIG1hZ25pdHVkZSB0byByb3VuZCB0byBhIG11bHRpcGxlIG9mLlxyXG4gKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqICd0b05lYXJlc3QoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xyXG4gKiAndG9OZWFyZXN0KCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXHJcbiAqXHJcbiAqL1xyXG5QLnRvTmVhcmVzdCA9IGZ1bmN0aW9uICh5LCBybSkge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICB4ID0gbmV3IEN0b3IoeCk7XHJcblxyXG4gIGlmICh5ID09IG51bGwpIHtcclxuXHJcbiAgICAvLyBJZiB4IGlzIG5vdCBmaW5pdGUsIHJldHVybiB4LlxyXG4gICAgaWYgKCF4LmQpIHJldHVybiB4O1xyXG5cclxuICAgIHkgPSBuZXcgQ3RvcigxKTtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICB9IGVsc2Uge1xyXG4gICAgeSA9IG5ldyBDdG9yKHkpO1xyXG4gICAgaWYgKHJtID09PSB2b2lkIDApIHtcclxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2hlY2tJbnQzMihybSwgMCwgOCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgeCBpcyBub3QgZmluaXRlLCByZXR1cm4geCBpZiB5IGlzIG5vdCBOYU4sIGVsc2UgTmFOLlxyXG4gICAgaWYgKCF4LmQpIHJldHVybiB5LnMgPyB4IDogeTtcclxuXHJcbiAgICAvLyBJZiB5IGlzIG5vdCBmaW5pdGUsIHJldHVybiBJbmZpbml0eSB3aXRoIHRoZSBzaWduIG9mIHggaWYgeSBpcyBJbmZpbml0eSwgZWxzZSBOYU4uXHJcbiAgICBpZiAoIXkuZCkge1xyXG4gICAgICBpZiAoeS5zKSB5LnMgPSB4LnM7XHJcbiAgICAgIHJldHVybiB5O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSWYgeSBpcyBub3QgemVybywgY2FsY3VsYXRlIHRoZSBuZWFyZXN0IG11bHRpcGxlIG9mIHkgdG8geC5cclxuICBpZiAoeS5kWzBdKSB7XHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gICAgeCA9IGRpdmlkZSh4LCB5LCAwLCBybSwgMSkudGltZXMoeSk7XHJcbiAgICBleHRlcm5hbCA9IHRydWU7XHJcbiAgICBmaW5hbGlzZSh4KTtcclxuXHJcbiAgLy8gSWYgeSBpcyB6ZXJvLCByZXR1cm4gemVybyB3aXRoIHRoZSBzaWduIG9mIHguXHJcbiAgfSBlbHNlIHtcclxuICAgIHkucyA9IHgucztcclxuICAgIHggPSB5O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHg7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICogWmVybyBrZWVwcyBpdHMgc2lnbi5cclxuICpcclxuICovXHJcblAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuICt0aGlzO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpbiBiYXNlIDgsIHJvdW5kIHRvIGBzZGAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYC5cclxuICpcclxuICogSWYgdGhlIG9wdGlvbmFsIGBzZGAgYXJndW1lbnQgaXMgcHJlc2VudCB0aGVuIHJldHVybiBiaW5hcnkgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAqXHJcbiAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqL1xyXG5QLnRvT2N0YWwgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgcmV0dXJuIHRvU3RyaW5nQmluYXJ5KHRoaXMsIDgsIHNkLCBybSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByYWlzZWQgdG8gdGhlIHBvd2VyIGB5YCwgcm91bmRlZFxyXG4gKiB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiBFQ01BU2NyaXB0IGNvbXBsaWFudC5cclxuICpcclxuICogICBwb3coeCwgTmFOKSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTmFOXHJcbiAqICAgcG93KHgsIMKxMCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxXHJcblxyXG4gKiAgIHBvdyhOYU4sIG5vbi16ZXJvKSAgICAgICAgICAgICAgICAgICAgPSBOYU5cclxuICogICBwb3coYWJzKHgpID4gMSwgK0luZmluaXR5KSAgICAgICAgICAgID0gK0luZmluaXR5XHJcbiAqICAgcG93KGFicyh4KSA+IDEsIC1JbmZpbml0eSkgICAgICAgICAgICA9ICswXHJcbiAqICAgcG93KGFicyh4KSA9PSAxLCDCsUluZmluaXR5KSAgICAgICAgICAgPSBOYU5cclxuICogICBwb3coYWJzKHgpIDwgMSwgK0luZmluaXR5KSAgICAgICAgICAgID0gKzBcclxuICogICBwb3coYWJzKHgpIDwgMSwgLUluZmluaXR5KSAgICAgICAgICAgID0gK0luZmluaXR5XHJcbiAqICAgcG93KCtJbmZpbml0eSwgeSA+IDApICAgICAgICAgICAgICAgICA9ICtJbmZpbml0eVxyXG4gKiAgIHBvdygrSW5maW5pdHksIHkgPCAwKSAgICAgICAgICAgICAgICAgPSArMFxyXG4gKiAgIHBvdygtSW5maW5pdHksIG9kZCBpbnRlZ2VyID4gMCkgICAgICAgPSAtSW5maW5pdHlcclxuICogICBwb3coLUluZmluaXR5LCBldmVuIGludGVnZXIgPiAwKSAgICAgID0gK0luZmluaXR5XHJcbiAqICAgcG93KC1JbmZpbml0eSwgb2RkIGludGVnZXIgPCAwKSAgICAgICA9IC0wXHJcbiAqICAgcG93KC1JbmZpbml0eSwgZXZlbiBpbnRlZ2VyIDwgMCkgICAgICA9ICswXHJcbiAqICAgcG93KCswLCB5ID4gMCkgICAgICAgICAgICAgICAgICAgICAgICA9ICswXHJcbiAqICAgcG93KCswLCB5IDwgMCkgICAgICAgICAgICAgICAgICAgICAgICA9ICtJbmZpbml0eVxyXG4gKiAgIHBvdygtMCwgb2RkIGludGVnZXIgPiAwKSAgICAgICAgICAgICAgPSAtMFxyXG4gKiAgIHBvdygtMCwgZXZlbiBpbnRlZ2VyID4gMCkgICAgICAgICAgICAgPSArMFxyXG4gKiAgIHBvdygtMCwgb2RkIGludGVnZXIgPCAwKSAgICAgICAgICAgICAgPSAtSW5maW5pdHlcclxuICogICBwb3coLTAsIGV2ZW4gaW50ZWdlciA8IDApICAgICAgICAgICAgID0gK0luZmluaXR5XHJcbiAqICAgcG93KGZpbml0ZSB4IDwgMCwgZmluaXRlIG5vbi1pbnRlZ2VyKSA9IE5hTlxyXG4gKlxyXG4gKiBGb3Igbm9uLWludGVnZXIgb3IgdmVyeSBsYXJnZSBleHBvbmVudHMgcG93KHgsIHkpIGlzIGNhbGN1bGF0ZWQgdXNpbmdcclxuICpcclxuICogICB4XnkgPSBleHAoeSpsbih4KSlcclxuICpcclxuICogQXNzdW1pbmcgdGhlIGZpcnN0IDE1IHJvdW5kaW5nIGRpZ2l0cyBhcmUgZWFjaCBlcXVhbGx5IGxpa2VseSB0byBiZSBhbnkgZGlnaXQgMC05LCB0aGVcclxuICogcHJvYmFiaWxpdHkgb2YgYW4gaW5jb3JyZWN0bHkgcm91bmRlZCByZXN1bHRcclxuICogUChbNDldOXsxNH0gfCBbNTBdMHsxNH0pID0gMiAqIDAuMiAqIDEwXi0xNCA9IDRlLTE1ID0gMS8yLjVlKzE0XHJcbiAqIGkuZS4gMSBpbiAyNTAsMDAwLDAwMCwwMDAsMDAwXHJcbiAqXHJcbiAqIElmIGEgcmVzdWx0IGlzIGluY29ycmVjdGx5IHJvdW5kZWQgdGhlIG1heGltdW0gZXJyb3Igd2lsbCBiZSAxIHVscCAodW5pdCBpbiBsYXN0IHBsYWNlKS5cclxuICpcclxuICogeSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgcG93ZXIgdG8gd2hpY2ggdG8gcmFpc2UgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKi9cclxuUC50b1Bvd2VyID0gUC5wb3cgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBlLCBrLCBwciwgciwgcm0sIHMsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgeW4gPSArKHkgPSBuZXcgQ3Rvcih5KSk7XHJcblxyXG4gIC8vIEVpdGhlciDCsUluZmluaXR5LCBOYU4gb3IgwrEwP1xyXG4gIGlmICgheC5kIHx8ICF5LmQgfHwgIXguZFswXSB8fCAheS5kWzBdKSByZXR1cm4gbmV3IEN0b3IobWF0aHBvdygreCwgeW4pKTtcclxuXHJcbiAgeCA9IG5ldyBDdG9yKHgpO1xyXG5cclxuICBpZiAoeC5lcSgxKSkgcmV0dXJuIHg7XHJcblxyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICBpZiAoeS5lcSgxKSkgcmV0dXJuIGZpbmFsaXNlKHgsIHByLCBybSk7XHJcblxyXG4gIC8vIHkgZXhwb25lbnRcclxuICBlID0gbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuXHJcbiAgLy8gSWYgeSBpcyBhIHNtYWxsIGludGVnZXIgdXNlIHRoZSAnZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcnIGFsZ29yaXRobS5cclxuICBpZiAoZSA+PSB5LmQubGVuZ3RoIC0gMSAmJiAoayA9IHluIDwgMCA/IC15biA6IHluKSA8PSBNQVhfU0FGRV9JTlRFR0VSKSB7XHJcbiAgICByID0gaW50UG93KEN0b3IsIHgsIGssIHByKTtcclxuICAgIHJldHVybiB5LnMgPCAwID8gbmV3IEN0b3IoMSkuZGl2KHIpIDogZmluYWxpc2UociwgcHIsIHJtKTtcclxuICB9XHJcblxyXG4gIHMgPSB4LnM7XHJcblxyXG4gIC8vIGlmIHggaXMgbmVnYXRpdmVcclxuICBpZiAocyA8IDApIHtcclxuXHJcbiAgICAvLyBpZiB5IGlzIG5vdCBhbiBpbnRlZ2VyXHJcbiAgICBpZiAoZSA8IHkuZC5sZW5ndGggLSAxKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuXHJcbiAgICAvLyBSZXN1bHQgaXMgcG9zaXRpdmUgaWYgeCBpcyBuZWdhdGl2ZSBhbmQgdGhlIGxhc3QgZGlnaXQgb2YgaW50ZWdlciB5IGlzIGV2ZW4uXHJcbiAgICBpZiAoKHkuZFtlXSAmIDEpID09IDApIHMgPSAxO1xyXG5cclxuICAgIC8vIGlmIHguZXEoLTEpXHJcbiAgICBpZiAoeC5lID09IDAgJiYgeC5kWzBdID09IDEgJiYgeC5kLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgIHgucyA9IHM7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRXN0aW1hdGUgcmVzdWx0IGV4cG9uZW50LlxyXG4gIC8vIHheeSA9IDEwXmUsICB3aGVyZSBlID0geSAqIGxvZzEwKHgpXHJcbiAgLy8gbG9nMTAoeCkgPSBsb2cxMCh4X3NpZ25pZmljYW5kKSArIHhfZXhwb25lbnRcclxuICAvLyBsb2cxMCh4X3NpZ25pZmljYW5kKSA9IGxuKHhfc2lnbmlmaWNhbmQpIC8gbG4oMTApXHJcbiAgayA9IG1hdGhwb3coK3gsIHluKTtcclxuICBlID0gayA9PSAwIHx8ICFpc0Zpbml0ZShrKVxyXG4gICAgPyBtYXRoZmxvb3IoeW4gKiAoTWF0aC5sb2coJzAuJyArIGRpZ2l0c1RvU3RyaW5nKHguZCkpIC8gTWF0aC5MTjEwICsgeC5lICsgMSkpXHJcbiAgICA6IG5ldyBDdG9yKGsgKyAnJykuZTtcclxuXHJcbiAgLy8gRXhwb25lbnQgZXN0aW1hdGUgbWF5IGJlIGluY29ycmVjdCBlLmcuIHg6IDAuOTk5OTk5OTk5OTk5OTk5OTk5LCB5OiAyLjI5LCBlOiAwLCByLmU6IC0xLlxyXG5cclxuICAvLyBPdmVyZmxvdy91bmRlcmZsb3c/XHJcbiAgaWYgKGUgPiBDdG9yLm1heEUgKyAxIHx8IGUgPCBDdG9yLm1pbkUgLSAxKSByZXR1cm4gbmV3IEN0b3IoZSA+IDAgPyBzIC8gMCA6IDApO1xyXG5cclxuICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gIEN0b3Iucm91bmRpbmcgPSB4LnMgPSAxO1xyXG5cclxuICAvLyBFc3RpbWF0ZSB0aGUgZXh0cmEgZ3VhcmQgZGlnaXRzIG5lZWRlZCB0byBlbnN1cmUgZml2ZSBjb3JyZWN0IHJvdW5kaW5nIGRpZ2l0cyBmcm9tXHJcbiAgLy8gbmF0dXJhbExvZ2FyaXRobSh4KS4gRXhhbXBsZSBvZiBmYWlsdXJlIHdpdGhvdXQgdGhlc2UgZXh0cmEgZGlnaXRzIChwcmVjaXNpb246IDEwKTpcclxuICAvLyBuZXcgRGVjaW1hbCgyLjMyNDU2KS5wb3coJzIwODc5ODc0MzY1MzQ1NjYuNDY0MTEnKVxyXG4gIC8vIHNob3VsZCBiZSAxLjE2MjM3NzgyM2UrNzY0OTE0OTA1MTczODE1LCBidXQgaXMgMS4xNjIzNTU4MjNlKzc2NDkxNDkwNTE3MzgxNVxyXG4gIGsgPSBNYXRoLm1pbigxMiwgKGUgKyAnJykubGVuZ3RoKTtcclxuXHJcbiAgLy8gciA9IHheeSA9IGV4cCh5KmxuKHgpKVxyXG4gIHIgPSBuYXR1cmFsRXhwb25lbnRpYWwoeS50aW1lcyhuYXR1cmFsTG9nYXJpdGhtKHgsIHByICsgaykpLCBwcik7XHJcblxyXG4gIC8vIHIgbWF5IGJlIEluZmluaXR5LCBlLmcuICgwLjk5OTk5OTk5OTk5OTk5OTkpLnBvdygtMWUrNDApXHJcbiAgaWYgKHIuZCkge1xyXG5cclxuICAgIC8vIFRydW5jYXRlIHRvIHRoZSByZXF1aXJlZCBwcmVjaXNpb24gcGx1cyBmaXZlIHJvdW5kaW5nIGRpZ2l0cy5cclxuICAgIHIgPSBmaW5hbGlzZShyLCBwciArIDUsIDEpO1xyXG5cclxuICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdHMgYXJlIFs0OV05OTk5IG9yIFs1MF0wMDAwIGluY3JlYXNlIHRoZSBwcmVjaXNpb24gYnkgMTAgYW5kIHJlY2FsY3VsYXRlXHJcbiAgICAvLyB0aGUgcmVzdWx0LlxyXG4gICAgaWYgKGNoZWNrUm91bmRpbmdEaWdpdHMoci5kLCBwciwgcm0pKSB7XHJcbiAgICAgIGUgPSBwciArIDEwO1xyXG5cclxuICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGluY3JlYXNlZCBwcmVjaXNpb24gcGx1cyBmaXZlIHJvdW5kaW5nIGRpZ2l0cy5cclxuICAgICAgciA9IGZpbmFsaXNlKG5hdHVyYWxFeHBvbmVudGlhbCh5LnRpbWVzKG5hdHVyYWxMb2dhcml0aG0oeCwgZSArIGspKSwgZSksIGUgKyA1LCAxKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciAxNCBuaW5lcyBmcm9tIHRoZSAybmQgcm91bmRpbmcgZGlnaXQgKHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdCBtYXkgYmUgNCBvciA5KS5cclxuICAgICAgaWYgKCtkaWdpdHNUb1N0cmluZyhyLmQpLnNsaWNlKHByICsgMSwgcHIgKyAxNSkgKyAxID09IDFlMTQpIHtcclxuICAgICAgICByID0gZmluYWxpc2UociwgcHIgKyAxLCAwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgci5zID0gcztcclxuICBleHRlcm5hbCA9IHRydWU7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICByZXR1cm4gZmluYWxpc2UociwgcHIsIHJtKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcm91bmRlZCB0byBgc2RgIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gKiB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIFJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbiBpZiBgc2RgIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50XHJcbiAqIHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIG5vcm1hbCBub3RhdGlvbi5cclxuICpcclxuICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICpcclxuICovXHJcblAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgdmFyIHN0cixcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmIChzZCA9PT0gdm9pZCAwKSB7XHJcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB4LmUgPD0gQ3Rvci50b0V4cE5lZyB8fCB4LmUgPj0gQ3Rvci50b0V4cFBvcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xyXG5cclxuICAgIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG5cclxuICAgIHggPSBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgc2QsIHJtKTtcclxuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHNkIDw9IHguZSB8fCB4LmUgPD0gQ3Rvci50b0V4cE5lZywgc2QpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/ICctJyArIHN0ciA6IHN0cjtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGBzZGBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYCwgb3IgdG8gYHByZWNpc2lvbmAgYW5kIGByb3VuZGluZ2AgcmVzcGVjdGl2ZWx5IGlmXHJcbiAqIG9taXR0ZWQuXHJcbiAqXHJcbiAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqICd0b1NEKCkgZGlnaXRzIG91dCBvZiByYW5nZToge3NkfSdcclxuICogJ3RvU0QoKSBkaWdpdHMgbm90IGFuIGludGVnZXI6IHtzZH0nXHJcbiAqICd0b1NEKCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcclxuICogJ3RvU0QoKSByb3VuZGluZyBtb2RlIG91dCBvZiByYW5nZToge3JtfSdcclxuICpcclxuICovXHJcblAudG9TaWduaWZpY2FudERpZ2l0cyA9IFAudG9TRCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICB2YXIgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKHNkID09PSB2b2lkIDApIHtcclxuICAgIHNkID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xyXG5cclxuICAgIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBzZCwgcm0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogUmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoaXMgRGVjaW1hbCBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBncmVhdGVyIHRoYW5cclxuICogYHRvRXhwUG9zYCwgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW4gYHRvRXhwTmVnYC5cclxuICpcclxuICovXHJcblAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB4LmUgPD0gQ3Rvci50b0V4cE5lZyB8fCB4LmUgPj0gQ3Rvci50b0V4cFBvcyk7XHJcblxyXG4gIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyAnLScgKyBzdHIgOiBzdHI7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCB0cnVuY2F0ZWQgdG8gYSB3aG9sZSBudW1iZXIuXHJcbiAqXHJcbiAqL1xyXG5QLnRydW5jYXRlZCA9IFAudHJ1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCB0aGlzLmUgKyAxLCAxKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAqIFVubGlrZSBgdG9TdHJpbmdgLCBuZWdhdGl2ZSB6ZXJvIHdpbGwgaW5jbHVkZSB0aGUgbWludXMgc2lnbi5cclxuICpcclxuICovXHJcblAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgeC5lIDw9IEN0b3IudG9FeHBOZWcgfHwgeC5lID49IEN0b3IudG9FeHBQb3MpO1xyXG5cclxuICByZXR1cm4geC5pc05lZygpID8gJy0nICsgc3RyIDogc3RyO1xyXG59O1xyXG5cclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIERlY2ltYWwucHJvdG90eXBlIChQKSBhbmQvb3IgRGVjaW1hbCBtZXRob2RzLCBhbmQgdGhlaXIgY2FsbGVycy5cclxuXHJcblxyXG4vKlxyXG4gKiAgZGlnaXRzVG9TdHJpbmcgICAgICAgICAgIFAuY3ViZVJvb3QsIFAubG9nYXJpdGhtLCBQLnNxdWFyZVJvb3QsIFAudG9GcmFjdGlvbiwgUC50b1Bvd2VyLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbml0ZVRvU3RyaW5nLCBuYXR1cmFsRXhwb25lbnRpYWwsIG5hdHVyYWxMb2dhcml0aG1cclxuICogIGNoZWNrSW50MzIgICAgICAgICAgICAgICBQLnRvRGVjaW1hbFBsYWNlcywgUC50b0V4cG9uZW50aWFsLCBQLnRvRml4ZWQsIFAudG9OZWFyZXN0LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAudG9QcmVjaXNpb24sIFAudG9TaWduaWZpY2FudERpZ2l0cywgdG9TdHJpbmdCaW5hcnksIHJhbmRvbVxyXG4gKiAgY2hlY2tSb3VuZGluZ0RpZ2l0cyAgICAgIFAubG9nYXJpdGhtLCBQLnRvUG93ZXIsIG5hdHVyYWxFeHBvbmVudGlhbCwgbmF0dXJhbExvZ2FyaXRobVxyXG4gKiAgY29udmVydEJhc2UgICAgICAgICAgICAgIHRvU3RyaW5nQmluYXJ5LCBwYXJzZU90aGVyXHJcbiAqICBjb3MgICAgICAgICAgICAgICAgICAgICAgUC5jb3NcclxuICogIGRpdmlkZSAgICAgICAgICAgICAgICAgICBQLmF0YW5oLCBQLmN1YmVSb290LCBQLmRpdmlkZWRCeSwgUC5kaXZpZGVkVG9JbnRlZ2VyQnksXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5sb2dhcml0aG0sIFAubW9kdWxvLCBQLnNxdWFyZVJvb3QsIFAudGFuLCBQLnRhbmgsIFAudG9GcmFjdGlvbixcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBQLnRvTmVhcmVzdCwgdG9TdHJpbmdCaW5hcnksIG5hdHVyYWxFeHBvbmVudGlhbCwgbmF0dXJhbExvZ2FyaXRobSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0YXlsb3JTZXJpZXMsIGF0YW4yLCBwYXJzZU90aGVyXHJcbiAqICBmaW5hbGlzZSAgICAgICAgICAgICAgICAgUC5hYnNvbHV0ZVZhbHVlLCBQLmF0YW4sIFAuYXRhbmgsIFAuY2VpbCwgUC5jb3MsIFAuY29zaCxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBQLmN1YmVSb290LCBQLmRpdmlkZWRUb0ludGVnZXJCeSwgUC5mbG9vciwgUC5sb2dhcml0aG0sIFAubWludXMsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5tb2R1bG8sIFAubmVnYXRlZCwgUC5wbHVzLCBQLnJvdW5kLCBQLnNpbiwgUC5zaW5oLCBQLnNxdWFyZVJvb3QsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC50YW4sIFAudGltZXMsIFAudG9EZWNpbWFsUGxhY2VzLCBQLnRvRXhwb25lbnRpYWwsIFAudG9GaXhlZCxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBQLnRvTmVhcmVzdCwgUC50b1Bvd2VyLCBQLnRvUHJlY2lzaW9uLCBQLnRvU2lnbmlmaWNhbnREaWdpdHMsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC50cnVuY2F0ZWQsIGRpdmlkZSwgZ2V0TG4xMCwgZ2V0UGksIG5hdHVyYWxFeHBvbmVudGlhbCxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBuYXR1cmFsTG9nYXJpdGhtLCBjZWlsLCBmbG9vciwgcm91bmQsIHRydW5jXHJcbiAqICBmaW5pdGVUb1N0cmluZyAgICAgICAgICAgUC50b0V4cG9uZW50aWFsLCBQLnRvRml4ZWQsIFAudG9QcmVjaXNpb24sIFAudG9TdHJpbmcsIFAudmFsdWVPZixcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmluZ0JpbmFyeVxyXG4gKiAgZ2V0QmFzZTEwRXhwb25lbnQgICAgICAgIFAubWludXMsIFAucGx1cywgUC50aW1lcywgcGFyc2VPdGhlclxyXG4gKiAgZ2V0TG4xMCAgICAgICAgICAgICAgICAgIFAubG9nYXJpdGhtLCBuYXR1cmFsTG9nYXJpdGhtXHJcbiAqICBnZXRQaSAgICAgICAgICAgICAgICAgICAgUC5hY29zLCBQLmFzaW4sIFAuYXRhbiwgdG9MZXNzVGhhbkhhbGZQaSwgYXRhbjJcclxuICogIGdldFByZWNpc2lvbiAgICAgICAgICAgICBQLnByZWNpc2lvbiwgUC50b0ZyYWN0aW9uXHJcbiAqICBnZXRaZXJvU3RyaW5nICAgICAgICAgICAgZGlnaXRzVG9TdHJpbmcsIGZpbml0ZVRvU3RyaW5nXHJcbiAqICBpbnRQb3cgICAgICAgICAgICAgICAgICAgUC50b1Bvd2VyLCBwYXJzZU90aGVyXHJcbiAqICBpc09kZCAgICAgICAgICAgICAgICAgICAgdG9MZXNzVGhhbkhhbGZQaVxyXG4gKiAgbWF4T3JNaW4gICAgICAgICAgICAgICAgIG1heCwgbWluXHJcbiAqICBuYXR1cmFsRXhwb25lbnRpYWwgICAgICAgUC5uYXR1cmFsRXhwb25lbnRpYWwsIFAudG9Qb3dlclxyXG4gKiAgbmF0dXJhbExvZ2FyaXRobSAgICAgICAgIFAuYWNvc2gsIFAuYXNpbmgsIFAuYXRhbmgsIFAubG9nYXJpdGhtLCBQLm5hdHVyYWxMb2dhcml0aG0sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC50b1Bvd2VyLCBuYXR1cmFsRXhwb25lbnRpYWxcclxuICogIG5vbkZpbml0ZVRvU3RyaW5nICAgICAgICBmaW5pdGVUb1N0cmluZywgdG9TdHJpbmdCaW5hcnlcclxuICogIHBhcnNlRGVjaW1hbCAgICAgICAgICAgICBEZWNpbWFsXHJcbiAqICBwYXJzZU90aGVyICAgICAgICAgICAgICAgRGVjaW1hbFxyXG4gKiAgc2luICAgICAgICAgICAgICAgICAgICAgIFAuc2luXHJcbiAqICB0YXlsb3JTZXJpZXMgICAgICAgICAgICAgUC5jb3NoLCBQLnNpbmgsIGNvcywgc2luXHJcbiAqICB0b0xlc3NUaGFuSGFsZlBpICAgICAgICAgUC5jb3MsIFAuc2luXHJcbiAqICB0b1N0cmluZ0JpbmFyeSAgICAgICAgICAgUC50b0JpbmFyeSwgUC50b0hleGFkZWNpbWFsLCBQLnRvT2N0YWxcclxuICogIHRydW5jYXRlICAgICAgICAgICAgICAgICBpbnRQb3dcclxuICpcclxuICogIFRocm93czogICAgICAgICAgICAgICAgICBQLmxvZ2FyaXRobSwgUC5wcmVjaXNpb24sIFAudG9GcmFjdGlvbiwgY2hlY2tJbnQzMiwgZ2V0TG4xMCwgZ2V0UGksXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0dXJhbExvZ2FyaXRobSwgY29uZmlnLCBwYXJzZU90aGVyLCByYW5kb20sIERlY2ltYWxcclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gZGlnaXRzVG9TdHJpbmcoZCkge1xyXG4gIHZhciBpLCBrLCB3cyxcclxuICAgIGluZGV4T2ZMYXN0V29yZCA9IGQubGVuZ3RoIC0gMSxcclxuICAgIHN0ciA9ICcnLFxyXG4gICAgdyA9IGRbMF07XHJcblxyXG4gIGlmIChpbmRleE9mTGFzdFdvcmQgPiAwKSB7XHJcbiAgICBzdHIgKz0gdztcclxuICAgIGZvciAoaSA9IDE7IGkgPCBpbmRleE9mTGFzdFdvcmQ7IGkrKykge1xyXG4gICAgICB3cyA9IGRbaV0gKyAnJztcclxuICAgICAgayA9IExPR19CQVNFIC0gd3MubGVuZ3RoO1xyXG4gICAgICBpZiAoaykgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XHJcbiAgICAgIHN0ciArPSB3cztcclxuICAgIH1cclxuXHJcbiAgICB3ID0gZFtpXTtcclxuICAgIHdzID0gdyArICcnO1xyXG4gICAgayA9IExPR19CQVNFIC0gd3MubGVuZ3RoO1xyXG4gICAgaWYgKGspIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xyXG4gIH0gZWxzZSBpZiAodyA9PT0gMCkge1xyXG4gICAgcmV0dXJuICcwJztcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcyBvZiBsYXN0IHcuXHJcbiAgZm9yICg7IHcgJSAxMCA9PT0gMDspIHcgLz0gMTA7XHJcblxyXG4gIHJldHVybiBzdHIgKyB3O1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gY2hlY2tJbnQzMihpLCBtaW4sIG1heCkge1xyXG4gIGlmIChpICE9PSB+fmkgfHwgaSA8IG1pbiB8fCBpID4gbWF4KSB7XHJcbiAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBpKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBDaGVjayA1IHJvdW5kaW5nIGRpZ2l0cyBpZiBgcmVwZWF0aW5nYCBpcyBudWxsLCA0IG90aGVyd2lzZS5cclxuICogYHJlcGVhdGluZyA9PSBudWxsYCBpZiBjYWxsZXIgaXMgYGxvZ2Agb3IgYHBvd2AsXHJcbiAqIGByZXBlYXRpbmcgIT0gbnVsbGAgaWYgY2FsbGVyIGlzIGBuYXR1cmFsTG9nYXJpdGhtYCBvciBgbmF0dXJhbEV4cG9uZW50aWFsYC5cclxuICovXHJcbmZ1bmN0aW9uIGNoZWNrUm91bmRpbmdEaWdpdHMoZCwgaSwgcm0sIHJlcGVhdGluZykge1xyXG4gIHZhciBkaSwgaywgciwgcmQ7XHJcblxyXG4gIC8vIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBhcnJheSBkLlxyXG4gIGZvciAoayA9IGRbMF07IGsgPj0gMTA7IGsgLz0gMTApIC0taTtcclxuXHJcbiAgLy8gSXMgdGhlIHJvdW5kaW5nIGRpZ2l0IGluIHRoZSBmaXJzdCB3b3JkIG9mIGQ/XHJcbiAgaWYgKC0taSA8IDApIHtcclxuICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICBkaSA9IDA7XHJcbiAgfSBlbHNlIHtcclxuICAgIGRpID0gTWF0aC5jZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XHJcbiAgICBpICU9IExPR19CQVNFO1xyXG4gIH1cclxuXHJcbiAgLy8gaSBpcyB0aGUgaW5kZXggKDAgLSA2KSBvZiB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgLy8gRS5nLiBpZiB3aXRoaW4gdGhlIHdvcmQgMzQ4NzU2MyB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQgaXMgNSxcclxuICAvLyB0aGVuIGkgPSA0LCBrID0gMTAwMCwgcmQgPSAzNDg3NTYzICUgMTAwMCA9IDU2M1xyXG4gIGsgPSBtYXRocG93KDEwLCBMT0dfQkFTRSAtIGkpO1xyXG4gIHJkID0gZFtkaV0gJSBrIHwgMDtcclxuXHJcbiAgaWYgKHJlcGVhdGluZyA9PSBudWxsKSB7XHJcbiAgICBpZiAoaSA8IDMpIHtcclxuICAgICAgaWYgKGkgPT0gMCkgcmQgPSByZCAvIDEwMCB8IDA7XHJcbiAgICAgIGVsc2UgaWYgKGkgPT0gMSkgcmQgPSByZCAvIDEwIHwgMDtcclxuICAgICAgciA9IHJtIDwgNCAmJiByZCA9PSA5OTk5OSB8fCBybSA+IDMgJiYgcmQgPT0gNDk5OTkgfHwgcmQgPT0gNTAwMDAgfHwgcmQgPT0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHIgPSAocm0gPCA0ICYmIHJkICsgMSA9PSBrIHx8IHJtID4gMyAmJiByZCArIDEgPT0gayAvIDIpICYmXHJcbiAgICAgICAgKGRbZGkgKyAxXSAvIGsgLyAxMDAgfCAwKSA9PSBtYXRocG93KDEwLCBpIC0gMikgLSAxIHx8XHJcbiAgICAgICAgICAocmQgPT0gayAvIDIgfHwgcmQgPT0gMCkgJiYgKGRbZGkgKyAxXSAvIGsgLyAxMDAgfCAwKSA9PSAwO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoaSA8IDQpIHtcclxuICAgICAgaWYgKGkgPT0gMCkgcmQgPSByZCAvIDEwMDAgfCAwO1xyXG4gICAgICBlbHNlIGlmIChpID09IDEpIHJkID0gcmQgLyAxMDAgfCAwO1xyXG4gICAgICBlbHNlIGlmIChpID09IDIpIHJkID0gcmQgLyAxMCB8IDA7XHJcbiAgICAgIHIgPSAocmVwZWF0aW5nIHx8IHJtIDwgNCkgJiYgcmQgPT0gOTk5OSB8fCAhcmVwZWF0aW5nICYmIHJtID4gMyAmJiByZCA9PSA0OTk5O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgciA9ICgocmVwZWF0aW5nIHx8IHJtIDwgNCkgJiYgcmQgKyAxID09IGsgfHxcclxuICAgICAgKCFyZXBlYXRpbmcgJiYgcm0gPiAzKSAmJiByZCArIDEgPT0gayAvIDIpICYmXHJcbiAgICAgICAgKGRbZGkgKyAxXSAvIGsgLyAxMDAwIHwgMCkgPT0gbWF0aHBvdygxMCwgaSAtIDMpIC0gMTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiByO1xyXG59XHJcblxyXG5cclxuLy8gQ29udmVydCBzdHJpbmcgb2YgYGJhc2VJbmAgdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBgYmFzZU91dGAuXHJcbi8vIEVnLiBjb252ZXJ0QmFzZSgnMjU1JywgMTAsIDE2KSByZXR1cm5zIFsxNSwgMTVdLlxyXG4vLyBFZy4gY29udmVydEJhc2UoJ2ZmJywgMTYsIDEwKSByZXR1cm5zIFsyLCA1LCA1XS5cclxuZnVuY3Rpb24gY29udmVydEJhc2Uoc3RyLCBiYXNlSW4sIGJhc2VPdXQpIHtcclxuICB2YXIgaixcclxuICAgIGFyciA9IFswXSxcclxuICAgIGFyckwsXHJcbiAgICBpID0gMCxcclxuICAgIHN0ckwgPSBzdHIubGVuZ3RoO1xyXG5cclxuICBmb3IgKDsgaSA8IHN0ckw7KSB7XHJcbiAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07KSBhcnJbYXJyTF0gKj0gYmFzZUluO1xyXG4gICAgYXJyWzBdICs9IE5VTUVSQUxTLmluZGV4T2Yoc3RyLmNoYXJBdChpKyspKTtcclxuICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcclxuICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XHJcbiAgICAgICAgaWYgKGFycltqICsgMV0gPT09IHZvaWQgMCkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcclxuICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBjb3MoeCkgPSAxIC0geF4yLzIhICsgeF40LzQhIC0gLi4uXHJcbiAqIHx4fCA8IHBpLzJcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGNvc2luZShDdG9yLCB4KSB7XHJcbiAgdmFyIGssIGxlbiwgeTtcclxuXHJcbiAgaWYgKHguaXNaZXJvKCkpIHJldHVybiB4O1xyXG5cclxuICAvLyBBcmd1bWVudCByZWR1Y3Rpb246IGNvcyg0eCkgPSA4Kihjb3NeNCh4KSAtIGNvc14yKHgpKSArIDFcclxuICAvLyBpLmUuIGNvcyh4KSA9IDgqKGNvc140KHgvNCkgLSBjb3NeMih4LzQpKSArIDFcclxuXHJcbiAgLy8gRXN0aW1hdGUgdGhlIG9wdGltdW0gbnVtYmVyIG9mIHRpbWVzIHRvIHVzZSB0aGUgYXJndW1lbnQgcmVkdWN0aW9uLlxyXG4gIGxlbiA9IHguZC5sZW5ndGg7XHJcbiAgaWYgKGxlbiA8IDMyKSB7XHJcbiAgICBrID0gTWF0aC5jZWlsKGxlbiAvIDMpO1xyXG4gICAgeSA9ICgxIC8gdGlueVBvdyg0LCBrKSkudG9TdHJpbmcoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgayA9IDE2O1xyXG4gICAgeSA9ICcyLjMyODMwNjQzNjUzODY5NjI4OTA2MjVlLTEwJztcclxuICB9XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uICs9IGs7XHJcblxyXG4gIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMSwgeC50aW1lcyh5KSwgbmV3IEN0b3IoMSkpO1xyXG5cclxuICAvLyBSZXZlcnNlIGFyZ3VtZW50IHJlZHVjdGlvblxyXG4gIGZvciAodmFyIGkgPSBrOyBpLS07KSB7XHJcbiAgICB2YXIgY29zMnggPSB4LnRpbWVzKHgpO1xyXG4gICAgeCA9IGNvczJ4LnRpbWVzKGNvczJ4KS5taW51cyhjb3MyeCkudGltZXMoOCkucGx1cygxKTtcclxuICB9XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uIC09IGs7XHJcblxyXG4gIHJldHVybiB4O1xyXG59XHJcblxyXG5cclxuLypcclxuICogUGVyZm9ybSBkaXZpc2lvbiBpbiB0aGUgc3BlY2lmaWVkIGJhc2UuXHJcbiAqL1xyXG52YXIgZGl2aWRlID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgLy8gQXNzdW1lcyBub24temVybyB4IGFuZCBrLCBhbmQgaGVuY2Ugbm9uLXplcm8gcmVzdWx0LlxyXG4gIGZ1bmN0aW9uIG11bHRpcGx5SW50ZWdlcih4LCBrLCBiYXNlKSB7XHJcbiAgICB2YXIgdGVtcCxcclxuICAgICAgY2FycnkgPSAwLFxyXG4gICAgICBpID0geC5sZW5ndGg7XHJcblxyXG4gICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07KSB7XHJcbiAgICAgIHRlbXAgPSB4W2ldICogayArIGNhcnJ5O1xyXG4gICAgICB4W2ldID0gdGVtcCAlIGJhc2UgfCAwO1xyXG4gICAgICBjYXJyeSA9IHRlbXAgLyBiYXNlIHwgMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2FycnkpIHgudW5zaGlmdChjYXJyeSk7XHJcblxyXG4gICAgcmV0dXJuIHg7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xyXG4gICAgdmFyIGksIHI7XHJcblxyXG4gICAgaWYgKGFMICE9IGJMKSB7XHJcbiAgICAgIHIgPSBhTCA+IGJMID8gMSA6IC0xO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yIChpID0gciA9IDA7IGkgPCBhTDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xyXG4gICAgICAgICAgciA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHI7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBhTCwgYmFzZSkge1xyXG4gICAgdmFyIGkgPSAwO1xyXG5cclxuICAgIC8vIFN1YnRyYWN0IGIgZnJvbSBhLlxyXG4gICAgZm9yICg7IGFMLS07KSB7XHJcbiAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgIGkgPSBhW2FMXSA8IGJbYUxdID8gMSA6IDA7XHJcbiAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTspIGEuc2hpZnQoKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiAoeCwgeSwgcHIsIHJtLCBkcCwgYmFzZSkge1xyXG4gICAgdmFyIGNtcCwgZSwgaSwgaywgbG9nQmFzZSwgbW9yZSwgcHJvZCwgcHJvZEwsIHEsIHFkLCByZW0sIHJlbUwsIHJlbTAsIHNkLCB0LCB4aSwgeEwsIHlkMCxcclxuICAgICAgeUwsIHl6LFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgc2lnbiA9IHgucyA9PSB5LnMgPyAxIDogLTEsXHJcbiAgICAgIHhkID0geC5kLFxyXG4gICAgICB5ZCA9IHkuZDtcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgaWYgKCF4ZCB8fCAheGRbMF0gfHwgIXlkIHx8ICF5ZFswXSkge1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBDdG9yKC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGQgPyB5ZCAmJiB4ZFswXSA9PSB5ZFswXSA6ICF5ZCkgPyBOYU4gOlxyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIHggaXMgMCBvciB5IGlzIMKxSW5maW5pdHksIG9yIHJldHVybiDCsUluZmluaXR5IGFzIHkgaXMgMC5cclxuICAgICAgICB4ZCAmJiB4ZFswXSA9PSAwIHx8ICF5ZCA/IHNpZ24gKiAwIDogc2lnbiAvIDApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChiYXNlKSB7XHJcbiAgICAgIGxvZ0Jhc2UgPSAxO1xyXG4gICAgICBlID0geC5lIC0geS5lO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgIGxvZ0Jhc2UgPSBMT0dfQkFTRTtcclxuICAgICAgZSA9IG1hdGhmbG9vcih4LmUgLyBsb2dCYXNlKSAtIG1hdGhmbG9vcih5LmUgLyBsb2dCYXNlKTtcclxuICAgIH1cclxuXHJcbiAgICB5TCA9IHlkLmxlbmd0aDtcclxuICAgIHhMID0geGQubGVuZ3RoO1xyXG4gICAgcSA9IG5ldyBDdG9yKHNpZ24pO1xyXG4gICAgcWQgPSBxLmQgPSBbXTtcclxuXHJcbiAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoYW4gZS5cclxuICAgIC8vIFRoZSBkaWdpdCBhcnJheSBvZiBhIERlY2ltYWwgZnJvbSB0b1N0cmluZ0JpbmFyeSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoaSA9IDA7IHlkW2ldID09ICh4ZFtpXSB8fCAwKTsgaSsrKTtcclxuXHJcbiAgICBpZiAoeWRbaV0gPiAoeGRbaV0gfHwgMCkpIGUtLTtcclxuXHJcbiAgICBpZiAocHIgPT0gbnVsbCkge1xyXG4gICAgICBzZCA9IHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIH0gZWxzZSBpZiAoZHApIHtcclxuICAgICAgc2QgPSBwciArICh4LmUgLSB5LmUpICsgMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNkID0gcHI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNkIDwgMCkge1xyXG4gICAgICBxZC5wdXNoKDEpO1xyXG4gICAgICBtb3JlID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IHByZWNpc2lvbiBpbiBudW1iZXIgb2YgYmFzZSAxMCBkaWdpdHMgdG8gYmFzZSAxZTcgZGlnaXRzLlxyXG4gICAgICBzZCA9IHNkIC8gbG9nQmFzZSArIDIgfCAwO1xyXG4gICAgICBpID0gMDtcclxuXHJcbiAgICAgIC8vIGRpdmlzb3IgPCAxZTdcclxuICAgICAgaWYgKHlMID09IDEpIHtcclxuICAgICAgICBrID0gMDtcclxuICAgICAgICB5ZCA9IHlkWzBdO1xyXG4gICAgICAgIHNkKys7XHJcblxyXG4gICAgICAgIC8vIGsgaXMgdGhlIGNhcnJ5LlxyXG4gICAgICAgIGZvciAoOyAoaSA8IHhMIHx8IGspICYmIHNkLS07IGkrKykge1xyXG4gICAgICAgICAgdCA9IGsgKiBiYXNlICsgKHhkW2ldIHx8IDApO1xyXG4gICAgICAgICAgcWRbaV0gPSB0IC8geWQgfCAwO1xyXG4gICAgICAgICAgayA9IHQgJSB5ZCB8IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtb3JlID0gayB8fCBpIDwgeEw7XHJcblxyXG4gICAgICAvLyBkaXZpc29yID49IDFlN1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBOb3JtYWxpc2UgeGQgYW5kIHlkIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWQgaXMgPj0gYmFzZS8yXHJcbiAgICAgICAgayA9IGJhc2UgLyAoeWRbMF0gKyAxKSB8IDA7XHJcblxyXG4gICAgICAgIGlmIChrID4gMSkge1xyXG4gICAgICAgICAgeWQgPSBtdWx0aXBseUludGVnZXIoeWQsIGssIGJhc2UpO1xyXG4gICAgICAgICAgeGQgPSBtdWx0aXBseUludGVnZXIoeGQsIGssIGJhc2UpO1xyXG4gICAgICAgICAgeUwgPSB5ZC5sZW5ndGg7XHJcbiAgICAgICAgICB4TCA9IHhkLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHhpID0geUw7XHJcbiAgICAgICAgcmVtID0geGQuc2xpY2UoMCwgeUwpO1xyXG4gICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gICAgICAgIGZvciAoOyByZW1MIDwgeUw7KSByZW1bcmVtTCsrXSA9IDA7XHJcblxyXG4gICAgICAgIHl6ID0geWQuc2xpY2UoKTtcclxuICAgICAgICB5ei51bnNoaWZ0KDApO1xyXG4gICAgICAgIHlkMCA9IHlkWzBdO1xyXG5cclxuICAgICAgICBpZiAoeWRbMV0gPj0gYmFzZSAvIDIpICsreWQwO1xyXG5cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICBrID0gMDtcclxuXHJcbiAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgIGNtcCA9IGNvbXBhcmUoeWQsIHJlbSwgeUwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBrLlxyXG4gICAgICAgICAgICByZW0wID0gcmVtWzBdO1xyXG4gICAgICAgICAgICBpZiAoeUwgIT0gcmVtTCkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGsgd2lsbCBiZSBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBrID0gcmVtMCAvIHlkMCB8IDA7XHJcblxyXG4gICAgICAgICAgICAvLyAgQWxnb3JpdGhtOlxyXG4gICAgICAgICAgICAvLyAgMS4gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdCAoaylcclxuICAgICAgICAgICAgLy8gIDIuIGlmIHByb2R1Y3QgPiByZW1haW5kZXI6IHByb2R1Y3QgLT0gZGl2aXNvciwgay0tXHJcbiAgICAgICAgICAgIC8vICAzLiByZW1haW5kZXIgLT0gcHJvZHVjdFxyXG4gICAgICAgICAgICAvLyAgNC4gaWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIgYXQgMjpcclxuICAgICAgICAgICAgLy8gICAgNS4gY29tcGFyZSBuZXcgcmVtYWluZGVyIGFuZCBkaXZpc29yXHJcbiAgICAgICAgICAgIC8vICAgIDYuIElmIHJlbWFpbmRlciA+IGRpdmlzb3I6IHJlbWFpbmRlciAtPSBkaXZpc29yLCBrKytcclxuXHJcbiAgICAgICAgICAgIGlmIChrID4gMSkge1xyXG4gICAgICAgICAgICAgIGlmIChrID49IGJhc2UpIGsgPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHlJbnRlZ2VyKHlkLCBrLCBiYXNlKTtcclxuICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAvLyBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBjbXAgPSBjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBwcm9kdWN0ID4gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIGlmIChjbXAgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgay0tO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWQsIHByb2RMLCBiYXNlKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAvLyBJZiBrIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5ZCBhbmQgcmVtIGFnYWluIGJlbG93LCBzbyBjaGFuZ2UgY21wIHRvIDFcclxuICAgICAgICAgICAgICAvLyB0byBhdm9pZCBpdC4gSWYgayBpcyAxIHRoZXJlIGlzIGEgbmVlZCB0byBjb21wYXJlIHlkIGFuZCByZW0gYWdhaW4gYmVsb3cuXHJcbiAgICAgICAgICAgICAgaWYgKGsgPT0gMCkgY21wID0gayA9IDE7XHJcbiAgICAgICAgICAgICAgcHJvZCA9IHlkLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpIHByb2QudW5zaGlmdCgwKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgcHJvZCwgcmVtTCwgYmFzZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBwcm9kdWN0IHdhcyA8IHByZXZpb3VzIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xyXG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIG5ldyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgY21wID0gY29tcGFyZSh5ZCwgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIGlmIChjbXAgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICBrKys7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5ZCwgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIGsrKztcclxuICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgfSAgICAvLyBpZiBjbXAgPT09IDEsIGsgd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgLy8gQWRkIHRoZSBuZXh0IGRpZ2l0LCBrLCB0byB0aGUgcmVzdWx0IGFycmF5LlxyXG4gICAgICAgICAgcWRbaSsrXSA9IGs7XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICBpZiAoY21wICYmIHJlbVswXSkge1xyXG4gICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhkW3hpXSB8fCAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVtID0gW3hkW3hpXV07XHJcbiAgICAgICAgICAgIHJlbUwgPSAxO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPT0gdm9pZCAwKSAmJiBzZC0tKTtcclxuXHJcbiAgICAgICAgbW9yZSA9IHJlbVswXSAhPT0gdm9pZCAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBMZWFkaW5nIHplcm8/XHJcbiAgICAgIGlmICghcWRbMF0pIHFkLnNoaWZ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbG9nQmFzZSBpcyAxIHdoZW4gZGl2aWRlIGlzIGJlaW5nIHVzZWQgZm9yIGJhc2UgY29udmVyc2lvbi5cclxuICAgIGlmIChsb2dCYXNlID09IDEpIHtcclxuICAgICAgcS5lID0gZTtcclxuICAgICAgaW5leGFjdCA9IG1vcmU7XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFkWzBdLlxyXG4gICAgICBmb3IgKGkgPSAxLCBrID0gcWRbMF07IGsgPj0gMTA7IGsgLz0gMTApIGkrKztcclxuICAgICAgcS5lID0gaSArIGUgKiBsb2dCYXNlIC0gMTtcclxuXHJcbiAgICAgIGZpbmFsaXNlKHEsIGRwID8gcHIgKyBxLmUgKyAxIDogcHIsIHJtLCBtb3JlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcTtcclxuICB9O1xyXG59KSgpO1xyXG5cclxuXHJcbi8qXHJcbiAqIFJvdW5kIGB4YCB0byBgc2RgIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGBybWAuXHJcbiAqIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAqL1xyXG4gZnVuY3Rpb24gZmluYWxpc2UoeCwgc2QsIHJtLCBpc1RydW5jYXRlZCkge1xyXG4gIHZhciBkaWdpdHMsIGksIGosIGssIHJkLCByb3VuZFVwLCB3LCB4ZCwgeGRpLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIC8vIERvbid0IHJvdW5kIGlmIHNkIGlzIG51bGwgb3IgdW5kZWZpbmVkLlxyXG4gIG91dDogaWYgKHNkICE9IG51bGwpIHtcclxuICAgIHhkID0geC5kO1xyXG5cclxuICAgIC8vIEluZmluaXR5L05hTi5cclxuICAgIGlmICgheGQpIHJldHVybiB4O1xyXG5cclxuICAgIC8vIHJkOiB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgLy8gdzogdGhlIHdvcmQgb2YgeGQgY29udGFpbmluZyByZCwgYSBiYXNlIDFlNyBudW1iZXIuXHJcbiAgICAvLyB4ZGk6IHRoZSBpbmRleCBvZiB3IHdpdGhpbiB4ZC5cclxuICAgIC8vIGRpZ2l0czogdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygdy5cclxuICAgIC8vIGk6IHdoYXQgd291bGQgYmUgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiB3IGlmIGFsbCB0aGUgbnVtYmVycyB3ZXJlIDcgZGlnaXRzIGxvbmcgKGkuZS4gaWZcclxuICAgIC8vIHRoZXkgaGFkIGxlYWRpbmcgemVyb3MpXHJcbiAgICAvLyBqOiBpZiA+IDAsIHRoZSBhY3R1YWwgaW5kZXggb2YgcmQgd2l0aGluIHcgKGlmIDwgMCwgcmQgaXMgYSBsZWFkaW5nIHplcm8pLlxyXG5cclxuICAgIC8vIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBkaWdpdHMgYXJyYXkgeGQuXHJcbiAgICBmb3IgKGRpZ2l0cyA9IDEsIGsgPSB4ZFswXTsgayA+PSAxMDsgayAvPSAxMCkgZGlnaXRzKys7XHJcbiAgICBpID0gc2QgLSBkaWdpdHM7XHJcblxyXG4gICAgLy8gSXMgdGhlIHJvdW5kaW5nIGRpZ2l0IGluIHRoZSBmaXJzdCB3b3JkIG9mIHhkP1xyXG4gICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgIGogPSBzZDtcclxuICAgICAgdyA9IHhkW3hkaSA9IDBdO1xyXG5cclxuICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIHcuXHJcbiAgICAgIHJkID0gdyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKSAlIDEwIHwgMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHhkaSA9IE1hdGguY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xyXG4gICAgICBrID0geGQubGVuZ3RoO1xyXG4gICAgICBpZiAoeGRpID49IGspIHtcclxuICAgICAgICBpZiAoaXNUcnVuY2F0ZWQpIHtcclxuXHJcbiAgICAgICAgICAvLyBOZWVkZWQgYnkgYG5hdHVyYWxFeHBvbmVudGlhbGAsIGBuYXR1cmFsTG9nYXJpdGhtYCBhbmQgYHNxdWFyZVJvb3RgLlxyXG4gICAgICAgICAgZm9yICg7IGsrKyA8PSB4ZGk7KSB4ZC5wdXNoKDApO1xyXG4gICAgICAgICAgdyA9IHJkID0gMDtcclxuICAgICAgICAgIGRpZ2l0cyA9IDE7XHJcbiAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG4gICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdyA9IGsgPSB4ZFt4ZGldO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygdy5cclxuICAgICAgICBmb3IgKGRpZ2l0cyA9IDE7IGsgPj0gMTA7IGsgLz0gMTApIGRpZ2l0cysrO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiB3LlxyXG4gICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIHcsIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiB3IGlzIGdpdmVuIGJ5IExPR19CQVNFIC0gZGlnaXRzLlxyXG4gICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkaWdpdHM7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiB3LlxyXG4gICAgICAgIHJkID0gaiA8IDAgPyAwIDogdyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKSAlIDEwIHwgMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFyZSB0aGVyZSBhbnkgbm9uLXplcm8gZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdD9cclxuICAgIGlzVHJ1bmNhdGVkID0gaXNUcnVuY2F0ZWQgfHwgc2QgPCAwIHx8XHJcbiAgICAgIHhkW3hkaSArIDFdICE9PSB2b2lkIDAgfHwgKGogPCAwID8gdyA6IHcgJSBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSkpO1xyXG5cclxuICAgIC8vIFRoZSBleHByZXNzaW9uIGB3ICUgbWF0aHBvdygxMCwgZGlnaXRzIC0gaiAtIDEpYCByZXR1cm5zIGFsbCB0aGUgZGlnaXRzIG9mIHcgdG8gdGhlIHJpZ2h0XHJcbiAgICAvLyBvZiB0aGUgZGlnaXQgYXQgKGxlZnQtdG8tcmlnaHQpIGluZGV4IGosIGUuZy4gaWYgdyBpcyA5MDg3MTQgYW5kIGogaXMgMiwgdGhlIGV4cHJlc3Npb25cclxuICAgIC8vIHdpbGwgZ2l2ZSA3MTQuXHJcblxyXG4gICAgcm91bmRVcCA9IHJtIDwgNFxyXG4gICAgICA/IChyZCB8fCBpc1RydW5jYXRlZCkgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKHJtID09IDQgfHwgaXNUcnVuY2F0ZWQgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkaWdpdCB0byB0aGUgbGVmdCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgb2RkLlxyXG4gICAgICAgICgoaSA+IDAgPyBqID4gMCA/IHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqKSA6IDAgOiB4ZFt4ZGkgLSAxXSkgJSAxMCkgJiAxIHx8XHJcbiAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgaWYgKHNkIDwgMSB8fCAheGRbMF0pIHtcclxuICAgICAgeGQubGVuZ3RoID0gMDtcclxuICAgICAgaWYgKHJvdW5kVXApIHtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCBzZCB0byBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICBzZCAtPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgIHhkWzBdID0gbWF0aHBvdygxMCwgKExPR19CQVNFIC0gc2QgJSBMT0dfQkFTRSkgJSBMT0dfQkFTRSk7XHJcbiAgICAgICAgeC5lID0gLXNkIHx8IDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgeGRbMF0gPSB4LmUgPSAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cclxuICAgIGlmIChpID09IDApIHtcclxuICAgICAgeGQubGVuZ3RoID0geGRpO1xyXG4gICAgICBrID0gMTtcclxuICAgICAgeGRpLS07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB4ZC5sZW5ndGggPSB4ZGkgKyAxO1xyXG4gICAgICBrID0gbWF0aHBvdygxMCwgTE9HX0JBU0UgLSBpKTtcclxuXHJcbiAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIHcuXHJcbiAgICAgIHhkW3hkaV0gPSBqID4gMCA/ICh3IC8gbWF0aHBvdygxMCwgZGlnaXRzIC0gaikgJSBtYXRocG93KDEwLCBqKSB8IDApICogayA6IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJvdW5kVXApIHtcclxuICAgICAgZm9yICg7Oykge1xyXG5cclxuICAgICAgICAvLyBJcyB0aGUgZGlnaXQgdG8gYmUgcm91bmRlZCB1cCBpbiB0aGUgZmlyc3Qgd29yZCBvZiB4ZD9cclxuICAgICAgICBpZiAoeGRpID09IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4ZFswXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4ZFswXTsgaiA+PSAxMDsgaiAvPSAxMCkgaSsrO1xyXG4gICAgICAgICAgaiA9IHhkWzBdICs9IGs7XHJcbiAgICAgICAgICBmb3IgKGsgPSAxOyBqID49IDEwOyBqIC89IDEwKSBrKys7XHJcblxyXG4gICAgICAgICAgLy8gaWYgaSAhPSBrIHRoZSBsZW5ndGggaGFzIGluY3JlYXNlZC5cclxuICAgICAgICAgIGlmIChpICE9IGspIHtcclxuICAgICAgICAgICAgeC5lKys7XHJcbiAgICAgICAgICAgIGlmICh4ZFswXSA9PSBCQVNFKSB4ZFswXSA9IDE7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHhkW3hkaV0gKz0gaztcclxuICAgICAgICAgIGlmICh4ZFt4ZGldICE9IEJBU0UpIGJyZWFrO1xyXG4gICAgICAgICAgeGRbeGRpLS1dID0gMDtcclxuICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoaSA9IHhkLmxlbmd0aDsgeGRbLS1pXSA9PT0gMDspIHhkLnBvcCgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGV4dGVybmFsKSB7XHJcblxyXG4gICAgLy8gT3ZlcmZsb3c/XHJcbiAgICBpZiAoeC5lID4gQ3Rvci5tYXhFKSB7XHJcblxyXG4gICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgeC5kID0gbnVsbDtcclxuICAgICAgeC5lID0gTmFOO1xyXG5cclxuICAgIC8vIFVuZGVyZmxvdz9cclxuICAgIH0gZWxzZSBpZiAoeC5lIDwgQ3Rvci5taW5FKSB7XHJcblxyXG4gICAgICAvLyBaZXJvLlxyXG4gICAgICB4LmUgPSAwO1xyXG4gICAgICB4LmQgPSBbMF07XHJcbiAgICAgIC8vIEN0b3IudW5kZXJmbG93ID0gdHJ1ZTtcclxuICAgIH0gLy8gZWxzZSBDdG9yLnVuZGVyZmxvdyA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHg7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBmaW5pdGVUb1N0cmluZyh4LCBpc0V4cCwgc2QpIHtcclxuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5vbkZpbml0ZVRvU3RyaW5nKHgpO1xyXG4gIHZhciBrLFxyXG4gICAgZSA9IHguZSxcclxuICAgIHN0ciA9IGRpZ2l0c1RvU3RyaW5nKHguZCksXHJcbiAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICBpZiAoaXNFeHApIHtcclxuICAgIGlmIChzZCAmJiAoayA9IHNkIC0gbGVuKSA+IDApIHtcclxuICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSArIGdldFplcm9TdHJpbmcoayk7XHJcbiAgICB9IGVsc2UgaWYgKGxlbiA+IDEpIHtcclxuICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKTtcclxuICAgIH1cclxuXHJcbiAgICBzdHIgPSBzdHIgKyAoeC5lIDwgMCA/ICdlJyA6ICdlKycpICsgeC5lO1xyXG4gIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuICAgIHN0ciA9ICcwLicgKyBnZXRaZXJvU3RyaW5nKC1lIC0gMSkgKyBzdHI7XHJcbiAgICBpZiAoc2QgJiYgKGsgPSBzZCAtIGxlbikgPiAwKSBzdHIgKz0gZ2V0WmVyb1N0cmluZyhrKTtcclxuICB9IGVsc2UgaWYgKGUgPj0gbGVuKSB7XHJcbiAgICBzdHIgKz0gZ2V0WmVyb1N0cmluZyhlICsgMSAtIGxlbik7XHJcbiAgICBpZiAoc2QgJiYgKGsgPSBzZCAtIGUgLSAxKSA+IDApIHN0ciA9IHN0ciArICcuJyArIGdldFplcm9TdHJpbmcoayk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICgoayA9IGUgKyAxKSA8IGxlbikgc3RyID0gc3RyLnNsaWNlKDAsIGspICsgJy4nICsgc3RyLnNsaWNlKGspO1xyXG4gICAgaWYgKHNkICYmIChrID0gc2QgLSBsZW4pID4gMCkge1xyXG4gICAgICBpZiAoZSArIDEgPT09IGxlbikgc3RyICs9ICcuJztcclxuICAgICAgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyO1xyXG59XHJcblxyXG5cclxuLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50IGZyb20gdGhlIGJhc2UgMWU3IGV4cG9uZW50LlxyXG5mdW5jdGlvbiBnZXRCYXNlMTBFeHBvbmVudChkaWdpdHMsIGUpIHtcclxuICB2YXIgdyA9IGRpZ2l0c1swXTtcclxuXHJcbiAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBkaWdpdHMgYXJyYXkuXHJcbiAgZm9yICggZSAqPSBMT0dfQkFTRTsgdyA+PSAxMDsgdyAvPSAxMCkgZSsrO1xyXG4gIHJldHVybiBlO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0TG4xMChDdG9yLCBzZCwgcHIpIHtcclxuICBpZiAoc2QgPiBMTjEwX1BSRUNJU0lPTikge1xyXG5cclxuICAgIC8vIFJlc2V0IGdsb2JhbCBzdGF0ZSBpbiBjYXNlIHRoZSBleGNlcHRpb24gaXMgY2F1Z2h0LlxyXG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gICAgaWYgKHByKSBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gICAgdGhyb3cgRXJyb3IocHJlY2lzaW9uTGltaXRFeGNlZWRlZCk7XHJcbiAgfVxyXG4gIHJldHVybiBmaW5hbGlzZShuZXcgQ3RvcihMTjEwKSwgc2QsIDEsIHRydWUpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0UGkoQ3Rvciwgc2QsIHJtKSB7XHJcbiAgaWYgKHNkID4gUElfUFJFQ0lTSU9OKSB0aHJvdyBFcnJvcihwcmVjaXNpb25MaW1pdEV4Y2VlZGVkKTtcclxuICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoUEkpLCBzZCwgcm0sIHRydWUpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0UHJlY2lzaW9uKGRpZ2l0cykge1xyXG4gIHZhciB3ID0gZGlnaXRzLmxlbmd0aCAtIDEsXHJcbiAgICBsZW4gPSB3ICogTE9HX0JBU0UgKyAxO1xyXG5cclxuICB3ID0gZGlnaXRzW3ddO1xyXG5cclxuICAvLyBJZiBub24temVyby4uLlxyXG4gIGlmICh3KSB7XHJcblxyXG4gICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCB3b3JkLlxyXG4gICAgZm9yICg7IHcgJSAxMCA9PSAwOyB3IC89IDEwKSBsZW4tLTtcclxuXHJcbiAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IHdvcmQuXHJcbiAgICBmb3IgKHcgPSBkaWdpdHNbMF07IHcgPj0gMTA7IHcgLz0gMTApIGxlbisrO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGxlbjtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldFplcm9TdHJpbmcoaykge1xyXG4gIHZhciB6cyA9ICcnO1xyXG4gIGZvciAoOyBrLS07KSB6cyArPSAnMCc7XHJcbiAgcmV0dXJuIHpzO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIERlY2ltYWwgYHhgIHRvIHRoZSBwb3dlciBgbmAsIHdoZXJlIGBuYCBpcyBhblxyXG4gKiBpbnRlZ2VyIG9mIHR5cGUgbnVtYmVyLlxyXG4gKlxyXG4gKiBJbXBsZW1lbnRzICdleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZycuIENhbGxlZCBieSBgcG93YCBhbmQgYHBhcnNlT3RoZXJgLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gaW50UG93KEN0b3IsIHgsIG4sIHByKSB7XHJcbiAgdmFyIGlzVHJ1bmNhdGVkLFxyXG4gICAgciA9IG5ldyBDdG9yKDEpLFxyXG5cclxuICAgIC8vIE1heCBuIG9mIDkwMDcxOTkyNTQ3NDA5OTEgdGFrZXMgNTMgbG9vcCBpdGVyYXRpb25zLlxyXG4gICAgLy8gTWF4aW11bSBkaWdpdHMgYXJyYXkgbGVuZ3RoOyBsZWF2ZXMgWzI4LCAzNF0gZ3VhcmQgZGlnaXRzLlxyXG4gICAgayA9IE1hdGguY2VpbChwciAvIExPR19CQVNFICsgNCk7XHJcblxyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gIGZvciAoOzspIHtcclxuICAgIGlmIChuICUgMikge1xyXG4gICAgICByID0gci50aW1lcyh4KTtcclxuICAgICAgaWYgKHRydW5jYXRlKHIuZCwgaykpIGlzVHJ1bmNhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBuID0gbWF0aGZsb29yKG4gLyAyKTtcclxuICAgIGlmIChuID09PSAwKSB7XHJcblxyXG4gICAgICAvLyBUbyBlbnN1cmUgY29ycmVjdCByb3VuZGluZyB3aGVuIHIuZCBpcyB0cnVuY2F0ZWQsIGluY3JlbWVudCB0aGUgbGFzdCB3b3JkIGlmIGl0IGlzIHplcm8uXHJcbiAgICAgIG4gPSByLmQubGVuZ3RoIC0gMTtcclxuICAgICAgaWYgKGlzVHJ1bmNhdGVkICYmIHIuZFtuXSA9PT0gMCkgKytyLmRbbl07XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHggPSB4LnRpbWVzKHgpO1xyXG4gICAgdHJ1bmNhdGUoeC5kLCBrKTtcclxuICB9XHJcblxyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgcmV0dXJuIHI7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgcmV0dXJuIG4uZFtuLmQubGVuZ3RoIC0gMV0gJiAxO1xyXG59XHJcblxyXG5cclxuLypcclxuICogSGFuZGxlIGBtYXhgIGFuZCBgbWluYC4gYGx0Z3RgIGlzICdsdCcgb3IgJ2d0Jy5cclxuICovXHJcbmZ1bmN0aW9uIG1heE9yTWluKEN0b3IsIGFyZ3MsIGx0Z3QpIHtcclxuICB2YXIgeSxcclxuICAgIHggPSBuZXcgQ3RvcihhcmdzWzBdKSxcclxuICAgIGkgPSAwO1xyXG5cclxuICBmb3IgKDsgKytpIDwgYXJncy5sZW5ndGg7KSB7XHJcbiAgICB5ID0gbmV3IEN0b3IoYXJnc1tpXSk7XHJcbiAgICBpZiAoIXkucykge1xyXG4gICAgICB4ID0geTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9IGVsc2UgaWYgKHhbbHRndF0oeSkpIHtcclxuICAgICAgeCA9IHk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4geDtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGV4cG9uZW50aWFsIG9mIGB4YCByb3VuZGVkIHRvIGBzZGAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzLlxyXG4gKlxyXG4gKiBUYXlsb3IvTWFjbGF1cmluIHNlcmllcy5cclxuICpcclxuICogZXhwKHgpID0geF4wLzAhICsgeF4xLzEhICsgeF4yLzIhICsgeF4zLzMhICsgLi4uXHJcbiAqXHJcbiAqIEFyZ3VtZW50IHJlZHVjdGlvbjpcclxuICogICBSZXBlYXQgeCA9IHggLyAzMiwgayArPSA1LCB1bnRpbCB8eHwgPCAwLjFcclxuICogICBleHAoeCkgPSBleHAoeCAvIDJeayleKDJeaylcclxuICpcclxuICogUHJldmlvdXNseSwgdGhlIGFyZ3VtZW50IHdhcyBpbml0aWFsbHkgcmVkdWNlZCBieVxyXG4gKiBleHAoeCkgPSBleHAocikgKiAxMF5rICB3aGVyZSByID0geCAtIGsgKiBsbjEwLCBrID0gZmxvb3IoeCAvIGxuMTApXHJcbiAqIHRvIGZpcnN0IHB1dCByIGluIHRoZSByYW5nZSBbMCwgbG4xMF0sIGJlZm9yZSBkaXZpZGluZyBieSAzMiB1bnRpbCB8eHwgPCAwLjEsIGJ1dCB0aGlzIHdhc1xyXG4gKiBmb3VuZCB0byBiZSBzbG93ZXIgdGhhbiBqdXN0IGRpdmlkaW5nIHJlcGVhdGVkbHkgYnkgMzIgYXMgYWJvdmUuXHJcbiAqXHJcbiAqIE1heCBpbnRlZ2VyIGFyZ3VtZW50OiBleHAoJzIwNzIzMjY1ODM2OTQ2NDEzJykgPSA2LjNlKzkwMDAwMDAwMDAwMDAwMDBcclxuICogTWluIGludGVnZXIgYXJndW1lbnQ6IGV4cCgnLTIwNzIzMjY1ODM2OTQ2NDExJykgPSAxLjJlLTkwMDAwMDAwMDAwMDAwMDBcclxuICogKE1hdGggb2JqZWN0IGludGVnZXIgbWluL21heDogTWF0aC5leHAoNzA5KSA9IDguMmUrMzA3LCBNYXRoLmV4cCgtNzQ1KSA9IDVlLTMyNClcclxuICpcclxuICogIGV4cChJbmZpbml0eSkgID0gSW5maW5pdHlcclxuICogIGV4cCgtSW5maW5pdHkpID0gMFxyXG4gKiAgZXhwKE5hTikgICAgICAgPSBOYU5cclxuICogIGV4cCjCsTApICAgICAgICA9IDFcclxuICpcclxuICogIGV4cCh4KSBpcyBub24tdGVybWluYXRpbmcgZm9yIGFueSBmaW5pdGUsIG5vbi16ZXJvIHguXHJcbiAqXHJcbiAqICBUaGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGNvcnJlY3RseSByb3VuZGVkLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gbmF0dXJhbEV4cG9uZW50aWFsKHgsIHNkKSB7XHJcbiAgdmFyIGRlbm9taW5hdG9yLCBndWFyZCwgaiwgcG93LCBzdW0sIHQsIHdwcixcclxuICAgIHJlcCA9IDAsXHJcbiAgICBpID0gMCxcclxuICAgIGsgPSAwLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmcsXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG5cclxuICAvLyAwL05hTi9JbmZpbml0eT9cclxuICBpZiAoIXguZCB8fCAheC5kWzBdIHx8IHguZSA+IDE3KSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBDdG9yKHguZFxyXG4gICAgICA/ICF4LmRbMF0gPyAxIDogeC5zIDwgMCA/IDAgOiAxIC8gMFxyXG4gICAgICA6IHgucyA/IHgucyA8IDAgPyAwIDogeCA6IDAgLyAwKTtcclxuICB9XHJcblxyXG4gIGlmIChzZCA9PSBudWxsKSB7XHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gICAgd3ByID0gcHI7XHJcbiAgfSBlbHNlIHtcclxuICAgIHdwciA9IHNkO1xyXG4gIH1cclxuXHJcbiAgdCA9IG5ldyBDdG9yKDAuMDMxMjUpO1xyXG5cclxuICAvLyB3aGlsZSBhYnMoeCkgPj0gMC4xXHJcbiAgd2hpbGUgKHguZSA+IC0yKSB7XHJcblxyXG4gICAgLy8geCA9IHggLyAyXjVcclxuICAgIHggPSB4LnRpbWVzKHQpO1xyXG4gICAgayArPSA1O1xyXG4gIH1cclxuXHJcbiAgLy8gVXNlIDIgKiBsb2cxMCgyXmspICsgNSAoZW1waXJpY2FsbHkgZGVyaXZlZCkgdG8gZXN0aW1hdGUgdGhlIGluY3JlYXNlIGluIHByZWNpc2lvblxyXG4gIC8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhlIGZpcnN0IDQgcm91bmRpbmcgZGlnaXRzIGFyZSBjb3JyZWN0LlxyXG4gIGd1YXJkID0gTWF0aC5sb2cobWF0aHBvdygyLCBrKSkgLyBNYXRoLkxOMTAgKiAyICsgNSB8IDA7XHJcbiAgd3ByICs9IGd1YXJkO1xyXG4gIGRlbm9taW5hdG9yID0gcG93ID0gc3VtID0gbmV3IEN0b3IoMSk7XHJcbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHI7XHJcblxyXG4gIGZvciAoOzspIHtcclxuICAgIHBvdyA9IGZpbmFsaXNlKHBvdy50aW1lcyh4KSwgd3ByLCAxKTtcclxuICAgIGRlbm9taW5hdG9yID0gZGVub21pbmF0b3IudGltZXMoKytpKTtcclxuICAgIHQgPSBzdW0ucGx1cyhkaXZpZGUocG93LCBkZW5vbWluYXRvciwgd3ByLCAxKSk7XHJcblxyXG4gICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgd3ByKSA9PT0gZGlnaXRzVG9TdHJpbmcoc3VtLmQpLnNsaWNlKDAsIHdwcikpIHtcclxuICAgICAgaiA9IGs7XHJcbiAgICAgIHdoaWxlIChqLS0pIHN1bSA9IGZpbmFsaXNlKHN1bS50aW1lcyhzdW0pLCB3cHIsIDEpO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBmaXJzdCA0IHJvdW5kaW5nIGRpZ2l0cyBhcmUgWzQ5XTk5OS5cclxuICAgICAgLy8gSWYgc28sIHJlcGVhdCB0aGUgc3VtbWF0aW9uIHdpdGggYSBoaWdoZXIgcHJlY2lzaW9uLCBvdGhlcndpc2VcclxuICAgICAgLy8gZS5nLiB3aXRoIHByZWNpc2lvbjogMTgsIHJvdW5kaW5nOiAxXHJcbiAgICAgIC8vIGV4cCgxOC40MDQyNzI0NjI1OTUwMzQwODM1Njc3OTM5MTk4NDM3NjEpID0gOTgzNzI1NjAuMTIyOTk5OTk5OSAoc2hvdWxkIGJlIDk4MzcyNTYwLjEyMylcclxuICAgICAgLy8gYHdwciAtIGd1YXJkYCBpcyB0aGUgaW5kZXggb2YgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgIGlmIChzZCA9PSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmIChyZXAgPCAzICYmIGNoZWNrUm91bmRpbmdEaWdpdHMoc3VtLmQsIHdwciAtIGd1YXJkLCBybSwgcmVwKSkge1xyXG4gICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgKz0gMTA7XHJcbiAgICAgICAgICBkZW5vbWluYXRvciA9IHBvdyA9IHQgPSBuZXcgQ3RvcigxKTtcclxuICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgcmVwKys7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBmaW5hbGlzZShzdW0sIEN0b3IucHJlY2lzaW9uID0gcHIsIHJtLCBleHRlcm5hbCA9IHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdW0gPSB0O1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiBgeGAgcm91bmRlZCB0byBgc2RgIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cy5cclxuICpcclxuICogIGxuKC1uKSAgICAgICAgPSBOYU5cclxuICogIGxuKDApICAgICAgICAgPSAtSW5maW5pdHlcclxuICogIGxuKC0wKSAgICAgICAgPSAtSW5maW5pdHlcclxuICogIGxuKDEpICAgICAgICAgPSAwXHJcbiAqICBsbihJbmZpbml0eSkgID0gSW5maW5pdHlcclxuICogIGxuKC1JbmZpbml0eSkgPSBOYU5cclxuICogIGxuKE5hTikgICAgICAgPSBOYU5cclxuICpcclxuICogIGxuKG4pIChuICE9IDEpIGlzIG5vbi10ZXJtaW5hdGluZy5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIG5hdHVyYWxMb2dhcml0aG0oeSwgc2QpIHtcclxuICB2YXIgYywgYzAsIGRlbm9taW5hdG9yLCBlLCBudW1lcmF0b3IsIHJlcCwgc3VtLCB0LCB3cHIsIHgxLCB4MixcclxuICAgIG4gPSAxLFxyXG4gICAgZ3VhcmQgPSAxMCxcclxuICAgIHggPSB5LFxyXG4gICAgeGQgPSB4LmQsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZyxcclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb247XHJcblxyXG4gIC8vIElzIHggbmVnYXRpdmUgb3IgSW5maW5pdHksIE5hTiwgMCBvciAxP1xyXG4gIGlmICh4LnMgPCAwIHx8ICF4ZCB8fCAheGRbMF0gfHwgIXguZSAmJiB4ZFswXSA9PSAxICYmIHhkLmxlbmd0aCA9PSAxKSB7XHJcbiAgICByZXR1cm4gbmV3IEN0b3IoeGQgJiYgIXhkWzBdID8gLTEgLyAwIDogeC5zICE9IDEgPyBOYU4gOiB4ZCA/IDAgOiB4KTtcclxuICB9XHJcblxyXG4gIGlmIChzZCA9PSBudWxsKSB7XHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gICAgd3ByID0gcHI7XHJcbiAgfSBlbHNlIHtcclxuICAgIHdwciA9IHNkO1xyXG4gIH1cclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgKz0gZ3VhcmQ7XHJcbiAgYyA9IGRpZ2l0c1RvU3RyaW5nKHhkKTtcclxuICBjMCA9IGMuY2hhckF0KDApO1xyXG5cclxuICBpZiAoTWF0aC5hYnMoZSA9IHguZSkgPCAxLjVlMTUpIHtcclxuXHJcbiAgICAvLyBBcmd1bWVudCByZWR1Y3Rpb24uXHJcbiAgICAvLyBUaGUgc2VyaWVzIGNvbnZlcmdlcyBmYXN0ZXIgdGhlIGNsb3NlciB0aGUgYXJndW1lbnQgaXMgdG8gMSwgc28gdXNpbmdcclxuICAgIC8vIGxuKGFeYikgPSBiICogbG4oYSksICAgbG4oYSkgPSBsbihhXmIpIC8gYlxyXG4gICAgLy8gbXVsdGlwbHkgdGhlIGFyZ3VtZW50IGJ5IGl0c2VsZiB1bnRpbCB0aGUgbGVhZGluZyBkaWdpdHMgb2YgdGhlIHNpZ25pZmljYW5kIGFyZSA3LCA4LCA5LFxyXG4gICAgLy8gMTAsIDExLCAxMiBvciAxMywgcmVjb3JkaW5nIHRoZSBudW1iZXIgb2YgbXVsdGlwbGljYXRpb25zIHNvIHRoZSBzdW0gb2YgdGhlIHNlcmllcyBjYW5cclxuICAgIC8vIGxhdGVyIGJlIGRpdmlkZWQgYnkgdGhpcyBudW1iZXIsIHRoZW4gc2VwYXJhdGUgb3V0IHRoZSBwb3dlciBvZiAxMCB1c2luZ1xyXG4gICAgLy8gbG4oYSoxMF5iKSA9IGxuKGEpICsgYipsbigxMCkuXHJcblxyXG4gICAgLy8gbWF4IG4gaXMgMjEgKGdpdmVzIDAuOSwgMS4wIG9yIDEuMSkgKDllMTUgLyAyMSA9IDQuMmUxNCkuXHJcbiAgICAvL3doaWxlIChjMCA8IDkgJiYgYzAgIT0gMSB8fCBjMCA9PSAxICYmIGMuY2hhckF0KDEpID4gMSkge1xyXG4gICAgLy8gbWF4IG4gaXMgNiAoZ2l2ZXMgMC43IC0gMS4zKVxyXG4gICAgd2hpbGUgKGMwIDwgNyAmJiBjMCAhPSAxIHx8IGMwID09IDEgJiYgYy5jaGFyQXQoMSkgPiAzKSB7XHJcbiAgICAgIHggPSB4LnRpbWVzKHkpO1xyXG4gICAgICBjID0gZGlnaXRzVG9TdHJpbmcoeC5kKTtcclxuICAgICAgYzAgPSBjLmNoYXJBdCgwKTtcclxuICAgICAgbisrO1xyXG4gICAgfVxyXG5cclxuICAgIGUgPSB4LmU7XHJcblxyXG4gICAgaWYgKGMwID4gMSkge1xyXG4gICAgICB4ID0gbmV3IEN0b3IoJzAuJyArIGMpO1xyXG4gICAgICBlKys7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB4ID0gbmV3IEN0b3IoYzAgKyAnLicgKyBjLnNsaWNlKDEpKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG5cclxuICAgIC8vIFRoZSBhcmd1bWVudCByZWR1Y3Rpb24gbWV0aG9kIGFib3ZlIG1heSByZXN1bHQgaW4gb3ZlcmZsb3cgaWYgdGhlIGFyZ3VtZW50IHkgaXMgYSBtYXNzaXZlXHJcbiAgICAvLyBudW1iZXIgd2l0aCBleHBvbmVudCA+PSAxNTAwMDAwMDAwMDAwMDAwICg5ZTE1IC8gNiA9IDEuNWUxNSksIHNvIGluc3RlYWQgcmVjYWxsIHRoaXNcclxuICAgIC8vIGZ1bmN0aW9uIHVzaW5nIGxuKHgqMTBeZSkgPSBsbih4KSArIGUqbG4oMTApLlxyXG4gICAgdCA9IGdldExuMTAoQ3Rvciwgd3ByICsgMiwgcHIpLnRpbWVzKGUgKyAnJyk7XHJcbiAgICB4ID0gbmF0dXJhbExvZ2FyaXRobShuZXcgQ3RvcihjMCArICcuJyArIGMuc2xpY2UoMSkpLCB3cHIgLSBndWFyZCkucGx1cyh0KTtcclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcblxyXG4gICAgcmV0dXJuIHNkID09IG51bGwgPyBmaW5hbGlzZSh4LCBwciwgcm0sIGV4dGVybmFsID0gdHJ1ZSkgOiB4O1xyXG4gIH1cclxuXHJcbiAgLy8geDEgaXMgeCByZWR1Y2VkIHRvIGEgdmFsdWUgbmVhciAxLlxyXG4gIHgxID0geDtcclxuXHJcbiAgLy8gVGF5bG9yIHNlcmllcy5cclxuICAvLyBsbih5KSA9IGxuKCgxICsgeCkvKDEgLSB4KSkgPSAyKHggKyB4XjMvMyArIHheNS81ICsgeF43LzcgKyAuLi4pXHJcbiAgLy8gd2hlcmUgeCA9ICh5IC0gMSkvKHkgKyAxKSAgICAofHh8IDwgMSlcclxuICBzdW0gPSBudW1lcmF0b3IgPSB4ID0gZGl2aWRlKHgubWludXMoMSksIHgucGx1cygxKSwgd3ByLCAxKTtcclxuICB4MiA9IGZpbmFsaXNlKHgudGltZXMoeCksIHdwciwgMSk7XHJcbiAgZGVub21pbmF0b3IgPSAzO1xyXG5cclxuICBmb3IgKDs7KSB7XHJcbiAgICBudW1lcmF0b3IgPSBmaW5hbGlzZShudW1lcmF0b3IudGltZXMoeDIpLCB3cHIsIDEpO1xyXG4gICAgdCA9IHN1bS5wbHVzKGRpdmlkZShudW1lcmF0b3IsIG5ldyBDdG9yKGRlbm9taW5hdG9yKSwgd3ByLCAxKSk7XHJcblxyXG4gICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgd3ByKSA9PT0gZGlnaXRzVG9TdHJpbmcoc3VtLmQpLnNsaWNlKDAsIHdwcikpIHtcclxuICAgICAgc3VtID0gc3VtLnRpbWVzKDIpO1xyXG5cclxuICAgICAgLy8gUmV2ZXJzZSB0aGUgYXJndW1lbnQgcmVkdWN0aW9uLiBDaGVjayB0aGF0IGUgaXMgbm90IDAgYmVjYXVzZSwgYmVzaWRlcyBwcmV2ZW50aW5nIGFuXHJcbiAgICAgIC8vIHVubmVjZXNzYXJ5IGNhbGN1bGF0aW9uLCAtMCArIDAgPSArMCBhbmQgdG8gZW5zdXJlIGNvcnJlY3Qgcm91bmRpbmcgLTAgbmVlZHMgdG8gc3RheSAtMC5cclxuICAgICAgaWYgKGUgIT09IDApIHN1bSA9IHN1bS5wbHVzKGdldExuMTAoQ3Rvciwgd3ByICsgMiwgcHIpLnRpbWVzKGUgKyAnJykpO1xyXG4gICAgICBzdW0gPSBkaXZpZGUoc3VtLCBuZXcgQ3RvcihuKSwgd3ByLCAxKTtcclxuXHJcbiAgICAgIC8vIElzIHJtID4gMyBhbmQgdGhlIGZpcnN0IDQgcm91bmRpbmcgZGlnaXRzIDQ5OTksIG9yIHJtIDwgNCAob3IgdGhlIHN1bW1hdGlvbiBoYXNcclxuICAgICAgLy8gYmVlbiByZXBlYXRlZCBwcmV2aW91c2x5KSBhbmQgdGhlIGZpcnN0IDQgcm91bmRpbmcgZGlnaXRzIDk5OTk/XHJcbiAgICAgIC8vIElmIHNvLCByZXN0YXJ0IHRoZSBzdW1tYXRpb24gd2l0aCBhIGhpZ2hlciBwcmVjaXNpb24sIG90aGVyd2lzZVxyXG4gICAgICAvLyBlLmcuIHdpdGggcHJlY2lzaW9uOiAxMiwgcm91bmRpbmc6IDFcclxuICAgICAgLy8gbG4oMTM1NTIwMDI4LjYxMjYwOTE3MTQyNjUzODE1MzMpID0gMTguNzI0NjI5OTk5OSB3aGVuIGl0IHNob3VsZCBiZSAxOC43MjQ2My5cclxuICAgICAgLy8gYHdwciAtIGd1YXJkYCBpcyB0aGUgaW5kZXggb2YgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgIGlmIChzZCA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGNoZWNrUm91bmRpbmdEaWdpdHMoc3VtLmQsIHdwciAtIGd1YXJkLCBybSwgcmVwKSkge1xyXG4gICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgKz0gZ3VhcmQ7XHJcbiAgICAgICAgICB0ID0gbnVtZXJhdG9yID0geCA9IGRpdmlkZSh4MS5taW51cygxKSwgeDEucGx1cygxKSwgd3ByLCAxKTtcclxuICAgICAgICAgIHgyID0gZmluYWxpc2UoeC50aW1lcyh4KSwgd3ByLCAxKTtcclxuICAgICAgICAgIGRlbm9taW5hdG9yID0gcmVwID0gMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIGZpbmFsaXNlKHN1bSwgQ3Rvci5wcmVjaXNpb24gPSBwciwgcm0sIGV4dGVybmFsID0gdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN1bSA9IHQ7XHJcbiAgICBkZW5vbWluYXRvciArPSAyO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8vIMKxSW5maW5pdHksIE5hTi5cclxuZnVuY3Rpb24gbm9uRmluaXRlVG9TdHJpbmcoeCkge1xyXG4gIC8vIFVuc2lnbmVkLlxyXG4gIHJldHVybiBTdHJpbmcoeC5zICogeC5zIC8gMCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBQYXJzZSB0aGUgdmFsdWUgb2YgYSBuZXcgRGVjaW1hbCBgeGAgZnJvbSBzdHJpbmcgYHN0cmAuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZURlY2ltYWwoeCwgc3RyKSB7XHJcbiAgdmFyIGUsIGksIGxlbjtcclxuXHJcbiAgLy8gRGVjaW1hbCBwb2ludD9cclxuICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuXHJcbiAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICBpZiAoKGkgPSBzdHIuc2VhcmNoKC9lL2kpKSA+IDApIHtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXHJcbiAgICBpZiAoZSA8IDApIGUgPSBpO1xyXG4gICAgZSArPSArc3RyLnNsaWNlKGkgKyAxKTtcclxuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSk7XHJcbiAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgIC8vIEludGVnZXIuXHJcbiAgICBlID0gc3RyLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gIGZvciAoaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrKTtcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQobGVuIC0gMSkgPT09IDQ4OyAtLWxlbik7XHJcbiAgc3RyID0gc3RyLnNsaWNlKGksIGxlbik7XHJcblxyXG4gIGlmIChzdHIpIHtcclxuICAgIGxlbiAtPSBpO1xyXG4gICAgeC5lID0gZSA9IGUgLSBpIC0gMTtcclxuICAgIHguZCA9IFtdO1xyXG5cclxuICAgIC8vIFRyYW5zZm9ybSBiYXNlXHJcblxyXG4gICAgLy8gZSBpcyB0aGUgYmFzZSAxMCBleHBvbmVudC5cclxuICAgIC8vIGkgaXMgd2hlcmUgdG8gc2xpY2Ugc3RyIHRvIGdldCB0aGUgZmlyc3Qgd29yZCBvZiB0aGUgZGlnaXRzIGFycmF5LlxyXG4gICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgIGlmIChlIDwgMCkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICBpZiAoaSA8IGxlbikge1xyXG4gICAgICBpZiAoaSkgeC5kLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XHJcbiAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOykgeC5kLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XHJcbiAgICAgIHN0ciA9IHN0ci5zbGljZShpKTtcclxuICAgICAgaSA9IExPR19CQVNFIC0gc3RyLmxlbmd0aDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGkgLT0gbGVuO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoOyBpLS07KSBzdHIgKz0gJzAnO1xyXG4gICAgeC5kLnB1c2goK3N0cik7XHJcblxyXG4gICAgaWYgKGV4dGVybmFsKSB7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgaWYgKHguZSA+IHguY29uc3RydWN0b3IubWF4RSkge1xyXG5cclxuICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICB4LmQgPSBudWxsO1xyXG4gICAgICAgIHguZSA9IE5hTjtcclxuXHJcbiAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgfSBlbHNlIGlmICh4LmUgPCB4LmNvbnN0cnVjdG9yLm1pbkUpIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4LmUgPSAwO1xyXG4gICAgICAgIHguZCA9IFswXTtcclxuICAgICAgICAvLyB4LmNvbnN0cnVjdG9yLnVuZGVyZmxvdyA9IHRydWU7XHJcbiAgICAgIH0gLy8gZWxzZSB4LmNvbnN0cnVjdG9yLnVuZGVyZmxvdyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcblxyXG4gICAgLy8gWmVyby5cclxuICAgIHguZSA9IDA7XHJcbiAgICB4LmQgPSBbMF07XHJcbiAgfVxyXG5cclxuICByZXR1cm4geDtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFBhcnNlIHRoZSB2YWx1ZSBvZiBhIG5ldyBEZWNpbWFsIGB4YCBmcm9tIGEgc3RyaW5nIGBzdHJgLCB3aGljaCBpcyBub3QgYSBkZWNpbWFsIHZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VPdGhlcih4LCBzdHIpIHtcclxuICB2YXIgYmFzZSwgQ3RvciwgZGl2aXNvciwgaSwgaXNGbG9hdCwgbGVuLCBwLCB4ZCwgeGU7XHJcblxyXG4gIGlmIChzdHIuaW5kZXhPZignXycpID4gLTEpIHtcclxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csICckMScpO1xyXG4gICAgaWYgKGlzRGVjaW1hbC50ZXN0KHN0cikpIHJldHVybiBwYXJzZURlY2ltYWwoeCwgc3RyKTtcclxuICB9IGVsc2UgaWYgKHN0ciA9PT0gJ0luZmluaXR5JyB8fCBzdHIgPT09ICdOYU4nKSB7XHJcbiAgICBpZiAoIStzdHIpIHgucyA9IE5hTjtcclxuICAgIHguZSA9IE5hTjtcclxuICAgIHguZCA9IG51bGw7XHJcbiAgICByZXR1cm4geDtcclxuICB9XHJcblxyXG4gIGlmIChpc0hleC50ZXN0KHN0cikpICB7XHJcbiAgICBiYXNlID0gMTY7XHJcbiAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcclxuICB9IGVsc2UgaWYgKGlzQmluYXJ5LnRlc3Qoc3RyKSkgIHtcclxuICAgIGJhc2UgPSAyO1xyXG4gIH0gZWxzZSBpZiAoaXNPY3RhbC50ZXN0KHN0cikpICB7XHJcbiAgICBiYXNlID0gODtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgc3RyKTtcclxuICB9XHJcblxyXG4gIC8vIElzIHRoZXJlIGEgYmluYXJ5IGV4cG9uZW50IHBhcnQ/XHJcbiAgaSA9IHN0ci5zZWFyY2goL3AvaSk7XHJcblxyXG4gIGlmIChpID4gMCkge1xyXG4gICAgcCA9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygyLCBpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgc3RyID0gc3RyLnNsaWNlKDIpO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29udmVydCBgc3RyYCBhcyBhbiBpbnRlZ2VyIHRoZW4gZGl2aWRlIHRoZSByZXN1bHQgYnkgYGJhc2VgIHJhaXNlZCB0byBhIHBvd2VyIHN1Y2ggdGhhdCB0aGVcclxuICAvLyBmcmFjdGlvbiBwYXJ0IHdpbGwgYmUgcmVzdG9yZWQuXHJcbiAgaSA9IHN0ci5pbmRleE9mKCcuJyk7XHJcbiAgaXNGbG9hdCA9IGkgPj0gMDtcclxuICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKGlzRmxvYXQpIHtcclxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgbGVuID0gc3RyLmxlbmd0aDtcclxuICAgIGkgPSBsZW4gLSBpO1xyXG5cclxuICAgIC8vIGxvZ1sxMF0oMTYpID0gMS4yMDQxLi4uICwgbG9nWzEwXSg4OCkgPSAxLjk0NDQuLi4uXHJcbiAgICBkaXZpc29yID0gaW50UG93KEN0b3IsIG5ldyBDdG9yKGJhc2UpLCBpLCBpICogMik7XHJcbiAgfVxyXG5cclxuICB4ZCA9IGNvbnZlcnRCYXNlKHN0ciwgYmFzZSwgQkFTRSk7XHJcbiAgeGUgPSB4ZC5sZW5ndGggLSAxO1xyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgZm9yIChpID0geGU7IHhkW2ldID09PSAwOyAtLWkpIHhkLnBvcCgpO1xyXG4gIGlmIChpIDwgMCkgcmV0dXJuIG5ldyBDdG9yKHgucyAqIDApO1xyXG4gIHguZSA9IGdldEJhc2UxMEV4cG9uZW50KHhkLCB4ZSk7XHJcbiAgeC5kID0geGQ7XHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgLy8gQXQgd2hhdCBwcmVjaXNpb24gdG8gcGVyZm9ybSB0aGUgZGl2aXNpb24gdG8gZW5zdXJlIGV4YWN0IGNvbnZlcnNpb24/XHJcbiAgLy8gbWF4RGVjaW1hbEludGVnZXJQYXJ0RGlnaXRDb3VudCA9IGNlaWwobG9nWzEwXShiKSAqIG90aGVyQmFzZUludGVnZXJQYXJ0RGlnaXRDb3VudClcclxuICAvLyBsb2dbMTBdKDIpID0gMC4zMDEwMywgbG9nWzEwXSg4KSA9IDAuOTAzMDksIGxvZ1sxMF0oMTYpID0gMS4yMDQxMlxyXG4gIC8vIEUuZy4gY2VpbCgxLjIgKiAzKSA9IDQsIHNvIHVwIHRvIDQgZGVjaW1hbCBkaWdpdHMgYXJlIG5lZWRlZCB0byByZXByZXNlbnQgMyBoZXggaW50IGRpZ2l0cy5cclxuICAvLyBtYXhEZWNpbWFsRnJhY3Rpb25QYXJ0RGlnaXRDb3VudCA9IHtIZXg6NHxPY3Q6M3xCaW46MX0gKiBvdGhlckJhc2VGcmFjdGlvblBhcnREaWdpdENvdW50XHJcbiAgLy8gVGhlcmVmb3JlIHVzaW5nIDQgKiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBzdHIgd2lsbCBhbHdheXMgYmUgZW5vdWdoLlxyXG4gIGlmIChpc0Zsb2F0KSB4ID0gZGl2aWRlKHgsIGRpdmlzb3IsIGxlbiAqIDQpO1xyXG5cclxuICAvLyBNdWx0aXBseSBieSB0aGUgYmluYXJ5IGV4cG9uZW50IHBhcnQgaWYgcHJlc2VudC5cclxuICBpZiAocCkgeCA9IHgudGltZXMoTWF0aC5hYnMocCkgPCA1NCA/IG1hdGhwb3coMiwgcCkgOiBEZWNpbWFsLnBvdygyLCBwKSk7XHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICByZXR1cm4geDtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIHNpbih4KSA9IHggLSB4XjMvMyEgKyB4XjUvNSEgLSAuLi5cclxuICogfHh8IDwgcGkvMlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gc2luZShDdG9yLCB4KSB7XHJcbiAgdmFyIGssXHJcbiAgICBsZW4gPSB4LmQubGVuZ3RoO1xyXG5cclxuICBpZiAobGVuIDwgMykge1xyXG4gICAgcmV0dXJuIHguaXNaZXJvKCkgPyB4IDogdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgpO1xyXG4gIH1cclxuXHJcbiAgLy8gQXJndW1lbnQgcmVkdWN0aW9uOiBzaW4oNXgpID0gMTYqc2luXjUoeCkgLSAyMCpzaW5eMyh4KSArIDUqc2luKHgpXHJcbiAgLy8gaS5lLiBzaW4oeCkgPSAxNipzaW5eNSh4LzUpIC0gMjAqc2luXjMoeC81KSArIDUqc2luKHgvNSlcclxuICAvLyBhbmQgIHNpbih4KSA9IHNpbih4LzUpKDUgKyBzaW5eMih4LzUpKDE2c2luXjIoeC81KSAtIDIwKSlcclxuXHJcbiAgLy8gRXN0aW1hdGUgdGhlIG9wdGltdW0gbnVtYmVyIG9mIHRpbWVzIHRvIHVzZSB0aGUgYXJndW1lbnQgcmVkdWN0aW9uLlxyXG4gIGsgPSAxLjQgKiBNYXRoLnNxcnQobGVuKTtcclxuICBrID0gayA+IDE2ID8gMTYgOiBrIHwgMDtcclxuXHJcbiAgeCA9IHgudGltZXMoMSAvIHRpbnlQb3coNSwgaykpO1xyXG4gIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCk7XHJcblxyXG4gIC8vIFJldmVyc2UgYXJndW1lbnQgcmVkdWN0aW9uXHJcbiAgdmFyIHNpbjJfeCxcclxuICAgIGQ1ID0gbmV3IEN0b3IoNSksXHJcbiAgICBkMTYgPSBuZXcgQ3RvcigxNiksXHJcbiAgICBkMjAgPSBuZXcgQ3RvcigyMCk7XHJcbiAgZm9yICg7IGstLTspIHtcclxuICAgIHNpbjJfeCA9IHgudGltZXMoeCk7XHJcbiAgICB4ID0geC50aW1lcyhkNS5wbHVzKHNpbjJfeC50aW1lcyhkMTYudGltZXMoc2luMl94KS5taW51cyhkMjApKSkpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHg7XHJcbn1cclxuXHJcblxyXG4vLyBDYWxjdWxhdGUgVGF5bG9yIHNlcmllcyBmb3IgYGNvc2AsIGBjb3NoYCwgYHNpbmAgYW5kIGBzaW5oYC5cclxuZnVuY3Rpb24gdGF5bG9yU2VyaWVzKEN0b3IsIG4sIHgsIHksIGlzSHlwZXJib2xpYykge1xyXG4gIHZhciBqLCB0LCB1LCB4MixcclxuICAgIGkgPSAxLFxyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbixcclxuICAgIGsgPSBNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSk7XHJcblxyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcbiAgeDIgPSB4LnRpbWVzKHgpO1xyXG4gIHUgPSBuZXcgQ3Rvcih5KTtcclxuXHJcbiAgZm9yICg7Oykge1xyXG4gICAgdCA9IGRpdmlkZSh1LnRpbWVzKHgyKSwgbmV3IEN0b3IobisrICogbisrKSwgcHIsIDEpO1xyXG4gICAgdSA9IGlzSHlwZXJib2xpYyA/IHkucGx1cyh0KSA6IHkubWludXModCk7XHJcbiAgICB5ID0gZGl2aWRlKHQudGltZXMoeDIpLCBuZXcgQ3RvcihuKysgKiBuKyspLCBwciwgMSk7XHJcbiAgICB0ID0gdS5wbHVzKHkpO1xyXG5cclxuICAgIGlmICh0LmRba10gIT09IHZvaWQgMCkge1xyXG4gICAgICBmb3IgKGogPSBrOyB0LmRbal0gPT09IHUuZFtqXSAmJiBqLS07KTtcclxuICAgICAgaWYgKGogPT0gLTEpIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIGogPSB1O1xyXG4gICAgdSA9IHk7XHJcbiAgICB5ID0gdDtcclxuICAgIHQgPSBqO1xyXG4gICAgaSsrO1xyXG4gIH1cclxuXHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gIHQuZC5sZW5ndGggPSBrICsgMTtcclxuXHJcbiAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcblxyXG4vLyBFeHBvbmVudCBlIG11c3QgYmUgcG9zaXRpdmUgYW5kIG5vbi16ZXJvLlxyXG5mdW5jdGlvbiB0aW55UG93KGIsIGUpIHtcclxuICB2YXIgbiA9IGI7XHJcbiAgd2hpbGUgKC0tZSkgbiAqPSBiO1xyXG4gIHJldHVybiBuO1xyXG59XHJcblxyXG5cclxuLy8gUmV0dXJuIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBgeGAgcmVkdWNlZCB0byBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gaGFsZiBwaS5cclxuZnVuY3Rpb24gdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSB7XHJcbiAgdmFyIHQsXHJcbiAgICBpc05lZyA9IHgucyA8IDAsXHJcbiAgICBwaSA9IGdldFBpKEN0b3IsIEN0b3IucHJlY2lzaW9uLCAxKSxcclxuICAgIGhhbGZQaSA9IHBpLnRpbWVzKDAuNSk7XHJcblxyXG4gIHggPSB4LmFicygpO1xyXG5cclxuICBpZiAoeC5sdGUoaGFsZlBpKSkge1xyXG4gICAgcXVhZHJhbnQgPSBpc05lZyA/IDQgOiAxO1xyXG4gICAgcmV0dXJuIHg7XHJcbiAgfVxyXG5cclxuICB0ID0geC5kaXZUb0ludChwaSk7XHJcblxyXG4gIGlmICh0LmlzWmVybygpKSB7XHJcbiAgICBxdWFkcmFudCA9IGlzTmVnID8gMyA6IDI7XHJcbiAgfSBlbHNlIHtcclxuICAgIHggPSB4Lm1pbnVzKHQudGltZXMocGkpKTtcclxuXHJcbiAgICAvLyAwIDw9IHggPCBwaVxyXG4gICAgaWYgKHgubHRlKGhhbGZQaSkpIHtcclxuICAgICAgcXVhZHJhbnQgPSBpc09kZCh0KSA/IChpc05lZyA/IDIgOiAzKSA6IChpc05lZyA/IDQgOiAxKTtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgcXVhZHJhbnQgPSBpc09kZCh0KSA/IChpc05lZyA/IDEgOiA0KSA6IChpc05lZyA/IDMgOiAyKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB4Lm1pbnVzKHBpKS5hYnMoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgRGVjaW1hbCBgeGAgYXMgYSBzdHJpbmcgaW4gYmFzZSBgYmFzZU91dGAuXHJcbiAqXHJcbiAqIElmIHRoZSBvcHRpb25hbCBgc2RgIGFyZ3VtZW50IGlzIHByZXNlbnQgaW5jbHVkZSBhIGJpbmFyeSBleHBvbmVudCBzdWZmaXguXHJcbiAqL1xyXG5mdW5jdGlvbiB0b1N0cmluZ0JpbmFyeSh4LCBiYXNlT3V0LCBzZCwgcm0pIHtcclxuICB2YXIgYmFzZSwgZSwgaSwgaywgbGVuLCByb3VuZFVwLCBzdHIsIHhkLCB5LFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICBpc0V4cCA9IHNkICE9PSB2b2lkIDA7XHJcblxyXG4gIGlmIChpc0V4cCkge1xyXG4gICAgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XHJcbiAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcclxuICB9IGVsc2Uge1xyXG4gICAgc2QgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICB9XHJcblxyXG4gIGlmICgheC5pc0Zpbml0ZSgpKSB7XHJcbiAgICBzdHIgPSBub25GaW5pdGVUb1N0cmluZyh4KTtcclxuICB9IGVsc2Uge1xyXG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCk7XHJcbiAgICBpID0gc3RyLmluZGV4T2YoJy4nKTtcclxuXHJcbiAgICAvLyBVc2UgZXhwb25lbnRpYWwgbm90YXRpb24gYWNjb3JkaW5nIHRvIGB0b0V4cFBvc2AgYW5kIGB0b0V4cE5lZ2A/IE5vLCBidXQgaWYgcmVxdWlyZWQ6XHJcbiAgICAvLyBtYXhCaW5hcnlFeHBvbmVudCA9IGZsb29yKChkZWNpbWFsRXhwb25lbnQgKyAxKSAqIGxvZ1syXSgxMCkpXHJcbiAgICAvLyBtaW5CaW5hcnlFeHBvbmVudCA9IGZsb29yKGRlY2ltYWxFeHBvbmVudCAqIGxvZ1syXSgxMCkpXHJcbiAgICAvLyBsb2dbMl0oMTApID0gMy4zMjE5MjgwOTQ4ODczNjIzNDc4NzAzMTk0Mjk0ODkzOTAxNzU4NjRcclxuXHJcbiAgICBpZiAoaXNFeHApIHtcclxuICAgICAgYmFzZSA9IDI7XHJcbiAgICAgIGlmIChiYXNlT3V0ID09IDE2KSB7XHJcbiAgICAgICAgc2QgPSBzZCAqIDQgLSAzO1xyXG4gICAgICB9IGVsc2UgaWYgKGJhc2VPdXQgPT0gOCkge1xyXG4gICAgICAgIHNkID0gc2QgKiAzIC0gMjtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYmFzZSA9IGJhc2VPdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGFuIGludGVnZXIgdGhlbiBkaXZpZGUgdGhlIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlciBzdWNoXHJcbiAgICAvLyB0aGF0IHRoZSBmcmFjdGlvbiBwYXJ0IHdpbGwgYmUgcmVzdG9yZWQuXHJcblxyXG4gICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICB5ID0gbmV3IEN0b3IoMSk7XHJcbiAgICAgIHkuZSA9IHN0ci5sZW5ndGggLSBpO1xyXG4gICAgICB5LmQgPSBjb252ZXJ0QmFzZShmaW5pdGVUb1N0cmluZyh5KSwgMTAsIGJhc2UpO1xyXG4gICAgICB5LmUgPSB5LmQubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIHhkID0gY29udmVydEJhc2Uoc3RyLCAxMCwgYmFzZSk7XHJcbiAgICBlID0gbGVuID0geGQubGVuZ3RoO1xyXG5cclxuICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoOyB4ZFstLWxlbl0gPT0gMDspIHhkLnBvcCgpO1xyXG5cclxuICAgIGlmICgheGRbMF0pIHtcclxuICAgICAgc3RyID0gaXNFeHAgPyAnMHArMCcgOiAnMCc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICBlLS07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeCA9IG5ldyBDdG9yKHgpO1xyXG4gICAgICAgIHguZCA9IHhkO1xyXG4gICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgeCA9IGRpdmlkZSh4LCB5LCBzZCwgcm0sIDAsIGJhc2UpO1xyXG4gICAgICAgIHhkID0geC5kO1xyXG4gICAgICAgIGUgPSB4LmU7XHJcbiAgICAgICAgcm91bmRVcCA9IGluZXhhY3Q7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoZSByb3VuZGluZyBkaWdpdCwgaS5lLiB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgIGkgPSB4ZFtzZF07XHJcbiAgICAgIGsgPSBiYXNlIC8gMjtcclxuICAgICAgcm91bmRVcCA9IHJvdW5kVXAgfHwgeGRbc2QgKyAxXSAhPT0gdm9pZCAwO1xyXG5cclxuICAgICAgcm91bmRVcCA9IHJtIDwgNFxyXG4gICAgICAgID8gKGkgIT09IHZvaWQgMCB8fCByb3VuZFVwKSAmJiAocm0gPT09IDAgfHwgcm0gPT09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgIDogaSA+IGsgfHwgaSA9PT0gayAmJiAocm0gPT09IDQgfHwgcm91bmRVcCB8fCBybSA9PT0gNiAmJiB4ZFtzZCAtIDFdICYgMSB8fFxyXG4gICAgICAgICAgcm0gPT09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgIHhkLmxlbmd0aCA9IHNkO1xyXG5cclxuICAgICAgaWYgKHJvdW5kVXApIHtcclxuXHJcbiAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICBmb3IgKDsgKyt4ZFstLXNkXSA+IGJhc2UgLSAxOykge1xyXG4gICAgICAgICAgeGRbc2RdID0gMDtcclxuICAgICAgICAgIGlmICghc2QpIHtcclxuICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICB4ZC51bnNoaWZ0KDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGxlbiA9IHhkLmxlbmd0aDsgIXhkW2xlbiAtIDFdOyAtLWxlbik7XHJcblxyXG4gICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICBmb3IgKGkgPSAwLCBzdHIgPSAnJzsgaSA8IGxlbjsgaSsrKSBzdHIgKz0gTlVNRVJBTFMuY2hhckF0KHhkW2ldKTtcclxuXHJcbiAgICAgIC8vIEFkZCBiaW5hcnkgZXhwb25lbnQgc3VmZml4P1xyXG4gICAgICBpZiAoaXNFeHApIHtcclxuICAgICAgICBpZiAobGVuID4gMSkge1xyXG4gICAgICAgICAgaWYgKGJhc2VPdXQgPT0gMTYgfHwgYmFzZU91dCA9PSA4KSB7XHJcbiAgICAgICAgICAgIGkgPSBiYXNlT3V0ID09IDE2ID8gNCA6IDM7XHJcbiAgICAgICAgICAgIGZvciAoLS1sZW47IGxlbiAlIGk7IGxlbisrKSBzdHIgKz0gJzAnO1xyXG4gICAgICAgICAgICB4ZCA9IGNvbnZlcnRCYXNlKHN0ciwgYmFzZSwgYmFzZU91dCk7XHJcbiAgICAgICAgICAgIGZvciAobGVuID0geGQubGVuZ3RoOyAheGRbbGVuIC0gMV07IC0tbGVuKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHhkWzBdIHdpbGwgYWx3YXlzIGJlIGJlIDFcclxuICAgICAgICAgICAgZm9yIChpID0gMSwgc3RyID0gJzEuJzsgaSA8IGxlbjsgaSsrKSBzdHIgKz0gTlVNRVJBTFMuY2hhckF0KHhkW2ldKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSAgc3RyICsgKGUgPCAwID8gJ3AnIDogJ3ArJykgKyBlO1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcbiAgICAgICAgZm9yICg7ICsrZTspIHN0ciA9ICcwJyArIHN0cjtcclxuICAgICAgICBzdHIgPSAnMC4nICsgc3RyO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICgrK2UgPiBsZW4pIGZvciAoZSAtPSBsZW47IGUtLSA7KSBzdHIgKz0gJzAnO1xyXG4gICAgICAgIGVsc2UgaWYgKGUgPCBsZW4pIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0ciA9IChiYXNlT3V0ID09IDE2ID8gJzB4JyA6IGJhc2VPdXQgPT0gMiA/ICcwYicgOiBiYXNlT3V0ID09IDggPyAnMG8nIDogJycpICsgc3RyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHgucyA8IDAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbn1cclxuXHJcblxyXG4vLyBEb2VzIG5vdCBzdHJpcCB0cmFpbGluZyB6ZXJvcy5cclxuZnVuY3Rpb24gdHJ1bmNhdGUoYXJyLCBsZW4pIHtcclxuICBpZiAoYXJyLmxlbmd0aCA+IGxlbikge1xyXG4gICAgYXJyLmxlbmd0aCA9IGxlbjtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8vIERlY2ltYWwgbWV0aG9kc1xyXG5cclxuXHJcbi8qXHJcbiAqICBhYnNcclxuICogIGFjb3NcclxuICogIGFjb3NoXHJcbiAqICBhZGRcclxuICogIGFzaW5cclxuICogIGFzaW5oXHJcbiAqICBhdGFuXHJcbiAqICBhdGFuaFxyXG4gKiAgYXRhbjJcclxuICogIGNicnRcclxuICogIGNlaWxcclxuICogIGNsYW1wXHJcbiAqICBjbG9uZVxyXG4gKiAgY29uZmlnXHJcbiAqICBjb3NcclxuICogIGNvc2hcclxuICogIGRpdlxyXG4gKiAgZXhwXHJcbiAqICBmbG9vclxyXG4gKiAgaHlwb3RcclxuICogIGxuXHJcbiAqICBsb2dcclxuICogIGxvZzJcclxuICogIGxvZzEwXHJcbiAqICBtYXhcclxuICogIG1pblxyXG4gKiAgbW9kXHJcbiAqICBtdWxcclxuICogIHBvd1xyXG4gKiAgcmFuZG9tXHJcbiAqICByb3VuZFxyXG4gKiAgc2V0XHJcbiAqICBzaWduXHJcbiAqICBzaW5cclxuICogIHNpbmhcclxuICogIHNxcnRcclxuICogIHN1YlxyXG4gKiAgc3VtXHJcbiAqICB0YW5cclxuICogIHRhbmhcclxuICogIHRydW5jXHJcbiAqL1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBgeGAuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGFicyh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFicygpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGFyY2Nvc2luZSBpbiByYWRpYW5zIG9mIGB4YC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gYWNvcyh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFjb3MoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBpbnZlcnNlIG9mIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiBgeGAsIHJvdW5kZWQgdG9cclxuICogYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBhY29zaCh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFjb3NoKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIGB4YCBhbmQgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICogeSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gYWRkKHgsIHkpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkucGx1cyh5KTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmNzaW5lIGluIHJhZGlhbnMgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGFzaW4oeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5hc2luKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaHlwZXJib2xpYyBzaW5lIG9mIGB4YCwgcm91bmRlZCB0b1xyXG4gKiBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGFzaW5oKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuYXNpbmgoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmN0YW5nZW50IGluIHJhZGlhbnMgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGF0YW4oeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5hdGFuKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaHlwZXJib2xpYyB0YW5nZW50IG9mIGB4YCwgcm91bmRlZCB0b1xyXG4gKiBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGF0YW5oKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuYXRhbmgoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmN0YW5nZW50IGluIHJhZGlhbnMgb2YgYHkveGAgaW4gdGhlIHJhbmdlIC1waSB0byBwaVxyXG4gKiAoaW5jbHVzaXZlKSwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gKiBSYW5nZTogWy1waSwgcGldXHJcbiAqXHJcbiAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIHktY29vcmRpbmF0ZS5cclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgeC1jb29yZGluYXRlLlxyXG4gKlxyXG4gKiBhdGFuMijCsTAsIC0wKSAgICAgICAgICAgICAgID0gwrFwaVxyXG4gKiBhdGFuMijCsTAsICswKSAgICAgICAgICAgICAgID0gwrEwXHJcbiAqIGF0YW4yKMKxMCwgLXgpICAgICAgICAgICAgICAgPSDCsXBpIGZvciB4ID4gMFxyXG4gKiBhdGFuMijCsTAsIHgpICAgICAgICAgICAgICAgID0gwrEwIGZvciB4ID4gMFxyXG4gKiBhdGFuMigteSwgwrEwKSAgICAgICAgICAgICAgID0gLXBpLzIgZm9yIHkgPiAwXHJcbiAqIGF0YW4yKHksIMKxMCkgICAgICAgICAgICAgICAgPSBwaS8yIGZvciB5ID4gMFxyXG4gKiBhdGFuMijCsXksIC1JbmZpbml0eSkgICAgICAgID0gwrFwaSBmb3IgZmluaXRlIHkgPiAwXHJcbiAqIGF0YW4yKMKxeSwgK0luZmluaXR5KSAgICAgICAgPSDCsTAgZm9yIGZpbml0ZSB5ID4gMFxyXG4gKiBhdGFuMijCsUluZmluaXR5LCB4KSAgICAgICAgID0gwrFwaS8yIGZvciBmaW5pdGUgeFxyXG4gKiBhdGFuMijCsUluZmluaXR5LCAtSW5maW5pdHkpID0gwrEzKnBpLzRcclxuICogYXRhbjIowrFJbmZpbml0eSwgK0luZmluaXR5KSA9IMKxcGkvNFxyXG4gKiBhdGFuMihOYU4sIHgpID0gTmFOXHJcbiAqIGF0YW4yKHksIE5hTikgPSBOYU5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGF0YW4yKHksIHgpIHtcclxuICB5ID0gbmV3IHRoaXMoeSk7XHJcbiAgeCA9IG5ldyB0aGlzKHgpO1xyXG4gIHZhciByLFxyXG4gICAgcHIgPSB0aGlzLnByZWNpc2lvbixcclxuICAgIHJtID0gdGhpcy5yb3VuZGluZyxcclxuICAgIHdwciA9IHByICsgNDtcclxuXHJcbiAgLy8gRWl0aGVyIE5hTlxyXG4gIGlmICgheS5zIHx8ICF4LnMpIHtcclxuICAgIHIgPSBuZXcgdGhpcyhOYU4pO1xyXG5cclxuICAvLyBCb3RoIMKxSW5maW5pdHlcclxuICB9IGVsc2UgaWYgKCF5LmQgJiYgIXguZCkge1xyXG4gICAgciA9IGdldFBpKHRoaXMsIHdwciwgMSkudGltZXMoeC5zID4gMCA/IDAuMjUgOiAwLjc1KTtcclxuICAgIHIucyA9IHkucztcclxuXHJcbiAgLy8geCBpcyDCsUluZmluaXR5IG9yIHkgaXMgwrEwXHJcbiAgfSBlbHNlIGlmICgheC5kIHx8IHkuaXNaZXJvKCkpIHtcclxuICAgIHIgPSB4LnMgPCAwID8gZ2V0UGkodGhpcywgcHIsIHJtKSA6IG5ldyB0aGlzKDApO1xyXG4gICAgci5zID0geS5zO1xyXG5cclxuICAvLyB5IGlzIMKxSW5maW5pdHkgb3IgeCBpcyDCsTBcclxuICB9IGVsc2UgaWYgKCF5LmQgfHwgeC5pc1plcm8oKSkge1xyXG4gICAgciA9IGdldFBpKHRoaXMsIHdwciwgMSkudGltZXMoMC41KTtcclxuICAgIHIucyA9IHkucztcclxuXHJcbiAgLy8gQm90aCBub24temVybyBhbmQgZmluaXRlXHJcbiAgfSBlbHNlIGlmICh4LnMgPCAwKSB7XHJcbiAgICB0aGlzLnByZWNpc2lvbiA9IHdwcjtcclxuICAgIHRoaXMucm91bmRpbmcgPSAxO1xyXG4gICAgciA9IHRoaXMuYXRhbihkaXZpZGUoeSwgeCwgd3ByLCAxKSk7XHJcbiAgICB4ID0gZ2V0UGkodGhpcywgd3ByLCAxKTtcclxuICAgIHRoaXMucHJlY2lzaW9uID0gcHI7XHJcbiAgICB0aGlzLnJvdW5kaW5nID0gcm07XHJcbiAgICByID0geS5zIDwgMCA/IHIubWludXMoeCkgOiByLnBsdXMoeCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHIgPSB0aGlzLmF0YW4oZGl2aWRlKHksIHgsIHdwciwgMSkpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHI7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgY3ViZSByb290IG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gKiBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjYnJ0KHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuY2JydCgpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIHJvdW5kZWQgdG8gYW4gaW50ZWdlciB1c2luZyBgUk9VTkRfQ0VJTGAuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGNlaWwoeCkge1xyXG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIDIpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIGNsYW1wZWQgdG8gdGhlIHJhbmdlIGRlbGluZWF0ZWQgYnkgYG1pbmAgYW5kIGBtYXhgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqIG1pbiB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKiBtYXgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGNsYW1wKHgsIG1pbiwgbWF4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmNsYW1wKG1pbiwgbWF4KTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIENvbmZpZ3VyZSBnbG9iYWwgc2V0dGluZ3MgZm9yIGEgRGVjaW1hbCBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogYG9iamAgaXMgYW4gb2JqZWN0IHdpdGggb25lIG9yIG1vcmUgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzLFxyXG4gKlxyXG4gKiAgIHByZWNpc2lvbiAge251bWJlcn1cclxuICogICByb3VuZGluZyAgIHtudW1iZXJ9XHJcbiAqICAgdG9FeHBOZWcgICB7bnVtYmVyfVxyXG4gKiAgIHRvRXhwUG9zICAge251bWJlcn1cclxuICogICBtYXhFICAgICAgIHtudW1iZXJ9XHJcbiAqICAgbWluRSAgICAgICB7bnVtYmVyfVxyXG4gKiAgIG1vZHVsbyAgICAge251bWJlcn1cclxuICogICBjcnlwdG8gICAgIHtib29sZWFufG51bWJlcn1cclxuICogICBkZWZhdWx0cyAgIHt0cnVlfVxyXG4gKlxyXG4gKiBFLmcuIERlY2ltYWwuY29uZmlnKHsgcHJlY2lzaW9uOiAyMCwgcm91bmRpbmc6IDQgfSlcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGNvbmZpZyhvYmopIHtcclxuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgdGhyb3cgRXJyb3IoZGVjaW1hbEVycm9yICsgJ09iamVjdCBleHBlY3RlZCcpO1xyXG4gIHZhciBpLCBwLCB2LFxyXG4gICAgdXNlRGVmYXVsdHMgPSBvYmouZGVmYXVsdHMgPT09IHRydWUsXHJcbiAgICBwcyA9IFtcclxuICAgICAgJ3ByZWNpc2lvbicsIDEsIE1BWF9ESUdJVFMsXHJcbiAgICAgICdyb3VuZGluZycsIDAsIDgsXHJcbiAgICAgICd0b0V4cE5lZycsIC1FWFBfTElNSVQsIDAsXHJcbiAgICAgICd0b0V4cFBvcycsIDAsIEVYUF9MSU1JVCxcclxuICAgICAgJ21heEUnLCAwLCBFWFBfTElNSVQsXHJcbiAgICAgICdtaW5FJywgLUVYUF9MSU1JVCwgMCxcclxuICAgICAgJ21vZHVsbycsIDAsIDlcclxuICAgIF07XHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgaWYgKHAgPSBwc1tpXSwgdXNlRGVmYXVsdHMpIHRoaXNbcF0gPSBERUZBVUxUU1twXTtcclxuICAgIGlmICgodiA9IG9ialtwXSkgIT09IHZvaWQgMCkge1xyXG4gICAgICBpZiAobWF0aGZsb29yKHYpID09PSB2ICYmIHYgPj0gcHNbaSArIDFdICYmIHYgPD0gcHNbaSArIDJdKSB0aGlzW3BdID0gdjtcclxuICAgICAgZWxzZSB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBwICsgJzogJyArIHYpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHAgPSAnY3J5cHRvJywgdXNlRGVmYXVsdHMpIHRoaXNbcF0gPSBERUZBVUxUU1twXTtcclxuICBpZiAoKHYgPSBvYmpbcF0pICE9PSB2b2lkIDApIHtcclxuICAgIGlmICh2ID09PSB0cnVlIHx8IHYgPT09IGZhbHNlIHx8IHYgPT09IDAgfHwgdiA9PT0gMSkge1xyXG4gICAgICBpZiAodikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0byAmJlxyXG4gICAgICAgICAgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xyXG4gICAgICAgICAgdGhpc1twXSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRocm93IEVycm9yKGNyeXB0b1VuYXZhaWxhYmxlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpc1twXSA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBwICsgJzogJyArIHYpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgY29zaW5lIG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gKiBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGNvcyh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmNvcygpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGh5cGVyYm9saWMgY29zaW5lIG9mIGB4YCwgcm91bmRlZCB0byBwcmVjaXNpb25cclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjb3NoKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuY29zaCgpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBEZWNpbWFsIGNvbnN0cnVjdG9yIHdpdGggdGhlIHNhbWUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIGFzIHRoaXMgRGVjaW1hbFxyXG4gKiBjb25zdHJ1Y3Rvci5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGNsb25lKG9iaikge1xyXG4gIHZhciBpLCBwLCBwcztcclxuXHJcbiAgLypcclxuICAgKiBUaGUgRGVjaW1hbCBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiB2IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIERlY2ltYWwodikge1xyXG4gICAgdmFyIGUsIGksIHQsXHJcbiAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgIC8vIERlY2ltYWwgY2FsbGVkIHdpdGhvdXQgbmV3LlxyXG4gICAgaWYgKCEoeCBpbnN0YW5jZW9mIERlY2ltYWwpKSByZXR1cm4gbmV3IERlY2ltYWwodik7XHJcblxyXG4gICAgLy8gUmV0YWluIGEgcmVmZXJlbmNlIHRvIHRoaXMgRGVjaW1hbCBjb25zdHJ1Y3RvciwgYW5kIHNoYWRvdyBEZWNpbWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG4gICAgLy8gd2hpY2ggcG9pbnRzIHRvIE9iamVjdC5cclxuICAgIHguY29uc3RydWN0b3IgPSBEZWNpbWFsO1xyXG5cclxuICAgIC8vIER1cGxpY2F0ZS5cclxuICAgIGlmIChpc0RlY2ltYWxJbnN0YW5jZSh2KSkge1xyXG4gICAgICB4LnMgPSB2LnM7XHJcblxyXG4gICAgICBpZiAoZXh0ZXJuYWwpIHtcclxuICAgICAgICBpZiAoIXYuZCB8fCB2LmUgPiBEZWNpbWFsLm1heEUpIHtcclxuXHJcbiAgICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICAgIHguZSA9IE5hTjtcclxuICAgICAgICAgIHguZCA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmICh2LmUgPCBEZWNpbWFsLm1pbkUpIHtcclxuXHJcbiAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgeC5lID0gMDtcclxuICAgICAgICAgIHguZCA9IFswXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5lID0gdi5lO1xyXG4gICAgICAgICAgeC5kID0gdi5kLnNsaWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHguZSA9IHYuZTtcclxuICAgICAgICB4LmQgPSB2LmQgPyB2LmQuc2xpY2UoKSA6IHYuZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHQgPSB0eXBlb2YgdjtcclxuXHJcbiAgICBpZiAodCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgaWYgKHYgPT09IDApIHtcclxuICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgeC5lID0gMDtcclxuICAgICAgICB4LmQgPSBbMF07XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodiA8IDApIHtcclxuICAgICAgICB2ID0gLXY7XHJcbiAgICAgICAgeC5zID0gLTE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeC5zID0gMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRmFzdCBwYXRoIGZvciBzbWFsbCBpbnRlZ2Vycy5cclxuICAgICAgaWYgKHYgPT09IH5+diAmJiB2IDwgMWU3KSB7XHJcbiAgICAgICAgZm9yIChlID0gMCwgaSA9IHY7IGkgPj0gMTA7IGkgLz0gMTApIGUrKztcclxuXHJcbiAgICAgICAgaWYgKGV4dGVybmFsKSB7XHJcbiAgICAgICAgICBpZiAoZSA+IERlY2ltYWwubWF4RSkge1xyXG4gICAgICAgICAgICB4LmUgPSBOYU47XHJcbiAgICAgICAgICAgIHguZCA9IG51bGw7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGUgPCBEZWNpbWFsLm1pbkUpIHtcclxuICAgICAgICAgICAgeC5lID0gMDtcclxuICAgICAgICAgICAgeC5kID0gWzBdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgICAgeC5kID0gW3ZdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgeC5kID0gW3ZdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgLy8gSW5maW5pdHksIE5hTi5cclxuICAgICAgfSBlbHNlIGlmICh2ICogMCAhPT0gMCkge1xyXG4gICAgICAgIGlmICghdikgeC5zID0gTmFOO1xyXG4gICAgICAgIHguZSA9IE5hTjtcclxuICAgICAgICB4LmQgPSBudWxsO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHBhcnNlRGVjaW1hbCh4LCB2LnRvU3RyaW5nKCkpO1xyXG5cclxuICAgIH0gZWxzZSBpZiAodCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgdik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWludXMgc2lnbj9cclxuICAgIGlmICgoaSA9IHYuY2hhckNvZGVBdCgwKSkgPT09IDQ1KSB7XHJcbiAgICAgIHYgPSB2LnNsaWNlKDEpO1xyXG4gICAgICB4LnMgPSAtMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFBsdXMgc2lnbj9cclxuICAgICAgaWYgKGkgPT09IDQzKSB2ID0gdi5zbGljZSgxKTtcclxuICAgICAgeC5zID0gMTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXNEZWNpbWFsLnRlc3QodikgPyBwYXJzZURlY2ltYWwoeCwgdikgOiBwYXJzZU90aGVyKHgsIHYpO1xyXG4gIH1cclxuXHJcbiAgRGVjaW1hbC5wcm90b3R5cGUgPSBQO1xyXG5cclxuICBEZWNpbWFsLlJPVU5EX1VQID0gMDtcclxuICBEZWNpbWFsLlJPVU5EX0RPV04gPSAxO1xyXG4gIERlY2ltYWwuUk9VTkRfQ0VJTCA9IDI7XHJcbiAgRGVjaW1hbC5ST1VORF9GTE9PUiA9IDM7XHJcbiAgRGVjaW1hbC5ST1VORF9IQUxGX1VQID0gNDtcclxuICBEZWNpbWFsLlJPVU5EX0hBTEZfRE9XTiA9IDU7XHJcbiAgRGVjaW1hbC5ST1VORF9IQUxGX0VWRU4gPSA2O1xyXG4gIERlY2ltYWwuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICBEZWNpbWFsLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xyXG4gIERlY2ltYWwuRVVDTElEID0gOTtcclxuXHJcbiAgRGVjaW1hbC5jb25maWcgPSBEZWNpbWFsLnNldCA9IGNvbmZpZztcclxuICBEZWNpbWFsLmNsb25lID0gY2xvbmU7XHJcbiAgRGVjaW1hbC5pc0RlY2ltYWwgPSBpc0RlY2ltYWxJbnN0YW5jZTtcclxuXHJcbiAgRGVjaW1hbC5hYnMgPSBhYnM7XHJcbiAgRGVjaW1hbC5hY29zID0gYWNvcztcclxuICBEZWNpbWFsLmFjb3NoID0gYWNvc2g7ICAgICAgICAvLyBFUzZcclxuICBEZWNpbWFsLmFkZCA9IGFkZDtcclxuICBEZWNpbWFsLmFzaW4gPSBhc2luO1xyXG4gIERlY2ltYWwuYXNpbmggPSBhc2luaDsgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwuYXRhbiA9IGF0YW47XHJcbiAgRGVjaW1hbC5hdGFuaCA9IGF0YW5oOyAgICAgICAgLy8gRVM2XHJcbiAgRGVjaW1hbC5hdGFuMiA9IGF0YW4yO1xyXG4gIERlY2ltYWwuY2JydCA9IGNicnQ7ICAgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwuY2VpbCA9IGNlaWw7XHJcbiAgRGVjaW1hbC5jbGFtcCA9IGNsYW1wO1xyXG4gIERlY2ltYWwuY29zID0gY29zO1xyXG4gIERlY2ltYWwuY29zaCA9IGNvc2g7ICAgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwuZGl2ID0gZGl2O1xyXG4gIERlY2ltYWwuZXhwID0gZXhwO1xyXG4gIERlY2ltYWwuZmxvb3IgPSBmbG9vcjtcclxuICBEZWNpbWFsLmh5cG90ID0gaHlwb3Q7ICAgICAgICAvLyBFUzZcclxuICBEZWNpbWFsLmxuID0gbG47XHJcbiAgRGVjaW1hbC5sb2cgPSBsb2c7XHJcbiAgRGVjaW1hbC5sb2cxMCA9IGxvZzEwOyAgICAgICAgLy8gRVM2XHJcbiAgRGVjaW1hbC5sb2cyID0gbG9nMjsgICAgICAgICAgLy8gRVM2XHJcbiAgRGVjaW1hbC5tYXggPSBtYXg7XHJcbiAgRGVjaW1hbC5taW4gPSBtaW47XHJcbiAgRGVjaW1hbC5tb2QgPSBtb2Q7XHJcbiAgRGVjaW1hbC5tdWwgPSBtdWw7XHJcbiAgRGVjaW1hbC5wb3cgPSBwb3c7XHJcbiAgRGVjaW1hbC5yYW5kb20gPSByYW5kb207XHJcbiAgRGVjaW1hbC5yb3VuZCA9IHJvdW5kO1xyXG4gIERlY2ltYWwuc2lnbiA9IHNpZ247ICAgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwuc2luID0gc2luO1xyXG4gIERlY2ltYWwuc2luaCA9IHNpbmg7ICAgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwuc3FydCA9IHNxcnQ7XHJcbiAgRGVjaW1hbC5zdWIgPSBzdWI7XHJcbiAgRGVjaW1hbC5zdW0gPSBzdW07XHJcbiAgRGVjaW1hbC50YW4gPSB0YW47XHJcbiAgRGVjaW1hbC50YW5oID0gdGFuaDsgICAgICAgICAgLy8gRVM2XHJcbiAgRGVjaW1hbC50cnVuYyA9IHRydW5jOyAgICAgICAgLy8gRVM2XHJcblxyXG4gIGlmIChvYmogPT09IHZvaWQgMCkgb2JqID0ge307XHJcbiAgaWYgKG9iaikge1xyXG4gICAgaWYgKG9iai5kZWZhdWx0cyAhPT0gdHJ1ZSkge1xyXG4gICAgICBwcyA9IFsncHJlY2lzaW9uJywgJ3JvdW5kaW5nJywgJ3RvRXhwTmVnJywgJ3RvRXhwUG9zJywgJ21heEUnLCAnbWluRScsICdtb2R1bG8nLCAnY3J5cHRvJ107XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBwcy5sZW5ndGg7KSBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShwID0gcHNbaSsrXSkpIG9ialtwXSA9IHRoaXNbcF07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBEZWNpbWFsLmNvbmZpZyhvYmopO1xyXG5cclxuICByZXR1cm4gRGVjaW1hbDtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCBkaXZpZGVkIGJ5IGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gKiBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGRpdih4LCB5KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmRpdih5KTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGV4cG9uZW50aWFsIG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBwb3dlciB0byB3aGljaCB0byByYWlzZSB0aGUgYmFzZSBvZiB0aGUgbmF0dXJhbCBsb2cuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBleHAoeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5leHAoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCByb3VuZCB0byBhbiBpbnRlZ2VyIHVzaW5nIGBST1VORF9GTE9PUmAuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGZsb29yKHgpIHtcclxuICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCAzKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgc3VtIG9mIHRoZSBzcXVhcmVzIG9mIHRoZSBhcmd1bWVudHMsXHJcbiAqIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogaHlwb3QoYSwgYiwgLi4uKSA9IHNxcnQoYV4yICsgYl4yICsgLi4uKVxyXG4gKlxyXG4gKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGh5cG90KCkge1xyXG4gIHZhciBpLCBuLFxyXG4gICAgdCA9IG5ldyB0aGlzKDApO1xyXG5cclxuICBleHRlcm5hbCA9IGZhbHNlO1xyXG5cclxuICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDspIHtcclxuICAgIG4gPSBuZXcgdGhpcyhhcmd1bWVudHNbaSsrXSk7XHJcbiAgICBpZiAoIW4uZCkge1xyXG4gICAgICBpZiAobi5zKSB7XHJcbiAgICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcygxIC8gMCk7XHJcbiAgICAgIH1cclxuICAgICAgdCA9IG47XHJcbiAgICB9IGVsc2UgaWYgKHQuZCkge1xyXG4gICAgICB0ID0gdC5wbHVzKG4udGltZXMobikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICByZXR1cm4gdC5zcXJ0KCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiBvYmplY3QgaXMgYSBEZWNpbWFsIGluc3RhbmNlICh3aGVyZSBEZWNpbWFsIGlzIGFueSBEZWNpbWFsIGNvbnN0cnVjdG9yKSxcclxuICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGlzRGVjaW1hbEluc3RhbmNlKG9iaikge1xyXG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBEZWNpbWFsIHx8IG9iaiAmJiBvYmoudG9TdHJpbmdUYWcgPT09IHRhZyB8fCBmYWxzZTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gbG4oeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5sbigpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGxvZyBvZiBgeGAgdG8gdGhlIGJhc2UgYHlgLCBvciB0byBiYXNlIDEwIGlmIG5vIGJhc2VcclxuICogaXMgc3BlY2lmaWVkLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIGxvZ1t5XSh4KVxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBhcmd1bWVudCBvZiB0aGUgbG9nYXJpdGhtLlxyXG4gKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBiYXNlIG9mIHRoZSBsb2dhcml0aG0uXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2coeCwgeSkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5sb2coeSk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYmFzZSAyIGxvZ2FyaXRobSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gbG9nMih4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmxvZygyKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBiYXNlIDEwIGxvZ2FyaXRobSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gbG9nMTAoeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5sb2coMTApO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICpcclxuICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXgoKSB7XHJcbiAgcmV0dXJuIG1heE9yTWluKHRoaXMsIGFyZ3VtZW50cywgJ2x0Jyk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gKlxyXG4gKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIG1pbigpIHtcclxuICByZXR1cm4gbWF4T3JNaW4odGhpcywgYXJndW1lbnRzLCAnZ3QnKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCBtb2R1bG8gYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gKiB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICogeSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gbW9kKHgsIHkpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkubW9kKHkpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIG11bHRpcGxpZWQgYnkgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICogeSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gbXVsKHgsIHkpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkubXVsKHkpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIHJhaXNlZCB0byB0aGUgcG93ZXIgYHlgLCByb3VuZGVkIHRvIHByZWNpc2lvblxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBiYXNlLlxyXG4gKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBleHBvbmVudC5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHBvdyh4LCB5KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnBvdyh5KTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybnMgYSBuZXcgRGVjaW1hbCB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSwgYW5kIHdpdGhcclxuICogYHNkYCwgb3IgYERlY2ltYWwucHJlY2lzaW9uYCBpZiBgc2RgIGlzIG9taXR0ZWQsIHNpZ25pZmljYW50IGRpZ2l0cyAob3IgbGVzcyBpZiB0cmFpbGluZyB6ZXJvc1xyXG4gKiBhcmUgcHJvZHVjZWQpLlxyXG4gKlxyXG4gKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMCB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHJhbmRvbShzZCkge1xyXG4gIHZhciBkLCBlLCBrLCBuLFxyXG4gICAgaSA9IDAsXHJcbiAgICByID0gbmV3IHRoaXMoMSksXHJcbiAgICByZCA9IFtdO1xyXG5cclxuICBpZiAoc2QgPT09IHZvaWQgMCkgc2QgPSB0aGlzLnByZWNpc2lvbjtcclxuICBlbHNlIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xyXG5cclxuICBrID0gTWF0aC5jZWlsKHNkIC8gTE9HX0JBU0UpO1xyXG5cclxuICBpZiAoIXRoaXMuY3J5cHRvKSB7XHJcbiAgICBmb3IgKDsgaSA8IGs7KSByZFtpKytdID0gTWF0aC5yYW5kb20oKSAqIDFlNyB8IDA7XHJcblxyXG4gIC8vIEJyb3dzZXJzIHN1cHBvcnRpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5cclxuICB9IGVsc2UgaWYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcclxuICAgIGQgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrKSk7XHJcblxyXG4gICAgZm9yICg7IGkgPCBrOykge1xyXG4gICAgICBuID0gZFtpXTtcclxuXHJcbiAgICAgIC8vIDAgPD0gbiA8IDQyOTQ5NjcyOTZcclxuICAgICAgLy8gUHJvYmFiaWxpdHkgbiA+PSA0LjI5ZTksIGlzIDQ5NjcyOTYgLyA0Mjk0OTY3Mjk2ID0gMC4wMDExNiAoMSBpbiA4NjUpLlxyXG4gICAgICBpZiAobiA+PSA0LjI5ZTkpIHtcclxuICAgICAgICBkW2ldID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyAwIDw9IG4gPD0gNDI4OTk5OTk5OVxyXG4gICAgICAgIC8vIDAgPD0gKG4gJSAxZTcpIDw9IDk5OTk5OTlcclxuICAgICAgICByZFtpKytdID0gbiAlIDFlNztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XHJcblxyXG4gICAgLy8gYnVmZmVyXHJcbiAgICBkID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNCk7XHJcblxyXG4gICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgLy8gMCA8PSBuIDwgMjE0NzQ4MzY0OFxyXG4gICAgICBuID0gZFtpXSArIChkW2kgKyAxXSA8PCA4KSArIChkW2kgKyAyXSA8PCAxNikgKyAoKGRbaSArIDNdICYgMHg3ZikgPDwgMjQpO1xyXG5cclxuICAgICAgLy8gUHJvYmFiaWxpdHkgbiA+PSAyLjE0ZTksIGlzIDc0ODM2NDggLyAyMTQ3NDgzNjQ4ID0gMC4wMDM1ICgxIGluIDI4NikuXHJcbiAgICAgIGlmIChuID49IDIuMTRlOSkge1xyXG4gICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg0KS5jb3B5KGQsIGkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyAwIDw9IG4gPD0gMjEzOTk5OTk5OVxyXG4gICAgICAgIC8vIDAgPD0gKG4gJSAxZTcpIDw9IDk5OTk5OTlcclxuICAgICAgICByZC5wdXNoKG4gJSAxZTcpO1xyXG4gICAgICAgIGkgKz0gNDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGkgPSBrIC8gNDtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgRXJyb3IoY3J5cHRvVW5hdmFpbGFibGUpO1xyXG4gIH1cclxuXHJcbiAgayA9IHJkWy0taV07XHJcbiAgc2QgJT0gTE9HX0JBU0U7XHJcblxyXG4gIC8vIENvbnZlcnQgdHJhaWxpbmcgZGlnaXRzIHRvIHplcm9zIGFjY29yZGluZyB0byBzZC5cclxuICBpZiAoayAmJiBzZCkge1xyXG4gICAgbiA9IG1hdGhwb3coMTAsIExPR19CQVNFIC0gc2QpO1xyXG4gICAgcmRbaV0gPSAoayAvIG4gfCAwKSAqIG47XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgd29yZHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgZm9yICg7IHJkW2ldID09PSAwOyBpLS0pIHJkLnBvcCgpO1xyXG5cclxuICAvLyBaZXJvP1xyXG4gIGlmIChpIDwgMCkge1xyXG4gICAgZSA9IDA7XHJcbiAgICByZCA9IFswXTtcclxuICB9IGVsc2Uge1xyXG4gICAgZSA9IC0xO1xyXG5cclxuICAgIC8vIFJlbW92ZSBsZWFkaW5nIHdvcmRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICBmb3IgKDsgcmRbMF0gPT09IDA7IGUgLT0gTE9HX0JBU0UpIHJkLnNoaWZ0KCk7XHJcblxyXG4gICAgLy8gQ291bnQgdGhlIGRpZ2l0cyBvZiB0aGUgZmlyc3Qgd29yZCBvZiByZCB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgIGZvciAoayA9IDEsIG4gPSByZFswXTsgbiA+PSAxMDsgbiAvPSAxMCkgaysrO1xyXG5cclxuICAgIC8vIEFkanVzdCB0aGUgZXhwb25lbnQgZm9yIGxlYWRpbmcgemVyb3Mgb2YgdGhlIGZpcnN0IHdvcmQgb2YgcmQuXHJcbiAgICBpZiAoayA8IExPR19CQVNFKSBlIC09IExPR19CQVNFIC0gaztcclxuICB9XHJcblxyXG4gIHIuZSA9IGU7XHJcbiAgci5kID0gcmQ7XHJcblxyXG4gIHJldHVybiByO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIHJvdW5kZWQgdG8gYW4gaW50ZWdlciB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIFRvIGVtdWxhdGUgYE1hdGgucm91bmRgLCBzZXQgcm91bmRpbmcgdG8gNyAoUk9VTkRfSEFMRl9DRUlMKS5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gcm91bmQoeCkge1xyXG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIHRoaXMucm91bmRpbmcpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuXHJcbiAqICAgMSAgICBpZiB4ID4gMCxcclxuICogIC0xICAgIGlmIHggPCAwLFxyXG4gKiAgIDAgICAgaWYgeCBpcyAwLFxyXG4gKiAgLTAgICAgaWYgeCBpcyAtMCxcclxuICogICBOYU4gIG90aGVyd2lzZVxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBzaWduKHgpIHtcclxuICB4ID0gbmV3IHRoaXMoeCk7XHJcbiAgcmV0dXJuIHguZCA/ICh4LmRbMF0gPyB4LnMgOiAwICogeC5zKSA6IHgucyB8fCBOYU47XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc2luZSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBzaW4oeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5zaW4oKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBoeXBlcmJvbGljIHNpbmUgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gc2luaCh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnNpbmgoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gc3FydCh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnNxcnQoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCBtaW51cyBgeWAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBzdWIoeCwgeSkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5zdWIoeSk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBhcmd1bWVudHMsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogT25seSB0aGUgcmVzdWx0IGlzIHJvdW5kZWQsIG5vdCB0aGUgaW50ZXJtZWRpYXRlIGNhbGN1bGF0aW9ucy5cclxuICpcclxuICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBzdW0oKSB7XHJcbiAgdmFyIGkgPSAwLFxyXG4gICAgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgIHggPSBuZXcgdGhpcyhhcmdzW2ldKTtcclxuXHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICBmb3IgKDsgeC5zICYmICsraSA8IGFyZ3MubGVuZ3RoOykgeCA9IHgucGx1cyhhcmdzW2ldKTtcclxuICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZSh4LCB0aGlzLnByZWNpc2lvbiwgdGhpcy5yb3VuZGluZyk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdGFuZ2VudCBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiB0YW4oeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS50YW4oKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gdGFuaCh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnRhbmgoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCB0cnVuY2F0ZWQgdG8gYW4gaW50ZWdlci5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gdHJ1bmMoeCkge1xyXG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIDEpO1xyXG59XHJcblxyXG5cclxuUFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSA9IFAudG9TdHJpbmc7XHJcblBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICdEZWNpbWFsJztcclxuXHJcbi8vIENyZWF0ZSBhbmQgY29uZmlndXJlIGluaXRpYWwgRGVjaW1hbCBjb25zdHJ1Y3Rvci5cclxuZXhwb3J0IHZhciBEZWNpbWFsID0gUC5jb25zdHJ1Y3RvciA9IGNsb25lKERFRkFVTFRTKTtcclxuXHJcbi8vIENyZWF0ZSB0aGUgaW50ZXJuYWwgY29uc3RhbnRzIGZyb20gdGhlaXIgc3RyaW5nIHZhbHVlcy5cclxuTE4xMCA9IG5ldyBEZWNpbWFsKExOMTApO1xyXG5QSSA9IG5ldyBEZWNpbWFsKFBJKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERlY2ltYWw7XHJcbiJdLCJuYW1lcyI6WyJFWFBfTElNSVQiLCJNQVhfRElHSVRTIiwiTlVNRVJBTFMiLCJMTjEwIiwiUEkiLCJERUZBVUxUUyIsInByZWNpc2lvbiIsInJvdW5kaW5nIiwibW9kdWxvIiwidG9FeHBOZWciLCJ0b0V4cFBvcyIsIm1pbkUiLCJtYXhFIiwiY3J5cHRvIiwiaW5leGFjdCIsInF1YWRyYW50IiwiZXh0ZXJuYWwiLCJkZWNpbWFsRXJyb3IiLCJpbnZhbGlkQXJndW1lbnQiLCJwcmVjaXNpb25MaW1pdEV4Y2VlZGVkIiwiY3J5cHRvVW5hdmFpbGFibGUiLCJ0YWciLCJtYXRoZmxvb3IiLCJNYXRoIiwiZmxvb3IiLCJtYXRocG93IiwicG93IiwiaXNCaW5hcnkiLCJpc0hleCIsImlzT2N0YWwiLCJpc0RlY2ltYWwiLCJCQVNFIiwiTE9HX0JBU0UiLCJNQVhfU0FGRV9JTlRFR0VSIiwiTE4xMF9QUkVDSVNJT04iLCJsZW5ndGgiLCJQSV9QUkVDSVNJT04iLCJQIiwidG9TdHJpbmdUYWciLCJhYnNvbHV0ZVZhbHVlIiwiYWJzIiwieCIsImNvbnN0cnVjdG9yIiwicyIsImZpbmFsaXNlIiwiY2VpbCIsImUiLCJjbGFtcGVkVG8iLCJjbGFtcCIsIm1pbiIsIm1heCIsImsiLCJDdG9yIiwiTmFOIiwiZ3QiLCJFcnJvciIsImNtcCIsImNvbXBhcmVkVG8iLCJ5IiwiaSIsImoiLCJ4ZEwiLCJ5ZEwiLCJ4ZCIsImQiLCJ5ZCIsInhzIiwieXMiLCJjb3NpbmUiLCJjb3MiLCJwciIsInJtIiwic2QiLCJ0b0xlc3NUaGFuSGFsZlBpIiwibmVnIiwiY3ViZVJvb3QiLCJjYnJ0IiwibSIsIm4iLCJyIiwicmVwIiwidCIsInQzIiwidDNwbHVzeCIsImlzRmluaXRlIiwiaXNaZXJvIiwiZGlnaXRzVG9TdHJpbmciLCJ0b0V4cG9uZW50aWFsIiwic2xpY2UiLCJpbmRleE9mIiwidG9TdHJpbmciLCJ0aW1lcyIsInBsdXMiLCJkaXZpZGUiLCJlcSIsImNoYXJBdCIsImRlY2ltYWxQbGFjZXMiLCJkcCIsInciLCJkaXZpZGVkQnkiLCJkaXYiLCJkaXZpZGVkVG9JbnRlZ2VyQnkiLCJkaXZUb0ludCIsImVxdWFscyIsImdyZWF0ZXJUaGFuIiwiZ3JlYXRlclRoYW5PckVxdWFsVG8iLCJndGUiLCJoeXBlcmJvbGljQ29zaW5lIiwiY29zaCIsImxlbiIsIm9uZSIsInRpbnlQb3ciLCJ0YXlsb3JTZXJpZXMiLCJjb3NoMl94IiwiZDgiLCJtaW51cyIsImh5cGVyYm9saWNTaW5lIiwic2luaCIsInNxcnQiLCJzaW5oMl94IiwiZDUiLCJkMTYiLCJkMjAiLCJoeXBlcmJvbGljVGFuZ2VudCIsInRhbmgiLCJpbnZlcnNlQ29zaW5lIiwiYWNvcyIsImhhbGZQaSIsImlzTmVnIiwiZ2V0UGkiLCJhc2luIiwiaW52ZXJzZUh5cGVyYm9saWNDb3NpbmUiLCJhY29zaCIsImx0ZSIsImxuIiwiaW52ZXJzZUh5cGVyYm9saWNTaW5lIiwiYXNpbmgiLCJpbnZlcnNlSHlwZXJib2xpY1RhbmdlbnQiLCJhdGFuaCIsIndwciIsInhzZCIsImludmVyc2VTaW5lIiwiYXRhbiIsImludmVyc2VUYW5nZW50IiwicHgiLCJ4MiIsImlzSW50ZWdlciIsImlzSW50IiwiaXNOYU4iLCJpc05lZ2F0aXZlIiwiaXNQb3NpdGl2ZSIsImlzUG9zIiwibGVzc1RoYW4iLCJsdCIsImxlc3NUaGFuT3JFcXVhbFRvIiwibG9nYXJpdGhtIiwibG9nIiwiYmFzZSIsImlzQmFzZTEwIiwiZGVub21pbmF0b3IiLCJpbmYiLCJudW0iLCJhcmciLCJndWFyZCIsIm5hdHVyYWxMb2dhcml0aG0iLCJnZXRMbjEwIiwiY2hlY2tSb3VuZGluZ0RpZ2l0cyIsInN1YiIsInhlIiwieExUeSIsInJldmVyc2UiLCJwdXNoIiwicG9wIiwic2hpZnQiLCJnZXRCYXNlMTBFeHBvbmVudCIsIm1vZCIsInEiLCJuYXR1cmFsRXhwb25lbnRpYWwiLCJleHAiLCJuZWdhdGVkIiwiYWRkIiwiY2FycnkiLCJ1bnNoaWZ0IiwieiIsImdldFByZWNpc2lvbiIsInJvdW5kIiwic2luZSIsInNpbiIsInNxdWFyZVJvb3QiLCJ0YW5nZW50IiwidGFuIiwibXVsIiwickwiLCJ0b0JpbmFyeSIsInRvU3RyaW5nQmluYXJ5IiwidG9EZWNpbWFsUGxhY2VzIiwidG9EUCIsImNoZWNrSW50MzIiLCJzdHIiLCJmaW5pdGVUb1N0cmluZyIsInRvRml4ZWQiLCJ0b0ZyYWN0aW9uIiwibWF4RCIsImQwIiwiZDEiLCJkMiIsIm4wIiwibjEiLCJ0b0hleGFkZWNpbWFsIiwidG9IZXgiLCJ0b05lYXJlc3QiLCJ0b051bWJlciIsInRvT2N0YWwiLCJ0b1Bvd2VyIiwieW4iLCJpbnRQb3ciLCJ0b1ByZWNpc2lvbiIsInRvU2lnbmlmaWNhbnREaWdpdHMiLCJ0b1NEIiwidHJ1bmNhdGVkIiwidHJ1bmMiLCJ2YWx1ZU9mIiwidG9KU09OIiwid3MiLCJpbmRleE9mTGFzdFdvcmQiLCJnZXRaZXJvU3RyaW5nIiwicmVwZWF0aW5nIiwiZGkiLCJyZCIsImNvbnZlcnRCYXNlIiwiYmFzZUluIiwiYmFzZU91dCIsImFyciIsImFyckwiLCJzdHJMIiwiY29zMngiLCJtdWx0aXBseUludGVnZXIiLCJ0ZW1wIiwiY29tcGFyZSIsImEiLCJiIiwiYUwiLCJiTCIsInN1YnRyYWN0IiwibG9nQmFzZSIsIm1vcmUiLCJwcm9kIiwicHJvZEwiLCJxZCIsInJlbSIsInJlbUwiLCJyZW0wIiwieGkiLCJ4TCIsInlkMCIsInlMIiwieXoiLCJzaWduIiwiaXNUcnVuY2F0ZWQiLCJkaWdpdHMiLCJyb3VuZFVwIiwieGRpIiwib3V0IiwiaXNFeHAiLCJub25GaW5pdGVUb1N0cmluZyIsInpzIiwidHJ1bmNhdGUiLCJpc09kZCIsIm1heE9yTWluIiwiYXJncyIsImx0Z3QiLCJzdW0iLCJjIiwiYzAiLCJudW1lcmF0b3IiLCJ4MSIsIlN0cmluZyIsInBhcnNlRGVjaW1hbCIsInJlcGxhY2UiLCJzZWFyY2giLCJzdWJzdHJpbmciLCJjaGFyQ29kZUF0IiwicGFyc2VPdGhlciIsImRpdmlzb3IiLCJpc0Zsb2F0IiwicCIsInRlc3QiLCJ0b0xvd2VyQ2FzZSIsIkRlY2ltYWwiLCJzaW4yX3giLCJpc0h5cGVyYm9saWMiLCJ1IiwicGkiLCJhdGFuMiIsImNvbmZpZyIsIm9iaiIsInYiLCJ1c2VEZWZhdWx0cyIsImRlZmF1bHRzIiwicHMiLCJnZXRSYW5kb21WYWx1ZXMiLCJyYW5kb21CeXRlcyIsImNsb25lIiwiaXNEZWNpbWFsSW5zdGFuY2UiLCJwcm90b3R5cGUiLCJST1VORF9VUCIsIlJPVU5EX0RPV04iLCJST1VORF9DRUlMIiwiUk9VTkRfRkxPT1IiLCJST1VORF9IQUxGX1VQIiwiUk9VTkRfSEFMRl9ET1dOIiwiUk9VTkRfSEFMRl9FVkVOIiwiUk9VTkRfSEFMRl9DRUlMIiwiUk9VTkRfSEFMRl9GTE9PUiIsIkVVQ0xJRCIsInNldCIsImh5cG90IiwibG9nMTAiLCJsb2cyIiwicmFuZG9tIiwiaGFzT3duUHJvcGVydHkiLCJhcmd1bWVudHMiLCJVaW50MzJBcnJheSIsImNvcHkiLCJTeW1ib2wiLCJmb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/decimal.js/decimal.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/decimal.js/decimal.mjs":
/*!*********************************************!*\
  !*** ./node_modules/decimal.js/decimal.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decimal: () => (/* binding */ Decimal),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\r\n *  decimal.js v10.4.3\r\n *  An arbitrary-precision Decimal type for JavaScript.\r\n *  https://github.com/MikeMcl/decimal.js\r\n *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *  MIT Licence\r\n */ // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\n// The maximum exponent magnitude.\n// The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\nvar EXP_LIMIT = 9e15, // The limit on the value of `precision`, and on the value of the first argument to\n// `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\nMAX_DIGITS = 1e9, // Base conversion alphabet.\nNUMERALS = \"0123456789abcdef\", // The natural logarithm of 10 (1025 digits).\nLN10 = \"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058\", // Pi (1025 digits).\nPI = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789\", // The initial configuration properties of the Decimal constructor.\nDEFAULTS = {\n    // These values must be integers within the stated ranges (inclusive).\n    // Most of these values can be changed at run-time using the `Decimal.config` method.\n    // The maximum number of significant digits of the result of a calculation or base conversion.\n    // E.g. `Decimal.config({ precision: 20 });`\n    precision: 20,\n    // The rounding mode used when rounding to `precision`.\n    //\n    // ROUND_UP         0 Away from zero.\n    // ROUND_DOWN       1 Towards zero.\n    // ROUND_CEIL       2 Towards +Infinity.\n    // ROUND_FLOOR      3 Towards -Infinity.\n    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n    //\n    // E.g.\n    // `Decimal.rounding = 4;`\n    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\n    rounding: 4,\n    // The modulo mode used when calculating the modulus: a mod n.\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\n    // The remainder (r) is calculated as: r = a - n * q.\n    //\n    // UP         0 The remainder is positive if the dividend is negative, else is negative.\n    // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\n    // FLOOR      3 The remainder has the same sign as the divisor (Python %).\n    // HALF_EVEN  6 The IEEE 754 remainder function.\n    // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\n    //\n    // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\n    // division (9) are commonly used for the modulus operation. The other rounding modes can also\n    // be used, but they may not give useful results.\n    modulo: 1,\n    // The exponent value at and beneath which `toString` returns exponential notation.\n    // JavaScript numbers: -7\n    toExpNeg: -7,\n    // The exponent value at and above which `toString` returns exponential notation.\n    // JavaScript numbers: 21\n    toExpPos: 21,\n    // The minimum exponent value, beneath which underflow to zero occurs.\n    // JavaScript numbers: -324  (5e-324)\n    minE: -EXP_LIMIT,\n    // The maximum exponent value, above which overflow to Infinity occurs.\n    // JavaScript numbers: 308  (1.7976931348623157e+308)\n    maxE: EXP_LIMIT,\n    // Whether to use cryptographically-secure random number generation, if available.\n    crypto: false // true/false\n}, // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\ninexact, quadrant, external = true, decimalError = \"[DecimalError] \", invalidArgument = decimalError + \"Invalid argument: \", precisionLimitExceeded = decimalError + \"Precision limit exceeded\", cryptoUnavailable = decimalError + \"crypto unavailable\", tag = \"[object Decimal]\", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i, isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i, isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i, isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, // Decimal.prototype object\nP = {\n    toStringTag: tag\n};\n// Decimal prototype methods\n/*\r\n *  absoluteValue             abs\r\n *  ceil\r\n *  clampedTo                 clamp\r\n *  comparedTo                cmp\r\n *  cosine                    cos\r\n *  cubeRoot                  cbrt\r\n *  decimalPlaces             dp\r\n *  dividedBy                 div\r\n *  dividedToIntegerBy        divToInt\r\n *  equals                    eq\r\n *  floor\r\n *  greaterThan               gt\r\n *  greaterThanOrEqualTo      gte\r\n *  hyperbolicCosine          cosh\r\n *  hyperbolicSine            sinh\r\n *  hyperbolicTangent         tanh\r\n *  inverseCosine             acos\r\n *  inverseHyperbolicCosine   acosh\r\n *  inverseHyperbolicSine     asinh\r\n *  inverseHyperbolicTangent  atanh\r\n *  inverseSine               asin\r\n *  inverseTangent            atan\r\n *  isFinite\r\n *  isInteger                 isInt\r\n *  isNaN\r\n *  isNegative                isNeg\r\n *  isPositive                isPos\r\n *  isZero\r\n *  lessThan                  lt\r\n *  lessThanOrEqualTo         lte\r\n *  logarithm                 log\r\n *  [maximum]                 [max]\r\n *  [minimum]                 [min]\r\n *  minus                     sub\r\n *  modulo                    mod\r\n *  naturalExponential        exp\r\n *  naturalLogarithm          ln\r\n *  negated                   neg\r\n *  plus                      add\r\n *  precision                 sd\r\n *  round\r\n *  sine                      sin\r\n *  squareRoot                sqrt\r\n *  tangent                   tan\r\n *  times                     mul\r\n *  toBinary\r\n *  toDecimalPlaces           toDP\r\n *  toExponential\r\n *  toFixed\r\n *  toFraction\r\n *  toHexadecimal             toHex\r\n *  toNearest\r\n *  toNumber\r\n *  toOctal\r\n *  toPower                   pow\r\n *  toPrecision\r\n *  toSignificantDigits       toSD\r\n *  toString\r\n *  truncated                 trunc\r\n *  valueOf                   toJSON\r\n */ /*\r\n * Return a new Decimal whose value is the absolute value of this Decimal.\r\n *\r\n */ P.absoluteValue = P.abs = function() {\n    var x = new this.constructor(this);\n    if (x.s < 0) x.s = 1;\n    return finalise(x);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n * direction of positive Infinity.\r\n *\r\n */ P.ceil = function() {\n    return finalise(new this.constructor(this), this.e + 1, 2);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal clamped to the range\r\n * delineated by `min` and `max`.\r\n *\r\n * min {number|string|Decimal}\r\n * max {number|string|Decimal}\r\n *\r\n */ P.clampedTo = P.clamp = function(min, max) {\n    var k, x = this, Ctor = x.constructor;\n    min = new Ctor(min);\n    max = new Ctor(max);\n    if (!min.s || !max.s) return new Ctor(NaN);\n    if (min.gt(max)) throw Error(invalidArgument + max);\n    k = x.cmp(min);\n    return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);\n};\n/*\r\n * Return\r\n *   1    if the value of this Decimal is greater than the value of `y`,\r\n *  -1    if the value of this Decimal is less than the value of `y`,\r\n *   0    if they have the same value,\r\n *   NaN  if the value of either Decimal is NaN.\r\n *\r\n */ P.comparedTo = P.cmp = function(y) {\n    var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;\n    // Either NaN or ±Infinity?\n    if (!xd || !yd) {\n        return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\n    }\n    // Either zero?\n    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\n    // Signs differ?\n    if (xs !== ys) return xs;\n    // Compare exponents.\n    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\n    xdL = xd.length;\n    ydL = yd.length;\n    // Compare digit by digit.\n    for(i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i){\n        if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\n    }\n    // Compare lengths.\n    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\n};\n/*\r\n * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * cos(0)         = 1\r\n * cos(-0)        = 1\r\n * cos(Infinity)  = NaN\r\n * cos(-Infinity) = NaN\r\n * cos(NaN)       = NaN\r\n *\r\n */ P.cosine = P.cos = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.d) return new Ctor(NaN);\n    // cos(0) = cos(-0) = 1\n    if (!x.d[0]) return new Ctor(1);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n    Ctor.rounding = 1;\n    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\n};\n/*\r\n *\r\n * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n *  cbrt(0)  =  0\r\n *  cbrt(-0) = -0\r\n *  cbrt(1)  =  1\r\n *  cbrt(-1) = -1\r\n *  cbrt(N)  =  N\r\n *  cbrt(-I) = -I\r\n *  cbrt(I)  =  I\r\n *\r\n * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n *\r\n */ P.cubeRoot = P.cbrt = function() {\n    var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\n    external = false;\n    // Initial estimate.\n    s = x.s * mathpow(x.s * x, 1 / 3);\n    // Math.cbrt underflow/overflow?\n    // Pass x to Math.pow as integer, then adjust the exponent of the result.\n    if (!s || Math.abs(s) == 1 / 0) {\n        n = digitsToString(x.d);\n        e = x.e;\n        // Adjust n exponent so it is a multiple of 3 away from x exponent.\n        if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? \"0\" : \"00\";\n        s = mathpow(n, 1 / 3);\n        // Rarely, e may be one less than the result exponent value.\n        e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\n        if (s == 1 / 0) {\n            n = \"5e\" + e;\n        } else {\n            n = s.toExponential();\n            n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n        }\n        r = new Ctor(n);\n        r.s = x.s;\n    } else {\n        r = new Ctor(s.toString());\n    }\n    sd = (e = Ctor.precision) + 3;\n    // Halley's method.\n    // TODO? Compare Newton's method.\n    for(;;){\n        t = r;\n        t3 = t.times(t).times(t);\n        t3plusx = t3.plus(x);\n        r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\n        // TODO? Replace with for-loop and checkRoundingDigits.\n        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n            n = n.slice(sd - 3, sd + 1);\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\n            // , i.e. approaching a rounding boundary, continue the iteration.\n            if (n == \"9999\" || !rep && n == \"4999\") {\n                // On the first iteration only, check to see if rounding up gives the exact result as the\n                // nines may infinitely repeat.\n                if (!rep) {\n                    finalise(t, e + 1, 0);\n                    if (t.times(t).times(t).eq(x)) {\n                        r = t;\n                        break;\n                    }\n                }\n                sd += 4;\n                rep = 1;\n            } else {\n                // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\n                // If not, then there are further digits and m will be truthy.\n                if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n                    // Truncate to the first rounding digit.\n                    finalise(r, e + 1, 1);\n                    m = !r.times(r).times(r).eq(x);\n                }\n                break;\n            }\n        }\n    }\n    external = true;\n    return finalise(r, e, Ctor.rounding, m);\n};\n/*\r\n * Return the number of decimal places of the value of this Decimal.\r\n *\r\n */ P.decimalPlaces = P.dp = function() {\n    var w, d = this.d, n = NaN;\n    if (d) {\n        w = d.length - 1;\n        n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\n        // Subtract the number of trailing zeros of the last word.\n        w = d[w];\n        if (w) for(; w % 10 == 0; w /= 10)n--;\n        if (n < 0) n = 0;\n    }\n    return n;\n};\n/*\r\n *  n / 0 = I\r\n *  n / N = N\r\n *  n / I = 0\r\n *  0 / n = 0\r\n *  0 / 0 = N\r\n *  0 / N = N\r\n *  0 / I = 0\r\n *  N / n = N\r\n *  N / 0 = N\r\n *  N / N = N\r\n *  N / I = N\r\n *  I / n = I\r\n *  I / 0 = I\r\n *  I / N = N\r\n *  I / I = N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */ P.dividedBy = P.div = function(y) {\n    return divide(this, new this.constructor(y));\n};\n/*\r\n * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */ P.dividedToIntegerBy = P.divToInt = function(y) {\n    var x = this, Ctor = x.constructor;\n    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\n};\n/*\r\n * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n *\r\n */ P.equals = P.eq = function(y) {\n    return this.cmp(y) === 0;\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n * direction of negative Infinity.\r\n *\r\n */ P.floor = function() {\n    return finalise(new this.constructor(this), this.e + 1, 3);\n};\n/*\r\n * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n * false.\r\n *\r\n */ P.greaterThan = P.gt = function(y) {\n    return this.cmp(y) > 0;\n};\n/*\r\n * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n * otherwise return false.\r\n *\r\n */ P.greaterThanOrEqualTo = P.gte = function(y) {\n    var k = this.cmp(y);\n    return k == 1 || k === 0;\n};\n/*\r\n * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [1, Infinity]\r\n *\r\n * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n *\r\n * cosh(0)         = 1\r\n * cosh(-0)        = 1\r\n * cosh(Infinity)  = Infinity\r\n * cosh(-Infinity) = Infinity\r\n * cosh(NaN)       = NaN\r\n *\r\n *  x        time taken (ms)   result\r\n * 1000      9                 9.8503555700852349694e+433\r\n * 10000     25                4.4034091128314607936e+4342\r\n * 100000    171               1.4033316802130615897e+43429\r\n * 1000000   3817              1.5166076984010437725e+434294\r\n * 10000000  abandoned after 2 minute wait\r\n *\r\n * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n *\r\n */ P.hyperbolicCosine = P.cosh = function() {\n    var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);\n    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\n    if (x.isZero()) return one;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n    Ctor.rounding = 1;\n    len = x.d.length;\n    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\n    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\n    // Estimate the optimum number of times to use the argument reduction.\n    // TODO? Estimation reused from cosine() and may not be optimal here.\n    if (len < 32) {\n        k = Math.ceil(len / 3);\n        n = (1 / tinyPow(4, k)).toString();\n    } else {\n        k = 16;\n        n = \"2.3283064365386962890625e-10\";\n    }\n    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\n    // Reverse argument reduction\n    var cosh2_x, i = k, d8 = new Ctor(8);\n    for(; i--;){\n        cosh2_x = x.times(x);\n        x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\n    }\n    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\n/*\r\n * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n *\r\n * sinh(0)         = 0\r\n * sinh(-0)        = -0\r\n * sinh(Infinity)  = Infinity\r\n * sinh(-Infinity) = -Infinity\r\n * sinh(NaN)       = NaN\r\n *\r\n * x        time taken (ms)\r\n * 10       2 ms\r\n * 100      5 ms\r\n * 1000     14 ms\r\n * 10000    82 ms\r\n * 100000   886 ms            1.4033316802130615897e+43429\r\n * 200000   2613 ms\r\n * 300000   5407 ms\r\n * 400000   8824 ms\r\n * 500000   13026 ms          8.7080643612718084129e+217146\r\n * 1000000  48543 ms\r\n *\r\n * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n *\r\n */ P.hyperbolicSine = P.sinh = function() {\n    var k, pr, rm, len, x = this, Ctor = x.constructor;\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n    Ctor.rounding = 1;\n    len = x.d.length;\n    if (len < 3) {\n        x = taylorSeries(Ctor, 2, x, x, true);\n    } else {\n        // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\n        // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\n        // 3 multiplications and 1 addition\n        // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\n        // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\n        // 4 multiplications and 2 additions\n        // Estimate the optimum number of times to use the argument reduction.\n        k = 1.4 * Math.sqrt(len);\n        k = k > 16 ? 16 : k | 0;\n        x = x.times(1 / tinyPow(5, k));\n        x = taylorSeries(Ctor, 2, x, x, true);\n        // Reverse argument reduction\n        var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n        for(; k--;){\n            sinh2_x = x.times(x);\n            x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\n        }\n    }\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(x, pr, rm, true);\n};\n/*\r\n * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * tanh(x) = sinh(x) / cosh(x)\r\n *\r\n * tanh(0)         = 0\r\n * tanh(-0)        = -0\r\n * tanh(Infinity)  = 1\r\n * tanh(-Infinity) = -1\r\n * tanh(NaN)       = NaN\r\n *\r\n */ P.hyperbolicTangent = P.tanh = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(x.s);\n    if (x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + 7;\n    Ctor.rounding = 1;\n    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\n};\n/*\r\n * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n * this Decimal.\r\n *\r\n * Domain: [-1, 1]\r\n * Range: [0, pi]\r\n *\r\n * acos(x) = pi/2 - asin(x)\r\n *\r\n * acos(0)       = pi/2\r\n * acos(-0)      = pi/2\r\n * acos(1)       = 0\r\n * acos(-1)      = pi\r\n * acos(1/2)     = pi/3\r\n * acos(-1/2)    = 2*pi/3\r\n * acos(|x| > 1) = NaN\r\n * acos(NaN)     = NaN\r\n *\r\n */ P.inverseCosine = P.acos = function() {\n    var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;\n    if (k !== -1) {\n        return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);\n    }\n    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\n    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\n    Ctor.precision = pr + 6;\n    Ctor.rounding = 1;\n    x = x.asin();\n    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return halfPi.minus(x);\n};\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n * value of this Decimal.\r\n *\r\n * Domain: [1, Infinity]\r\n * Range: [0, Infinity]\r\n *\r\n * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n *\r\n * acosh(x < 1)     = NaN\r\n * acosh(NaN)       = NaN\r\n * acosh(Infinity)  = Infinity\r\n * acosh(-Infinity) = NaN\r\n * acosh(0)         = NaN\r\n * acosh(-0)        = NaN\r\n * acosh(1)         = 0\r\n * acosh(-1)        = NaN\r\n *\r\n */ P.inverseHyperbolicCosine = P.acosh = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\n    if (!x.isFinite()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\n    Ctor.rounding = 1;\n    external = false;\n    x = x.times(x).minus(1).sqrt().plus(x);\n    external = true;\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.ln();\n};\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n * of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n *\r\n * asinh(NaN)       = NaN\r\n * asinh(Infinity)  = Infinity\r\n * asinh(-Infinity) = -Infinity\r\n * asinh(0)         = 0\r\n * asinh(-0)        = -0\r\n *\r\n */ P.inverseHyperbolicSine = P.asinh = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\n    Ctor.rounding = 1;\n    external = false;\n    x = x.times(x).plus(1).sqrt().plus(x);\n    external = true;\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.ln();\n};\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n * value of this Decimal.\r\n *\r\n * Domain: [-1, 1]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n *\r\n * atanh(|x| > 1)   = NaN\r\n * atanh(NaN)       = NaN\r\n * atanh(Infinity)  = NaN\r\n * atanh(-Infinity) = NaN\r\n * atanh(0)         = 0\r\n * atanh(-0)        = -0\r\n * atanh(1)         = Infinity\r\n * atanh(-1)        = -Infinity\r\n *\r\n */ P.inverseHyperbolicTangent = P.atanh = function() {\n    var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(NaN);\n    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    xsd = x.sd();\n    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\n    Ctor.precision = wpr = xsd - x.e;\n    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\n    Ctor.precision = pr + 4;\n    Ctor.rounding = 1;\n    x = x.ln();\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.times(0.5);\n};\n/*\r\n * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi/2, pi/2]\r\n *\r\n * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n *\r\n * asin(0)       = 0\r\n * asin(-0)      = -0\r\n * asin(1/2)     = pi/6\r\n * asin(-1/2)    = -pi/6\r\n * asin(1)       = pi/2\r\n * asin(-1)      = -pi/2\r\n * asin(|x| > 1) = NaN\r\n * asin(NaN)     = NaN\r\n *\r\n * TODO? Compare performance of Taylor series.\r\n *\r\n */ P.inverseSine = P.asin = function() {\n    var halfPi, k, pr, rm, x = this, Ctor = x.constructor;\n    if (x.isZero()) return new Ctor(x);\n    k = x.abs().cmp(1);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    if (k !== -1) {\n        // |x| is 1\n        if (k === 0) {\n            halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n            halfPi.s = x.s;\n            return halfPi;\n        }\n        // |x| > 1 or x is NaN\n        return new Ctor(NaN);\n    }\n    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\n    Ctor.precision = pr + 6;\n    Ctor.rounding = 1;\n    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.times(2);\n};\n/*\r\n * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n * of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi/2, pi/2]\r\n *\r\n * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n *\r\n * atan(0)         = 0\r\n * atan(-0)        = -0\r\n * atan(1)         = pi/4\r\n * atan(-1)        = -pi/4\r\n * atan(Infinity)  = pi/2\r\n * atan(-Infinity) = -pi/2\r\n * atan(NaN)       = NaN\r\n *\r\n */ P.inverseTangent = P.atan = function() {\n    var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;\n    if (!x.isFinite()) {\n        if (!x.s) return new Ctor(NaN);\n        if (pr + 4 <= PI_PRECISION) {\n            r = getPi(Ctor, pr + 4, rm).times(0.5);\n            r.s = x.s;\n            return r;\n        }\n    } else if (x.isZero()) {\n        return new Ctor(x);\n    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\n        r = getPi(Ctor, pr + 4, rm).times(0.25);\n        r.s = x.s;\n        return r;\n    }\n    Ctor.precision = wpr = pr + 10;\n    Ctor.rounding = 1;\n    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\n    // Argument reduction\n    // Ensure |x| < 0.42\n    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\n    k = Math.min(28, wpr / LOG_BASE + 2 | 0);\n    for(i = k; i; --i)x = x.div(x.times(x).plus(1).sqrt().plus(1));\n    external = false;\n    j = Math.ceil(wpr / LOG_BASE);\n    n = 1;\n    x2 = x.times(x);\n    r = new Ctor(x);\n    px = x;\n    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\n    for(; i !== -1;){\n        px = px.times(x2);\n        t = r.minus(px.div(n += 2));\n        px = px.times(x2);\n        r = t.plus(px.div(n += 2));\n        if (r.d[j] !== void 0) for(i = j; r.d[i] === t.d[i] && i--;);\n    }\n    if (k) r = r.times(2 << k - 1);\n    external = true;\n    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\n/*\r\n * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n *\r\n */ P.isFinite = function() {\n    return !!this.d;\n};\n/*\r\n * Return true if the value of this Decimal is an integer, otherwise return false.\r\n *\r\n */ P.isInteger = P.isInt = function() {\n    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\n};\n/*\r\n * Return true if the value of this Decimal is NaN, otherwise return false.\r\n *\r\n */ P.isNaN = function() {\n    return !this.s;\n};\n/*\r\n * Return true if the value of this Decimal is negative, otherwise return false.\r\n *\r\n */ P.isNegative = P.isNeg = function() {\n    return this.s < 0;\n};\n/*\r\n * Return true if the value of this Decimal is positive, otherwise return false.\r\n *\r\n */ P.isPositive = P.isPos = function() {\n    return this.s > 0;\n};\n/*\r\n * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n *\r\n */ P.isZero = function() {\n    return !!this.d && this.d[0] === 0;\n};\n/*\r\n * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n *\r\n */ P.lessThan = P.lt = function(y) {\n    return this.cmp(y) < 0;\n};\n/*\r\n * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n *\r\n */ P.lessThanOrEqualTo = P.lte = function(y) {\n    return this.cmp(y) < 1;\n};\n/*\r\n * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * If no base is specified, return log[10](arg).\r\n *\r\n * log[base](arg) = ln(arg) / ln(base)\r\n *\r\n * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n * otherwise:\r\n *\r\n * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n *\r\n * log[-b](a)       = NaN\r\n * log[0](a)        = NaN\r\n * log[1](a)        = NaN\r\n * log[NaN](a)      = NaN\r\n * log[Infinity](a) = NaN\r\n * log[b](0)        = -Infinity\r\n * log[b](-0)       = -Infinity\r\n * log[b](-a)       = NaN\r\n * log[b](1)        = 0\r\n * log[b](Infinity) = Infinity\r\n * log[b](NaN)      = NaN\r\n *\r\n * [base] {number|string|Decimal} The base of the logarithm.\r\n *\r\n */ P.logarithm = P.log = function(base) {\n    var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;\n    // Default base is 10.\n    if (base == null) {\n        base = new Ctor(10);\n        isBase10 = true;\n    } else {\n        base = new Ctor(base);\n        d = base.d;\n        // Return NaN if base is negative, or non-finite, or is 0 or 1.\n        if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\n        isBase10 = base.eq(10);\n    }\n    d = arg.d;\n    // Is arg negative, non-finite, 0 or 1?\n    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\n        return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\n    }\n    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\n    // integer power of 10.\n    if (isBase10) {\n        if (d.length > 1) {\n            inf = true;\n        } else {\n            for(k = d[0]; k % 10 === 0;)k /= 10;\n            inf = k !== 1;\n        }\n    }\n    external = false;\n    sd = pr + guard;\n    num = naturalLogarithm(arg, sd);\n    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n    // The result will have 5 rounding digits.\n    r = divide(num, denominator, sd, 1);\n    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\n    // calculate 10 further digits.\n    //\n    // If the result is known to have an infinite decimal expansion, repeat this until it is clear\n    // that the result is above or below the boundary. Otherwise, if after calculating the 10\n    // further digits, the last 14 are nines, round up and assume the result is exact.\n    // Also assume the result is exact if the last 14 are zero.\n    //\n    // Example of a result that will be incorrectly rounded:\n    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\n    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\n    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\n    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\n    // place is still 2.6.\n    if (checkRoundingDigits(r.d, k = pr, rm)) {\n        do {\n            sd += 10;\n            num = naturalLogarithm(arg, sd);\n            denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n            r = divide(num, denominator, sd, 1);\n            if (!inf) {\n                // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\n                if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\n                    r = finalise(r, pr + 1, 0);\n                }\n                break;\n            }\n        }while (checkRoundingDigits(r.d, k += 10, rm));\n    }\n    external = true;\n    return finalise(r, pr, rm);\n};\n/*\r\n * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\nP.max = function () {\r\n  Array.prototype.push.call(arguments, this);\r\n  return maxOrMin(this.constructor, arguments, 'lt');\r\n};\r\n */ /*\r\n * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\nP.min = function () {\r\n  Array.prototype.push.call(arguments, this);\r\n  return maxOrMin(this.constructor, arguments, 'gt');\r\n};\r\n */ /*\r\n *  n - 0 = n\r\n *  n - N = N\r\n *  n - I = -I\r\n *  0 - n = -n\r\n *  0 - 0 = 0\r\n *  0 - N = N\r\n *  0 - I = -I\r\n *  N - n = N\r\n *  N - 0 = N\r\n *  N - N = N\r\n *  N - I = N\r\n *  I - n = I\r\n *  I - 0 = I\r\n *  I - N = N\r\n *  I - I = N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */ P.minus = P.sub = function(y) {\n    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;\n    y = new Ctor(y);\n    // If either is not finite...\n    if (!x.d || !y.d) {\n        // Return NaN if either is NaN.\n        if (!x.s || !y.s) y = new Ctor(NaN);\n        else if (x.d) y.s = -y.s;\n        else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\n        return y;\n    }\n    // If signs differ...\n    if (x.s != y.s) {\n        y.s = -y.s;\n        return x.plus(y);\n    }\n    xd = x.d;\n    yd = y.d;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    // If either is zero...\n    if (!xd[0] || !yd[0]) {\n        // Return y negated if x is zero and y is non-zero.\n        if (yd[0]) y.s = -y.s;\n        else if (xd[0]) y = new Ctor(x);\n        else return new Ctor(rm === 3 ? -0 : 0);\n        return external ? finalise(y, pr, rm) : y;\n    }\n    // x and y are finite, non-zero numbers with the same sign.\n    // Calculate base 1e7 exponents.\n    e = mathfloor(y.e / LOG_BASE);\n    xe = mathfloor(x.e / LOG_BASE);\n    xd = xd.slice();\n    k = xe - e;\n    // If base 1e7 exponents differ...\n    if (k) {\n        xLTy = k < 0;\n        if (xLTy) {\n            d = xd;\n            k = -k;\n            len = yd.length;\n        } else {\n            d = yd;\n            e = xe;\n            len = xd.length;\n        }\n        // Numbers with massively different exponents would result in a very high number of\n        // zeros needing to be prepended, but this can be avoided while still ensuring correct\n        // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\n        i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\n        if (k > i) {\n            k = i;\n            d.length = 1;\n        }\n        // Prepend zeros to equalise exponents.\n        d.reverse();\n        for(i = k; i--;)d.push(0);\n        d.reverse();\n    // Base 1e7 exponents equal.\n    } else {\n        // Check digits to determine which is the bigger number.\n        i = xd.length;\n        len = yd.length;\n        xLTy = i < len;\n        if (xLTy) len = i;\n        for(i = 0; i < len; i++){\n            if (xd[i] != yd[i]) {\n                xLTy = xd[i] < yd[i];\n                break;\n            }\n        }\n        k = 0;\n    }\n    if (xLTy) {\n        d = xd;\n        xd = yd;\n        yd = d;\n        y.s = -y.s;\n    }\n    len = xd.length;\n    // Append zeros to `xd` if shorter.\n    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\n    for(i = yd.length - len; i > 0; --i)xd[len++] = 0;\n    // Subtract yd from xd.\n    for(i = yd.length; i > k;){\n        if (xd[--i] < yd[i]) {\n            for(j = i; j && xd[--j] === 0;)xd[j] = BASE - 1;\n            --xd[j];\n            xd[i] += BASE;\n        }\n        xd[i] -= yd[i];\n    }\n    // Remove trailing zeros.\n    for(; xd[--len] === 0;)xd.pop();\n    // Remove leading zeros and adjust exponent accordingly.\n    for(; xd[0] === 0; xd.shift())--e;\n    // Zero?\n    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\n    y.d = xd;\n    y.e = getBase10Exponent(xd, e);\n    return external ? finalise(y, pr, rm) : y;\n};\n/*\r\n *   n % 0 =  N\r\n *   n % N =  N\r\n *   n % I =  n\r\n *   0 % n =  0\r\n *  -0 % n = -0\r\n *   0 % 0 =  N\r\n *   0 % N =  N\r\n *   0 % I =  0\r\n *   N % n =  N\r\n *   N % 0 =  N\r\n *   N % N =  N\r\n *   N % I =  N\r\n *   I % n =  N\r\n *   I % 0 =  N\r\n *   I % N =  N\r\n *   I % I =  N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * The result depends on the modulo mode.\r\n *\r\n */ P.modulo = P.mod = function(y) {\n    var q, x = this, Ctor = x.constructor;\n    y = new Ctor(y);\n    // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.\n    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\n    // Return x if y is ±Infinity or x is ±0.\n    if (!y.d || x.d && !x.d[0]) {\n        return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\n    }\n    // Prevent rounding of intermediate calculations.\n    external = false;\n    if (Ctor.modulo == 9) {\n        // Euclidian division: q = sign(y) * floor(x / abs(y))\n        // result = x - q * y    where  0 <= result < abs(y)\n        q = divide(x, y.abs(), 0, 3, 1);\n        q.s *= y.s;\n    } else {\n        q = divide(x, y, 0, Ctor.modulo, 1);\n    }\n    q = q.times(y);\n    external = true;\n    return x.minus(q);\n};\n/*\r\n * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */ P.naturalExponential = P.exp = function() {\n    return naturalExponential(this);\n};\n/*\r\n * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n * rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */ P.naturalLogarithm = P.ln = function() {\n    return naturalLogarithm(this);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n * -1.\r\n *\r\n */ P.negated = P.neg = function() {\n    var x = new this.constructor(this);\n    x.s = -x.s;\n    return finalise(x);\n};\n/*\r\n *  n + 0 = n\r\n *  n + N = N\r\n *  n + I = I\r\n *  0 + n = n\r\n *  0 + 0 = 0\r\n *  0 + N = N\r\n *  0 + I = I\r\n *  N + n = N\r\n *  N + 0 = N\r\n *  N + N = N\r\n *  N + I = N\r\n *  I + n = I\r\n *  I + 0 = I\r\n *  I + N = N\r\n *  I + I = I\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */ P.plus = P.add = function(y) {\n    var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;\n    y = new Ctor(y);\n    // If either is not finite...\n    if (!x.d || !y.d) {\n        // Return NaN if either is NaN.\n        if (!x.s || !y.s) y = new Ctor(NaN);\n        else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\n        return y;\n    }\n    // If signs differ...\n    if (x.s != y.s) {\n        y.s = -y.s;\n        return x.minus(y);\n    }\n    xd = x.d;\n    yd = y.d;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    // If either is zero...\n    if (!xd[0] || !yd[0]) {\n        // Return x if y is zero.\n        // Return y if y is non-zero.\n        if (!yd[0]) y = new Ctor(x);\n        return external ? finalise(y, pr, rm) : y;\n    }\n    // x and y are finite, non-zero numbers with the same sign.\n    // Calculate base 1e7 exponents.\n    k = mathfloor(x.e / LOG_BASE);\n    e = mathfloor(y.e / LOG_BASE);\n    xd = xd.slice();\n    i = k - e;\n    // If base 1e7 exponents differ...\n    if (i) {\n        if (i < 0) {\n            d = xd;\n            i = -i;\n            len = yd.length;\n        } else {\n            d = yd;\n            e = k;\n            len = xd.length;\n        }\n        // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\n        k = Math.ceil(pr / LOG_BASE);\n        len = k > len ? k + 1 : len + 1;\n        if (i > len) {\n            i = len;\n            d.length = 1;\n        }\n        // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\n        d.reverse();\n        for(; i--;)d.push(0);\n        d.reverse();\n    }\n    len = xd.length;\n    i = yd.length;\n    // If yd is longer than xd, swap xd and yd so xd points to the longer array.\n    if (len - i < 0) {\n        i = len;\n        d = yd;\n        yd = xd;\n        xd = d;\n    }\n    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\n    for(carry = 0; i;){\n        carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\n        xd[i] %= BASE;\n    }\n    if (carry) {\n        xd.unshift(carry);\n        ++e;\n    }\n    // Remove trailing zeros.\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n    for(len = xd.length; xd[--len] == 0;)xd.pop();\n    y.d = xd;\n    y.e = getBase10Exponent(xd, e);\n    return external ? finalise(y, pr, rm) : y;\n};\n/*\r\n * Return the number of significant digits of the value of this Decimal.\r\n *\r\n * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n *\r\n */ P.precision = P.sd = function(z) {\n    var k, x = this;\n    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\n    if (x.d) {\n        k = getPrecision(x.d);\n        if (z && x.e + 1 > k) k = x.e + 1;\n    } else {\n        k = NaN;\n    }\n    return k;\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n * rounding mode `rounding`.\r\n *\r\n */ P.round = function() {\n    var x = this, Ctor = x.constructor;\n    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\n};\n/*\r\n * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * sin(x) = x - x^3/3! + x^5/5! - ...\r\n *\r\n * sin(0)         = 0\r\n * sin(-0)        = -0\r\n * sin(Infinity)  = NaN\r\n * sin(-Infinity) = NaN\r\n * sin(NaN)       = NaN\r\n *\r\n */ P.sine = P.sin = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(NaN);\n    if (x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n    Ctor.rounding = 1;\n    x = sine(Ctor, toLessThanHalfPi(Ctor, x));\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\n};\n/*\r\n * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n *  sqrt(-n) =  N\r\n *  sqrt(N)  =  N\r\n *  sqrt(-I) =  N\r\n *  sqrt(I)  =  I\r\n *  sqrt(0)  =  0\r\n *  sqrt(-0) = -0\r\n *\r\n */ P.squareRoot = P.sqrt = function() {\n    var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;\n    // Negative/NaN/Infinity/zero?\n    if (s !== 1 || !d || !d[0]) {\n        return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\n    }\n    external = false;\n    // Initial estimate.\n    s = Math.sqrt(+x);\n    // Math.sqrt underflow/overflow?\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\n    if (s == 0 || s == 1 / 0) {\n        n = digitsToString(d);\n        if ((n.length + e) % 2 == 0) n += \"0\";\n        s = Math.sqrt(n);\n        e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\n        if (s == 1 / 0) {\n            n = \"5e\" + e;\n        } else {\n            n = s.toExponential();\n            n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n        }\n        r = new Ctor(n);\n    } else {\n        r = new Ctor(s.toString());\n    }\n    sd = (e = Ctor.precision) + 3;\n    // Newton-Raphson iteration.\n    for(;;){\n        t = r;\n        r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\n        // TODO? Replace with for-loop and checkRoundingDigits.\n        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n            n = n.slice(sd - 3, sd + 1);\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\n            // 4999, i.e. approaching a rounding boundary, continue the iteration.\n            if (n == \"9999\" || !rep && n == \"4999\") {\n                // On the first iteration only, check to see if rounding up gives the exact result as the\n                // nines may infinitely repeat.\n                if (!rep) {\n                    finalise(t, e + 1, 0);\n                    if (t.times(t).eq(x)) {\n                        r = t;\n                        break;\n                    }\n                }\n                sd += 4;\n                rep = 1;\n            } else {\n                // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\n                // If not, then there are further digits and m will be truthy.\n                if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n                    // Truncate to the first rounding digit.\n                    finalise(r, e + 1, 1);\n                    m = !r.times(r).eq(x);\n                }\n                break;\n            }\n        }\n    }\n    external = true;\n    return finalise(r, e, Ctor.rounding, m);\n};\n/*\r\n * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * tan(0)         = 0\r\n * tan(-0)        = -0\r\n * tan(Infinity)  = NaN\r\n * tan(-Infinity) = NaN\r\n * tan(NaN)       = NaN\r\n *\r\n */ P.tangent = P.tan = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(NaN);\n    if (x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + 10;\n    Ctor.rounding = 1;\n    x = x.sin();\n    x.s = 1;\n    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\n};\n/*\r\n *  n * 0 = 0\r\n *  n * N = N\r\n *  n * I = I\r\n *  0 * n = 0\r\n *  0 * 0 = 0\r\n *  0 * N = N\r\n *  0 * I = N\r\n *  N * n = N\r\n *  N * 0 = N\r\n *  N * N = N\r\n *  N * I = N\r\n *  I * n = I\r\n *  I * 0 = N\r\n *  I * N = N\r\n *  I * I = I\r\n *\r\n * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n */ P.times = P.mul = function(y) {\n    var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;\n    y.s *= x.s;\n    // If either is NaN, ±Infinity or ±0...\n    if (!xd || !xd[0] || !yd || !yd[0]) {\n        return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);\n    }\n    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\n    xdL = xd.length;\n    ydL = yd.length;\n    // Ensure xd points to the longer array.\n    if (xdL < ydL) {\n        r = xd;\n        xd = yd;\n        yd = r;\n        rL = xdL;\n        xdL = ydL;\n        ydL = rL;\n    }\n    // Initialise the result array with zeros.\n    r = [];\n    rL = xdL + ydL;\n    for(i = rL; i--;)r.push(0);\n    // Multiply!\n    for(i = ydL; --i >= 0;){\n        carry = 0;\n        for(k = xdL + i; k > i;){\n            t = r[k] + yd[i] * xd[k - i - 1] + carry;\n            r[k--] = t % BASE | 0;\n            carry = t / BASE | 0;\n        }\n        r[k] = (r[k] + carry) % BASE | 0;\n    }\n    // Remove trailing zeros.\n    for(; !r[--rL];)r.pop();\n    if (carry) ++e;\n    else r.shift();\n    y.d = r;\n    y.e = getBase10Exponent(r, e);\n    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\n};\n/*\r\n * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toBinary = function(sd, rm) {\n    return toStringBinary(this, 2, sd, rm);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n *\r\n * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toDecimalPlaces = P.toDP = function(dp, rm) {\n    var x = this, Ctor = x.constructor;\n    x = new Ctor(x);\n    if (dp === void 0) return x;\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0) rm = Ctor.rounding;\n    else checkInt32(rm, 0, 8);\n    return finalise(x, dp + x.e + 1, rm);\n};\n/*\r\n * Return a string representing the value of this Decimal in exponential notation rounded to\r\n * `dp` fixed decimal places using rounding mode `rounding`.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toExponential = function(dp, rm) {\n    var str, x = this, Ctor = x.constructor;\n    if (dp === void 0) {\n        str = finiteToString(x, true);\n    } else {\n        checkInt32(dp, 0, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n        x = finalise(new Ctor(x), dp + 1, rm);\n        str = finiteToString(x, true, dp + 1);\n    }\n    return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\n/*\r\n * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n * omitted.\r\n *\r\n * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n * (-0).toFixed(3) is '0.000'.\r\n * (-0.5).toFixed(0) is '-0'.\r\n *\r\n */ P.toFixed = function(dp, rm) {\n    var str, y, x = this, Ctor = x.constructor;\n    if (dp === void 0) {\n        str = finiteToString(x);\n    } else {\n        checkInt32(dp, 0, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n        y = finalise(new Ctor(x), dp + x.e + 1, rm);\n        str = finiteToString(y, false, dp + y.e + 1);\n    }\n    // To determine whether to add the minus sign look at the value before it was rounded,\n    // i.e. look at `x` rather than `y`.\n    return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\n/*\r\n * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n * numerator and an integer denominator.\r\n *\r\n * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n * value necessary to represent the number exactly.\r\n *\r\n * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n *\r\n */ P.toFraction = function(maxD) {\n    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;\n    if (!xd) return new Ctor(x);\n    n1 = d0 = new Ctor(1);\n    d1 = n0 = new Ctor(0);\n    d = new Ctor(d1);\n    e = d.e = getPrecision(xd) - x.e - 1;\n    k = e % LOG_BASE;\n    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\n    if (maxD == null) {\n        // d is 10**e, the minimum max-denominator needed.\n        maxD = e > 0 ? d : n1;\n    } else {\n        n = new Ctor(maxD);\n        if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\n        maxD = n.gt(d) ? e > 0 ? d : n1 : n;\n    }\n    external = false;\n    n = new Ctor(digitsToString(xd));\n    pr = Ctor.precision;\n    Ctor.precision = e = xd.length * LOG_BASE * 2;\n    for(;;){\n        q = divide(n, d, 0, 1, 1);\n        d2 = d0.plus(q.times(d1));\n        if (d2.cmp(maxD) == 1) break;\n        d0 = d1;\n        d1 = d2;\n        d2 = n1;\n        n1 = n0.plus(q.times(d2));\n        n0 = d2;\n        d2 = d;\n        d = n.minus(q.times(d2));\n        n = d2;\n    }\n    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\n    n0 = n0.plus(d2.times(n1));\n    d0 = d0.plus(d2.times(d1));\n    n0.s = n1.s = x.s;\n    // Determine which fraction is closer to x, n0/d0 or n1/d1?\n    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [\n        n1,\n        d1\n    ] : [\n        n0,\n        d0\n    ];\n    Ctor.precision = pr;\n    external = true;\n    return r;\n};\n/*\r\n * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toHexadecimal = P.toHex = function(sd, rm) {\n    return toStringBinary(this, 16, sd, rm);\n};\n/*\r\n * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding\r\n * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.\r\n *\r\n * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n * or `y` is NaN, in which case the return value will be also be NaN.\r\n *\r\n * The return value is not affected by the value of `precision`.\r\n *\r\n * y {number|string|Decimal} The magnitude to round to a multiple of.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * 'toNearest() rounding mode not an integer: {rm}'\r\n * 'toNearest() rounding mode out of range: {rm}'\r\n *\r\n */ P.toNearest = function(y, rm) {\n    var x = this, Ctor = x.constructor;\n    x = new Ctor(x);\n    if (y == null) {\n        // If x is not finite, return x.\n        if (!x.d) return x;\n        y = new Ctor(1);\n        rm = Ctor.rounding;\n    } else {\n        y = new Ctor(y);\n        if (rm === void 0) {\n            rm = Ctor.rounding;\n        } else {\n            checkInt32(rm, 0, 8);\n        }\n        // If x is not finite, return x if y is not NaN, else NaN.\n        if (!x.d) return y.s ? x : y;\n        // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\n        if (!y.d) {\n            if (y.s) y.s = x.s;\n            return y;\n        }\n    }\n    // If y is not zero, calculate the nearest multiple of y to x.\n    if (y.d[0]) {\n        external = false;\n        x = divide(x, y, 0, rm, 1).times(y);\n        external = true;\n        finalise(x);\n    // If y is zero, return zero with the sign of x.\n    } else {\n        y.s = x.s;\n        x = y;\n    }\n    return x;\n};\n/*\r\n * Return the value of this Decimal converted to a number primitive.\r\n * Zero keeps its sign.\r\n *\r\n */ P.toNumber = function() {\n    return +this;\n};\n/*\r\n * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toOctal = function(sd, rm) {\n    return toStringBinary(this, 8, sd, rm);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n * to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * ECMAScript compliant.\r\n *\r\n *   pow(x, NaN)                           = NaN\r\n *   pow(x, ±0)                            = 1\r\n\r\n *   pow(NaN, non-zero)                    = NaN\r\n *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n *   pow(abs(x) > 1, -Infinity)            = +0\r\n *   pow(abs(x) == 1, ±Infinity)           = NaN\r\n *   pow(abs(x) < 1, +Infinity)            = +0\r\n *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n *   pow(+Infinity, y > 0)                 = +Infinity\r\n *   pow(+Infinity, y < 0)                 = +0\r\n *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n *   pow(-Infinity, even integer > 0)      = +Infinity\r\n *   pow(-Infinity, odd integer < 0)       = -0\r\n *   pow(-Infinity, even integer < 0)      = +0\r\n *   pow(+0, y > 0)                        = +0\r\n *   pow(+0, y < 0)                        = +Infinity\r\n *   pow(-0, odd integer > 0)              = -0\r\n *   pow(-0, even integer > 0)             = +0\r\n *   pow(-0, odd integer < 0)              = -Infinity\r\n *   pow(-0, even integer < 0)             = +Infinity\r\n *   pow(finite x < 0, finite non-integer) = NaN\r\n *\r\n * For non-integer or very large exponents pow(x, y) is calculated using\r\n *\r\n *   x^y = exp(y*ln(x))\r\n *\r\n * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n * probability of an incorrectly rounded result\r\n * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n * i.e. 1 in 250,000,000,000,000\r\n *\r\n * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n *\r\n * y {number|string|Decimal} The power to which to raise this Decimal.\r\n *\r\n */ P.toPower = P.pow = function(y) {\n    var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));\n    // Either ±Infinity, NaN or ±0?\n    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));\n    x = new Ctor(x);\n    if (x.eq(1)) return x;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    if (y.eq(1)) return finalise(x, pr, rm);\n    // y exponent\n    e = mathfloor(y.e / LOG_BASE);\n    // If y is a small integer use the 'exponentiation by squaring' algorithm.\n    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\n        r = intPow(Ctor, x, k, pr);\n        return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\n    }\n    s = x.s;\n    // if x is negative\n    if (s < 0) {\n        // if y is not an integer\n        if (e < y.d.length - 1) return new Ctor(NaN);\n        // Result is positive if x is negative and the last digit of integer y is even.\n        if ((y.d[e] & 1) == 0) s = 1;\n        // if x.eq(-1)\n        if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\n            x.s = s;\n            return x;\n        }\n    }\n    // Estimate result exponent.\n    // x^y = 10^e,  where e = y * log10(x)\n    // log10(x) = log10(x_significand) + x_exponent\n    // log10(x_significand) = ln(x_significand) / ln(10)\n    k = mathpow(+x, yn);\n    e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log(\"0.\" + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + \"\").e;\n    // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\n    // Overflow/underflow?\n    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);\n    external = false;\n    Ctor.rounding = x.s = 1;\n    // Estimate the extra guard digits needed to ensure five correct rounding digits from\n    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\n    // new Decimal(2.32456).pow('2087987436534566.46411')\n    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\n    k = Math.min(12, (e + \"\").length);\n    // r = x^y = exp(y*ln(x))\n    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\n    // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)\n    if (r.d) {\n        // Truncate to the required precision plus five rounding digits.\n        r = finalise(r, pr + 5, 1);\n        // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\n        // the result.\n        if (checkRoundingDigits(r.d, pr, rm)) {\n            e = pr + 10;\n            // Truncate to the increased precision plus five rounding digits.\n            r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\n            // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\n            if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\n                r = finalise(r, pr + 1, 0);\n            }\n        }\n    }\n    r.s = s;\n    external = true;\n    Ctor.rounding = rm;\n    return finalise(r, pr, rm);\n};\n/*\r\n * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n * the integer part of the value in normal notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toPrecision = function(sd, rm) {\n    var str, x = this, Ctor = x.constructor;\n    if (sd === void 0) {\n        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n    } else {\n        checkInt32(sd, 1, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n        x = finalise(new Ctor(x), sd, rm);\n        str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\n    }\n    return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n * omitted.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * 'toSD() digits out of range: {sd}'\r\n * 'toSD() digits not an integer: {sd}'\r\n * 'toSD() rounding mode not an integer: {rm}'\r\n * 'toSD() rounding mode out of range: {rm}'\r\n *\r\n */ P.toSignificantDigits = P.toSD = function(sd, rm) {\n    var x = this, Ctor = x.constructor;\n    if (sd === void 0) {\n        sd = Ctor.precision;\n        rm = Ctor.rounding;\n    } else {\n        checkInt32(sd, 1, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n    }\n    return finalise(new Ctor(x), sd, rm);\n};\n/*\r\n * Return a string representing the value of this Decimal.\r\n *\r\n * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n *\r\n */ P.toString = function() {\n    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n    return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n *\r\n */ P.truncated = P.trunc = function() {\n    return finalise(new this.constructor(this), this.e + 1, 1);\n};\n/*\r\n * Return a string representing the value of this Decimal.\r\n * Unlike `toString`, negative zero will include the minus sign.\r\n *\r\n */ P.valueOf = P.toJSON = function() {\n    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n    return x.isNeg() ? \"-\" + str : str;\n};\n// Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\n/*\r\n *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n *                           finiteToString, naturalExponential, naturalLogarithm\r\n *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n *  convertBase              toStringBinary, parseOther\r\n *  cos                      P.cos\r\n *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n *                           taylorSeries, atan2, parseOther\r\n *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n *                           naturalLogarithm, ceil, floor, round, trunc\r\n *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n *                           toStringBinary\r\n *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n *  getLn10                  P.logarithm, naturalLogarithm\r\n *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n *  getPrecision             P.precision, P.toFraction\r\n *  getZeroString            digitsToString, finiteToString\r\n *  intPow                   P.toPower, parseOther\r\n *  isOdd                    toLessThanHalfPi\r\n *  maxOrMin                 max, min\r\n *  naturalExponential       P.naturalExponential, P.toPower\r\n *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n *                           P.toPower, naturalExponential\r\n *  nonFiniteToString        finiteToString, toStringBinary\r\n *  parseDecimal             Decimal\r\n *  parseOther               Decimal\r\n *  sin                      P.sin\r\n *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n *  toLessThanHalfPi         P.cos, P.sin\r\n *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n *  truncate                 intPow\r\n *\r\n *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n *                           naturalLogarithm, config, parseOther, random, Decimal\r\n */ function digitsToString(d) {\n    var i, k, ws, indexOfLastWord = d.length - 1, str = \"\", w = d[0];\n    if (indexOfLastWord > 0) {\n        str += w;\n        for(i = 1; i < indexOfLastWord; i++){\n            ws = d[i] + \"\";\n            k = LOG_BASE - ws.length;\n            if (k) str += getZeroString(k);\n            str += ws;\n        }\n        w = d[i];\n        ws = w + \"\";\n        k = LOG_BASE - ws.length;\n        if (k) str += getZeroString(k);\n    } else if (w === 0) {\n        return \"0\";\n    }\n    // Remove trailing zeros of last w.\n    for(; w % 10 === 0;)w /= 10;\n    return str + w;\n}\nfunction checkInt32(i, min, max) {\n    if (i !== ~~i || i < min || i > max) {\n        throw Error(invalidArgument + i);\n    }\n}\n/*\r\n * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n * `repeating == null` if caller is `log` or `pow`,\r\n * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n */ function checkRoundingDigits(d, i, rm, repeating) {\n    var di, k, r, rd;\n    // Get the length of the first word of the array d.\n    for(k = d[0]; k >= 10; k /= 10)--i;\n    // Is the rounding digit in the first word of d?\n    if (--i < 0) {\n        i += LOG_BASE;\n        di = 0;\n    } else {\n        di = Math.ceil((i + 1) / LOG_BASE);\n        i %= LOG_BASE;\n    }\n    // i is the index (0 - 6) of the rounding digit.\n    // E.g. if within the word 3487563 the first rounding digit is 5,\n    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\n    k = mathpow(10, LOG_BASE - i);\n    rd = d[di] % k | 0;\n    if (repeating == null) {\n        if (i < 3) {\n            if (i == 0) rd = rd / 100 | 0;\n            else if (i == 1) rd = rd / 10 | 0;\n            r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\n        } else {\n            r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\n        }\n    } else {\n        if (i < 4) {\n            if (i == 0) rd = rd / 1000 | 0;\n            else if (i == 1) rd = rd / 100 | 0;\n            else if (i == 2) rd = rd / 10 | 0;\n            r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\n        } else {\n            r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\n        }\n    }\n    return r;\n}\n// Convert string of `baseIn` to an array of numbers of `baseOut`.\n// Eg. convertBase('255', 10, 16) returns [15, 15].\n// Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\nfunction convertBase(str, baseIn, baseOut) {\n    var j, arr = [\n        0\n    ], arrL, i = 0, strL = str.length;\n    for(; i < strL;){\n        for(arrL = arr.length; arrL--;)arr[arrL] *= baseIn;\n        arr[0] += NUMERALS.indexOf(str.charAt(i++));\n        for(j = 0; j < arr.length; j++){\n            if (arr[j] > baseOut - 1) {\n                if (arr[j + 1] === void 0) arr[j + 1] = 0;\n                arr[j + 1] += arr[j] / baseOut | 0;\n                arr[j] %= baseOut;\n            }\n        }\n    }\n    return arr.reverse();\n}\n/*\r\n * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n * |x| < pi/2\r\n *\r\n */ function cosine(Ctor, x) {\n    var k, len, y;\n    if (x.isZero()) return x;\n    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\n    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\n    // Estimate the optimum number of times to use the argument reduction.\n    len = x.d.length;\n    if (len < 32) {\n        k = Math.ceil(len / 3);\n        y = (1 / tinyPow(4, k)).toString();\n    } else {\n        k = 16;\n        y = \"2.3283064365386962890625e-10\";\n    }\n    Ctor.precision += k;\n    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\n    // Reverse argument reduction\n    for(var i = k; i--;){\n        var cos2x = x.times(x);\n        x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\n    }\n    Ctor.precision -= k;\n    return x;\n}\n/*\r\n * Perform division in the specified base.\r\n */ var divide = function() {\n    // Assumes non-zero x and k, and hence non-zero result.\n    function multiplyInteger(x, k, base) {\n        var temp, carry = 0, i = x.length;\n        for(x = x.slice(); i--;){\n            temp = x[i] * k + carry;\n            x[i] = temp % base | 0;\n            carry = temp / base | 0;\n        }\n        if (carry) x.unshift(carry);\n        return x;\n    }\n    function compare(a, b, aL, bL) {\n        var i, r;\n        if (aL != bL) {\n            r = aL > bL ? 1 : -1;\n        } else {\n            for(i = r = 0; i < aL; i++){\n                if (a[i] != b[i]) {\n                    r = a[i] > b[i] ? 1 : -1;\n                    break;\n                }\n            }\n        }\n        return r;\n    }\n    function subtract(a, b, aL, base) {\n        var i = 0;\n        // Subtract b from a.\n        for(; aL--;){\n            a[aL] -= i;\n            i = a[aL] < b[aL] ? 1 : 0;\n            a[aL] = i * base + a[aL] - b[aL];\n        }\n        // Remove leading zeros.\n        for(; !a[0] && a.length > 1;)a.shift();\n    }\n    return function(x, y, pr, rm, dp, base) {\n        var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;\n        // Either NaN, Infinity or 0?\n        if (!xd || !xd[0] || !yd || !yd[0]) {\n            return new Ctor(!x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.\n            xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\n        }\n        if (base) {\n            logBase = 1;\n            e = x.e - y.e;\n        } else {\n            base = BASE;\n            logBase = LOG_BASE;\n            e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\n        }\n        yL = yd.length;\n        xL = xd.length;\n        q = new Ctor(sign);\n        qd = q.d = [];\n        // Result exponent may be one less than e.\n        // The digit array of a Decimal from toStringBinary may have trailing zeros.\n        for(i = 0; yd[i] == (xd[i] || 0); i++);\n        if (yd[i] > (xd[i] || 0)) e--;\n        if (pr == null) {\n            sd = pr = Ctor.precision;\n            rm = Ctor.rounding;\n        } else if (dp) {\n            sd = pr + (x.e - y.e) + 1;\n        } else {\n            sd = pr;\n        }\n        if (sd < 0) {\n            qd.push(1);\n            more = true;\n        } else {\n            // Convert precision in number of base 10 digits to base 1e7 digits.\n            sd = sd / logBase + 2 | 0;\n            i = 0;\n            // divisor < 1e7\n            if (yL == 1) {\n                k = 0;\n                yd = yd[0];\n                sd++;\n                // k is the carry.\n                for(; (i < xL || k) && sd--; i++){\n                    t = k * base + (xd[i] || 0);\n                    qd[i] = t / yd | 0;\n                    k = t % yd | 0;\n                }\n                more = k || i < xL;\n            // divisor >= 1e7\n            } else {\n                // Normalise xd and yd so highest order digit of yd is >= base/2\n                k = base / (yd[0] + 1) | 0;\n                if (k > 1) {\n                    yd = multiplyInteger(yd, k, base);\n                    xd = multiplyInteger(xd, k, base);\n                    yL = yd.length;\n                    xL = xd.length;\n                }\n                xi = yL;\n                rem = xd.slice(0, yL);\n                remL = rem.length;\n                // Add zeros to make remainder as long as divisor.\n                for(; remL < yL;)rem[remL++] = 0;\n                yz = yd.slice();\n                yz.unshift(0);\n                yd0 = yd[0];\n                if (yd[1] >= base / 2) ++yd0;\n                do {\n                    k = 0;\n                    // Compare divisor and remainder.\n                    cmp = compare(yd, rem, yL, remL);\n                    // If divisor < remainder.\n                    if (cmp < 0) {\n                        // Calculate trial digit, k.\n                        rem0 = rem[0];\n                        if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\n                        // k will be how many times the divisor goes into the current remainder.\n                        k = rem0 / yd0 | 0;\n                        //  Algorithm:\n                        //  1. product = divisor * trial digit (k)\n                        //  2. if product > remainder: product -= divisor, k--\n                        //  3. remainder -= product\n                        //  4. if product was < remainder at 2:\n                        //    5. compare new remainder and divisor\n                        //    6. If remainder > divisor: remainder -= divisor, k++\n                        if (k > 1) {\n                            if (k >= base) k = base - 1;\n                            // product = divisor * trial digit.\n                            prod = multiplyInteger(yd, k, base);\n                            prodL = prod.length;\n                            remL = rem.length;\n                            // Compare product and remainder.\n                            cmp = compare(prod, rem, prodL, remL);\n                            // product > remainder.\n                            if (cmp == 1) {\n                                k--;\n                                // Subtract divisor from product.\n                                subtract(prod, yL < prodL ? yz : yd, prodL, base);\n                            }\n                        } else {\n                            // cmp is -1.\n                            // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\n                            // to avoid it. If k is 1 there is a need to compare yd and rem again below.\n                            if (k == 0) cmp = k = 1;\n                            prod = yd.slice();\n                        }\n                        prodL = prod.length;\n                        if (prodL < remL) prod.unshift(0);\n                        // Subtract product from remainder.\n                        subtract(rem, prod, remL, base);\n                        // If product was < previous remainder.\n                        if (cmp == -1) {\n                            remL = rem.length;\n                            // Compare divisor and new remainder.\n                            cmp = compare(yd, rem, yL, remL);\n                            // If divisor < new remainder, subtract divisor from remainder.\n                            if (cmp < 1) {\n                                k++;\n                                // Subtract divisor from remainder.\n                                subtract(rem, yL < remL ? yz : yd, remL, base);\n                            }\n                        }\n                        remL = rem.length;\n                    } else if (cmp === 0) {\n                        k++;\n                        rem = [\n                            0\n                        ];\n                    } // if cmp === 1, k will be 0\n                    // Add the next digit, k, to the result array.\n                    qd[i++] = k;\n                    // Update the remainder.\n                    if (cmp && rem[0]) {\n                        rem[remL++] = xd[xi] || 0;\n                    } else {\n                        rem = [\n                            xd[xi]\n                        ];\n                        remL = 1;\n                    }\n                }while ((xi++ < xL || rem[0] !== void 0) && sd--);\n                more = rem[0] !== void 0;\n            }\n            // Leading zero?\n            if (!qd[0]) qd.shift();\n        }\n        // logBase is 1 when divide is being used for base conversion.\n        if (logBase == 1) {\n            q.e = e;\n            inexact = more;\n        } else {\n            // To calculate q.e, first get the number of digits of qd[0].\n            for(i = 1, k = qd[0]; k >= 10; k /= 10)i++;\n            q.e = i + e * logBase - 1;\n            finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\n        }\n        return q;\n    };\n}();\n/*\r\n * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n * Check for over/under-flow.\r\n */ function finalise(x, sd, rm, isTruncated) {\n    var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;\n    // Don't round if sd is null or undefined.\n    out: if (sd != null) {\n        xd = x.d;\n        // Infinity/NaN.\n        if (!xd) return x;\n        // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\n        // w: the word of xd containing rd, a base 1e7 number.\n        // xdi: the index of w within xd.\n        // digits: the number of digits of w.\n        // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\n        // they had leading zeros)\n        // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\n        // Get the length of the first word of the digits array xd.\n        for(digits = 1, k = xd[0]; k >= 10; k /= 10)digits++;\n        i = sd - digits;\n        // Is the rounding digit in the first word of xd?\n        if (i < 0) {\n            i += LOG_BASE;\n            j = sd;\n            w = xd[xdi = 0];\n            // Get the rounding digit at index j of w.\n            rd = w / mathpow(10, digits - j - 1) % 10 | 0;\n        } else {\n            xdi = Math.ceil((i + 1) / LOG_BASE);\n            k = xd.length;\n            if (xdi >= k) {\n                if (isTruncated) {\n                    // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\n                    for(; k++ <= xdi;)xd.push(0);\n                    w = rd = 0;\n                    digits = 1;\n                    i %= LOG_BASE;\n                    j = i - LOG_BASE + 1;\n                } else {\n                    break out;\n                }\n            } else {\n                w = k = xd[xdi];\n                // Get the number of digits of w.\n                for(digits = 1; k >= 10; k /= 10)digits++;\n                // Get the index of rd within w.\n                i %= LOG_BASE;\n                // Get the index of rd within w, adjusted for leading zeros.\n                // The number of leading zeros of w is given by LOG_BASE - digits.\n                j = i - LOG_BASE + digits;\n                // Get the rounding digit at index j of w.\n                rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\n            }\n        }\n        // Are there any non-zero digits after the rounding digit?\n        isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\n        // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\n        // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\n        // will give 714.\n        roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n        if (sd < 1 || !xd[0]) {\n            xd.length = 0;\n            if (roundUp) {\n                // Convert sd to decimal places.\n                sd -= x.e + 1;\n                // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n                xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\n                x.e = -sd || 0;\n            } else {\n                // Zero.\n                xd[0] = x.e = 0;\n            }\n            return x;\n        }\n        // Remove excess digits.\n        if (i == 0) {\n            xd.length = xdi;\n            k = 1;\n            xdi--;\n        } else {\n            xd.length = xdi + 1;\n            k = mathpow(10, LOG_BASE - i);\n            // E.g. 56700 becomes 56000 if 7 is the rounding digit.\n            // j > 0 means i > number of leading zeros of w.\n            xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\n        }\n        if (roundUp) {\n            for(;;){\n                // Is the digit to be rounded up in the first word of xd?\n                if (xdi == 0) {\n                    // i will be the length of xd[0] before k is added.\n                    for(i = 1, j = xd[0]; j >= 10; j /= 10)i++;\n                    j = xd[0] += k;\n                    for(k = 1; j >= 10; j /= 10)k++;\n                    // if i != k the length has increased.\n                    if (i != k) {\n                        x.e++;\n                        if (xd[0] == BASE) xd[0] = 1;\n                    }\n                    break;\n                } else {\n                    xd[xdi] += k;\n                    if (xd[xdi] != BASE) break;\n                    xd[xdi--] = 0;\n                    k = 1;\n                }\n            }\n        }\n        // Remove trailing zeros.\n        for(i = xd.length; xd[--i] === 0;)xd.pop();\n    }\n    if (external) {\n        // Overflow?\n        if (x.e > Ctor.maxE) {\n            // Infinity.\n            x.d = null;\n            x.e = NaN;\n        // Underflow?\n        } else if (x.e < Ctor.minE) {\n            // Zero.\n            x.e = 0;\n            x.d = [\n                0\n            ];\n        // Ctor.underflow = true;\n        } // else Ctor.underflow = false;\n    }\n    return x;\n}\nfunction finiteToString(x, isExp, sd) {\n    if (!x.isFinite()) return nonFiniteToString(x);\n    var k, e = x.e, str = digitsToString(x.d), len = str.length;\n    if (isExp) {\n        if (sd && (k = sd - len) > 0) {\n            str = str.charAt(0) + \".\" + str.slice(1) + getZeroString(k);\n        } else if (len > 1) {\n            str = str.charAt(0) + \".\" + str.slice(1);\n        }\n        str = str + (x.e < 0 ? \"e\" : \"e+\") + x.e;\n    } else if (e < 0) {\n        str = \"0.\" + getZeroString(-e - 1) + str;\n        if (sd && (k = sd - len) > 0) str += getZeroString(k);\n    } else if (e >= len) {\n        str += getZeroString(e + 1 - len);\n        if (sd && (k = sd - e - 1) > 0) str = str + \".\" + getZeroString(k);\n    } else {\n        if ((k = e + 1) < len) str = str.slice(0, k) + \".\" + str.slice(k);\n        if (sd && (k = sd - len) > 0) {\n            if (e + 1 === len) str += \".\";\n            str += getZeroString(k);\n        }\n    }\n    return str;\n}\n// Calculate the base 10 exponent from the base 1e7 exponent.\nfunction getBase10Exponent(digits, e) {\n    var w = digits[0];\n    // Add the number of digits of the first word of the digits array.\n    for(e *= LOG_BASE; w >= 10; w /= 10)e++;\n    return e;\n}\nfunction getLn10(Ctor, sd, pr) {\n    if (sd > LN10_PRECISION) {\n        // Reset global state in case the exception is caught.\n        external = true;\n        if (pr) Ctor.precision = pr;\n        throw Error(precisionLimitExceeded);\n    }\n    return finalise(new Ctor(LN10), sd, 1, true);\n}\nfunction getPi(Ctor, sd, rm) {\n    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\n    return finalise(new Ctor(PI), sd, rm, true);\n}\nfunction getPrecision(digits) {\n    var w = digits.length - 1, len = w * LOG_BASE + 1;\n    w = digits[w];\n    // If non-zero...\n    if (w) {\n        // Subtract the number of trailing zeros of the last word.\n        for(; w % 10 == 0; w /= 10)len--;\n        // Add the number of digits of the first word.\n        for(w = digits[0]; w >= 10; w /= 10)len++;\n    }\n    return len;\n}\nfunction getZeroString(k) {\n    var zs = \"\";\n    for(; k--;)zs += \"0\";\n    return zs;\n}\n/*\r\n * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n * integer of type number.\r\n *\r\n * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n *\r\n */ function intPow(Ctor, x, n, pr) {\n    var isTruncated, r = new Ctor(1), // Max n of 9007199254740991 takes 53 loop iterations.\n    // Maximum digits array length; leaves [28, 34] guard digits.\n    k = Math.ceil(pr / LOG_BASE + 4);\n    external = false;\n    for(;;){\n        if (n % 2) {\n            r = r.times(x);\n            if (truncate(r.d, k)) isTruncated = true;\n        }\n        n = mathfloor(n / 2);\n        if (n === 0) {\n            // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\n            n = r.d.length - 1;\n            if (isTruncated && r.d[n] === 0) ++r.d[n];\n            break;\n        }\n        x = x.times(x);\n        truncate(x.d, k);\n    }\n    external = true;\n    return r;\n}\nfunction isOdd(n) {\n    return n.d[n.d.length - 1] & 1;\n}\n/*\r\n * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.\r\n */ function maxOrMin(Ctor, args, ltgt) {\n    var y, x = new Ctor(args[0]), i = 0;\n    for(; ++i < args.length;){\n        y = new Ctor(args[i]);\n        if (!y.s) {\n            x = y;\n            break;\n        } else if (x[ltgt](y)) {\n            x = y;\n        }\n    }\n    return x;\n}\n/*\r\n * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n * digits.\r\n *\r\n * Taylor/Maclaurin series.\r\n *\r\n * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n *\r\n * Argument reduction:\r\n *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n *   exp(x) = exp(x / 2^k)^(2^k)\r\n *\r\n * Previously, the argument was initially reduced by\r\n * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n * found to be slower than just dividing repeatedly by 32 as above.\r\n *\r\n * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n *\r\n *  exp(Infinity)  = Infinity\r\n *  exp(-Infinity) = 0\r\n *  exp(NaN)       = NaN\r\n *  exp(±0)        = 1\r\n *\r\n *  exp(x) is non-terminating for any finite, non-zero x.\r\n *\r\n *  The result will always be correctly rounded.\r\n *\r\n */ function naturalExponential(x, sd) {\n    var denominator, guard, j, pow, sum, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n    // 0/NaN/Infinity?\n    if (!x.d || !x.d[0] || x.e > 17) {\n        return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);\n    }\n    if (sd == null) {\n        external = false;\n        wpr = pr;\n    } else {\n        wpr = sd;\n    }\n    t = new Ctor(0.03125);\n    // while abs(x) >= 0.1\n    while(x.e > -2){\n        // x = x / 2^5\n        x = x.times(t);\n        k += 5;\n    }\n    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\n    // necessary to ensure the first 4 rounding digits are correct.\n    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\n    wpr += guard;\n    denominator = pow = sum = new Ctor(1);\n    Ctor.precision = wpr;\n    for(;;){\n        pow = finalise(pow.times(x), wpr, 1);\n        denominator = denominator.times(++i);\n        t = sum.plus(divide(pow, denominator, wpr, 1));\n        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\n            j = k;\n            while(j--)sum = finalise(sum.times(sum), wpr, 1);\n            // Check to see if the first 4 rounding digits are [49]999.\n            // If so, repeat the summation with a higher precision, otherwise\n            // e.g. with precision: 18, rounding: 1\n            // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\n            // `wpr - guard` is the index of first rounding digit.\n            if (sd == null) {\n                if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\n                    Ctor.precision = wpr += 10;\n                    denominator = pow = t = new Ctor(1);\n                    i = 0;\n                    rep++;\n                } else {\n                    return finalise(sum, Ctor.precision = pr, rm, external = true);\n                }\n            } else {\n                Ctor.precision = pr;\n                return sum;\n            }\n        }\n        sum = t;\n    }\n}\n/*\r\n * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n * digits.\r\n *\r\n *  ln(-n)        = NaN\r\n *  ln(0)         = -Infinity\r\n *  ln(-0)        = -Infinity\r\n *  ln(1)         = 0\r\n *  ln(Infinity)  = Infinity\r\n *  ln(-Infinity) = NaN\r\n *  ln(NaN)       = NaN\r\n *\r\n *  ln(n) (n != 1) is non-terminating.\r\n *\r\n */ function naturalLogarithm(y, sd) {\n    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n    // Is x negative or Infinity, NaN, 0 or 1?\n    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\n        return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\n    }\n    if (sd == null) {\n        external = false;\n        wpr = pr;\n    } else {\n        wpr = sd;\n    }\n    Ctor.precision = wpr += guard;\n    c = digitsToString(xd);\n    c0 = c.charAt(0);\n    if (Math.abs(e = x.e) < 1.5e15) {\n        // Argument reduction.\n        // The series converges faster the closer the argument is to 1, so using\n        // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\n        // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\n        // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\n        // later be divided by this number, then separate out the power of 10 using\n        // ln(a*10^b) = ln(a) + b*ln(10).\n        // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\n        //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\n        // max n is 6 (gives 0.7 - 1.3)\n        while(c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3){\n            x = x.times(y);\n            c = digitsToString(x.d);\n            c0 = c.charAt(0);\n            n++;\n        }\n        e = x.e;\n        if (c0 > 1) {\n            x = new Ctor(\"0.\" + c);\n            e++;\n        } else {\n            x = new Ctor(c0 + \".\" + c.slice(1));\n        }\n    } else {\n        // The argument reduction method above may result in overflow if the argument y is a massive\n        // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\n        // function using ln(x*10^e) = ln(x) + e*ln(10).\n        t = getLn10(Ctor, wpr + 2, pr).times(e + \"\");\n        x = naturalLogarithm(new Ctor(c0 + \".\" + c.slice(1)), wpr - guard).plus(t);\n        Ctor.precision = pr;\n        return sd == null ? finalise(x, pr, rm, external = true) : x;\n    }\n    // x1 is x reduced to a value near 1.\n    x1 = x;\n    // Taylor series.\n    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\n    // where x = (y - 1)/(y + 1)    (|x| < 1)\n    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\n    x2 = finalise(x.times(x), wpr, 1);\n    denominator = 3;\n    for(;;){\n        numerator = finalise(numerator.times(x2), wpr, 1);\n        t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\n        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\n            sum = sum.times(2);\n            // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\n            // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\n            if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + \"\"));\n            sum = divide(sum, new Ctor(n), wpr, 1);\n            // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\n            // been repeated previously) and the first 4 rounding digits 9999?\n            // If so, restart the summation with a higher precision, otherwise\n            // e.g. with precision: 12, rounding: 1\n            // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\n            // `wpr - guard` is the index of first rounding digit.\n            if (sd == null) {\n                if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\n                    Ctor.precision = wpr += guard;\n                    t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\n                    x2 = finalise(x.times(x), wpr, 1);\n                    denominator = rep = 1;\n                } else {\n                    return finalise(sum, Ctor.precision = pr, rm, external = true);\n                }\n            } else {\n                Ctor.precision = pr;\n                return sum;\n            }\n        }\n        sum = t;\n        denominator += 2;\n    }\n}\n// ±Infinity, NaN.\nfunction nonFiniteToString(x) {\n    // Unsigned.\n    return String(x.s * x.s / 0);\n}\n/*\r\n * Parse the value of a new Decimal `x` from string `str`.\r\n */ function parseDecimal(x, str) {\n    var e, i, len;\n    // Decimal point?\n    if ((e = str.indexOf(\".\")) > -1) str = str.replace(\".\", \"\");\n    // Exponential form?\n    if ((i = str.search(/e/i)) > 0) {\n        // Determine exponent.\n        if (e < 0) e = i;\n        e += +str.slice(i + 1);\n        str = str.substring(0, i);\n    } else if (e < 0) {\n        // Integer.\n        e = str.length;\n    }\n    // Determine leading zeros.\n    for(i = 0; str.charCodeAt(i) === 48; i++);\n    // Determine trailing zeros.\n    for(len = str.length; str.charCodeAt(len - 1) === 48; --len);\n    str = str.slice(i, len);\n    if (str) {\n        len -= i;\n        x.e = e = e - i - 1;\n        x.d = [];\n        // Transform base\n        // e is the base 10 exponent.\n        // i is where to slice str to get the first word of the digits array.\n        i = (e + 1) % LOG_BASE;\n        if (e < 0) i += LOG_BASE;\n        if (i < len) {\n            if (i) x.d.push(+str.slice(0, i));\n            for(len -= LOG_BASE; i < len;)x.d.push(+str.slice(i, i += LOG_BASE));\n            str = str.slice(i);\n            i = LOG_BASE - str.length;\n        } else {\n            i -= len;\n        }\n        for(; i--;)str += \"0\";\n        x.d.push(+str);\n        if (external) {\n            // Overflow?\n            if (x.e > x.constructor.maxE) {\n                // Infinity.\n                x.d = null;\n                x.e = NaN;\n            // Underflow?\n            } else if (x.e < x.constructor.minE) {\n                // Zero.\n                x.e = 0;\n                x.d = [\n                    0\n                ];\n            // x.constructor.underflow = true;\n            } // else x.constructor.underflow = false;\n        }\n    } else {\n        // Zero.\n        x.e = 0;\n        x.d = [\n            0\n        ];\n    }\n    return x;\n}\n/*\r\n * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n */ function parseOther(x, str) {\n    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\n    if (str.indexOf(\"_\") > -1) {\n        str = str.replace(/(\\d)_(?=\\d)/g, \"$1\");\n        if (isDecimal.test(str)) return parseDecimal(x, str);\n    } else if (str === \"Infinity\" || str === \"NaN\") {\n        if (!+str) x.s = NaN;\n        x.e = NaN;\n        x.d = null;\n        return x;\n    }\n    if (isHex.test(str)) {\n        base = 16;\n        str = str.toLowerCase();\n    } else if (isBinary.test(str)) {\n        base = 2;\n    } else if (isOctal.test(str)) {\n        base = 8;\n    } else {\n        throw Error(invalidArgument + str);\n    }\n    // Is there a binary exponent part?\n    i = str.search(/p/i);\n    if (i > 0) {\n        p = +str.slice(i + 1);\n        str = str.substring(2, i);\n    } else {\n        str = str.slice(2);\n    }\n    // Convert `str` as an integer then divide the result by `base` raised to a power such that the\n    // fraction part will be restored.\n    i = str.indexOf(\".\");\n    isFloat = i >= 0;\n    Ctor = x.constructor;\n    if (isFloat) {\n        str = str.replace(\".\", \"\");\n        len = str.length;\n        i = len - i;\n        // log[10](16) = 1.2041... , log[10](88) = 1.9444....\n        divisor = intPow(Ctor, new Ctor(base), i, i * 2);\n    }\n    xd = convertBase(str, base, BASE);\n    xe = xd.length - 1;\n    // Remove trailing zeros.\n    for(i = xe; xd[i] === 0; --i)xd.pop();\n    if (i < 0) return new Ctor(x.s * 0);\n    x.e = getBase10Exponent(xd, xe);\n    x.d = xd;\n    external = false;\n    // At what precision to perform the division to ensure exact conversion?\n    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\n    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\n    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\n    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\n    // Therefore using 4 * the number of digits of str will always be enough.\n    if (isFloat) x = divide(x, divisor, len * 4);\n    // Multiply by the binary exponent part if present.\n    if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\n    external = true;\n    return x;\n}\n/*\r\n * sin(x) = x - x^3/3! + x^5/5! - ...\r\n * |x| < pi/2\r\n *\r\n */ function sine(Ctor, x) {\n    var k, len = x.d.length;\n    if (len < 3) {\n        return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);\n    }\n    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\n    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\n    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\n    // Estimate the optimum number of times to use the argument reduction.\n    k = 1.4 * Math.sqrt(len);\n    k = k > 16 ? 16 : k | 0;\n    x = x.times(1 / tinyPow(5, k));\n    x = taylorSeries(Ctor, 2, x, x);\n    // Reverse argument reduction\n    var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n    for(; k--;){\n        sin2_x = x.times(x);\n        x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\n    }\n    return x;\n}\n// Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\nfunction taylorSeries(Ctor, n, x, y, isHyperbolic) {\n    var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);\n    external = false;\n    x2 = x.times(x);\n    u = new Ctor(y);\n    for(;;){\n        t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\n        u = isHyperbolic ? y.plus(t) : y.minus(t);\n        y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\n        t = u.plus(y);\n        if (t.d[k] !== void 0) {\n            for(j = k; t.d[j] === u.d[j] && j--;);\n            if (j == -1) break;\n        }\n        j = u;\n        u = y;\n        y = t;\n        t = j;\n        i++;\n    }\n    external = true;\n    t.d.length = k + 1;\n    return t;\n}\n// Exponent e must be positive and non-zero.\nfunction tinyPow(b, e) {\n    var n = b;\n    while(--e)n *= b;\n    return n;\n}\n// Return the absolute value of `x` reduced to less than or equal to half pi.\nfunction toLessThanHalfPi(Ctor, x) {\n    var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);\n    x = x.abs();\n    if (x.lte(halfPi)) {\n        quadrant = isNeg ? 4 : 1;\n        return x;\n    }\n    t = x.divToInt(pi);\n    if (t.isZero()) {\n        quadrant = isNeg ? 3 : 2;\n    } else {\n        x = x.minus(t.times(pi));\n        // 0 <= x < pi\n        if (x.lte(halfPi)) {\n            quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;\n            return x;\n        }\n        quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;\n    }\n    return x.minus(pi).abs();\n}\n/*\r\n * Return the value of Decimal `x` as a string in base `baseOut`.\r\n *\r\n * If the optional `sd` argument is present include a binary exponent suffix.\r\n */ function toStringBinary(x, baseOut, sd, rm) {\n    var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;\n    if (isExp) {\n        checkInt32(sd, 1, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n    } else {\n        sd = Ctor.precision;\n        rm = Ctor.rounding;\n    }\n    if (!x.isFinite()) {\n        str = nonFiniteToString(x);\n    } else {\n        str = finiteToString(x);\n        i = str.indexOf(\".\");\n        // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\n        // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\n        // minBinaryExponent = floor(decimalExponent * log[2](10))\n        // log[2](10) = 3.321928094887362347870319429489390175864\n        if (isExp) {\n            base = 2;\n            if (baseOut == 16) {\n                sd = sd * 4 - 3;\n            } else if (baseOut == 8) {\n                sd = sd * 3 - 2;\n            }\n        } else {\n            base = baseOut;\n        }\n        // Convert the number as an integer then divide the result by its base raised to a power such\n        // that the fraction part will be restored.\n        // Non-integer.\n        if (i >= 0) {\n            str = str.replace(\".\", \"\");\n            y = new Ctor(1);\n            y.e = str.length - i;\n            y.d = convertBase(finiteToString(y), 10, base);\n            y.e = y.d.length;\n        }\n        xd = convertBase(str, 10, base);\n        e = len = xd.length;\n        // Remove trailing zeros.\n        for(; xd[--len] == 0;)xd.pop();\n        if (!xd[0]) {\n            str = isExp ? \"0p+0\" : \"0\";\n        } else {\n            if (i < 0) {\n                e--;\n            } else {\n                x = new Ctor(x);\n                x.d = xd;\n                x.e = e;\n                x = divide(x, y, sd, rm, 0, base);\n                xd = x.d;\n                e = x.e;\n                roundUp = inexact;\n            }\n            // The rounding digit, i.e. the digit after the digit that may be rounded up.\n            i = xd[sd];\n            k = base / 2;\n            roundUp = roundUp || xd[sd + 1] !== void 0;\n            roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));\n            xd.length = sd;\n            if (roundUp) {\n                // Rounding up may mean the previous digit has to be rounded up and so on.\n                for(; ++xd[--sd] > base - 1;){\n                    xd[sd] = 0;\n                    if (!sd) {\n                        ++e;\n                        xd.unshift(1);\n                    }\n                }\n            }\n            // Determine trailing zeros.\n            for(len = xd.length; !xd[len - 1]; --len);\n            // E.g. [4, 11, 15] becomes 4bf.\n            for(i = 0, str = \"\"; i < len; i++)str += NUMERALS.charAt(xd[i]);\n            // Add binary exponent suffix?\n            if (isExp) {\n                if (len > 1) {\n                    if (baseOut == 16 || baseOut == 8) {\n                        i = baseOut == 16 ? 4 : 3;\n                        for(--len; len % i; len++)str += \"0\";\n                        xd = convertBase(str, base, baseOut);\n                        for(len = xd.length; !xd[len - 1]; --len);\n                        // xd[0] will always be be 1\n                        for(i = 1, str = \"1.\"; i < len; i++)str += NUMERALS.charAt(xd[i]);\n                    } else {\n                        str = str.charAt(0) + \".\" + str.slice(1);\n                    }\n                }\n                str = str + (e < 0 ? \"p\" : \"p+\") + e;\n            } else if (e < 0) {\n                for(; ++e;)str = \"0\" + str;\n                str = \"0.\" + str;\n            } else {\n                if (++e > len) for(e -= len; e--;)str += \"0\";\n                else if (e < len) str = str.slice(0, e) + \".\" + str.slice(e);\n            }\n        }\n        str = (baseOut == 16 ? \"0x\" : baseOut == 2 ? \"0b\" : baseOut == 8 ? \"0o\" : \"\") + str;\n    }\n    return x.s < 0 ? \"-\" + str : str;\n}\n// Does not strip trailing zeros.\nfunction truncate(arr, len) {\n    if (arr.length > len) {\n        arr.length = len;\n        return true;\n    }\n}\n// Decimal methods\n/*\r\n *  abs\r\n *  acos\r\n *  acosh\r\n *  add\r\n *  asin\r\n *  asinh\r\n *  atan\r\n *  atanh\r\n *  atan2\r\n *  cbrt\r\n *  ceil\r\n *  clamp\r\n *  clone\r\n *  config\r\n *  cos\r\n *  cosh\r\n *  div\r\n *  exp\r\n *  floor\r\n *  hypot\r\n *  ln\r\n *  log\r\n *  log2\r\n *  log10\r\n *  max\r\n *  min\r\n *  mod\r\n *  mul\r\n *  pow\r\n *  random\r\n *  round\r\n *  set\r\n *  sign\r\n *  sin\r\n *  sinh\r\n *  sqrt\r\n *  sub\r\n *  sum\r\n *  tan\r\n *  tanh\r\n *  trunc\r\n */ /*\r\n * Return a new Decimal whose value is the absolute value of `x`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function abs(x) {\n    return new this(x).abs();\n}\n/*\r\n * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function acos(x) {\n    return new this(x).acos();\n}\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function acosh(x) {\n    return new this(x).acosh();\n}\n/*\r\n * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */ function add(x, y) {\n    return new this(x).plus(y);\n}\n/*\r\n * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function asin(x) {\n    return new this(x).asin();\n}\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function asinh(x) {\n    return new this(x).asinh();\n}\n/*\r\n * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function atan(x) {\n    return new this(x).atan();\n}\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function atanh(x) {\n    return new this(x).atanh();\n}\n/*\r\n * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi, pi]\r\n *\r\n * y {number|string|Decimal} The y-coordinate.\r\n * x {number|string|Decimal} The x-coordinate.\r\n *\r\n * atan2(±0, -0)               = ±pi\r\n * atan2(±0, +0)               = ±0\r\n * atan2(±0, -x)               = ±pi for x > 0\r\n * atan2(±0, x)                = ±0 for x > 0\r\n * atan2(-y, ±0)               = -pi/2 for y > 0\r\n * atan2(y, ±0)                = pi/2 for y > 0\r\n * atan2(±y, -Infinity)        = ±pi for finite y > 0\r\n * atan2(±y, +Infinity)        = ±0 for finite y > 0\r\n * atan2(±Infinity, x)         = ±pi/2 for finite x\r\n * atan2(±Infinity, -Infinity) = ±3*pi/4\r\n * atan2(±Infinity, +Infinity) = ±pi/4\r\n * atan2(NaN, x) = NaN\r\n * atan2(y, NaN) = NaN\r\n *\r\n */ function atan2(y, x) {\n    y = new this(y);\n    x = new this(x);\n    var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;\n    // Either NaN\n    if (!y.s || !x.s) {\n        r = new this(NaN);\n    // Both ±Infinity\n    } else if (!y.d && !x.d) {\n        r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\n        r.s = y.s;\n    // x is ±Infinity or y is ±0\n    } else if (!x.d || y.isZero()) {\n        r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\n        r.s = y.s;\n    // y is ±Infinity or x is ±0\n    } else if (!y.d || x.isZero()) {\n        r = getPi(this, wpr, 1).times(0.5);\n        r.s = y.s;\n    // Both non-zero and finite\n    } else if (x.s < 0) {\n        this.precision = wpr;\n        this.rounding = 1;\n        r = this.atan(divide(y, x, wpr, 1));\n        x = getPi(this, wpr, 1);\n        this.precision = pr;\n        this.rounding = rm;\n        r = y.s < 0 ? r.minus(x) : r.plus(x);\n    } else {\n        r = this.atan(divide(y, x, wpr, 1));\n    }\n    return r;\n}\n/*\r\n * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function cbrt(x) {\n    return new this(x).cbrt();\n}\n/*\r\n * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function ceil(x) {\n    return finalise(x = new this(x), x.e + 1, 2);\n}\n/*\r\n * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.\r\n *\r\n * x {number|string|Decimal}\r\n * min {number|string|Decimal}\r\n * max {number|string|Decimal}\r\n *\r\n */ function clamp(x, min, max) {\n    return new this(x).clamp(min, max);\n}\n/*\r\n * Configure global settings for a Decimal constructor.\r\n *\r\n * `obj` is an object with one or more of the following properties,\r\n *\r\n *   precision  {number}\r\n *   rounding   {number}\r\n *   toExpNeg   {number}\r\n *   toExpPos   {number}\r\n *   maxE       {number}\r\n *   minE       {number}\r\n *   modulo     {number}\r\n *   crypto     {boolean|number}\r\n *   defaults   {true}\r\n *\r\n * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n *\r\n */ function config(obj) {\n    if (!obj || typeof obj !== \"object\") throw Error(decimalError + \"Object expected\");\n    var i, p, v, useDefaults = obj.defaults === true, ps = [\n        \"precision\",\n        1,\n        MAX_DIGITS,\n        \"rounding\",\n        0,\n        8,\n        \"toExpNeg\",\n        -EXP_LIMIT,\n        0,\n        \"toExpPos\",\n        0,\n        EXP_LIMIT,\n        \"maxE\",\n        0,\n        EXP_LIMIT,\n        \"minE\",\n        -EXP_LIMIT,\n        0,\n        \"modulo\",\n        0,\n        9\n    ];\n    for(i = 0; i < ps.length; i += 3){\n        if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];\n        if ((v = obj[p]) !== void 0) {\n            if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\n            else throw Error(invalidArgument + p + \": \" + v);\n        }\n    }\n    if (p = \"crypto\", useDefaults) this[p] = DEFAULTS[p];\n    if ((v = obj[p]) !== void 0) {\n        if (v === true || v === false || v === 0 || v === 1) {\n            if (v) {\n                if (typeof crypto != \"undefined\" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n                    this[p] = true;\n                } else {\n                    throw Error(cryptoUnavailable);\n                }\n            } else {\n                this[p] = false;\n            }\n        } else {\n            throw Error(invalidArgument + p + \": \" + v);\n        }\n    }\n    return this;\n}\n/*\r\n * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function cos(x) {\n    return new this(x).cos();\n}\n/*\r\n * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function cosh(x) {\n    return new this(x).cosh();\n}\n/*\r\n * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n * constructor.\r\n *\r\n */ function clone(obj) {\n    var i, p, ps;\n    /*\r\n   * The Decimal constructor and exported function.\r\n   * Return a new Decimal instance.\r\n   *\r\n   * v {number|string|Decimal} A numeric value.\r\n   *\r\n   */ function Decimal(v) {\n        var e, i, t, x = this;\n        // Decimal called without new.\n        if (!(x instanceof Decimal)) return new Decimal(v);\n        // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\n        // which points to Object.\n        x.constructor = Decimal;\n        // Duplicate.\n        if (isDecimalInstance(v)) {\n            x.s = v.s;\n            if (external) {\n                if (!v.d || v.e > Decimal.maxE) {\n                    // Infinity.\n                    x.e = NaN;\n                    x.d = null;\n                } else if (v.e < Decimal.minE) {\n                    // Zero.\n                    x.e = 0;\n                    x.d = [\n                        0\n                    ];\n                } else {\n                    x.e = v.e;\n                    x.d = v.d.slice();\n                }\n            } else {\n                x.e = v.e;\n                x.d = v.d ? v.d.slice() : v.d;\n            }\n            return;\n        }\n        t = typeof v;\n        if (t === \"number\") {\n            if (v === 0) {\n                x.s = 1 / v < 0 ? -1 : 1;\n                x.e = 0;\n                x.d = [\n                    0\n                ];\n                return;\n            }\n            if (v < 0) {\n                v = -v;\n                x.s = -1;\n            } else {\n                x.s = 1;\n            }\n            // Fast path for small integers.\n            if (v === ~~v && v < 1e7) {\n                for(e = 0, i = v; i >= 10; i /= 10)e++;\n                if (external) {\n                    if (e > Decimal.maxE) {\n                        x.e = NaN;\n                        x.d = null;\n                    } else if (e < Decimal.minE) {\n                        x.e = 0;\n                        x.d = [\n                            0\n                        ];\n                    } else {\n                        x.e = e;\n                        x.d = [\n                            v\n                        ];\n                    }\n                } else {\n                    x.e = e;\n                    x.d = [\n                        v\n                    ];\n                }\n                return;\n            // Infinity, NaN.\n            } else if (v * 0 !== 0) {\n                if (!v) x.s = NaN;\n                x.e = NaN;\n                x.d = null;\n                return;\n            }\n            return parseDecimal(x, v.toString());\n        } else if (t !== \"string\") {\n            throw Error(invalidArgument + v);\n        }\n        // Minus sign?\n        if ((i = v.charCodeAt(0)) === 45) {\n            v = v.slice(1);\n            x.s = -1;\n        } else {\n            // Plus sign?\n            if (i === 43) v = v.slice(1);\n            x.s = 1;\n        }\n        return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\n    }\n    Decimal.prototype = P;\n    Decimal.ROUND_UP = 0;\n    Decimal.ROUND_DOWN = 1;\n    Decimal.ROUND_CEIL = 2;\n    Decimal.ROUND_FLOOR = 3;\n    Decimal.ROUND_HALF_UP = 4;\n    Decimal.ROUND_HALF_DOWN = 5;\n    Decimal.ROUND_HALF_EVEN = 6;\n    Decimal.ROUND_HALF_CEIL = 7;\n    Decimal.ROUND_HALF_FLOOR = 8;\n    Decimal.EUCLID = 9;\n    Decimal.config = Decimal.set = config;\n    Decimal.clone = clone;\n    Decimal.isDecimal = isDecimalInstance;\n    Decimal.abs = abs;\n    Decimal.acos = acos;\n    Decimal.acosh = acosh; // ES6\n    Decimal.add = add;\n    Decimal.asin = asin;\n    Decimal.asinh = asinh; // ES6\n    Decimal.atan = atan;\n    Decimal.atanh = atanh; // ES6\n    Decimal.atan2 = atan2;\n    Decimal.cbrt = cbrt; // ES6\n    Decimal.ceil = ceil;\n    Decimal.clamp = clamp;\n    Decimal.cos = cos;\n    Decimal.cosh = cosh; // ES6\n    Decimal.div = div;\n    Decimal.exp = exp;\n    Decimal.floor = floor;\n    Decimal.hypot = hypot; // ES6\n    Decimal.ln = ln;\n    Decimal.log = log;\n    Decimal.log10 = log10; // ES6\n    Decimal.log2 = log2; // ES6\n    Decimal.max = max;\n    Decimal.min = min;\n    Decimal.mod = mod;\n    Decimal.mul = mul;\n    Decimal.pow = pow;\n    Decimal.random = random;\n    Decimal.round = round;\n    Decimal.sign = sign; // ES6\n    Decimal.sin = sin;\n    Decimal.sinh = sinh; // ES6\n    Decimal.sqrt = sqrt;\n    Decimal.sub = sub;\n    Decimal.sum = sum;\n    Decimal.tan = tan;\n    Decimal.tanh = tanh; // ES6\n    Decimal.trunc = trunc; // ES6\n    if (obj === void 0) obj = {};\n    if (obj) {\n        if (obj.defaults !== true) {\n            ps = [\n                \"precision\",\n                \"rounding\",\n                \"toExpNeg\",\n                \"toExpPos\",\n                \"maxE\",\n                \"minE\",\n                \"modulo\",\n                \"crypto\"\n            ];\n            for(i = 0; i < ps.length;)if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\n        }\n    }\n    Decimal.config(obj);\n    return Decimal;\n}\n/*\r\n * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */ function div(x, y) {\n    return new this(x).div(y);\n}\n/*\r\n * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} The power to which to raise the base of the natural log.\r\n *\r\n */ function exp(x) {\n    return new this(x).exp();\n}\n/*\r\n * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function floor(x) {\n    return finalise(x = new this(x), x.e + 1, 3);\n}\n/*\r\n * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n * rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */ function hypot() {\n    var i, n, t = new this(0);\n    external = false;\n    for(i = 0; i < arguments.length;){\n        n = new this(arguments[i++]);\n        if (!n.d) {\n            if (n.s) {\n                external = true;\n                return new this(1 / 0);\n            }\n            t = n;\n        } else if (t.d) {\n            t = t.plus(n.times(n));\n        }\n    }\n    external = true;\n    return t.sqrt();\n}\n/*\r\n * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),\r\n * otherwise return false.\r\n *\r\n */ function isDecimalInstance(obj) {\n    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;\n}\n/*\r\n * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function ln(x) {\n    return new this(x).ln();\n}\n/*\r\n * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * log[y](x)\r\n *\r\n * x {number|string|Decimal} The argument of the logarithm.\r\n * y {number|string|Decimal} The base of the logarithm.\r\n *\r\n */ function log(x, y) {\n    return new this(x).log(y);\n}\n/*\r\n * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function log2(x) {\n    return new this(x).log(2);\n}\n/*\r\n * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function log10(x) {\n    return new this(x).log(10);\n}\n/*\r\n * Return a new Decimal whose value is the maximum of the arguments.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */ function max() {\n    return maxOrMin(this, arguments, \"lt\");\n}\n/*\r\n * Return a new Decimal whose value is the minimum of the arguments.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */ function min() {\n    return maxOrMin(this, arguments, \"gt\");\n}\n/*\r\n * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */ function mod(x, y) {\n    return new this(x).mod(y);\n}\n/*\r\n * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */ function mul(x, y) {\n    return new this(x).mul(y);\n}\n/*\r\n * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} The base.\r\n * y {number|string|Decimal} The exponent.\r\n *\r\n */ function pow(x, y) {\n    return new this(x).pow(y);\n}\n/*\r\n * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n * are produced).\r\n *\r\n * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n *\r\n */ function random(sd) {\n    var d, e, k, n, i = 0, r = new this(1), rd = [];\n    if (sd === void 0) sd = this.precision;\n    else checkInt32(sd, 1, MAX_DIGITS);\n    k = Math.ceil(sd / LOG_BASE);\n    if (!this.crypto) {\n        for(; i < k;)rd[i++] = Math.random() * 1e7 | 0;\n    // Browsers supporting crypto.getRandomValues.\n    } else if (crypto.getRandomValues) {\n        d = crypto.getRandomValues(new Uint32Array(k));\n        for(; i < k;){\n            n = d[i];\n            // 0 <= n < 4294967296\n            // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\n            if (n >= 4.29e9) {\n                d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\n            } else {\n                // 0 <= n <= 4289999999\n                // 0 <= (n % 1e7) <= 9999999\n                rd[i++] = n % 1e7;\n            }\n        }\n    // Node.js supporting crypto.randomBytes.\n    } else if (crypto.randomBytes) {\n        // buffer\n        d = crypto.randomBytes(k *= 4);\n        for(; i < k;){\n            // 0 <= n < 2147483648\n            n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);\n            // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\n            if (n >= 2.14e9) {\n                crypto.randomBytes(4).copy(d, i);\n            } else {\n                // 0 <= n <= 2139999999\n                // 0 <= (n % 1e7) <= 9999999\n                rd.push(n % 1e7);\n                i += 4;\n            }\n        }\n        i = k / 4;\n    } else {\n        throw Error(cryptoUnavailable);\n    }\n    k = rd[--i];\n    sd %= LOG_BASE;\n    // Convert trailing digits to zeros according to sd.\n    if (k && sd) {\n        n = mathpow(10, LOG_BASE - sd);\n        rd[i] = (k / n | 0) * n;\n    }\n    // Remove trailing words which are zero.\n    for(; rd[i] === 0; i--)rd.pop();\n    // Zero?\n    if (i < 0) {\n        e = 0;\n        rd = [\n            0\n        ];\n    } else {\n        e = -1;\n        // Remove leading words which are zero and adjust exponent accordingly.\n        for(; rd[0] === 0; e -= LOG_BASE)rd.shift();\n        // Count the digits of the first word of rd to determine leading zeros.\n        for(k = 1, n = rd[0]; n >= 10; n /= 10)k++;\n        // Adjust the exponent for leading zeros of the first word of rd.\n        if (k < LOG_BASE) e -= LOG_BASE - k;\n    }\n    r.e = e;\n    r.d = rd;\n    return r;\n}\n/*\r\n * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n *\r\n * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function round(x) {\n    return finalise(x = new this(x), x.e + 1, this.rounding);\n}\n/*\r\n * Return\r\n *   1    if x > 0,\r\n *  -1    if x < 0,\r\n *   0    if x is 0,\r\n *  -0    if x is -0,\r\n *   NaN  otherwise\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function sign(x) {\n    x = new this(x);\n    return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;\n}\n/*\r\n * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function sin(x) {\n    return new this(x).sin();\n}\n/*\r\n * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function sinh(x) {\n    return new this(x).sinh();\n}\n/*\r\n * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function sqrt(x) {\n    return new this(x).sqrt();\n}\n/*\r\n * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */ function sub(x, y) {\n    return new this(x).sub(y);\n}\n/*\r\n * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * Only the result is rounded, not the intermediate calculations.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */ function sum() {\n    var i = 0, args = arguments, x = new this(args[i]);\n    external = false;\n    for(; x.s && ++i < args.length;)x = x.plus(args[i]);\n    external = true;\n    return finalise(x, this.precision, this.rounding);\n}\n/*\r\n * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function tan(x) {\n    return new this(x).tan();\n}\n/*\r\n * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function tanh(x) {\n    return new this(x).tanh();\n}\n/*\r\n * Return a new Decimal whose value is `x` truncated to an integer.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function trunc(x) {\n    return finalise(x = new this(x), x.e + 1, 1);\n}\nP[Symbol.for(\"nodejs.util.inspect.custom\")] = P.toString;\nP[Symbol.toStringTag] = \"Decimal\";\n// Create and configure initial Decimal constructor.\nvar Decimal = P.constructor = clone(DEFAULTS);\n// Create the internal constants from their string values.\nLN10 = new Decimal(LN10);\nPI = new Decimal(PI);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Decimal);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZGVjaW1hbC5qcy9kZWNpbWFsLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7Q0FNQyxHQUdELGtHQUFrRztBQUdoRyxrQ0FBa0M7QUFDbEMsdUVBQXVFO0FBQ3pFLElBQUlBLFlBQVksTUFFZCxtRkFBbUY7QUFDbkYsMEZBQTBGO0FBQzFGQyxhQUFhLEtBRWIsNEJBQTRCO0FBQzVCQyxXQUFXLG9CQUVYLDZDQUE2QztBQUM3Q0MsT0FBTyxzZ0NBRVAsb0JBQW9CO0FBQ3BCQyxLQUFLLHNnQ0FHTCxtRUFBbUU7QUFDbkVDLFdBQVc7SUFFVCxzRUFBc0U7SUFDdEUscUZBQXFGO0lBRXJGLDhGQUE4RjtJQUM5Riw0Q0FBNEM7SUFDNUNDLFdBQVc7SUFFWCx1REFBdUQ7SUFDdkQsRUFBRTtJQUNGLHFDQUFxQztJQUNyQyxtQ0FBbUM7SUFDbkMsd0NBQXdDO0lBQ3hDLHdDQUF3QztJQUN4QyxvRUFBb0U7SUFDcEUsc0VBQXNFO0lBQ3RFLHdGQUF3RjtJQUN4RixtRkFBbUY7SUFDbkYsbUZBQW1GO0lBQ25GLEVBQUU7SUFDRixPQUFPO0lBQ1AsMEJBQTBCO0lBQzFCLDhDQUE4QztJQUM5Q0MsVUFBVTtJQUVWLDhEQUE4RDtJQUM5RCx1RkFBdUY7SUFDdkYscURBQXFEO0lBQ3JELEVBQUU7SUFDRix3RkFBd0Y7SUFDeEYsK0VBQStFO0lBQy9FLDBFQUEwRTtJQUMxRSxnREFBZ0Q7SUFDaEQscUZBQXFGO0lBQ3JGLEVBQUU7SUFDRiwwRkFBMEY7SUFDMUYsOEZBQThGO0lBQzlGLGlEQUFpRDtJQUNqREMsUUFBUTtJQUVSLG1GQUFtRjtJQUNuRix5QkFBeUI7SUFDekJDLFVBQVUsQ0FBQztJQUVYLGlGQUFpRjtJQUNqRix5QkFBeUI7SUFDekJDLFVBQVc7SUFFWCxzRUFBc0U7SUFDdEUscUNBQXFDO0lBQ3JDQyxNQUFNLENBQUNYO0lBRVAsdUVBQXVFO0lBQ3ZFLHFEQUFxRDtJQUNyRFksTUFBTVo7SUFFTixrRkFBa0Y7SUFD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QUFLLElBQUk0UixRQUFRNVI7QUFFakIsaUVBQWU0UixPQUFPQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGtleXN0YXRpYy90ZW1wbGF0ZXMtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2RlY2ltYWwuanMvZGVjaW1hbC5tanM/YzUzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuICogIGRlY2ltYWwuanMgdjEwLjQuM1xyXG4gKiAgQW4gYXJiaXRyYXJ5LXByZWNpc2lvbiBEZWNpbWFsIHR5cGUgZm9yIEphdmFTY3JpcHQuXHJcbiAqICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9kZWNpbWFsLmpzXHJcbiAqICBDb3B5cmlnaHQgKGMpIDIwMjIgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICogIE1JVCBMaWNlbmNlXHJcbiAqL1xyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICBFRElUQUJMRSBERUZBVUxUUyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblxyXG5cclxuICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCBtYWduaXR1ZGUuXHJcbiAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBgdG9FeHBOZWdgLCBgdG9FeHBQb3NgLCBgbWluRWAgYW5kIGBtYXhFYC5cclxudmFyIEVYUF9MSU1JVCA9IDllMTUsICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOWUxNVxyXG5cclxuICAvLyBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIGBwcmVjaXNpb25gLCBhbmQgb24gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBhcmd1bWVudCB0b1xyXG4gIC8vIGB0b0RlY2ltYWxQbGFjZXNgLCBgdG9FeHBvbmVudGlhbGAsIGB0b0ZpeGVkYCwgYHRvUHJlY2lzaW9uYCBhbmQgYHRvU2lnbmlmaWNhbnREaWdpdHNgLlxyXG4gIE1BWF9ESUdJVFMgPSAxZTksICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAxZTlcclxuXHJcbiAgLy8gQmFzZSBjb252ZXJzaW9uIGFscGhhYmV0LlxyXG4gIE5VTUVSQUxTID0gJzAxMjM0NTY3ODlhYmNkZWYnLFxyXG5cclxuICAvLyBUaGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgMTAgKDEwMjUgZGlnaXRzKS5cclxuICBMTjEwID0gJzIuMzAyNTg1MDkyOTk0MDQ1Njg0MDE3OTkxNDU0Njg0MzY0MjA3NjAxMTAxNDg4NjI4NzcyOTc2MDMzMzI3OTAwOTY3NTcyNjA5Njc3MzUyNDgwMjM1OTk3MjA1MDg5NTk4Mjk4MzQxOTY3Nzg0MDQyMjg2MjQ4NjMzNDA5NTI1NDY1MDgyODA2NzU2NjY2Mjg3MzY5MDk4NzgxNjg5NDgyOTA3MjA4MzI1NTU0NjgwODQzNzk5ODk0ODI2MjMzMTk4NTI4MzkzNTA1MzA4OTY1Mzc3NzMyNjI4ODQ2MTYzMzY2MjIyMjg3Njk4MjE5ODg2NzQ2NTQzNjY3NDc0NDA0MjQzMjc0MzY1MTU1MDQ4OTM0MzE0OTM5MzkxNDc5NjE5NDA0NDAwMjIyMTA1MTAxNzE0MTc0ODAwMzY4ODA4NDAxMjY0NzA4MDY4NTU2Nzc0MzIxNjIyODM1NTIyMDExNDgwNDY2MzcxNTY1OTEyMTM3MzQ1MDc0Nzg1Njk0NzY4MzQ2MzYxNjc5MjEwMTgwNjQ0NTA3MDY0ODAwMDI3NzUwMjY4NDkxNjc0NjU1MDU4Njg1NjkzNTY3MzQyMDY3MDU4MTEzNjQyOTIyNDU1NDQwNTc1ODkyNTcyNDIwODI0MTMxNDY5NTY4OTAxNjc1ODk0MDI1Njc3NjMxMTM1NjkxOTI5MjAzMzM3NjU4NzE0MTY2MDIzMDEwNTcwMzA4OTYzNDU3MjA3NTQ0MDM3MDg0NzQ2OTk0MDE2ODI2OTI4MjgwODQ4MTE4NDI4OTMxNDg0ODUyNDk0ODY0NDg3MTkyNzgwOTY3NjI3MTI3NTc3NTM5NzAyNzY2ODYwNTk1MjQ5NjcxNjY3NDE4MzQ4NTcwNDQyMjUwNzE5Nzk2NTAwNDcxNDk1MTA1MDQ5MjIxNDc3NjU2NzYzNjkzODY2Mjk3Njk3OTUyMjExMDcxODI2NDU0OTczNDc3MjY2MjQyNTcwOTQyOTMyMjU4Mjc5ODUwMjU4NTUwOTc4NTI2NTM4MzIwNzYwNjcyNjMxNzE2NDMwOTUwNTk5NTA4NzgwNzUyMzcxMDMzMzEwMTE5Nzg1NzU0NzMzMTU0MTQyMTgwODQyNzU0Mzg2MzU5MTc3ODExNzA1NDMwOTgyNzQ4MjM4NTA0NTY0ODAxOTA5NTYxMDI5OTI5MTgyNDMxODIzNzUyNTM1NzcwOTc1MDUzOTU2NTE4NzY5NzUxMDM3NDk3MDg4ODY5MjE4MDIwNTE4OTMzOTUwNzIzODUzOTIwNTE0NDYzNDE5NzI2NTI4NzI4Njk2NTExMDg2MjU3MTQ5MjE5ODg0OTk3ODc0ODg3Mzc3MTM0NTY4NjIwOTE2NzA1OCcsXHJcblxyXG4gIC8vIFBpICgxMDI1IGRpZ2l0cykuXHJcbiAgUEkgPSAnMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjA5NzQ5NDQ1OTIzMDc4MTY0MDYyODYyMDg5OTg2MjgwMzQ4MjUzNDIxMTcwNjc5ODIxNDgwODY1MTMyODIzMDY2NDcwOTM4NDQ2MDk1NTA1ODIyMzE3MjUzNTk0MDgxMjg0ODExMTc0NTAyODQxMDI3MDE5Mzg1MjExMDU1NTk2NDQ2MjI5NDg5NTQ5MzAzODE5NjQ0Mjg4MTA5NzU2NjU5MzM0NDYxMjg0NzU2NDgyMzM3ODY3ODMxNjUyNzEyMDE5MDkxNDU2NDg1NjY5MjM0NjAzNDg2MTA0NTQzMjY2NDgyMTMzOTM2MDcyNjAyNDkxNDEyNzM3MjQ1ODcwMDY2MDYzMTU1ODgxNzQ4ODE1MjA5MjA5NjI4MjkyNTQwOTE3MTUzNjQzNjc4OTI1OTAzNjAwMTEzMzA1MzA1NDg4MjA0NjY1MjEzODQxNDY5NTE5NDE1MTE2MDk0MzMwNTcyNzAzNjU3NTk1OTE5NTMwOTIxODYxMTczODE5MzI2MTE3OTMxMDUxMTg1NDgwNzQ0NjIzNzk5NjI3NDk1NjczNTE4ODU3NTI3MjQ4OTEyMjc5MzgxODMwMTE5NDkxMjk4MzM2NzMzNjI0NDA2NTY2NDMwODYwMjEzOTQ5NDYzOTUyMjQ3MzcxOTA3MDIxNzk4NjA5NDM3MDI3NzA1MzkyMTcxNzYyOTMxNzY3NTIzODQ2NzQ4MTg0Njc2Njk0MDUxMzIwMDA1NjgxMjcxNDUyNjM1NjA4Mjc3ODU3NzEzNDI3NTc3ODk2MDkxNzM2MzcxNzg3MjE0Njg0NDA5MDEyMjQ5NTM0MzAxNDY1NDk1ODUzNzEwNTA3OTIyNzk2ODkyNTg5MjM1NDIwMTk5NTYxMTIxMjkwMjE5NjA4NjQwMzQ0MTgxNTk4MTM2Mjk3NzQ3NzEzMDk5NjA1MTg3MDcyMTEzNDk5OTk5OTgzNzI5NzgwNDk5NTEwNTk3MzE3MzI4MTYwOTYzMTg1OTUwMjQ0NTk0NTUzNDY5MDgzMDI2NDI1MjIzMDgyNTMzNDQ2ODUwMzUyNjE5MzExODgxNzEwMTAwMDMxMzc4Mzg3NTI4ODY1ODc1MzMyMDgzODE0MjA2MTcxNzc2NjkxNDczMDM1OTgyNTM0OTA0Mjg3NTU0Njg3MzExNTk1NjI4NjM4ODIzNTM3ODc1OTM3NTE5NTc3ODE4NTc3ODA1MzIxNzEyMjY4MDY2MTMwMDE5Mjc4NzY2MTExOTU5MDkyMTY0MjAxOTg5MzgwOTUyNTcyMDEwNjU0ODU4NjMyNzg5JyxcclxuXHJcblxyXG4gIC8vIFRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyBvZiB0aGUgRGVjaW1hbCBjb25zdHJ1Y3Rvci5cclxuICBERUZBVUxUUyA9IHtcclxuXHJcbiAgICAvLyBUaGVzZSB2YWx1ZXMgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIHN0YXRlZCByYW5nZXMgKGluY2x1c2l2ZSkuXHJcbiAgICAvLyBNb3N0IG9mIHRoZXNlIHZhbHVlcyBjYW4gYmUgY2hhbmdlZCBhdCBydW4tdGltZSB1c2luZyB0aGUgYERlY2ltYWwuY29uZmlnYCBtZXRob2QuXHJcblxyXG4gICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIGEgY2FsY3VsYXRpb24gb3IgYmFzZSBjb252ZXJzaW9uLlxyXG4gICAgLy8gRS5nLiBgRGVjaW1hbC5jb25maWcoeyBwcmVjaXNpb246IDIwIH0pO2BcclxuICAgIHByZWNpc2lvbjogMjAsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gTUFYX0RJR0lUU1xyXG5cclxuICAgIC8vIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byBgcHJlY2lzaW9uYC5cclxuICAgIC8vXHJcbiAgICAvLyBST1VORF9VUCAgICAgICAgIDAgQXdheSBmcm9tIHplcm8uXHJcbiAgICAvLyBST1VORF9ET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxyXG4gICAgLy8gUk9VTkRfQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgLy8gUk9VTkRfRkxPT1IgICAgICAzIFRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgLy8gUk9VTkRfSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cclxuICAgIC8vIFJPVU5EX0hBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgIC8vIFJPVU5EX0hBTEZfRVZFTiAgNiBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyBldmVuIG5laWdoYm91ci5cclxuICAgIC8vIFJPVU5EX0hBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAvLyBST1VORF9IQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgLy9cclxuICAgIC8vIEUuZy5cclxuICAgIC8vIGBEZWNpbWFsLnJvdW5kaW5nID0gNDtgXHJcbiAgICAvLyBgRGVjaW1hbC5yb3VuZGluZyA9IERlY2ltYWwuUk9VTkRfSEFMRl9VUDtgXHJcbiAgICByb3VuZGluZzogNCwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDhcclxuXHJcbiAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgLy8gVGhlIHF1b3RpZW50IChxID0gYSAvIG4pIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAvLyBUaGUgcmVtYWluZGVyIChyKSBpcyBjYWxjdWxhdGVkIGFzOiByID0gYSAtIG4gKiBxLlxyXG4gICAgLy9cclxuICAgIC8vIFVQICAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgIC8vIERPV04gICAgICAgMSBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpZGVuZCAoSmF2YVNjcmlwdCAlKS5cclxuICAgIC8vIEZMT09SICAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAvLyBIQUxGX0VWRU4gIDYgVGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgIC8vIEVVQ0xJRCAgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuIEFsd2F5cyBwb3NpdGl2ZS5cclxuICAgIC8vXHJcbiAgICAvLyBUcnVuY2F0ZWQgZGl2aXNpb24gKDEpLCBmbG9vcmVkIGRpdmlzaW9uICgzKSwgdGhlIElFRUUgNzU0IHJlbWFpbmRlciAoNiksIGFuZCBFdWNsaWRpYW5cclxuICAgIC8vIGRpdmlzaW9uICg5KSBhcmUgY29tbW9ubHkgdXNlZCBmb3IgdGhlIG1vZHVsdXMgb3BlcmF0aW9uLiBUaGUgb3RoZXIgcm91bmRpbmcgbW9kZXMgY2FuIGFsc29cclxuICAgIC8vIGJlIHVzZWQsIGJ1dCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cclxuICAgIG1vZHVsbzogMSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYmVuZWF0aCB3aGljaCBgdG9TdHJpbmdgIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAvLyBKYXZhU2NyaXB0IG51bWJlcnM6IC03XHJcbiAgICB0b0V4cE5lZzogLTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1FWFBfTElNSVRcclxuXHJcbiAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIGB0b1N0cmluZ2AgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgIC8vIEphdmFTY3JpcHQgbnVtYmVyczogMjFcclxuICAgIHRvRXhwUG9zOiAgMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gRVhQX0xJTUlUXHJcblxyXG4gICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgLy8gSmF2YVNjcmlwdCBudW1iZXJzOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgbWluRTogLUVYUF9MSU1JVCwgICAgICAgICAgICAgICAgICAgICAgLy8gLTEgdG8gLUVYUF9MSU1JVFxyXG5cclxuICAgIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IHZhbHVlLCBhYm92ZSB3aGljaCBvdmVyZmxvdyB0byBJbmZpbml0eSBvY2N1cnMuXHJcbiAgICAvLyBKYXZhU2NyaXB0IG51bWJlcnM6IDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgbWF4RTogRVhQX0xJTUlULCAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBFWFBfTElNSVRcclxuXHJcbiAgICAvLyBXaGV0aGVyIHRvIHVzZSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uLCBpZiBhdmFpbGFibGUuXHJcbiAgICBjcnlwdG86IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlL2ZhbHNlXHJcbiAgfSxcclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFTkQgT0YgRURJVEFCTEUgREVGQVVMVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cclxuXHJcbiAgaW5leGFjdCwgcXVhZHJhbnQsXHJcbiAgZXh0ZXJuYWwgPSB0cnVlLFxyXG5cclxuICBkZWNpbWFsRXJyb3IgPSAnW0RlY2ltYWxFcnJvcl0gJyxcclxuICBpbnZhbGlkQXJndW1lbnQgPSBkZWNpbWFsRXJyb3IgKyAnSW52YWxpZCBhcmd1bWVudDogJyxcclxuICBwcmVjaXNpb25MaW1pdEV4Y2VlZGVkID0gZGVjaW1hbEVycm9yICsgJ1ByZWNpc2lvbiBsaW1pdCBleGNlZWRlZCcsXHJcbiAgY3J5cHRvVW5hdmFpbGFibGUgPSBkZWNpbWFsRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyxcclxuICB0YWcgPSAnW29iamVjdCBEZWNpbWFsXScsXHJcblxyXG4gIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcbiAgbWF0aHBvdyA9IE1hdGgucG93LFxyXG5cclxuICBpc0JpbmFyeSA9IC9eMGIoWzAxXSsoXFwuWzAxXSopP3xcXC5bMDFdKykocFsrLV0/XFxkKyk/JC9pLFxyXG4gIGlzSGV4ID0gL14weChbMC05YS1mXSsoXFwuWzAtOWEtZl0qKT98XFwuWzAtOWEtZl0rKShwWystXT9cXGQrKT8kL2ksXHJcbiAgaXNPY3RhbCA9IC9eMG8oWzAtN10rKFxcLlswLTddKik/fFxcLlswLTddKykocFsrLV0/XFxkKyk/JC9pLFxyXG4gIGlzRGVjaW1hbCA9IC9eKFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaSxcclxuXHJcbiAgQkFTRSA9IDFlNyxcclxuICBMT0dfQkFTRSA9IDcsXHJcbiAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXHJcblxyXG4gIExOMTBfUFJFQ0lTSU9OID0gTE4xMC5sZW5ndGggLSAxLFxyXG4gIFBJX1BSRUNJU0lPTiA9IFBJLmxlbmd0aCAtIDEsXHJcblxyXG4gIC8vIERlY2ltYWwucHJvdG90eXBlIG9iamVjdFxyXG4gIFAgPSB7IHRvU3RyaW5nVGFnOiB0YWcgfTtcclxuXHJcblxyXG4vLyBEZWNpbWFsIHByb3RvdHlwZSBtZXRob2RzXHJcblxyXG5cclxuLypcclxuICogIGFic29sdXRlVmFsdWUgICAgICAgICAgICAgYWJzXHJcbiAqICBjZWlsXHJcbiAqICBjbGFtcGVkVG8gICAgICAgICAgICAgICAgIGNsYW1wXHJcbiAqICBjb21wYXJlZFRvICAgICAgICAgICAgICAgIGNtcFxyXG4gKiAgY29zaW5lICAgICAgICAgICAgICAgICAgICBjb3NcclxuICogIGN1YmVSb290ICAgICAgICAgICAgICAgICAgY2JydFxyXG4gKiAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgICBkcFxyXG4gKiAgZGl2aWRlZEJ5ICAgICAgICAgICAgICAgICBkaXZcclxuICogIGRpdmlkZWRUb0ludGVnZXJCeSAgICAgICAgZGl2VG9JbnRcclxuICogIGVxdWFscyAgICAgICAgICAgICAgICAgICAgZXFcclxuICogIGZsb29yXHJcbiAqICBncmVhdGVyVGhhbiAgICAgICAgICAgICAgIGd0XHJcbiAqICBncmVhdGVyVGhhbk9yRXF1YWxUbyAgICAgIGd0ZVxyXG4gKiAgaHlwZXJib2xpY0Nvc2luZSAgICAgICAgICBjb3NoXHJcbiAqICBoeXBlcmJvbGljU2luZSAgICAgICAgICAgIHNpbmhcclxuICogIGh5cGVyYm9saWNUYW5nZW50ICAgICAgICAgdGFuaFxyXG4gKiAgaW52ZXJzZUNvc2luZSAgICAgICAgICAgICBhY29zXHJcbiAqICBpbnZlcnNlSHlwZXJib2xpY0Nvc2luZSAgIGFjb3NoXHJcbiAqICBpbnZlcnNlSHlwZXJib2xpY1NpbmUgICAgIGFzaW5oXHJcbiAqICBpbnZlcnNlSHlwZXJib2xpY1RhbmdlbnQgIGF0YW5oXHJcbiAqICBpbnZlcnNlU2luZSAgICAgICAgICAgICAgIGFzaW5cclxuICogIGludmVyc2VUYW5nZW50ICAgICAgICAgICAgYXRhblxyXG4gKiAgaXNGaW5pdGVcclxuICogIGlzSW50ZWdlciAgICAgICAgICAgICAgICAgaXNJbnRcclxuICogIGlzTmFOXHJcbiAqICBpc05lZ2F0aXZlICAgICAgICAgICAgICAgIGlzTmVnXHJcbiAqICBpc1Bvc2l0aXZlICAgICAgICAgICAgICAgIGlzUG9zXHJcbiAqICBpc1plcm9cclxuICogIGxlc3NUaGFuICAgICAgICAgICAgICAgICAgbHRcclxuICogIGxlc3NUaGFuT3JFcXVhbFRvICAgICAgICAgbHRlXHJcbiAqICBsb2dhcml0aG0gICAgICAgICAgICAgICAgIGxvZ1xyXG4gKiAgW21heGltdW1dICAgICAgICAgICAgICAgICBbbWF4XVxyXG4gKiAgW21pbmltdW1dICAgICAgICAgICAgICAgICBbbWluXVxyXG4gKiAgbWludXMgICAgICAgICAgICAgICAgICAgICBzdWJcclxuICogIG1vZHVsbyAgICAgICAgICAgICAgICAgICAgbW9kXHJcbiAqICBuYXR1cmFsRXhwb25lbnRpYWwgICAgICAgIGV4cFxyXG4gKiAgbmF0dXJhbExvZ2FyaXRobSAgICAgICAgICBsblxyXG4gKiAgbmVnYXRlZCAgICAgICAgICAgICAgICAgICBuZWdcclxuICogIHBsdXMgICAgICAgICAgICAgICAgICAgICAgYWRkXHJcbiAqICBwcmVjaXNpb24gICAgICAgICAgICAgICAgIHNkXHJcbiAqICByb3VuZFxyXG4gKiAgc2luZSAgICAgICAgICAgICAgICAgICAgICBzaW5cclxuICogIHNxdWFyZVJvb3QgICAgICAgICAgICAgICAgc3FydFxyXG4gKiAgdGFuZ2VudCAgICAgICAgICAgICAgICAgICB0YW5cclxuICogIHRpbWVzICAgICAgICAgICAgICAgICAgICAgbXVsXHJcbiAqICB0b0JpbmFyeVxyXG4gKiAgdG9EZWNpbWFsUGxhY2VzICAgICAgICAgICB0b0RQXHJcbiAqICB0b0V4cG9uZW50aWFsXHJcbiAqICB0b0ZpeGVkXHJcbiAqICB0b0ZyYWN0aW9uXHJcbiAqICB0b0hleGFkZWNpbWFsICAgICAgICAgICAgIHRvSGV4XHJcbiAqICB0b05lYXJlc3RcclxuICogIHRvTnVtYmVyXHJcbiAqICB0b09jdGFsXHJcbiAqICB0b1Bvd2VyICAgICAgICAgICAgICAgICAgIHBvd1xyXG4gKiAgdG9QcmVjaXNpb25cclxuICogIHRvU2lnbmlmaWNhbnREaWdpdHMgICAgICAgdG9TRFxyXG4gKiAgdG9TdHJpbmdcclxuICogIHRydW5jYXRlZCAgICAgICAgICAgICAgICAgdHJ1bmNcclxuICogIHZhbHVlT2YgICAgICAgICAgICAgICAgICAgdG9KU09OXHJcbiAqL1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqL1xyXG5QLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgeCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xyXG4gIGlmICh4LnMgPCAwKSB4LnMgPSAxO1xyXG4gIHJldHVybiBmaW5hbGlzZSh4KTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJvdW5kZWQgdG8gYSB3aG9sZSBudW1iZXIgaW4gdGhlXHJcbiAqIGRpcmVjdGlvbiBvZiBwb3NpdGl2ZSBJbmZpbml0eS5cclxuICpcclxuICovXHJcblAuY2VpbCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gZmluYWxpc2UobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyksIHRoaXMuZSArIDEsIDIpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgY2xhbXBlZCB0byB0aGUgcmFuZ2VcclxuICogZGVsaW5lYXRlZCBieSBgbWluYCBhbmQgYG1heGAuXHJcbiAqXHJcbiAqIG1pbiB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKiBtYXgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcblAuY2xhbXBlZFRvID0gUC5jbGFtcCA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xyXG4gIHZhciBrLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuICBtaW4gPSBuZXcgQ3RvcihtaW4pO1xyXG4gIG1heCA9IG5ldyBDdG9yKG1heCk7XHJcbiAgaWYgKCFtaW4ucyB8fCAhbWF4LnMpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG4gIGlmIChtaW4uZ3QobWF4KSkgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgbWF4KTtcclxuICBrID0geC5jbXAobWluKTtcclxuICByZXR1cm4gayA8IDAgPyBtaW4gOiB4LmNtcChtYXgpID4gMCA/IG1heCA6IG5ldyBDdG9yKHgpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVyblxyXG4gKiAgIDEgICAgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIGB5YCxcclxuICogIC0xICAgIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBgeWAsXHJcbiAqICAgMCAgICBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUsXHJcbiAqICAgTmFOICBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIERlY2ltYWwgaXMgTmFOLlxyXG4gKlxyXG4gKi9cclxuUC5jb21wYXJlZFRvID0gUC5jbXAgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBpLCBqLCB4ZEwsIHlkTCxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgeGQgPSB4LmQsXHJcbiAgICB5ZCA9ICh5ID0gbmV3IHguY29uc3RydWN0b3IoeSkpLmQsXHJcbiAgICB4cyA9IHgucyxcclxuICAgIHlzID0geS5zO1xyXG5cclxuICAvLyBFaXRoZXIgTmFOIG9yIMKxSW5maW5pdHk/XHJcbiAgaWYgKCF4ZCB8fCAheWQpIHtcclxuICAgIHJldHVybiAheHMgfHwgIXlzID8gTmFOIDogeHMgIT09IHlzID8geHMgOiB4ZCA9PT0geWQgPyAwIDogIXhkIF4geHMgPCAwID8gMSA6IC0xO1xyXG4gIH1cclxuXHJcbiAgLy8gRWl0aGVyIHplcm8/XHJcbiAgaWYgKCF4ZFswXSB8fCAheWRbMF0pIHJldHVybiB4ZFswXSA/IHhzIDogeWRbMF0gPyAteXMgOiAwO1xyXG5cclxuICAvLyBTaWducyBkaWZmZXI/XHJcbiAgaWYgKHhzICE9PSB5cykgcmV0dXJuIHhzO1xyXG5cclxuICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICBpZiAoeC5lICE9PSB5LmUpIHJldHVybiB4LmUgPiB5LmUgXiB4cyA8IDAgPyAxIDogLTE7XHJcblxyXG4gIHhkTCA9IHhkLmxlbmd0aDtcclxuICB5ZEwgPSB5ZC5sZW5ndGg7XHJcblxyXG4gIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgZm9yIChpID0gMCwgaiA9IHhkTCA8IHlkTCA/IHhkTCA6IHlkTDsgaSA8IGo7ICsraSkge1xyXG4gICAgaWYgKHhkW2ldICE9PSB5ZFtpXSkgcmV0dXJuIHhkW2ldID4geWRbaV0gXiB4cyA8IDAgPyAxIDogLTE7XHJcbiAgfVxyXG5cclxuICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgcmV0dXJuIHhkTCA9PT0geWRMID8gMCA6IHhkTCA+IHlkTCBeIHhzIDwgMCA/IDEgOiAtMTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgY29zaW5lIG9mIHRoZSB2YWx1ZSBpbiByYWRpYW5zIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICogUmFuZ2U6IFstMSwgMV1cclxuICpcclxuICogY29zKDApICAgICAgICAgPSAxXHJcbiAqIGNvcygtMCkgICAgICAgID0gMVxyXG4gKiBjb3MoSW5maW5pdHkpICA9IE5hTlxyXG4gKiBjb3MoLUluZmluaXR5KSA9IE5hTlxyXG4gKiBjb3MoTmFOKSAgICAgICA9IE5hTlxyXG4gKlxyXG4gKi9cclxuUC5jb3NpbmUgPSBQLmNvcyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcHIsIHJtLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKCF4LmQpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG5cclxuICAvLyBjb3MoMCkgPSBjb3MoLTApID0gMVxyXG4gIGlmICgheC5kWzBdKSByZXR1cm4gbmV3IEN0b3IoMSk7XHJcblxyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyBMT0dfQkFTRTtcclxuICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgeCA9IGNvc2luZShDdG9yLCB0b0xlc3NUaGFuSGFsZlBpKEN0b3IsIHgpKTtcclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZShxdWFkcmFudCA9PSAyIHx8IHF1YWRyYW50ID09IDMgPyB4Lm5lZygpIDogeCwgcHIsIHJtLCB0cnVlKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgY3ViZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwsIHJvdW5kZWQgdG9cclxuICogYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogIGNicnQoMCkgID0gIDBcclxuICogIGNicnQoLTApID0gLTBcclxuICogIGNicnQoMSkgID0gIDFcclxuICogIGNicnQoLTEpID0gLTFcclxuICogIGNicnQoTikgID0gIE5cclxuICogIGNicnQoLUkpID0gLUlcclxuICogIGNicnQoSSkgID0gIElcclxuICpcclxuICogTWF0aC5jYnJ0KHgpID0gKHggPCAwID8gLU1hdGgucG93KC14LCAxLzMpIDogTWF0aC5wb3coeCwgMS8zKSlcclxuICpcclxuICovXHJcblAuY3ViZVJvb3QgPSBQLmNicnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGUsIG0sIG4sIHIsIHJlcCwgcywgc2QsIHQsIHQzLCB0M3BsdXN4LFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKCF4LmlzRmluaXRlKCkgfHwgeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgcyA9IHgucyAqIG1hdGhwb3coeC5zICogeCwgMSAvIDMpO1xyXG5cclxuICAgLy8gTWF0aC5jYnJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgLy8gUGFzcyB4IHRvIE1hdGgucG93IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gIGlmICghcyB8fCBNYXRoLmFicyhzKSA9PSAxIC8gMCkge1xyXG4gICAgbiA9IGRpZ2l0c1RvU3RyaW5nKHguZCk7XHJcbiAgICBlID0geC5lO1xyXG5cclxuICAgIC8vIEFkanVzdCBuIGV4cG9uZW50IHNvIGl0IGlzIGEgbXVsdGlwbGUgb2YgMyBhd2F5IGZyb20geCBleHBvbmVudC5cclxuICAgIGlmIChzID0gKGUgLSBuLmxlbmd0aCArIDEpICUgMykgbiArPSAocyA9PSAxIHx8IHMgPT0gLTIgPyAnMCcgOiAnMDAnKTtcclxuICAgIHMgPSBtYXRocG93KG4sIDEgLyAzKTtcclxuXHJcbiAgICAvLyBSYXJlbHksIGUgbWF5IGJlIG9uZSBsZXNzIHRoYW4gdGhlIHJlc3VsdCBleHBvbmVudCB2YWx1ZS5cclxuICAgIGUgPSBtYXRoZmxvb3IoKGUgKyAxKSAvIDMpIC0gKGUgJSAzID09IChlIDwgMCA/IC0xIDogMikpO1xyXG5cclxuICAgIGlmIChzID09IDEgLyAwKSB7XHJcbiAgICAgIG4gPSAnNWUnICsgZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKCdlJykgKyAxKSArIGU7XHJcbiAgICB9XHJcblxyXG4gICAgciA9IG5ldyBDdG9yKG4pO1xyXG4gICAgci5zID0geC5zO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByID0gbmV3IEN0b3Iocy50b1N0cmluZygpKTtcclxuICB9XHJcblxyXG4gIHNkID0gKGUgPSBDdG9yLnByZWNpc2lvbikgKyAzO1xyXG5cclxuICAvLyBIYWxsZXkncyBtZXRob2QuXHJcbiAgLy8gVE9ETz8gQ29tcGFyZSBOZXd0b24ncyBtZXRob2QuXHJcbiAgZm9yICg7Oykge1xyXG4gICAgdCA9IHI7XHJcbiAgICB0MyA9IHQudGltZXModCkudGltZXModCk7XHJcbiAgICB0M3BsdXN4ID0gdDMucGx1cyh4KTtcclxuICAgIHIgPSBkaXZpZGUodDNwbHVzeC5wbHVzKHgpLnRpbWVzKHQpLCB0M3BsdXN4LnBsdXModDMpLCBzZCArIDIsIDEpO1xyXG5cclxuICAgIC8vIFRPRE8/IFJlcGxhY2Ugd2l0aCBmb3ItbG9vcCBhbmQgY2hlY2tSb3VuZGluZ0RpZ2l0cy5cclxuICAgIGlmIChkaWdpdHNUb1N0cmluZyh0LmQpLnNsaWNlKDAsIHNkKSA9PT0gKG4gPSBkaWdpdHNUb1N0cmluZyhyLmQpKS5zbGljZSgwLCBzZCkpIHtcclxuICAgICAgbiA9IG4uc2xpY2Uoc2QgLSAzLCBzZCArIDEpO1xyXG5cclxuICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzIGFyZSA5OTk5IG9yIDQ5OTlcclxuICAgICAgLy8gLCBpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnksIGNvbnRpbnVlIHRoZSBpdGVyYXRpb24uXHJcbiAgICAgIGlmIChuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknKSB7XHJcblxyXG4gICAgICAgIC8vIE9uIHRoZSBmaXJzdCBpdGVyYXRpb24gb25seSwgY2hlY2sgdG8gc2VlIGlmIHJvdW5kaW5nIHVwIGdpdmVzIHRoZSBleGFjdCByZXN1bHQgYXMgdGhlXHJcbiAgICAgICAgLy8gbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgIGlmICghcmVwKSB7XHJcbiAgICAgICAgICBmaW5hbGlzZSh0LCBlICsgMSwgMCk7XHJcblxyXG4gICAgICAgICAgaWYgKHQudGltZXModCkudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2QgKz0gNDtcclxuICAgICAgICByZXAgPSAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGFuIGV4YWN0IHJlc3VsdC5cclxuICAgICAgICAvLyBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgIGZpbmFsaXNlKHIsIGUgKyAxLCAxKTtcclxuICAgICAgICAgIG0gPSAhci50aW1lcyhyKS50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZShyLCBlLCBDdG9yLnJvdW5kaW5nLCBtKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKi9cclxuUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgdyxcclxuICAgIGQgPSB0aGlzLmQsXHJcbiAgICBuID0gTmFOO1xyXG5cclxuICBpZiAoZCkge1xyXG4gICAgdyA9IGQubGVuZ3RoIC0gMTtcclxuICAgIG4gPSAodyAtIG1hdGhmbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCB3b3JkLlxyXG4gICAgdyA9IGRbd107XHJcbiAgICBpZiAodykgZm9yICg7IHcgJSAxMCA9PSAwOyB3IC89IDEwKSBuLS07XHJcbiAgICBpZiAobiA8IDApIG4gPSAwO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG47XHJcbn07XHJcblxyXG5cclxuLypcclxuICogIG4gLyAwID0gSVxyXG4gKiAgbiAvIE4gPSBOXHJcbiAqICBuIC8gSSA9IDBcclxuICogIDAgLyBuID0gMFxyXG4gKiAgMCAvIDAgPSBOXHJcbiAqICAwIC8gTiA9IE5cclxuICogIDAgLyBJID0gMFxyXG4gKiAgTiAvIG4gPSBOXHJcbiAqICBOIC8gMCA9IE5cclxuICogIE4gLyBOID0gTlxyXG4gKiAgTiAvIEkgPSBOXHJcbiAqICBJIC8gbiA9IElcclxuICogIEkgLyAwID0gSVxyXG4gKiAgSSAvIE4gPSBOXHJcbiAqICBJIC8gSSA9IE5cclxuICpcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBkaXZpZGVkIGJ5IGB5YCwgcm91bmRlZCB0b1xyXG4gKiBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKi9cclxuUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgcmV0dXJuIGRpdmlkZSh0aGlzLCBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih5KSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGludGVnZXIgcGFydCBvZiBkaXZpZGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsXHJcbiAqIGJ5IHRoZSB2YWx1ZSBvZiBgeWAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICovXHJcblAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5kaXZUb0ludCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcbiAgcmV0dXJuIGZpbmFsaXNlKGRpdmlkZSh4LCBuZXcgQ3Rvcih5KSwgMCwgMSwgMSksIEN0b3IucHJlY2lzaW9uLCBDdG9yLnJvdW5kaW5nKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBgeWAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmVxdWFscyA9IFAuZXEgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiB0aGlzLmNtcCh5KSA9PT0gMDtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJvdW5kZWQgdG8gYSB3aG9sZSBudW1iZXIgaW4gdGhlXHJcbiAqIGRpcmVjdGlvbiBvZiBuZWdhdGl2ZSBJbmZpbml0eS5cclxuICpcclxuICovXHJcblAuZmxvb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCB0aGlzLmUgKyAxLCAzKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgYHlgLCBvdGhlcndpc2UgcmV0dXJuXHJcbiAqIGZhbHNlLlxyXG4gKlxyXG4gKi9cclxuUC5ncmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiB0aGlzLmNtcCh5KSA+IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIGB5YCxcclxuICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICpcclxuICovXHJcblAuZ3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIGsgPSB0aGlzLmNtcCh5KTtcclxuICByZXR1cm4gayA9PSAxIHx8IGsgPT09IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGh5cGVyYm9saWMgY29zaW5lIG9mIHRoZSB2YWx1ZSBpbiByYWRpYW5zIG9mIHRoaXNcclxuICogRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICogUmFuZ2U6IFsxLCBJbmZpbml0eV1cclxuICpcclxuICogY29zaCh4KSA9IDEgKyB4XjIvMiEgKyB4XjQvNCEgKyB4XjYvNiEgKyAuLi5cclxuICpcclxuICogY29zaCgwKSAgICAgICAgID0gMVxyXG4gKiBjb3NoKC0wKSAgICAgICAgPSAxXHJcbiAqIGNvc2goSW5maW5pdHkpICA9IEluZmluaXR5XHJcbiAqIGNvc2goLUluZmluaXR5KSA9IEluZmluaXR5XHJcbiAqIGNvc2goTmFOKSAgICAgICA9IE5hTlxyXG4gKlxyXG4gKiAgeCAgICAgICAgdGltZSB0YWtlbiAobXMpICAgcmVzdWx0XHJcbiAqIDEwMDAgICAgICA5ICAgICAgICAgICAgICAgICA5Ljg1MDM1NTU3MDA4NTIzNDk2OTRlKzQzM1xyXG4gKiAxMDAwMCAgICAgMjUgICAgICAgICAgICAgICAgNC40MDM0MDkxMTI4MzE0NjA3OTM2ZSs0MzQyXHJcbiAqIDEwMDAwMCAgICAxNzEgICAgICAgICAgICAgICAxLjQwMzMzMTY4MDIxMzA2MTU4OTdlKzQzNDI5XHJcbiAqIDEwMDAwMDAgICAzODE3ICAgICAgICAgICAgICAxLjUxNjYwNzY5ODQwMTA0Mzc3MjVlKzQzNDI5NFxyXG4gKiAxMDAwMDAwMCAgYWJhbmRvbmVkIGFmdGVyIDIgbWludXRlIHdhaXRcclxuICpcclxuICogVE9ETz8gQ29tcGFyZSBwZXJmb3JtYW5jZSBvZiBjb3NoKHgpID0gMC41ICogKGV4cCh4KSArIGV4cCgteCkpXHJcbiAqXHJcbiAqL1xyXG5QLmh5cGVyYm9saWNDb3NpbmUgPSBQLmNvc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGssIG4sIHByLCBybSwgbGVuLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgIG9uZSA9IG5ldyBDdG9yKDEpO1xyXG5cclxuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKHgucyA/IDEgLyAwIDogTmFOKTtcclxuICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIG9uZTtcclxuXHJcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KHguZSwgeC5zZCgpKSArIDQ7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcbiAgbGVuID0geC5kLmxlbmd0aDtcclxuXHJcbiAgLy8gQXJndW1lbnQgcmVkdWN0aW9uOiBjb3MoNHgpID0gMSAtIDhjb3NeMih4KSArIDhjb3NeNCh4KSArIDFcclxuICAvLyBpLmUuIGNvcyh4KSA9IDEgLSBjb3NeMih4LzQpKDggLSA4Y29zXjIoeC80KSlcclxuXHJcbiAgLy8gRXN0aW1hdGUgdGhlIG9wdGltdW0gbnVtYmVyIG9mIHRpbWVzIHRvIHVzZSB0aGUgYXJndW1lbnQgcmVkdWN0aW9uLlxyXG4gIC8vIFRPRE8/IEVzdGltYXRpb24gcmV1c2VkIGZyb20gY29zaW5lKCkgYW5kIG1heSBub3QgYmUgb3B0aW1hbCBoZXJlLlxyXG4gIGlmIChsZW4gPCAzMikge1xyXG4gICAgayA9IE1hdGguY2VpbChsZW4gLyAzKTtcclxuICAgIG4gPSAoMSAvIHRpbnlQb3coNCwgaykpLnRvU3RyaW5nKCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGsgPSAxNjtcclxuICAgIG4gPSAnMi4zMjgzMDY0MzY1Mzg2OTYyODkwNjI1ZS0xMCc7XHJcbiAgfVxyXG5cclxuICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDEsIHgudGltZXMobiksIG5ldyBDdG9yKDEpLCB0cnVlKTtcclxuXHJcbiAgLy8gUmV2ZXJzZSBhcmd1bWVudCByZWR1Y3Rpb25cclxuICB2YXIgY29zaDJfeCxcclxuICAgIGkgPSBrLFxyXG4gICAgZDggPSBuZXcgQ3Rvcig4KTtcclxuICBmb3IgKDsgaS0tOykge1xyXG4gICAgY29zaDJfeCA9IHgudGltZXMoeCk7XHJcbiAgICB4ID0gb25lLm1pbnVzKGNvc2gyX3gudGltZXMoZDgubWludXMoY29zaDJfeC50aW1lcyhkOCkpKSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmluYWxpc2UoeCwgQ3Rvci5wcmVjaXNpb24gPSBwciwgQ3Rvci5yb3VuZGluZyA9IHJtLCB0cnVlKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaHlwZXJib2xpYyBzaW5lIG9mIHRoZSB2YWx1ZSBpbiByYWRpYW5zIG9mIHRoaXNcclxuICogRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICogUmFuZ2U6IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gKlxyXG4gKiBzaW5oKHgpID0geCArIHheMy8zISArIHheNS81ISArIHheNy83ISArIC4uLlxyXG4gKlxyXG4gKiBzaW5oKDApICAgICAgICAgPSAwXHJcbiAqIHNpbmgoLTApICAgICAgICA9IC0wXHJcbiAqIHNpbmgoSW5maW5pdHkpICA9IEluZmluaXR5XHJcbiAqIHNpbmgoLUluZmluaXR5KSA9IC1JbmZpbml0eVxyXG4gKiBzaW5oKE5hTikgICAgICAgPSBOYU5cclxuICpcclxuICogeCAgICAgICAgdGltZSB0YWtlbiAobXMpXHJcbiAqIDEwICAgICAgIDIgbXNcclxuICogMTAwICAgICAgNSBtc1xyXG4gKiAxMDAwICAgICAxNCBtc1xyXG4gKiAxMDAwMCAgICA4MiBtc1xyXG4gKiAxMDAwMDAgICA4ODYgbXMgICAgICAgICAgICAxLjQwMzMzMTY4MDIxMzA2MTU4OTdlKzQzNDI5XHJcbiAqIDIwMDAwMCAgIDI2MTMgbXNcclxuICogMzAwMDAwICAgNTQwNyBtc1xyXG4gKiA0MDAwMDAgICA4ODI0IG1zXHJcbiAqIDUwMDAwMCAgIDEzMDI2IG1zICAgICAgICAgIDguNzA4MDY0MzYxMjcxODA4NDEyOWUrMjE3MTQ2XHJcbiAqIDEwMDAwMDAgIDQ4NTQzIG1zXHJcbiAqXHJcbiAqIFRPRE8/IENvbXBhcmUgcGVyZm9ybWFuY2Ugb2Ygc2luaCh4KSA9IDAuNSAqIChleHAoeCkgLSBleHAoLXgpKVxyXG4gKlxyXG4gKi9cclxuUC5oeXBlcmJvbGljU2luZSA9IFAuc2luaCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaywgcHIsIHJtLCBsZW4sXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICBpZiAoIXguaXNGaW5pdGUoKSB8fCB4LmlzWmVybygpKSByZXR1cm4gbmV3IEN0b3IoeCk7XHJcblxyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyA0O1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG4gIGxlbiA9IHguZC5sZW5ndGg7XHJcblxyXG4gIGlmIChsZW4gPCAzKSB7XHJcbiAgICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgsIHRydWUpO1xyXG4gIH0gZWxzZSB7XHJcblxyXG4gICAgLy8gQWx0ZXJuYXRpdmUgYXJndW1lbnQgcmVkdWN0aW9uOiBzaW5oKDN4KSA9IHNpbmgoeCkoMyArIDRzaW5oXjIoeCkpXHJcbiAgICAvLyBpLmUuIHNpbmgoeCkgPSBzaW5oKHgvMykoMyArIDRzaW5oXjIoeC8zKSlcclxuICAgIC8vIDMgbXVsdGlwbGljYXRpb25zIGFuZCAxIGFkZGl0aW9uXHJcblxyXG4gICAgLy8gQXJndW1lbnQgcmVkdWN0aW9uOiBzaW5oKDV4KSA9IHNpbmgoeCkoNSArIHNpbmheMih4KSgyMCArIDE2c2luaF4yKHgpKSlcclxuICAgIC8vIGkuZS4gc2luaCh4KSA9IHNpbmgoeC81KSg1ICsgc2luaF4yKHgvNSkoMjAgKyAxNnNpbmheMih4LzUpKSlcclxuICAgIC8vIDQgbXVsdGlwbGljYXRpb25zIGFuZCAyIGFkZGl0aW9uc1xyXG5cclxuICAgIC8vIEVzdGltYXRlIHRoZSBvcHRpbXVtIG51bWJlciBvZiB0aW1lcyB0byB1c2UgdGhlIGFyZ3VtZW50IHJlZHVjdGlvbi5cclxuICAgIGsgPSAxLjQgKiBNYXRoLnNxcnQobGVuKTtcclxuICAgIGsgPSBrID4gMTYgPyAxNiA6IGsgfCAwO1xyXG5cclxuICAgIHggPSB4LnRpbWVzKDEgLyB0aW55UG93KDUsIGspKTtcclxuICAgIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCwgdHJ1ZSk7XHJcblxyXG4gICAgLy8gUmV2ZXJzZSBhcmd1bWVudCByZWR1Y3Rpb25cclxuICAgIHZhciBzaW5oMl94LFxyXG4gICAgICBkNSA9IG5ldyBDdG9yKDUpLFxyXG4gICAgICBkMTYgPSBuZXcgQ3RvcigxNiksXHJcbiAgICAgIGQyMCA9IG5ldyBDdG9yKDIwKTtcclxuICAgIGZvciAoOyBrLS07KSB7XHJcbiAgICAgIHNpbmgyX3ggPSB4LnRpbWVzKHgpO1xyXG4gICAgICB4ID0geC50aW1lcyhkNS5wbHVzKHNpbmgyX3gudGltZXMoZDE2LnRpbWVzKHNpbmgyX3gpLnBsdXMoZDIwKSkpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICByZXR1cm4gZmluYWxpc2UoeCwgcHIsIHJtLCB0cnVlKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaHlwZXJib2xpYyB0YW5nZW50IG9mIHRoZSB2YWx1ZSBpbiByYWRpYW5zIG9mIHRoaXNcclxuICogRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICogUmFuZ2U6IFstMSwgMV1cclxuICpcclxuICogdGFuaCh4KSA9IHNpbmgoeCkgLyBjb3NoKHgpXHJcbiAqXHJcbiAqIHRhbmgoMCkgICAgICAgICA9IDBcclxuICogdGFuaCgtMCkgICAgICAgID0gLTBcclxuICogdGFuaChJbmZpbml0eSkgID0gMVxyXG4gKiB0YW5oKC1JbmZpbml0eSkgPSAtMVxyXG4gKiB0YW5oKE5hTikgICAgICAgPSBOYU5cclxuICpcclxuICovXHJcblAuaHlwZXJib2xpY1RhbmdlbnQgPSBQLnRhbmggPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHByLCBybSxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmICgheC5pc0Zpbml0ZSgpKSByZXR1cm4gbmV3IEN0b3IoeC5zKTtcclxuICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgNztcclxuICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgcmV0dXJuIGRpdmlkZSh4LnNpbmgoKSwgeC5jb3NoKCksIEN0b3IucHJlY2lzaW9uID0gcHIsIEN0b3Iucm91bmRpbmcgPSBybSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGFyY2Nvc2luZSAoaW52ZXJzZSBjb3NpbmUpIGluIHJhZGlhbnMgb2YgdGhlIHZhbHVlIG9mXHJcbiAqIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLTEsIDFdXHJcbiAqIFJhbmdlOiBbMCwgcGldXHJcbiAqXHJcbiAqIGFjb3MoeCkgPSBwaS8yIC0gYXNpbih4KVxyXG4gKlxyXG4gKiBhY29zKDApICAgICAgID0gcGkvMlxyXG4gKiBhY29zKC0wKSAgICAgID0gcGkvMlxyXG4gKiBhY29zKDEpICAgICAgID0gMFxyXG4gKiBhY29zKC0xKSAgICAgID0gcGlcclxuICogYWNvcygxLzIpICAgICA9IHBpLzNcclxuICogYWNvcygtMS8yKSAgICA9IDIqcGkvM1xyXG4gKiBhY29zKHx4fCA+IDEpID0gTmFOXHJcbiAqIGFjb3MoTmFOKSAgICAgPSBOYU5cclxuICpcclxuICovXHJcblAuaW52ZXJzZUNvc2luZSA9IFAuYWNvcyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaGFsZlBpLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgIGsgPSB4LmFicygpLmNtcCgxKSxcclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb24sXHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcblxyXG4gIGlmIChrICE9PSAtMSkge1xyXG4gICAgcmV0dXJuIGsgPT09IDBcclxuICAgICAgLy8gfHh8IGlzIDFcclxuICAgICAgPyB4LmlzTmVnKCkgPyBnZXRQaShDdG9yLCBwciwgcm0pIDogbmV3IEN0b3IoMClcclxuICAgICAgLy8gfHh8ID4gMSBvciB4IGlzIE5hTlxyXG4gICAgICA6IG5ldyBDdG9yKE5hTik7XHJcbiAgfVxyXG5cclxuICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XHJcblxyXG4gIC8vIFRPRE8/IFNwZWNpYWwgY2FzZSBhY29zKDAuNSkgPSBwaS8zIGFuZCBhY29zKC0wLjUpID0gMipwaS8zXHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyA2O1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICB4ID0geC5hc2luKCk7XHJcbiAgaGFsZlBpID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC41KTtcclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gIHJldHVybiBoYWxmUGkubWludXMoeCk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGludmVyc2Ugb2YgdGhlIGh5cGVyYm9saWMgY29zaW5lIGluIHJhZGlhbnMgb2YgdGhlXHJcbiAqIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbMSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbMCwgSW5maW5pdHldXHJcbiAqXHJcbiAqIGFjb3NoKHgpID0gbG4oeCArIHNxcnQoeF4yIC0gMSkpXHJcbiAqXHJcbiAqIGFjb3NoKHggPCAxKSAgICAgPSBOYU5cclxuICogYWNvc2goTmFOKSAgICAgICA9IE5hTlxyXG4gKiBhY29zaChJbmZpbml0eSkgID0gSW5maW5pdHlcclxuICogYWNvc2goLUluZmluaXR5KSA9IE5hTlxyXG4gKiBhY29zaCgwKSAgICAgICAgID0gTmFOXHJcbiAqIGFjb3NoKC0wKSAgICAgICAgPSBOYU5cclxuICogYWNvc2goMSkgICAgICAgICA9IDBcclxuICogYWNvc2goLTEpICAgICAgICA9IE5hTlxyXG4gKlxyXG4gKi9cclxuUC5pbnZlcnNlSHlwZXJib2xpY0Nvc2luZSA9IFAuYWNvc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHByLCBybSxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmICh4Lmx0ZSgxKSkgcmV0dXJuIG5ldyBDdG9yKHguZXEoMSkgPyAwIDogTmFOKTtcclxuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoTWF0aC5hYnMoeC5lKSwgeC5zZCgpKSArIDQ7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgeCA9IHgudGltZXMoeCkubWludXMoMSkuc3FydCgpLnBsdXMoeCk7XHJcblxyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgcmV0dXJuIHgubG4oKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaHlwZXJib2xpYyBzaW5lIGluIHJhZGlhbnMgb2YgdGhlIHZhbHVlXHJcbiAqIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICogUmFuZ2U6IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gKlxyXG4gKiBhc2luaCh4KSA9IGxuKHggKyBzcXJ0KHheMiArIDEpKVxyXG4gKlxyXG4gKiBhc2luaChOYU4pICAgICAgID0gTmFOXHJcbiAqIGFzaW5oKEluZmluaXR5KSAgPSBJbmZpbml0eVxyXG4gKiBhc2luaCgtSW5maW5pdHkpID0gLUluZmluaXR5XHJcbiAqIGFzaW5oKDApICAgICAgICAgPSAwXHJcbiAqIGFzaW5oKC0wKSAgICAgICAgPSAtMFxyXG4gKlxyXG4gKi9cclxuUC5pbnZlcnNlSHlwZXJib2xpY1NpbmUgPSBQLmFzaW5oID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBwciwgcm0sXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICBpZiAoIXguaXNGaW5pdGUoKSB8fCB4LmlzWmVybygpKSByZXR1cm4gbmV3IEN0b3IoeCk7XHJcblxyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyAyICogTWF0aC5tYXgoTWF0aC5hYnMoeC5lKSwgeC5zZCgpKSArIDY7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgeCA9IHgudGltZXMoeCkucGx1cygxKS5zcXJ0KCkucGx1cyh4KTtcclxuXHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICByZXR1cm4geC5sbigpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBpbnZlcnNlIG9mIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgaW4gcmFkaWFucyBvZiB0aGVcclxuICogdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKiBEb21haW46IFstMSwgMV1cclxuICogUmFuZ2U6IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gKlxyXG4gKiBhdGFuaCh4KSA9IDAuNSAqIGxuKCgxICsgeCkgLyAoMSAtIHgpKVxyXG4gKlxyXG4gKiBhdGFuaCh8eHwgPiAxKSAgID0gTmFOXHJcbiAqIGF0YW5oKE5hTikgICAgICAgPSBOYU5cclxuICogYXRhbmgoSW5maW5pdHkpICA9IE5hTlxyXG4gKiBhdGFuaCgtSW5maW5pdHkpID0gTmFOXHJcbiAqIGF0YW5oKDApICAgICAgICAgPSAwXHJcbiAqIGF0YW5oKC0wKSAgICAgICAgPSAtMFxyXG4gKiBhdGFuaCgxKSAgICAgICAgID0gSW5maW5pdHlcclxuICogYXRhbmgoLTEpICAgICAgICA9IC1JbmZpbml0eVxyXG4gKlxyXG4gKi9cclxuUC5pbnZlcnNlSHlwZXJib2xpY1RhbmdlbnQgPSBQLmF0YW5oID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBwciwgcm0sIHdwciwgeHNkLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG4gIGlmICh4LmUgPj0gMCkgcmV0dXJuIG5ldyBDdG9yKHguYWJzKCkuZXEoMSkgPyB4LnMgLyAwIDogeC5pc1plcm8oKSA/IHggOiBOYU4pO1xyXG5cclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICB4c2QgPSB4LnNkKCk7XHJcblxyXG4gIGlmIChNYXRoLm1heCh4c2QsIHByKSA8IDIgKiAteC5lIC0gMSkgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBwciwgcm0sIHRydWUpO1xyXG5cclxuICBDdG9yLnByZWNpc2lvbiA9IHdwciA9IHhzZCAtIHguZTtcclxuXHJcbiAgeCA9IGRpdmlkZSh4LnBsdXMoMSksIG5ldyBDdG9yKDEpLm1pbnVzKHgpLCB3cHIgKyBwciwgMSk7XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyA0O1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICB4ID0geC5sbigpO1xyXG5cclxuICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgcmV0dXJuIHgudGltZXMoMC41KTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjc2luZSAoaW52ZXJzZSBzaW5lKSBpbiByYWRpYW5zIG9mIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAqIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbLXBpLzIsIHBpLzJdXHJcbiAqXHJcbiAqIGFzaW4oeCkgPSAyKmF0YW4oeC8oMSArIHNxcnQoMSAtIHheMikpKVxyXG4gKlxyXG4gKiBhc2luKDApICAgICAgID0gMFxyXG4gKiBhc2luKC0wKSAgICAgID0gLTBcclxuICogYXNpbigxLzIpICAgICA9IHBpLzZcclxuICogYXNpbigtMS8yKSAgICA9IC1waS82XHJcbiAqIGFzaW4oMSkgICAgICAgPSBwaS8yXHJcbiAqIGFzaW4oLTEpICAgICAgPSAtcGkvMlxyXG4gKiBhc2luKHx4fCA+IDEpID0gTmFOXHJcbiAqIGFzaW4oTmFOKSAgICAgPSBOYU5cclxuICpcclxuICogVE9ETz8gQ29tcGFyZSBwZXJmb3JtYW5jZSBvZiBUYXlsb3Igc2VyaWVzLlxyXG4gKlxyXG4gKi9cclxuUC5pbnZlcnNlU2luZSA9IFAuYXNpbiA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaGFsZlBpLCBrLFxyXG4gICAgcHIsIHJtLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgayA9IHguYWJzKCkuY21wKDEpO1xyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICBpZiAoayAhPT0gLTEpIHtcclxuXHJcbiAgICAvLyB8eHwgaXMgMVxyXG4gICAgaWYgKGsgPT09IDApIHtcclxuICAgICAgaGFsZlBpID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC41KTtcclxuICAgICAgaGFsZlBpLnMgPSB4LnM7XHJcbiAgICAgIHJldHVybiBoYWxmUGk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gfHh8ID4gMSBvciB4IGlzIE5hTlxyXG4gICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPPyBTcGVjaWFsIGNhc2UgYXNpbigxLzIpID0gcGkvNiBhbmQgYXNpbigtMS8yKSA9IC1waS82XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyA2O1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICB4ID0geC5kaXYobmV3IEN0b3IoMSkubWludXMoeC50aW1lcyh4KSkuc3FydCgpLnBsdXMoMSkpLmF0YW4oKTtcclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gIHJldHVybiB4LnRpbWVzKDIpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmN0YW5nZW50IChpbnZlcnNlIHRhbmdlbnQpIGluIHJhZGlhbnMgb2YgdGhlIHZhbHVlXHJcbiAqIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICogUmFuZ2U6IFstcGkvMiwgcGkvMl1cclxuICpcclxuICogYXRhbih4KSA9IHggLSB4XjMvMyArIHheNS81IC0geF43LzcgKyAuLi5cclxuICpcclxuICogYXRhbigwKSAgICAgICAgID0gMFxyXG4gKiBhdGFuKC0wKSAgICAgICAgPSAtMFxyXG4gKiBhdGFuKDEpICAgICAgICAgPSBwaS80XHJcbiAqIGF0YW4oLTEpICAgICAgICA9IC1waS80XHJcbiAqIGF0YW4oSW5maW5pdHkpICA9IHBpLzJcclxuICogYXRhbigtSW5maW5pdHkpID0gLXBpLzJcclxuICogYXRhbihOYU4pICAgICAgID0gTmFOXHJcbiAqXHJcbiAqL1xyXG5QLmludmVyc2VUYW5nZW50ID0gUC5hdGFuID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBpLCBqLCBrLCBuLCBweCwgdCwgciwgd3ByLCB4MixcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uLFxyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICBpZiAoIXguaXNGaW5pdGUoKSkge1xyXG4gICAgaWYgKCF4LnMpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG4gICAgaWYgKHByICsgNCA8PSBQSV9QUkVDSVNJT04pIHtcclxuICAgICAgciA9IGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XHJcbiAgICAgIHIucyA9IHgucztcclxuICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICh4LmlzWmVybygpKSB7XHJcbiAgICByZXR1cm4gbmV3IEN0b3IoeCk7XHJcbiAgfSBlbHNlIGlmICh4LmFicygpLmVxKDEpICYmIHByICsgNCA8PSBQSV9QUkVDSVNJT04pIHtcclxuICAgIHIgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjI1KTtcclxuICAgIHIucyA9IHgucztcclxuICAgIHJldHVybiByO1xyXG4gIH1cclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgPSBwciArIDEwO1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICAvLyBUT0RPPyBpZiAoeCA+PSAxICYmIHByIDw9IFBJX1BSRUNJU0lPTikgYXRhbih4KSA9IGhhbGZQaSAqIHgucyAtIGF0YW4oMSAvIHgpO1xyXG5cclxuICAvLyBBcmd1bWVudCByZWR1Y3Rpb25cclxuICAvLyBFbnN1cmUgfHh8IDwgMC40MlxyXG4gIC8vIGF0YW4oeCkgPSAyICogYXRhbih4IC8gKDEgKyBzcXJ0KDEgKyB4XjIpKSlcclxuXHJcbiAgayA9IE1hdGgubWluKDI4LCB3cHIgLyBMT0dfQkFTRSArIDIgfCAwKTtcclxuXHJcbiAgZm9yIChpID0gazsgaTsgLS1pKSB4ID0geC5kaXYoeC50aW1lcyh4KS5wbHVzKDEpLnNxcnQoKS5wbHVzKDEpKTtcclxuXHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgaiA9IE1hdGguY2VpbCh3cHIgLyBMT0dfQkFTRSk7XHJcbiAgbiA9IDE7XHJcbiAgeDIgPSB4LnRpbWVzKHgpO1xyXG4gIHIgPSBuZXcgQ3Rvcih4KTtcclxuICBweCA9IHg7XHJcblxyXG4gIC8vIGF0YW4oeCkgPSB4IC0geF4zLzMgKyB4XjUvNSAtIHheNy83ICsgLi4uXHJcbiAgZm9yICg7IGkgIT09IC0xOykge1xyXG4gICAgcHggPSBweC50aW1lcyh4Mik7XHJcbiAgICB0ID0gci5taW51cyhweC5kaXYobiArPSAyKSk7XHJcblxyXG4gICAgcHggPSBweC50aW1lcyh4Mik7XHJcbiAgICByID0gdC5wbHVzKHB4LmRpdihuICs9IDIpKTtcclxuXHJcbiAgICBpZiAoci5kW2pdICE9PSB2b2lkIDApIGZvciAoaSA9IGo7IHIuZFtpXSA9PT0gdC5kW2ldICYmIGktLTspO1xyXG4gIH1cclxuXHJcbiAgaWYgKGspIHIgPSByLnRpbWVzKDIgPDwgKGsgLSAxKSk7XHJcblxyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIEN0b3IucHJlY2lzaW9uID0gcHIsIEN0b3Iucm91bmRpbmcgPSBybSwgdHJ1ZSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiAhIXRoaXMuZDtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmlzSW50ZWdlciA9IFAuaXNJbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuICEhdGhpcy5kICYmIG1hdGhmbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkgPiB0aGlzLmQubGVuZ3RoIC0gMjtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIE5hTiwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICpcclxuICovXHJcblAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuICF0aGlzLnM7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICpcclxuICovXHJcblAuaXNOZWdhdGl2ZSA9IFAuaXNOZWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMucyA8IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBwb3NpdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICpcclxuICovXHJcblAuaXNQb3NpdGl2ZSA9IFAuaXNQb3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMucyA+IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gKlxyXG4gKi9cclxuUC5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuICEhdGhpcy5kICYmIHRoaXMuZFswXSA9PT0gMDtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGxlc3MgdGhhbiBgeWAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmxlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgcmV0dXJuIHRoaXMuY21wKHkpIDwgMDtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgeWAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmxlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiB0aGlzLmNtcCh5KSA8IDE7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRoZSBsb2dhcml0aG0gb2YgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCB0byB0aGUgc3BlY2lmaWVkIGJhc2UsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogSWYgbm8gYmFzZSBpcyBzcGVjaWZpZWQsIHJldHVybiBsb2dbMTBdKGFyZykuXHJcbiAqXHJcbiAqIGxvZ1tiYXNlXShhcmcpID0gbG4oYXJnKSAvIGxuKGJhc2UpXHJcbiAqXHJcbiAqIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgY29ycmVjdGx5IHJvdW5kZWQgaWYgdGhlIGJhc2Ugb2YgdGhlIGxvZyBpcyAxMCwgYW5kICdhbG1vc3QgYWx3YXlzJ1xyXG4gKiBvdGhlcndpc2U6XHJcbiAqXHJcbiAqIERlcGVuZGluZyBvbiB0aGUgcm91bmRpbmcgbW9kZSwgdGhlIHJlc3VsdCBtYXkgYmUgaW5jb3JyZWN0bHkgcm91bmRlZCBpZiB0aGUgZmlyc3QgZmlmdGVlblxyXG4gKiByb3VuZGluZyBkaWdpdHMgYXJlIFs0OV05OTk5OTk5OTk5OTk5OSBvciBbNTBdMDAwMDAwMDAwMDAwMDAuIEluIHRoYXQgY2FzZSwgdGhlIG1heGltdW0gZXJyb3JcclxuICogYmV0d2VlbiB0aGUgcmVzdWx0IGFuZCB0aGUgY29ycmVjdGx5IHJvdW5kZWQgcmVzdWx0IHdpbGwgYmUgb25lIHVscCAodW5pdCBpbiB0aGUgbGFzdCBwbGFjZSkuXHJcbiAqXHJcbiAqIGxvZ1stYl0oYSkgICAgICAgPSBOYU5cclxuICogbG9nWzBdKGEpICAgICAgICA9IE5hTlxyXG4gKiBsb2dbMV0oYSkgICAgICAgID0gTmFOXHJcbiAqIGxvZ1tOYU5dKGEpICAgICAgPSBOYU5cclxuICogbG9nW0luZmluaXR5XShhKSA9IE5hTlxyXG4gKiBsb2dbYl0oMCkgICAgICAgID0gLUluZmluaXR5XHJcbiAqIGxvZ1tiXSgtMCkgICAgICAgPSAtSW5maW5pdHlcclxuICogbG9nW2JdKC1hKSAgICAgICA9IE5hTlxyXG4gKiBsb2dbYl0oMSkgICAgICAgID0gMFxyXG4gKiBsb2dbYl0oSW5maW5pdHkpID0gSW5maW5pdHlcclxuICogbG9nW2JdKE5hTikgICAgICA9IE5hTlxyXG4gKlxyXG4gKiBbYmFzZV0ge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIGJhc2Ugb2YgdGhlIGxvZ2FyaXRobS5cclxuICpcclxuICovXHJcblAubG9nYXJpdGhtID0gUC5sb2cgPSBmdW5jdGlvbiAoYmFzZSkge1xyXG4gIHZhciBpc0Jhc2UxMCwgZCwgZGVub21pbmF0b3IsIGssIGluZiwgbnVtLCBzZCwgcixcclxuICAgIGFyZyA9IHRoaXMsXHJcbiAgICBDdG9yID0gYXJnLmNvbnN0cnVjdG9yLFxyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbixcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZyxcclxuICAgIGd1YXJkID0gNTtcclxuXHJcbiAgLy8gRGVmYXVsdCBiYXNlIGlzIDEwLlxyXG4gIGlmIChiYXNlID09IG51bGwpIHtcclxuICAgIGJhc2UgPSBuZXcgQ3RvcigxMCk7XHJcbiAgICBpc0Jhc2UxMCA9IHRydWU7XHJcbiAgfSBlbHNlIHtcclxuICAgIGJhc2UgPSBuZXcgQ3RvcihiYXNlKTtcclxuICAgIGQgPSBiYXNlLmQ7XHJcblxyXG4gICAgLy8gUmV0dXJuIE5hTiBpZiBiYXNlIGlzIG5lZ2F0aXZlLCBvciBub24tZmluaXRlLCBvciBpcyAwIG9yIDEuXHJcbiAgICBpZiAoYmFzZS5zIDwgMCB8fCAhZCB8fCAhZFswXSB8fCBiYXNlLmVxKDEpKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuXHJcbiAgICBpc0Jhc2UxMCA9IGJhc2UuZXEoMTApO1xyXG4gIH1cclxuXHJcbiAgZCA9IGFyZy5kO1xyXG5cclxuICAvLyBJcyBhcmcgbmVnYXRpdmUsIG5vbi1maW5pdGUsIDAgb3IgMT9cclxuICBpZiAoYXJnLnMgPCAwIHx8ICFkIHx8ICFkWzBdIHx8IGFyZy5lcSgxKSkge1xyXG4gICAgcmV0dXJuIG5ldyBDdG9yKGQgJiYgIWRbMF0gPyAtMSAvIDAgOiBhcmcucyAhPSAxID8gTmFOIDogZCA/IDAgOiAxIC8gMCk7XHJcbiAgfVxyXG5cclxuICAvLyBUaGUgcmVzdWx0IHdpbGwgaGF2ZSBhIG5vbi10ZXJtaW5hdGluZyBkZWNpbWFsIGV4cGFuc2lvbiBpZiBiYXNlIGlzIDEwIGFuZCBhcmcgaXMgbm90IGFuXHJcbiAgLy8gaW50ZWdlciBwb3dlciBvZiAxMC5cclxuICBpZiAoaXNCYXNlMTApIHtcclxuICAgIGlmIChkLmxlbmd0aCA+IDEpIHtcclxuICAgICAgaW5mID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvciAoayA9IGRbMF07IGsgJSAxMCA9PT0gMDspIGsgLz0gMTA7XHJcbiAgICAgIGluZiA9IGsgIT09IDE7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gIHNkID0gcHIgKyBndWFyZDtcclxuICBudW0gPSBuYXR1cmFsTG9nYXJpdGhtKGFyZywgc2QpO1xyXG4gIGRlbm9taW5hdG9yID0gaXNCYXNlMTAgPyBnZXRMbjEwKEN0b3IsIHNkICsgMTApIDogbmF0dXJhbExvZ2FyaXRobShiYXNlLCBzZCk7XHJcblxyXG4gIC8vIFRoZSByZXN1bHQgd2lsbCBoYXZlIDUgcm91bmRpbmcgZGlnaXRzLlxyXG4gIHIgPSBkaXZpZGUobnVtLCBkZW5vbWluYXRvciwgc2QsIDEpO1xyXG5cclxuICAvLyBJZiBhdCBhIHJvdW5kaW5nIGJvdW5kYXJ5LCBpLmUuIHRoZSByZXN1bHQncyByb3VuZGluZyBkaWdpdHMgYXJlIFs0OV05OTk5IG9yIFs1MF0wMDAwLFxyXG4gIC8vIGNhbGN1bGF0ZSAxMCBmdXJ0aGVyIGRpZ2l0cy5cclxuICAvL1xyXG4gIC8vIElmIHRoZSByZXN1bHQgaXMga25vd24gdG8gaGF2ZSBhbiBpbmZpbml0ZSBkZWNpbWFsIGV4cGFuc2lvbiwgcmVwZWF0IHRoaXMgdW50aWwgaXQgaXMgY2xlYXJcclxuICAvLyB0aGF0IHRoZSByZXN1bHQgaXMgYWJvdmUgb3IgYmVsb3cgdGhlIGJvdW5kYXJ5LiBPdGhlcndpc2UsIGlmIGFmdGVyIGNhbGN1bGF0aW5nIHRoZSAxMFxyXG4gIC8vIGZ1cnRoZXIgZGlnaXRzLCB0aGUgbGFzdCAxNCBhcmUgbmluZXMsIHJvdW5kIHVwIGFuZCBhc3N1bWUgdGhlIHJlc3VsdCBpcyBleGFjdC5cclxuICAvLyBBbHNvIGFzc3VtZSB0aGUgcmVzdWx0IGlzIGV4YWN0IGlmIHRoZSBsYXN0IDE0IGFyZSB6ZXJvLlxyXG4gIC8vXHJcbiAgLy8gRXhhbXBsZSBvZiBhIHJlc3VsdCB0aGF0IHdpbGwgYmUgaW5jb3JyZWN0bHkgcm91bmRlZDpcclxuICAvLyBsb2dbMTA0ODU3Nl0oNDUwMzU5OTYyNzM3MDUwMikgPSAyLjYwMDAwMDAwMDAwMDAwMDA5NjEwMjc5NTExNDQ0NzQ2Li4uXHJcbiAgLy8gVGhlIGFib3ZlIHJlc3VsdCBjb3JyZWN0bHkgcm91bmRlZCB1c2luZyBST1VORF9DRUlMIHRvIDEgZGVjaW1hbCBwbGFjZSBzaG91bGQgYmUgMi43LCBidXQgaXRcclxuICAvLyB3aWxsIGJlIGdpdmVuIGFzIDIuNiBhcyB0aGVyZSBhcmUgMTUgemVyb3MgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHJlcXVlc3RlZCBkZWNpbWFsIHBsYWNlLCBzb1xyXG4gIC8vIHRoZSBleGFjdCByZXN1bHQgd291bGQgYmUgYXNzdW1lZCB0byBiZSAyLjYsIHdoaWNoIHJvdW5kZWQgdXNpbmcgUk9VTkRfQ0VJTCB0byAxIGRlY2ltYWxcclxuICAvLyBwbGFjZSBpcyBzdGlsbCAyLjYuXHJcbiAgaWYgKGNoZWNrUm91bmRpbmdEaWdpdHMoci5kLCBrID0gcHIsIHJtKSkge1xyXG5cclxuICAgIGRvIHtcclxuICAgICAgc2QgKz0gMTA7XHJcbiAgICAgIG51bSA9IG5hdHVyYWxMb2dhcml0aG0oYXJnLCBzZCk7XHJcbiAgICAgIGRlbm9taW5hdG9yID0gaXNCYXNlMTAgPyBnZXRMbjEwKEN0b3IsIHNkICsgMTApIDogbmF0dXJhbExvZ2FyaXRobShiYXNlLCBzZCk7XHJcbiAgICAgIHIgPSBkaXZpZGUobnVtLCBkZW5vbWluYXRvciwgc2QsIDEpO1xyXG5cclxuICAgICAgaWYgKCFpbmYpIHtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIDE0IG5pbmVzIGZyb20gdGhlIDJuZCByb3VuZGluZyBkaWdpdCwgYXMgdGhlIGZpcnN0IG1heSBiZSA0LlxyXG4gICAgICAgIGlmICgrZGlnaXRzVG9TdHJpbmcoci5kKS5zbGljZShrICsgMSwgayArIDE1KSArIDEgPT0gMWUxNCkge1xyXG4gICAgICAgICAgciA9IGZpbmFsaXNlKHIsIHByICsgMSwgMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfSB3aGlsZSAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhyLmQsIGsgKz0gMTAsIHJtKSk7XHJcbiAgfVxyXG5cclxuICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZShyLCBwciwgcm0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMgYW5kIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG5QLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICBBcnJheS5wcm90b3R5cGUucHVzaC5jYWxsKGFyZ3VtZW50cywgdGhpcyk7XHJcbiAgcmV0dXJuIG1heE9yTWluKHRoaXMuY29uc3RydWN0b3IsIGFyZ3VtZW50cywgJ2x0Jyk7XHJcbn07XHJcbiAqL1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMgYW5kIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG5QLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICBBcnJheS5wcm90b3R5cGUucHVzaC5jYWxsKGFyZ3VtZW50cywgdGhpcyk7XHJcbiAgcmV0dXJuIG1heE9yTWluKHRoaXMuY29uc3RydWN0b3IsIGFyZ3VtZW50cywgJ2d0Jyk7XHJcbn07XHJcbiAqL1xyXG5cclxuXHJcbi8qXHJcbiAqICBuIC0gMCA9IG5cclxuICogIG4gLSBOID0gTlxyXG4gKiAgbiAtIEkgPSAtSVxyXG4gKiAgMCAtIG4gPSAtblxyXG4gKiAgMCAtIDAgPSAwXHJcbiAqICAwIC0gTiA9IE5cclxuICogIDAgLSBJID0gLUlcclxuICogIE4gLSBuID0gTlxyXG4gKiAgTiAtIDAgPSBOXHJcbiAqICBOIC0gTiA9IE5cclxuICogIE4gLSBJID0gTlxyXG4gKiAgSSAtIG4gPSBJXHJcbiAqICBJIC0gMCA9IElcclxuICogIEkgLSBOID0gTlxyXG4gKiAgSSAtIEkgPSBOXHJcbiAqXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgbWludXMgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqL1xyXG5QLm1pbnVzID0gUC5zdWIgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBkLCBlLCBpLCBqLCBrLCBsZW4sIHByLCBybSwgeGQsIHhlLCB4TFR5LCB5ZCxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIHkgPSBuZXcgQ3Rvcih5KTtcclxuXHJcbiAgLy8gSWYgZWl0aGVyIGlzIG5vdCBmaW5pdGUuLi5cclxuICBpZiAoIXguZCB8fCAheS5kKSB7XHJcblxyXG4gICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgaWYgKCF4LnMgfHwgIXkucykgeSA9IG5ldyBDdG9yKE5hTik7XHJcblxyXG4gICAgLy8gUmV0dXJuIHkgbmVnYXRlZCBpZiB4IGlzIGZpbml0ZSBhbmQgeSBpcyDCsUluZmluaXR5LlxyXG4gICAgZWxzZSBpZiAoeC5kKSB5LnMgPSAteS5zO1xyXG5cclxuICAgIC8vIFJldHVybiB4IGlmIHkgaXMgZmluaXRlIGFuZCB4IGlzIMKxSW5maW5pdHkuXHJcbiAgICAvLyBSZXR1cm4geCBpZiBib3RoIGFyZSDCsUluZmluaXR5IHdpdGggZGlmZmVyZW50IHNpZ25zLlxyXG4gICAgLy8gUmV0dXJuIE5hTiBpZiBib3RoIGFyZSDCsUluZmluaXR5IHdpdGggdGhlIHNhbWUgc2lnbi5cclxuICAgIGVsc2UgeSA9IG5ldyBDdG9yKHkuZCB8fCB4LnMgIT09IHkucyA/IHggOiBOYU4pO1xyXG5cclxuICAgIHJldHVybiB5O1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgc2lnbnMgZGlmZmVyLi4uXHJcbiAgaWYgKHgucyAhPSB5LnMpIHtcclxuICAgIHkucyA9IC15LnM7XHJcbiAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gIH1cclxuXHJcbiAgeGQgPSB4LmQ7XHJcbiAgeWQgPSB5LmQ7XHJcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICBybSA9IEN0b3Iucm91bmRpbmc7XHJcblxyXG4gIC8vIElmIGVpdGhlciBpcyB6ZXJvLi4uXHJcbiAgaWYgKCF4ZFswXSB8fCAheWRbMF0pIHtcclxuXHJcbiAgICAvLyBSZXR1cm4geSBuZWdhdGVkIGlmIHggaXMgemVybyBhbmQgeSBpcyBub24temVyby5cclxuICAgIGlmICh5ZFswXSkgeS5zID0gLXkucztcclxuXHJcbiAgICAvLyBSZXR1cm4geCBpZiB5IGlzIHplcm8gYW5kIHggaXMgbm9uLXplcm8uXHJcbiAgICBlbHNlIGlmICh4ZFswXSkgeSA9IG5ldyBDdG9yKHgpO1xyXG5cclxuICAgIC8vIFJldHVybiB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAvLyBGcm9tIElFRUUgNzU0ICgyMDA4KSA2LjM6IDAgLSAwID0gLTAgLSAtMCA9IC0wIHdoZW4gcm91bmRpbmcgdG8gLUluZmluaXR5LlxyXG4gICAgZWxzZSByZXR1cm4gbmV3IEN0b3Iocm0gPT09IDMgPyAtMCA6IDApO1xyXG5cclxuICAgIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xyXG4gIH1cclxuXHJcbiAgLy8geCBhbmQgeSBhcmUgZmluaXRlLCBub24temVybyBudW1iZXJzIHdpdGggdGhlIHNhbWUgc2lnbi5cclxuXHJcbiAgLy8gQ2FsY3VsYXRlIGJhc2UgMWU3IGV4cG9uZW50cy5cclxuICBlID0gbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICB4ZSA9IG1hdGhmbG9vcih4LmUgLyBMT0dfQkFTRSk7XHJcblxyXG4gIHhkID0geGQuc2xpY2UoKTtcclxuICBrID0geGUgLSBlO1xyXG5cclxuICAvLyBJZiBiYXNlIDFlNyBleHBvbmVudHMgZGlmZmVyLi4uXHJcbiAgaWYgKGspIHtcclxuICAgIHhMVHkgPSBrIDwgMDtcclxuXHJcbiAgICBpZiAoeExUeSkge1xyXG4gICAgICBkID0geGQ7XHJcbiAgICAgIGsgPSAtaztcclxuICAgICAgbGVuID0geWQubGVuZ3RoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZCA9IHlkO1xyXG4gICAgICBlID0geGU7XHJcbiAgICAgIGxlbiA9IHhkLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOdW1iZXJzIHdpdGggbWFzc2l2ZWx5IGRpZmZlcmVudCBleHBvbmVudHMgd291bGQgcmVzdWx0IGluIGEgdmVyeSBoaWdoIG51bWJlciBvZlxyXG4gICAgLy8gemVyb3MgbmVlZGluZyB0byBiZSBwcmVwZW5kZWQsIGJ1dCB0aGlzIGNhbiBiZSBhdm9pZGVkIHdoaWxlIHN0aWxsIGVuc3VyaW5nIGNvcnJlY3RcclxuICAgIC8vIHJvdW5kaW5nIGJ5IGxpbWl0aW5nIHRoZSBudW1iZXIgb2YgemVyb3MgdG8gYE1hdGguY2VpbChwciAvIExPR19CQVNFKSArIDJgLlxyXG4gICAgaSA9IE1hdGgubWF4KE1hdGguY2VpbChwciAvIExPR19CQVNFKSwgbGVuKSArIDI7XHJcblxyXG4gICAgaWYgKGsgPiBpKSB7XHJcbiAgICAgIGsgPSBpO1xyXG4gICAgICBkLmxlbmd0aCA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICBkLnJldmVyc2UoKTtcclxuICAgIGZvciAoaSA9IGs7IGktLTspIGQucHVzaCgwKTtcclxuICAgIGQucmV2ZXJzZSgpO1xyXG5cclxuICAvLyBCYXNlIDFlNyBleHBvbmVudHMgZXF1YWwuXHJcbiAgfSBlbHNlIHtcclxuXHJcbiAgICAvLyBDaGVjayBkaWdpdHMgdG8gZGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG5cclxuICAgIGkgPSB4ZC5sZW5ndGg7XHJcbiAgICBsZW4gPSB5ZC5sZW5ndGg7XHJcbiAgICB4TFR5ID0gaSA8IGxlbjtcclxuICAgIGlmICh4TFR5KSBsZW4gPSBpO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBpZiAoeGRbaV0gIT0geWRbaV0pIHtcclxuICAgICAgICB4TFR5ID0geGRbaV0gPCB5ZFtpXTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGsgPSAwO1xyXG4gIH1cclxuXHJcbiAgaWYgKHhMVHkpIHtcclxuICAgIGQgPSB4ZDtcclxuICAgIHhkID0geWQ7XHJcbiAgICB5ZCA9IGQ7XHJcbiAgICB5LnMgPSAteS5zO1xyXG4gIH1cclxuXHJcbiAgbGVuID0geGQubGVuZ3RoO1xyXG5cclxuICAvLyBBcHBlbmQgemVyb3MgdG8gYHhkYCBpZiBzaG9ydGVyLlxyXG4gIC8vIERvbid0IGFkZCB6ZXJvcyB0byBgeWRgIGlmIHNob3J0ZXIgYXMgc3VidHJhY3Rpb24gb25seSBuZWVkcyB0byBzdGFydCBhdCBgeWRgIGxlbmd0aC5cclxuICBmb3IgKGkgPSB5ZC5sZW5ndGggLSBsZW47IGkgPiAwOyAtLWkpIHhkW2xlbisrXSA9IDA7XHJcblxyXG4gIC8vIFN1YnRyYWN0IHlkIGZyb20geGQuXHJcbiAgZm9yIChpID0geWQubGVuZ3RoOyBpID4gazspIHtcclxuXHJcbiAgICBpZiAoeGRbLS1pXSA8IHlkW2ldKSB7XHJcbiAgICAgIGZvciAoaiA9IGk7IGogJiYgeGRbLS1qXSA9PT0gMDspIHhkW2pdID0gQkFTRSAtIDE7XHJcbiAgICAgIC0teGRbal07XHJcbiAgICAgIHhkW2ldICs9IEJBU0U7XHJcbiAgICB9XHJcblxyXG4gICAgeGRbaV0gLT0geWRbaV07XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgZm9yICg7IHhkWy0tbGVuXSA9PT0gMDspIHhkLnBvcCgpO1xyXG5cclxuICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gIGZvciAoOyB4ZFswXSA9PT0gMDsgeGQuc2hpZnQoKSkgLS1lO1xyXG5cclxuICAvLyBaZXJvP1xyXG4gIGlmICgheGRbMF0pIHJldHVybiBuZXcgQ3RvcihybSA9PT0gMyA/IC0wIDogMCk7XHJcblxyXG4gIHkuZCA9IHhkO1xyXG4gIHkuZSA9IGdldEJhc2UxMEV4cG9uZW50KHhkLCBlKTtcclxuXHJcbiAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgcHIsIHJtKSA6IHk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogICBuICUgMCA9ICBOXHJcbiAqICAgbiAlIE4gPSAgTlxyXG4gKiAgIG4gJSBJID0gIG5cclxuICogICAwICUgbiA9ICAwXHJcbiAqICAtMCAlIG4gPSAtMFxyXG4gKiAgIDAgJSAwID0gIE5cclxuICogICAwICUgTiA9ICBOXHJcbiAqICAgMCAlIEkgPSAgMFxyXG4gKiAgIE4gJSBuID0gIE5cclxuICogICBOICUgMCA9ICBOXHJcbiAqICAgTiAlIE4gPSAgTlxyXG4gKiAgIE4gJSBJID0gIE5cclxuICogICBJICUgbiA9ICBOXHJcbiAqICAgSSAlIDAgPSAgTlxyXG4gKiAgIEkgJSBOID0gIE5cclxuICogICBJICUgSSA9ICBOXHJcbiAqXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgbW9kdWxvIGB5YCwgcm91bmRlZCB0b1xyXG4gKiBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiBUaGUgcmVzdWx0IGRlcGVuZHMgb24gdGhlIG1vZHVsbyBtb2RlLlxyXG4gKlxyXG4gKi9cclxuUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIHEsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICB5ID0gbmV3IEN0b3IoeSk7XHJcblxyXG4gIC8vIFJldHVybiBOYU4gaWYgeCBpcyDCsUluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgwrEwLlxyXG4gIGlmICgheC5kIHx8ICF5LnMgfHwgeS5kICYmICF5LmRbMF0pIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG5cclxuICAvLyBSZXR1cm4geCBpZiB5IGlzIMKxSW5maW5pdHkgb3IgeCBpcyDCsTAuXHJcbiAgaWYgKCF5LmQgfHwgeC5kICYmICF4LmRbMF0pIHtcclxuICAgIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgQ3Rvci5wcmVjaXNpb24sIEN0b3Iucm91bmRpbmcpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHJldmVudCByb3VuZGluZyBvZiBpbnRlcm1lZGlhdGUgY2FsY3VsYXRpb25zLlxyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gIGlmIChDdG9yLm1vZHVsbyA9PSA5KSB7XHJcblxyXG4gICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAvLyByZXN1bHQgPSB4IC0gcSAqIHkgICAgd2hlcmUgIDAgPD0gcmVzdWx0IDwgYWJzKHkpXHJcbiAgICBxID0gZGl2aWRlKHgsIHkuYWJzKCksIDAsIDMsIDEpO1xyXG4gICAgcS5zICo9IHkucztcclxuICB9IGVsc2Uge1xyXG4gICAgcSA9IGRpdmlkZSh4LCB5LCAwLCBDdG9yLm1vZHVsbywgMSk7XHJcbiAgfVxyXG5cclxuICBxID0gcS50aW1lcyh5KTtcclxuXHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICByZXR1cm4geC5taW51cyhxKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbmF0dXJhbCBleHBvbmVudGlhbCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLFxyXG4gKiBpLmUuIHRoZSBiYXNlIGUgcmFpc2VkIHRvIHRoZSBwb3dlciB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqL1xyXG5QLm5hdHVyYWxFeHBvbmVudGlhbCA9IFAuZXhwID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBuYXR1cmFsRXhwb25lbnRpYWwodGhpcyk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwsXHJcbiAqIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICovXHJcblAubmF0dXJhbExvZ2FyaXRobSA9IFAubG4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIG5hdHVyYWxMb2dhcml0aG0odGhpcyk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBuZWdhdGVkLCBpLmUuIGFzIGlmIG11bHRpcGxpZWQgYnlcclxuICogLTEuXHJcbiAqXHJcbiAqL1xyXG5QLm5lZ2F0ZWQgPSBQLm5lZyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgeCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xyXG4gIHgucyA9IC14LnM7XHJcbiAgcmV0dXJuIGZpbmFsaXNlKHgpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqICBuICsgMCA9IG5cclxuICogIG4gKyBOID0gTlxyXG4gKiAgbiArIEkgPSBJXHJcbiAqICAwICsgbiA9IG5cclxuICogIDAgKyAwID0gMFxyXG4gKiAgMCArIE4gPSBOXHJcbiAqICAwICsgSSA9IElcclxuICogIE4gKyBuID0gTlxyXG4gKiAgTiArIDAgPSBOXHJcbiAqICBOICsgTiA9IE5cclxuICogIE4gKyBJID0gTlxyXG4gKiAgSSArIG4gPSBJXHJcbiAqICBJICsgMCA9IElcclxuICogIEkgKyBOID0gTlxyXG4gKiAgSSArIEkgPSBJXHJcbiAqXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcGx1cyBgeWAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICovXHJcblAucGx1cyA9IFAuYWRkID0gZnVuY3Rpb24gKHkpIHtcclxuICB2YXIgY2FycnksIGQsIGUsIGksIGssIGxlbiwgcHIsIHJtLCB4ZCwgeWQsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICB5ID0gbmV3IEN0b3IoeSk7XHJcblxyXG4gIC8vIElmIGVpdGhlciBpcyBub3QgZmluaXRlLi4uXHJcbiAgaWYgKCF4LmQgfHwgIXkuZCkge1xyXG5cclxuICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTi5cclxuICAgIGlmICgheC5zIHx8ICF5LnMpIHkgPSBuZXcgQ3RvcihOYU4pO1xyXG5cclxuICAgIC8vIFJldHVybiB4IGlmIHkgaXMgZmluaXRlIGFuZCB4IGlzIMKxSW5maW5pdHkuXHJcbiAgICAvLyBSZXR1cm4geCBpZiBib3RoIGFyZSDCsUluZmluaXR5IHdpdGggdGhlIHNhbWUgc2lnbi5cclxuICAgIC8vIFJldHVybiBOYU4gaWYgYm90aCBhcmUgwrFJbmZpbml0eSB3aXRoIGRpZmZlcmVudCBzaWducy5cclxuICAgIC8vIFJldHVybiB5IGlmIHggaXMgZmluaXRlIGFuZCB5IGlzIMKxSW5maW5pdHkuXHJcbiAgICBlbHNlIGlmICgheC5kKSB5ID0gbmV3IEN0b3IoeS5kIHx8IHgucyA9PT0geS5zID8geCA6IE5hTik7XHJcblxyXG4gICAgcmV0dXJuIHk7XHJcbiAgfVxyXG5cclxuICAgLy8gSWYgc2lnbnMgZGlmZmVyLi4uXHJcbiAgaWYgKHgucyAhPSB5LnMpIHtcclxuICAgIHkucyA9IC15LnM7XHJcbiAgICByZXR1cm4geC5taW51cyh5KTtcclxuICB9XHJcblxyXG4gIHhkID0geC5kO1xyXG4gIHlkID0geS5kO1xyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICAvLyBJZiBlaXRoZXIgaXMgemVyby4uLlxyXG4gIGlmICgheGRbMF0gfHwgIXlkWzBdKSB7XHJcblxyXG4gICAgLy8gUmV0dXJuIHggaWYgeSBpcyB6ZXJvLlxyXG4gICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVyby5cclxuICAgIGlmICgheWRbMF0pIHkgPSBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcclxuICB9XHJcblxyXG4gIC8vIHggYW5kIHkgYXJlIGZpbml0ZSwgbm9uLXplcm8gbnVtYmVycyB3aXRoIHRoZSBzYW1lIHNpZ24uXHJcblxyXG4gIC8vIENhbGN1bGF0ZSBiYXNlIDFlNyBleHBvbmVudHMuXHJcbiAgayA9IG1hdGhmbG9vcih4LmUgLyBMT0dfQkFTRSk7XHJcbiAgZSA9IG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcblxyXG4gIHhkID0geGQuc2xpY2UoKTtcclxuICBpID0gayAtIGU7XHJcblxyXG4gIC8vIElmIGJhc2UgMWU3IGV4cG9uZW50cyBkaWZmZXIuLi5cclxuICBpZiAoaSkge1xyXG5cclxuICAgIGlmIChpIDwgMCkge1xyXG4gICAgICBkID0geGQ7XHJcbiAgICAgIGkgPSAtaTtcclxuICAgICAgbGVuID0geWQubGVuZ3RoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZCA9IHlkO1xyXG4gICAgICBlID0gaztcclxuICAgICAgbGVuID0geGQubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExpbWl0IG51bWJlciBvZiB6ZXJvcyBwcmVwZW5kZWQgdG8gbWF4KGNlaWwocHIgLyBMT0dfQkFTRSksIGxlbikgKyAxLlxyXG4gICAgayA9IE1hdGguY2VpbChwciAvIExPR19CQVNFKTtcclxuICAgIGxlbiA9IGsgPiBsZW4gPyBrICsgMSA6IGxlbiArIDE7XHJcblxyXG4gICAgaWYgKGkgPiBsZW4pIHtcclxuICAgICAgaSA9IGxlbjtcclxuICAgICAgZC5sZW5ndGggPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBOb3RlOiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgIGQucmV2ZXJzZSgpO1xyXG4gICAgZm9yICg7IGktLTspIGQucHVzaCgwKTtcclxuICAgIGQucmV2ZXJzZSgpO1xyXG4gIH1cclxuXHJcbiAgbGVuID0geGQubGVuZ3RoO1xyXG4gIGkgPSB5ZC5sZW5ndGg7XHJcblxyXG4gIC8vIElmIHlkIGlzIGxvbmdlciB0aGFuIHhkLCBzd2FwIHhkIGFuZCB5ZCBzbyB4ZCBwb2ludHMgdG8gdGhlIGxvbmdlciBhcnJheS5cclxuICBpZiAobGVuIC0gaSA8IDApIHtcclxuICAgIGkgPSBsZW47XHJcbiAgICBkID0geWQ7XHJcbiAgICB5ZCA9IHhkO1xyXG4gICAgeGQgPSBkO1xyXG4gIH1cclxuXHJcbiAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWQubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGQgY2FuIGJlIGxlZnQgYXMgdGhleSBhcmUuXHJcbiAgZm9yIChjYXJyeSA9IDA7IGk7KSB7XHJcbiAgICBjYXJyeSA9ICh4ZFstLWldID0geGRbaV0gKyB5ZFtpXSArIGNhcnJ5KSAvIEJBU0UgfCAwO1xyXG4gICAgeGRbaV0gJT0gQkFTRTtcclxuICB9XHJcblxyXG4gIGlmIChjYXJyeSkge1xyXG4gICAgeGQudW5zaGlmdChjYXJyeSk7XHJcbiAgICArK2U7XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG4gIGZvciAobGVuID0geGQubGVuZ3RoOyB4ZFstLWxlbl0gPT0gMDspIHhkLnBvcCgpO1xyXG5cclxuICB5LmQgPSB4ZDtcclxuICB5LmUgPSBnZXRCYXNlMTBFeHBvbmVudCh4ZCwgZSk7XHJcblxyXG4gIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKiBbel0ge2Jvb2xlYW58bnVtYmVyfSBXaGV0aGVyIHRvIGNvdW50IGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvczogdHJ1ZSwgZmFsc2UsIDEgb3IgMC5cclxuICpcclxuICovXHJcblAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uICh6KSB7XHJcbiAgdmFyIGssXHJcbiAgICB4ID0gdGhpcztcclxuXHJcbiAgaWYgKHogIT09IHZvaWQgMCAmJiB6ICE9PSAhIXogJiYgeiAhPT0gMSAmJiB6ICE9PSAwKSB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyB6KTtcclxuXHJcbiAgaWYgKHguZCkge1xyXG4gICAgayA9IGdldFByZWNpc2lvbih4LmQpO1xyXG4gICAgaWYgKHogJiYgeC5lICsgMSA+IGspIGsgPSB4LmUgKyAxO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBrID0gTmFOO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGs7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByb3VuZGVkIHRvIGEgd2hvbGUgbnVtYmVyIHVzaW5nXHJcbiAqIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICovXHJcblAucm91bmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgeC5lICsgMSwgQ3Rvci5yb3VuZGluZyk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHNpbmUgb2YgdGhlIHZhbHVlIGluIHJhZGlhbnMgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gKiBSYW5nZTogWy0xLCAxXVxyXG4gKlxyXG4gKiBzaW4oeCkgPSB4IC0geF4zLzMhICsgeF41LzUhIC0gLi4uXHJcbiAqXHJcbiAqIHNpbigwKSAgICAgICAgID0gMFxyXG4gKiBzaW4oLTApICAgICAgICA9IC0wXHJcbiAqIHNpbihJbmZpbml0eSkgID0gTmFOXHJcbiAqIHNpbigtSW5maW5pdHkpID0gTmFOXHJcbiAqIHNpbihOYU4pICAgICAgID0gTmFOXHJcbiAqXHJcbiAqL1xyXG5QLnNpbmUgPSBQLnNpbiA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcHIsIHJtLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG4gIGlmICh4LmlzWmVybygpKSByZXR1cm4gbmV3IEN0b3IoeCk7XHJcblxyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyBMT0dfQkFTRTtcclxuICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgeCA9IHNpbmUoQ3RvciwgdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSk7XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICByZXR1cm4gZmluYWxpc2UocXVhZHJhbnQgPiAyID8geC5uZWcoKSA6IHgsIHByLCBybSwgdHJ1ZSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoaXMgRGVjaW1hbCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiAgc3FydCgtbikgPSAgTlxyXG4gKiAgc3FydChOKSAgPSAgTlxyXG4gKiAgc3FydCgtSSkgPSAgTlxyXG4gKiAgc3FydChJKSAgPSAgSVxyXG4gKiAgc3FydCgwKSAgPSAgMFxyXG4gKiAgc3FydCgtMCkgPSAtMFxyXG4gKlxyXG4gKi9cclxuUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtLCBuLCBzZCwgciwgcmVwLCB0LFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBkID0geC5kLFxyXG4gICAgZSA9IHguZSxcclxuICAgIHMgPSB4LnMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XHJcbiAgaWYgKHMgIT09IDEgfHwgIWQgfHwgIWRbMF0pIHtcclxuICAgIHJldHVybiBuZXcgQ3RvcighcyB8fCBzIDwgMCAmJiAoIWQgfHwgZFswXSkgPyBOYU4gOiBkID8geCA6IDEgLyAwKTtcclxuICB9XHJcblxyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgcyA9IE1hdGguc3FydCgreCk7XHJcblxyXG4gIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcclxuICAgIG4gPSBkaWdpdHNUb1N0cmluZyhkKTtcclxuXHJcbiAgICBpZiAoKG4ubGVuZ3RoICsgZSkgJSAyID09IDApIG4gKz0gJzAnO1xyXG4gICAgcyA9IE1hdGguc3FydChuKTtcclxuICAgIGUgPSBtYXRoZmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcclxuXHJcbiAgICBpZiAocyA9PSAxIC8gMCkge1xyXG4gICAgICBuID0gJzVlJyArIGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgfVxyXG5cclxuICAgIHIgPSBuZXcgQ3RvcihuKTtcclxuICB9IGVsc2Uge1xyXG4gICAgciA9IG5ldyBDdG9yKHMudG9TdHJpbmcoKSk7XHJcbiAgfVxyXG5cclxuICBzZCA9IChlID0gQ3Rvci5wcmVjaXNpb24pICsgMztcclxuXHJcbiAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gIGZvciAoOzspIHtcclxuICAgIHQgPSByO1xyXG4gICAgciA9IHQucGx1cyhkaXZpZGUoeCwgdCwgc2QgKyAyLCAxKSkudGltZXMoMC41KTtcclxuXHJcbiAgICAvLyBUT0RPPyBSZXBsYWNlIHdpdGggZm9yLWxvb3AgYW5kIGNoZWNrUm91bmRpbmdEaWdpdHMuXHJcbiAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCBzZCkgPT09IChuID0gZGlnaXRzVG9TdHJpbmcoci5kKSkuc2xpY2UoMCwgc2QpKSB7XHJcbiAgICAgIG4gPSBuLnNsaWNlKHNkIC0gMywgc2QgKyAxKTtcclxuXHJcbiAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0cyBhcmUgOTk5OSBvclxyXG4gICAgICAvLyA0OTk5LCBpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnksIGNvbnRpbnVlIHRoZSBpdGVyYXRpb24uXHJcbiAgICAgIGlmIChuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknKSB7XHJcblxyXG4gICAgICAgIC8vIE9uIHRoZSBmaXJzdCBpdGVyYXRpb24gb25seSwgY2hlY2sgdG8gc2VlIGlmIHJvdW5kaW5nIHVwIGdpdmVzIHRoZSBleGFjdCByZXN1bHQgYXMgdGhlXHJcbiAgICAgICAgLy8gbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgIGlmICghcmVwKSB7XHJcbiAgICAgICAgICBmaW5hbGlzZSh0LCBlICsgMSwgMCk7XHJcblxyXG4gICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2QgKz0gNDtcclxuICAgICAgICByZXAgPSAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGFuIGV4YWN0IHJlc3VsdC5cclxuICAgICAgICAvLyBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgIGZpbmFsaXNlKHIsIGUgKyAxLCAxKTtcclxuICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZShyLCBlLCBDdG9yLnJvdW5kaW5nLCBtKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdGFuZ2VudCBvZiB0aGUgdmFsdWUgaW4gcmFkaWFucyBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICpcclxuICogdGFuKDApICAgICAgICAgPSAwXHJcbiAqIHRhbigtMCkgICAgICAgID0gLTBcclxuICogdGFuKEluZmluaXR5KSAgPSBOYU5cclxuICogdGFuKC1JbmZpbml0eSkgPSBOYU5cclxuICogdGFuKE5hTikgICAgICAgPSBOYU5cclxuICpcclxuICovXHJcblAudGFuZ2VudCA9IFAudGFuID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBwciwgcm0sXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcbiAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDEwO1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICB4ID0geC5zaW4oKTtcclxuICB4LnMgPSAxO1xyXG4gIHggPSBkaXZpZGUoeCwgbmV3IEN0b3IoMSkubWludXMoeC50aW1lcyh4KSkuc3FydCgpLCBwciArIDEwLCAwKTtcclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZShxdWFkcmFudCA9PSAyIHx8IHF1YWRyYW50ID09IDQgPyB4Lm5lZygpIDogeCwgcHIsIHJtLCB0cnVlKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiAgbiAqIDAgPSAwXHJcbiAqICBuICogTiA9IE5cclxuICogIG4gKiBJID0gSVxyXG4gKiAgMCAqIG4gPSAwXHJcbiAqICAwICogMCA9IDBcclxuICogIDAgKiBOID0gTlxyXG4gKiAgMCAqIEkgPSBOXHJcbiAqICBOICogbiA9IE5cclxuICogIE4gKiAwID0gTlxyXG4gKiAgTiAqIE4gPSBOXHJcbiAqICBOICogSSA9IE5cclxuICogIEkgKiBuID0gSVxyXG4gKiAgSSAqIDAgPSBOXHJcbiAqICBJICogTiA9IE5cclxuICogIEkgKiBJID0gSVxyXG4gKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGlzIERlY2ltYWwgdGltZXMgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqL1xyXG5QLnRpbWVzID0gUC5tdWwgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBjYXJyeSwgZSwgaSwgaywgciwgckwsIHQsIHhkTCwgeWRMLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgIHhkID0geC5kLFxyXG4gICAgeWQgPSAoeSA9IG5ldyBDdG9yKHkpKS5kO1xyXG5cclxuICB5LnMgKj0geC5zO1xyXG5cclxuICAgLy8gSWYgZWl0aGVyIGlzIE5hTiwgwrFJbmZpbml0eSBvciDCsTAuLi5cclxuICBpZiAoIXhkIHx8ICF4ZFswXSB8fCAheWQgfHwgIXlkWzBdKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBDdG9yKCF5LnMgfHwgeGQgJiYgIXhkWzBdICYmICF5ZCB8fCB5ZCAmJiAheWRbMF0gJiYgIXhkXHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBpcyBOYU4uXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgeCBpcyDCsTAgYW5kIHkgaXMgwrFJbmZpbml0eSwgb3IgeSBpcyDCsTAgYW5kIHggaXMgwrFJbmZpbml0eS5cclxuICAgICAgPyBOYU5cclxuXHJcbiAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgIDogIXhkIHx8ICF5ZCA/IHkucyAvIDAgOiB5LnMgKiAwKTtcclxuICB9XHJcblxyXG4gIGUgPSBtYXRoZmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICB4ZEwgPSB4ZC5sZW5ndGg7XHJcbiAgeWRMID0geWQubGVuZ3RoO1xyXG5cclxuICAvLyBFbnN1cmUgeGQgcG9pbnRzIHRvIHRoZSBsb25nZXIgYXJyYXkuXHJcbiAgaWYgKHhkTCA8IHlkTCkge1xyXG4gICAgciA9IHhkO1xyXG4gICAgeGQgPSB5ZDtcclxuICAgIHlkID0gcjtcclxuICAgIHJMID0geGRMO1xyXG4gICAgeGRMID0geWRMO1xyXG4gICAgeWRMID0gckw7XHJcbiAgfVxyXG5cclxuICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICByID0gW107XHJcbiAgckwgPSB4ZEwgKyB5ZEw7XHJcbiAgZm9yIChpID0gckw7IGktLTspIHIucHVzaCgwKTtcclxuXHJcbiAgLy8gTXVsdGlwbHkhXHJcbiAgZm9yIChpID0geWRMOyAtLWkgPj0gMDspIHtcclxuICAgIGNhcnJ5ID0gMDtcclxuICAgIGZvciAoayA9IHhkTCArIGk7IGsgPiBpOykge1xyXG4gICAgICB0ID0gcltrXSArIHlkW2ldICogeGRbayAtIGkgLSAxXSArIGNhcnJ5O1xyXG4gICAgICByW2stLV0gPSB0ICUgQkFTRSB8IDA7XHJcbiAgICAgIGNhcnJ5ID0gdCAvIEJBU0UgfCAwO1xyXG4gICAgfVxyXG5cclxuICAgIHJba10gPSAocltrXSArIGNhcnJ5KSAlIEJBU0UgfCAwO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gIGZvciAoOyAhclstLXJMXTspIHIucG9wKCk7XHJcblxyXG4gIGlmIChjYXJyeSkgKytlO1xyXG4gIGVsc2Ugci5zaGlmdCgpO1xyXG5cclxuICB5LmQgPSByO1xyXG4gIHkuZSA9IGdldEJhc2UxMEV4cG9uZW50KHIsIGUpO1xyXG5cclxuICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBDdG9yLnByZWNpc2lvbiwgQ3Rvci5yb3VuZGluZykgOiB5O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpbiBiYXNlIDIsIHJvdW5kIHRvIGBzZGAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYC5cclxuICpcclxuICogSWYgdGhlIG9wdGlvbmFsIGBzZGAgYXJndW1lbnQgaXMgcHJlc2VudCB0aGVuIHJldHVybiBiaW5hcnkgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAqXHJcbiAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqL1xyXG5QLnRvQmluYXJ5ID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCAyLCBzZCwgcm0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcm91bmRlZCB0byBhIG1heGltdW0gb2YgYGRwYFxyXG4gKiBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIGBybWAgb3IgYHJvdW5kaW5nYCBpZiBgcm1gIGlzIG9taXR0ZWQuXHJcbiAqXHJcbiAqIElmIGBkcGAgaXMgb21pdHRlZCwgcmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gKlxyXG4gKi9cclxuUC50b0RlY2ltYWxQbGFjZXMgPSBQLnRvRFAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIHggPSBuZXcgQ3Rvcih4KTtcclxuICBpZiAoZHAgPT09IHZvaWQgMCkgcmV0dXJuIHg7XHJcblxyXG4gIGNoZWNrSW50MzIoZHAsIDAsIE1BWF9ESUdJVFMpO1xyXG5cclxuICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gIGVsc2UgY2hlY2tJbnQzMihybSwgMCwgOCk7XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZSh4LCBkcCArIHguZSArIDEsIHJtKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gcm91bmRlZCB0b1xyXG4gKiBgZHBgIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gKlxyXG4gKi9cclxuUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gIHZhciBzdHIsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICBpZiAoZHAgPT09IHZvaWQgMCkge1xyXG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgdHJ1ZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNoZWNrSW50MzIoZHAsIDAsIE1BWF9ESUdJVFMpO1xyXG5cclxuICAgIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG5cclxuICAgIHggPSBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgZHAgKyAxLCBybSk7XHJcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB0cnVlLCBkcCArIDEpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/ICctJyArIHN0ciA6IHN0cjtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaW4gbm9ybWFsIChmaXhlZC1wb2ludCkgbm90YXRpb24gdG9cclxuICogYGRwYCBmaXhlZCBkZWNpbWFsIHBsYWNlcyBhbmQgcm91bmRlZCB1c2luZyByb3VuZGluZyBtb2RlIGBybWAgb3IgYHJvdW5kaW5nYCBpZiBgcm1gIGlzXHJcbiAqIG9taXR0ZWQuXHJcbiAqXHJcbiAqIEFzIHdpdGggSmF2YVNjcmlwdCBudW1iZXJzLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLCBidXQgZS5nLiAoLTAuMDAwMDEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICpcclxuICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gKlxyXG4gKiAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLCBidXQgKC0wLjEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICogKC0wKS50b0ZpeGVkKDEpIGlzICcwLjAnLCBidXQgKC0wLjAxKS50b0ZpeGVkKDEpIGlzICctMC4wJy5cclxuICogKC0wKS50b0ZpeGVkKDMpIGlzICcwLjAwMCcuXHJcbiAqICgtMC41KS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAqXHJcbiAqL1xyXG5QLnRvRml4ZWQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgdmFyIHN0ciwgeSxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmIChkcCA9PT0gdm9pZCAwKSB7XHJcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4KTtcclxuICB9IGVsc2Uge1xyXG4gICAgY2hlY2tJbnQzMihkcCwgMCwgTUFYX0RJR0lUUyk7XHJcblxyXG4gICAgaWYgKHJtID09PSB2b2lkIDApIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIGVsc2UgY2hlY2tJbnQzMihybSwgMCwgOCk7XHJcblxyXG4gICAgeSA9IGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBkcCArIHguZSArIDEsIHJtKTtcclxuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHksIGZhbHNlLCBkcCArIHkuZSArIDEpO1xyXG4gIH1cclxuXHJcbiAgLy8gVG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gYWRkIHRoZSBtaW51cyBzaWduIGxvb2sgYXQgdGhlIHZhbHVlIGJlZm9yZSBpdCB3YXMgcm91bmRlZCxcclxuICAvLyBpLmUuIGxvb2sgYXQgYHhgIHJhdGhlciB0aGFuIGB5YC5cclxuICByZXR1cm4geC5pc05lZygpICYmICF4LmlzWmVybygpID8gJy0nICsgc3RyIDogc3RyO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBhcyBhIHNpbXBsZSBmcmFjdGlvbiB3aXRoIGFuIGludGVnZXJcclxuICogbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLlxyXG4gKlxyXG4gKiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkIG1heGltdW1cclxuICogZGVub21pbmF0b3IuIElmIGEgbWF4aW11bSBkZW5vbWluYXRvciBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgZGVub21pbmF0b3Igd2lsbCBiZSB0aGUgbG93ZXN0XHJcbiAqIHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gKlxyXG4gKiBbbWF4RF0ge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gTWF4aW11bSBkZW5vbWluYXRvci4gSW50ZWdlciA+PSAxIGFuZCA8IEluZmluaXR5LlxyXG4gKlxyXG4gKi9cclxuUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1heEQpIHtcclxuICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgaywgbiwgbjAsIG4xLCBwciwgcSwgcixcclxuICAgIHggPSB0aGlzLFxyXG4gICAgeGQgPSB4LmQsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKCF4ZCkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICBuMSA9IGQwID0gbmV3IEN0b3IoMSk7XHJcbiAgZDEgPSBuMCA9IG5ldyBDdG9yKDApO1xyXG5cclxuICBkID0gbmV3IEN0b3IoZDEpO1xyXG4gIGUgPSBkLmUgPSBnZXRQcmVjaXNpb24oeGQpIC0geC5lIC0gMTtcclxuICBrID0gZSAlIExPR19CQVNFO1xyXG4gIGQuZFswXSA9IG1hdGhwb3coMTAsIGsgPCAwID8gTE9HX0JBU0UgKyBrIDogayk7XHJcblxyXG4gIGlmIChtYXhEID09IG51bGwpIHtcclxuXHJcbiAgICAvLyBkIGlzIDEwKiplLCB0aGUgbWluaW11bSBtYXgtZGVub21pbmF0b3IgbmVlZGVkLlxyXG4gICAgbWF4RCA9IGUgPiAwID8gZCA6IG4xO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBuID0gbmV3IEN0b3IobWF4RCk7XHJcbiAgICBpZiAoIW4uaXNJbnQoKSB8fCBuLmx0KG4xKSkgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgbik7XHJcbiAgICBtYXhEID0gbi5ndChkKSA/IChlID4gMCA/IGQgOiBuMSkgOiBuO1xyXG4gIH1cclxuXHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICBuID0gbmV3IEN0b3IoZGlnaXRzVG9TdHJpbmcoeGQpKTtcclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIEN0b3IucHJlY2lzaW9uID0gZSA9IHhkLmxlbmd0aCAqIExPR19CQVNFICogMjtcclxuXHJcbiAgZm9yICg7OykgIHtcclxuICAgIHEgPSBkaXZpZGUobiwgZCwgMCwgMSwgMSk7XHJcbiAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xyXG4gICAgaWYgKGQyLmNtcChtYXhEKSA9PSAxKSBicmVhaztcclxuICAgIGQwID0gZDE7XHJcbiAgICBkMSA9IGQyO1xyXG4gICAgZDIgPSBuMTtcclxuICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyKSk7XHJcbiAgICBuMCA9IGQyO1xyXG4gICAgZDIgPSBkO1xyXG4gICAgZCA9IG4ubWludXMocS50aW1lcyhkMikpO1xyXG4gICAgbiA9IGQyO1xyXG4gIH1cclxuXHJcbiAgZDIgPSBkaXZpZGUobWF4RC5taW51cyhkMCksIGQxLCAwLCAxLCAxKTtcclxuICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcclxuICBkMCA9IGQwLnBsdXMoZDIudGltZXMoZDEpKTtcclxuICBuMC5zID0gbjEucyA9IHgucztcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMT9cclxuICByID0gZGl2aWRlKG4xLCBkMSwgZSwgMSkubWludXMoeCkuYWJzKCkuY21wKGRpdmlkZShuMCwgZDAsIGUsIDEpLm1pbnVzKHgpLmFicygpKSA8IDFcclxuICAgICAgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGluIGJhc2UgMTYsIHJvdW5kIHRvIGBzZGAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYC5cclxuICpcclxuICogSWYgdGhlIG9wdGlvbmFsIGBzZGAgYXJndW1lbnQgaXMgcHJlc2VudCB0aGVuIHJldHVybiBiaW5hcnkgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAqXHJcbiAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqL1xyXG5QLnRvSGV4YWRlY2ltYWwgPSBQLnRvSGV4ID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCAxNiwgc2QsIHJtKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm5zIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5lYXJlc3QgbXVsdGlwbGUgb2YgYHlgIGluIHRoZSBkaXJlY3Rpb24gb2Ygcm91bmRpbmdcclxuICogbW9kZSBgcm1gLCBvciBgRGVjaW1hbC5yb3VuZGluZ2AgaWYgYHJtYCBpcyBvbWl0dGVkLCB0byB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYWx3YXlzIGhhdmUgdGhlIHNhbWUgc2lnbiBhcyB0aGlzIERlY2ltYWwsIHVubGVzcyBlaXRoZXIgdGhpcyBEZWNpbWFsXHJcbiAqIG9yIGB5YCBpcyBOYU4sIGluIHdoaWNoIGNhc2UgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIGFsc28gYmUgTmFOLlxyXG4gKlxyXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdmFsdWUgb2YgYHByZWNpc2lvbmAuXHJcbiAqXHJcbiAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIG1hZ25pdHVkZSB0byByb3VuZCB0byBhIG11bHRpcGxlIG9mLlxyXG4gKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqICd0b05lYXJlc3QoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xyXG4gKiAndG9OZWFyZXN0KCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXHJcbiAqXHJcbiAqL1xyXG5QLnRvTmVhcmVzdCA9IGZ1bmN0aW9uICh5LCBybSkge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICB4ID0gbmV3IEN0b3IoeCk7XHJcblxyXG4gIGlmICh5ID09IG51bGwpIHtcclxuXHJcbiAgICAvLyBJZiB4IGlzIG5vdCBmaW5pdGUsIHJldHVybiB4LlxyXG4gICAgaWYgKCF4LmQpIHJldHVybiB4O1xyXG5cclxuICAgIHkgPSBuZXcgQ3RvcigxKTtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICB9IGVsc2Uge1xyXG4gICAgeSA9IG5ldyBDdG9yKHkpO1xyXG4gICAgaWYgKHJtID09PSB2b2lkIDApIHtcclxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2hlY2tJbnQzMihybSwgMCwgOCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgeCBpcyBub3QgZmluaXRlLCByZXR1cm4geCBpZiB5IGlzIG5vdCBOYU4sIGVsc2UgTmFOLlxyXG4gICAgaWYgKCF4LmQpIHJldHVybiB5LnMgPyB4IDogeTtcclxuXHJcbiAgICAvLyBJZiB5IGlzIG5vdCBmaW5pdGUsIHJldHVybiBJbmZpbml0eSB3aXRoIHRoZSBzaWduIG9mIHggaWYgeSBpcyBJbmZpbml0eSwgZWxzZSBOYU4uXHJcbiAgICBpZiAoIXkuZCkge1xyXG4gICAgICBpZiAoeS5zKSB5LnMgPSB4LnM7XHJcbiAgICAgIHJldHVybiB5O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSWYgeSBpcyBub3QgemVybywgY2FsY3VsYXRlIHRoZSBuZWFyZXN0IG11bHRpcGxlIG9mIHkgdG8geC5cclxuICBpZiAoeS5kWzBdKSB7XHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gICAgeCA9IGRpdmlkZSh4LCB5LCAwLCBybSwgMSkudGltZXMoeSk7XHJcbiAgICBleHRlcm5hbCA9IHRydWU7XHJcbiAgICBmaW5hbGlzZSh4KTtcclxuXHJcbiAgLy8gSWYgeSBpcyB6ZXJvLCByZXR1cm4gemVybyB3aXRoIHRoZSBzaWduIG9mIHguXHJcbiAgfSBlbHNlIHtcclxuICAgIHkucyA9IHgucztcclxuICAgIHggPSB5O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHg7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICogWmVybyBrZWVwcyBpdHMgc2lnbi5cclxuICpcclxuICovXHJcblAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuICt0aGlzO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpbiBiYXNlIDgsIHJvdW5kIHRvIGBzZGAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYC5cclxuICpcclxuICogSWYgdGhlIG9wdGlvbmFsIGBzZGAgYXJndW1lbnQgaXMgcHJlc2VudCB0aGVuIHJldHVybiBiaW5hcnkgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAqXHJcbiAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqL1xyXG5QLnRvT2N0YWwgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgcmV0dXJuIHRvU3RyaW5nQmluYXJ5KHRoaXMsIDgsIHNkLCBybSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByYWlzZWQgdG8gdGhlIHBvd2VyIGB5YCwgcm91bmRlZFxyXG4gKiB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiBFQ01BU2NyaXB0IGNvbXBsaWFudC5cclxuICpcclxuICogICBwb3coeCwgTmFOKSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTmFOXHJcbiAqICAgcG93KHgsIMKxMCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAxXHJcblxyXG4gKiAgIHBvdyhOYU4sIG5vbi16ZXJvKSAgICAgICAgICAgICAgICAgICAgPSBOYU5cclxuICogICBwb3coYWJzKHgpID4gMSwgK0luZmluaXR5KSAgICAgICAgICAgID0gK0luZmluaXR5XHJcbiAqICAgcG93KGFicyh4KSA+IDEsIC1JbmZpbml0eSkgICAgICAgICAgICA9ICswXHJcbiAqICAgcG93KGFicyh4KSA9PSAxLCDCsUluZmluaXR5KSAgICAgICAgICAgPSBOYU5cclxuICogICBwb3coYWJzKHgpIDwgMSwgK0luZmluaXR5KSAgICAgICAgICAgID0gKzBcclxuICogICBwb3coYWJzKHgpIDwgMSwgLUluZmluaXR5KSAgICAgICAgICAgID0gK0luZmluaXR5XHJcbiAqICAgcG93KCtJbmZpbml0eSwgeSA+IDApICAgICAgICAgICAgICAgICA9ICtJbmZpbml0eVxyXG4gKiAgIHBvdygrSW5maW5pdHksIHkgPCAwKSAgICAgICAgICAgICAgICAgPSArMFxyXG4gKiAgIHBvdygtSW5maW5pdHksIG9kZCBpbnRlZ2VyID4gMCkgICAgICAgPSAtSW5maW5pdHlcclxuICogICBwb3coLUluZmluaXR5LCBldmVuIGludGVnZXIgPiAwKSAgICAgID0gK0luZmluaXR5XHJcbiAqICAgcG93KC1JbmZpbml0eSwgb2RkIGludGVnZXIgPCAwKSAgICAgICA9IC0wXHJcbiAqICAgcG93KC1JbmZpbml0eSwgZXZlbiBpbnRlZ2VyIDwgMCkgICAgICA9ICswXHJcbiAqICAgcG93KCswLCB5ID4gMCkgICAgICAgICAgICAgICAgICAgICAgICA9ICswXHJcbiAqICAgcG93KCswLCB5IDwgMCkgICAgICAgICAgICAgICAgICAgICAgICA9ICtJbmZpbml0eVxyXG4gKiAgIHBvdygtMCwgb2RkIGludGVnZXIgPiAwKSAgICAgICAgICAgICAgPSAtMFxyXG4gKiAgIHBvdygtMCwgZXZlbiBpbnRlZ2VyID4gMCkgICAgICAgICAgICAgPSArMFxyXG4gKiAgIHBvdygtMCwgb2RkIGludGVnZXIgPCAwKSAgICAgICAgICAgICAgPSAtSW5maW5pdHlcclxuICogICBwb3coLTAsIGV2ZW4gaW50ZWdlciA8IDApICAgICAgICAgICAgID0gK0luZmluaXR5XHJcbiAqICAgcG93KGZpbml0ZSB4IDwgMCwgZmluaXRlIG5vbi1pbnRlZ2VyKSA9IE5hTlxyXG4gKlxyXG4gKiBGb3Igbm9uLWludGVnZXIgb3IgdmVyeSBsYXJnZSBleHBvbmVudHMgcG93KHgsIHkpIGlzIGNhbGN1bGF0ZWQgdXNpbmdcclxuICpcclxuICogICB4XnkgPSBleHAoeSpsbih4KSlcclxuICpcclxuICogQXNzdW1pbmcgdGhlIGZpcnN0IDE1IHJvdW5kaW5nIGRpZ2l0cyBhcmUgZWFjaCBlcXVhbGx5IGxpa2VseSB0byBiZSBhbnkgZGlnaXQgMC05LCB0aGVcclxuICogcHJvYmFiaWxpdHkgb2YgYW4gaW5jb3JyZWN0bHkgcm91bmRlZCByZXN1bHRcclxuICogUChbNDldOXsxNH0gfCBbNTBdMHsxNH0pID0gMiAqIDAuMiAqIDEwXi0xNCA9IDRlLTE1ID0gMS8yLjVlKzE0XHJcbiAqIGkuZS4gMSBpbiAyNTAsMDAwLDAwMCwwMDAsMDAwXHJcbiAqXHJcbiAqIElmIGEgcmVzdWx0IGlzIGluY29ycmVjdGx5IHJvdW5kZWQgdGhlIG1heGltdW0gZXJyb3Igd2lsbCBiZSAxIHVscCAodW5pdCBpbiBsYXN0IHBsYWNlKS5cclxuICpcclxuICogeSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgcG93ZXIgdG8gd2hpY2ggdG8gcmFpc2UgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKi9cclxuUC50b1Bvd2VyID0gUC5wb3cgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBlLCBrLCBwciwgciwgcm0sIHMsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgeW4gPSArKHkgPSBuZXcgQ3Rvcih5KSk7XHJcblxyXG4gIC8vIEVpdGhlciDCsUluZmluaXR5LCBOYU4gb3IgwrEwP1xyXG4gIGlmICgheC5kIHx8ICF5LmQgfHwgIXguZFswXSB8fCAheS5kWzBdKSByZXR1cm4gbmV3IEN0b3IobWF0aHBvdygreCwgeW4pKTtcclxuXHJcbiAgeCA9IG5ldyBDdG9yKHgpO1xyXG5cclxuICBpZiAoeC5lcSgxKSkgcmV0dXJuIHg7XHJcblxyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICBpZiAoeS5lcSgxKSkgcmV0dXJuIGZpbmFsaXNlKHgsIHByLCBybSk7XHJcblxyXG4gIC8vIHkgZXhwb25lbnRcclxuICBlID0gbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuXHJcbiAgLy8gSWYgeSBpcyBhIHNtYWxsIGludGVnZXIgdXNlIHRoZSAnZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcnIGFsZ29yaXRobS5cclxuICBpZiAoZSA+PSB5LmQubGVuZ3RoIC0gMSAmJiAoayA9IHluIDwgMCA/IC15biA6IHluKSA8PSBNQVhfU0FGRV9JTlRFR0VSKSB7XHJcbiAgICByID0gaW50UG93KEN0b3IsIHgsIGssIHByKTtcclxuICAgIHJldHVybiB5LnMgPCAwID8gbmV3IEN0b3IoMSkuZGl2KHIpIDogZmluYWxpc2UociwgcHIsIHJtKTtcclxuICB9XHJcblxyXG4gIHMgPSB4LnM7XHJcblxyXG4gIC8vIGlmIHggaXMgbmVnYXRpdmVcclxuICBpZiAocyA8IDApIHtcclxuXHJcbiAgICAvLyBpZiB5IGlzIG5vdCBhbiBpbnRlZ2VyXHJcbiAgICBpZiAoZSA8IHkuZC5sZW5ndGggLSAxKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuXHJcbiAgICAvLyBSZXN1bHQgaXMgcG9zaXRpdmUgaWYgeCBpcyBuZWdhdGl2ZSBhbmQgdGhlIGxhc3QgZGlnaXQgb2YgaW50ZWdlciB5IGlzIGV2ZW4uXHJcbiAgICBpZiAoKHkuZFtlXSAmIDEpID09IDApIHMgPSAxO1xyXG5cclxuICAgIC8vIGlmIHguZXEoLTEpXHJcbiAgICBpZiAoeC5lID09IDAgJiYgeC5kWzBdID09IDEgJiYgeC5kLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgIHgucyA9IHM7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRXN0aW1hdGUgcmVzdWx0IGV4cG9uZW50LlxyXG4gIC8vIHheeSA9IDEwXmUsICB3aGVyZSBlID0geSAqIGxvZzEwKHgpXHJcbiAgLy8gbG9nMTAoeCkgPSBsb2cxMCh4X3NpZ25pZmljYW5kKSArIHhfZXhwb25lbnRcclxuICAvLyBsb2cxMCh4X3NpZ25pZmljYW5kKSA9IGxuKHhfc2lnbmlmaWNhbmQpIC8gbG4oMTApXHJcbiAgayA9IG1hdGhwb3coK3gsIHluKTtcclxuICBlID0gayA9PSAwIHx8ICFpc0Zpbml0ZShrKVxyXG4gICAgPyBtYXRoZmxvb3IoeW4gKiAoTWF0aC5sb2coJzAuJyArIGRpZ2l0c1RvU3RyaW5nKHguZCkpIC8gTWF0aC5MTjEwICsgeC5lICsgMSkpXHJcbiAgICA6IG5ldyBDdG9yKGsgKyAnJykuZTtcclxuXHJcbiAgLy8gRXhwb25lbnQgZXN0aW1hdGUgbWF5IGJlIGluY29ycmVjdCBlLmcuIHg6IDAuOTk5OTk5OTk5OTk5OTk5OTk5LCB5OiAyLjI5LCBlOiAwLCByLmU6IC0xLlxyXG5cclxuICAvLyBPdmVyZmxvdy91bmRlcmZsb3c/XHJcbiAgaWYgKGUgPiBDdG9yLm1heEUgKyAxIHx8IGUgPCBDdG9yLm1pbkUgLSAxKSByZXR1cm4gbmV3IEN0b3IoZSA+IDAgPyBzIC8gMCA6IDApO1xyXG5cclxuICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gIEN0b3Iucm91bmRpbmcgPSB4LnMgPSAxO1xyXG5cclxuICAvLyBFc3RpbWF0ZSB0aGUgZXh0cmEgZ3VhcmQgZGlnaXRzIG5lZWRlZCB0byBlbnN1cmUgZml2ZSBjb3JyZWN0IHJvdW5kaW5nIGRpZ2l0cyBmcm9tXHJcbiAgLy8gbmF0dXJhbExvZ2FyaXRobSh4KS4gRXhhbXBsZSBvZiBmYWlsdXJlIHdpdGhvdXQgdGhlc2UgZXh0cmEgZGlnaXRzIChwcmVjaXNpb246IDEwKTpcclxuICAvLyBuZXcgRGVjaW1hbCgyLjMyNDU2KS5wb3coJzIwODc5ODc0MzY1MzQ1NjYuNDY0MTEnKVxyXG4gIC8vIHNob3VsZCBiZSAxLjE2MjM3NzgyM2UrNzY0OTE0OTA1MTczODE1LCBidXQgaXMgMS4xNjIzNTU4MjNlKzc2NDkxNDkwNTE3MzgxNVxyXG4gIGsgPSBNYXRoLm1pbigxMiwgKGUgKyAnJykubGVuZ3RoKTtcclxuXHJcbiAgLy8gciA9IHheeSA9IGV4cCh5KmxuKHgpKVxyXG4gIHIgPSBuYXR1cmFsRXhwb25lbnRpYWwoeS50aW1lcyhuYXR1cmFsTG9nYXJpdGhtKHgsIHByICsgaykpLCBwcik7XHJcblxyXG4gIC8vIHIgbWF5IGJlIEluZmluaXR5LCBlLmcuICgwLjk5OTk5OTk5OTk5OTk5OTkpLnBvdygtMWUrNDApXHJcbiAgaWYgKHIuZCkge1xyXG5cclxuICAgIC8vIFRydW5jYXRlIHRvIHRoZSByZXF1aXJlZCBwcmVjaXNpb24gcGx1cyBmaXZlIHJvdW5kaW5nIGRpZ2l0cy5cclxuICAgIHIgPSBmaW5hbGlzZShyLCBwciArIDUsIDEpO1xyXG5cclxuICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdHMgYXJlIFs0OV05OTk5IG9yIFs1MF0wMDAwIGluY3JlYXNlIHRoZSBwcmVjaXNpb24gYnkgMTAgYW5kIHJlY2FsY3VsYXRlXHJcbiAgICAvLyB0aGUgcmVzdWx0LlxyXG4gICAgaWYgKGNoZWNrUm91bmRpbmdEaWdpdHMoci5kLCBwciwgcm0pKSB7XHJcbiAgICAgIGUgPSBwciArIDEwO1xyXG5cclxuICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGluY3JlYXNlZCBwcmVjaXNpb24gcGx1cyBmaXZlIHJvdW5kaW5nIGRpZ2l0cy5cclxuICAgICAgciA9IGZpbmFsaXNlKG5hdHVyYWxFeHBvbmVudGlhbCh5LnRpbWVzKG5hdHVyYWxMb2dhcml0aG0oeCwgZSArIGspKSwgZSksIGUgKyA1LCAxKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciAxNCBuaW5lcyBmcm9tIHRoZSAybmQgcm91bmRpbmcgZGlnaXQgKHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdCBtYXkgYmUgNCBvciA5KS5cclxuICAgICAgaWYgKCtkaWdpdHNUb1N0cmluZyhyLmQpLnNsaWNlKHByICsgMSwgcHIgKyAxNSkgKyAxID09IDFlMTQpIHtcclxuICAgICAgICByID0gZmluYWxpc2UociwgcHIgKyAxLCAwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgci5zID0gcztcclxuICBleHRlcm5hbCA9IHRydWU7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICByZXR1cm4gZmluYWxpc2UociwgcHIsIHJtKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcm91bmRlZCB0byBgc2RgIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gKiB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIFJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbiBpZiBgc2RgIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50XHJcbiAqIHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIG5vcm1hbCBub3RhdGlvbi5cclxuICpcclxuICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICpcclxuICovXHJcblAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgdmFyIHN0cixcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmIChzZCA9PT0gdm9pZCAwKSB7XHJcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB4LmUgPD0gQ3Rvci50b0V4cE5lZyB8fCB4LmUgPj0gQ3Rvci50b0V4cFBvcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xyXG5cclxuICAgIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG5cclxuICAgIHggPSBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgc2QsIHJtKTtcclxuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHNkIDw9IHguZSB8fCB4LmUgPD0gQ3Rvci50b0V4cE5lZywgc2QpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/ICctJyArIHN0ciA6IHN0cjtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGBzZGBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYCwgb3IgdG8gYHByZWNpc2lvbmAgYW5kIGByb3VuZGluZ2AgcmVzcGVjdGl2ZWx5IGlmXHJcbiAqIG9taXR0ZWQuXHJcbiAqXHJcbiAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqICd0b1NEKCkgZGlnaXRzIG91dCBvZiByYW5nZToge3NkfSdcclxuICogJ3RvU0QoKSBkaWdpdHMgbm90IGFuIGludGVnZXI6IHtzZH0nXHJcbiAqICd0b1NEKCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcclxuICogJ3RvU0QoKSByb3VuZGluZyBtb2RlIG91dCBvZiByYW5nZToge3JtfSdcclxuICpcclxuICovXHJcblAudG9TaWduaWZpY2FudERpZ2l0cyA9IFAudG9TRCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICB2YXIgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKHNkID09PSB2b2lkIDApIHtcclxuICAgIHNkID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xyXG5cclxuICAgIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBzZCwgcm0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogUmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoaXMgRGVjaW1hbCBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBncmVhdGVyIHRoYW5cclxuICogYHRvRXhwUG9zYCwgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW4gYHRvRXhwTmVnYC5cclxuICpcclxuICovXHJcblAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB4LmUgPD0gQ3Rvci50b0V4cE5lZyB8fCB4LmUgPj0gQ3Rvci50b0V4cFBvcyk7XHJcblxyXG4gIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyAnLScgKyBzdHIgOiBzdHI7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCB0cnVuY2F0ZWQgdG8gYSB3aG9sZSBudW1iZXIuXHJcbiAqXHJcbiAqL1xyXG5QLnRydW5jYXRlZCA9IFAudHJ1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCB0aGlzLmUgKyAxLCAxKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAqIFVubGlrZSBgdG9TdHJpbmdgLCBuZWdhdGl2ZSB6ZXJvIHdpbGwgaW5jbHVkZSB0aGUgbWludXMgc2lnbi5cclxuICpcclxuICovXHJcblAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgeC5lIDw9IEN0b3IudG9FeHBOZWcgfHwgeC5lID49IEN0b3IudG9FeHBQb3MpO1xyXG5cclxuICByZXR1cm4geC5pc05lZygpID8gJy0nICsgc3RyIDogc3RyO1xyXG59O1xyXG5cclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIERlY2ltYWwucHJvdG90eXBlIChQKSBhbmQvb3IgRGVjaW1hbCBtZXRob2RzLCBhbmQgdGhlaXIgY2FsbGVycy5cclxuXHJcblxyXG4vKlxyXG4gKiAgZGlnaXRzVG9TdHJpbmcgICAgICAgICAgIFAuY3ViZVJvb3QsIFAubG9nYXJpdGhtLCBQLnNxdWFyZVJvb3QsIFAudG9GcmFjdGlvbiwgUC50b1Bvd2VyLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbml0ZVRvU3RyaW5nLCBuYXR1cmFsRXhwb25lbnRpYWwsIG5hdHVyYWxMb2dhcml0aG1cclxuICogIGNoZWNrSW50MzIgICAgICAgICAgICAgICBQLnRvRGVjaW1hbFBsYWNlcywgUC50b0V4cG9uZW50aWFsLCBQLnRvRml4ZWQsIFAudG9OZWFyZXN0LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAudG9QcmVjaXNpb24sIFAudG9TaWduaWZpY2FudERpZ2l0cywgdG9TdHJpbmdCaW5hcnksIHJhbmRvbVxyXG4gKiAgY2hlY2tSb3VuZGluZ0RpZ2l0cyAgICAgIFAubG9nYXJpdGhtLCBQLnRvUG93ZXIsIG5hdHVyYWxFeHBvbmVudGlhbCwgbmF0dXJhbExvZ2FyaXRobVxyXG4gKiAgY29udmVydEJhc2UgICAgICAgICAgICAgIHRvU3RyaW5nQmluYXJ5LCBwYXJzZU90aGVyXHJcbiAqICBjb3MgICAgICAgICAgICAgICAgICAgICAgUC5jb3NcclxuICogIGRpdmlkZSAgICAgICAgICAgICAgICAgICBQLmF0YW5oLCBQLmN1YmVSb290LCBQLmRpdmlkZWRCeSwgUC5kaXZpZGVkVG9JbnRlZ2VyQnksXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5sb2dhcml0aG0sIFAubW9kdWxvLCBQLnNxdWFyZVJvb3QsIFAudGFuLCBQLnRhbmgsIFAudG9GcmFjdGlvbixcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBQLnRvTmVhcmVzdCwgdG9TdHJpbmdCaW5hcnksIG5hdHVyYWxFeHBvbmVudGlhbCwgbmF0dXJhbExvZ2FyaXRobSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0YXlsb3JTZXJpZXMsIGF0YW4yLCBwYXJzZU90aGVyXHJcbiAqICBmaW5hbGlzZSAgICAgICAgICAgICAgICAgUC5hYnNvbHV0ZVZhbHVlLCBQLmF0YW4sIFAuYXRhbmgsIFAuY2VpbCwgUC5jb3MsIFAuY29zaCxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBQLmN1YmVSb290LCBQLmRpdmlkZWRUb0ludGVnZXJCeSwgUC5mbG9vciwgUC5sb2dhcml0aG0sIFAubWludXMsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5tb2R1bG8sIFAubmVnYXRlZCwgUC5wbHVzLCBQLnJvdW5kLCBQLnNpbiwgUC5zaW5oLCBQLnNxdWFyZVJvb3QsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC50YW4sIFAudGltZXMsIFAudG9EZWNpbWFsUGxhY2VzLCBQLnRvRXhwb25lbnRpYWwsIFAudG9GaXhlZCxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBQLnRvTmVhcmVzdCwgUC50b1Bvd2VyLCBQLnRvUHJlY2lzaW9uLCBQLnRvU2lnbmlmaWNhbnREaWdpdHMsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC50cnVuY2F0ZWQsIGRpdmlkZSwgZ2V0TG4xMCwgZ2V0UGksIG5hdHVyYWxFeHBvbmVudGlhbCxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBuYXR1cmFsTG9nYXJpdGhtLCBjZWlsLCBmbG9vciwgcm91bmQsIHRydW5jXHJcbiAqICBmaW5pdGVUb1N0cmluZyAgICAgICAgICAgUC50b0V4cG9uZW50aWFsLCBQLnRvRml4ZWQsIFAudG9QcmVjaXNpb24sIFAudG9TdHJpbmcsIFAudmFsdWVPZixcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmluZ0JpbmFyeVxyXG4gKiAgZ2V0QmFzZTEwRXhwb25lbnQgICAgICAgIFAubWludXMsIFAucGx1cywgUC50aW1lcywgcGFyc2VPdGhlclxyXG4gKiAgZ2V0TG4xMCAgICAgICAgICAgICAgICAgIFAubG9nYXJpdGhtLCBuYXR1cmFsTG9nYXJpdGhtXHJcbiAqICBnZXRQaSAgICAgICAgICAgICAgICAgICAgUC5hY29zLCBQLmFzaW4sIFAuYXRhbiwgdG9MZXNzVGhhbkhhbGZQaSwgYXRhbjJcclxuICogIGdldFByZWNpc2lvbiAgICAgICAgICAgICBQLnByZWNpc2lvbiwgUC50b0ZyYWN0aW9uXHJcbiAqICBnZXRaZXJvU3RyaW5nICAgICAgICAgICAgZGlnaXRzVG9TdHJpbmcsIGZpbml0ZVRvU3RyaW5nXHJcbiAqICBpbnRQb3cgICAgICAgICAgICAgICAgICAgUC50b1Bvd2VyLCBwYXJzZU90aGVyXHJcbiAqICBpc09kZCAgICAgICAgICAgICAgICAgICAgdG9MZXNzVGhhbkhhbGZQaVxyXG4gKiAgbWF4T3JNaW4gICAgICAgICAgICAgICAgIG1heCwgbWluXHJcbiAqICBuYXR1cmFsRXhwb25lbnRpYWwgICAgICAgUC5uYXR1cmFsRXhwb25lbnRpYWwsIFAudG9Qb3dlclxyXG4gKiAgbmF0dXJhbExvZ2FyaXRobSAgICAgICAgIFAuYWNvc2gsIFAuYXNpbmgsIFAuYXRhbmgsIFAubG9nYXJpdGhtLCBQLm5hdHVyYWxMb2dhcml0aG0sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC50b1Bvd2VyLCBuYXR1cmFsRXhwb25lbnRpYWxcclxuICogIG5vbkZpbml0ZVRvU3RyaW5nICAgICAgICBmaW5pdGVUb1N0cmluZywgdG9TdHJpbmdCaW5hcnlcclxuICogIHBhcnNlRGVjaW1hbCAgICAgICAgICAgICBEZWNpbWFsXHJcbiAqICBwYXJzZU90aGVyICAgICAgICAgICAgICAgRGVjaW1hbFxyXG4gKiAgc2luICAgICAgICAgICAgICAgICAgICAgIFAuc2luXHJcbiAqICB0YXlsb3JTZXJpZXMgICAgICAgICAgICAgUC5jb3NoLCBQLnNpbmgsIGNvcywgc2luXHJcbiAqICB0b0xlc3NUaGFuSGFsZlBpICAgICAgICAgUC5jb3MsIFAuc2luXHJcbiAqICB0b1N0cmluZ0JpbmFyeSAgICAgICAgICAgUC50b0JpbmFyeSwgUC50b0hleGFkZWNpbWFsLCBQLnRvT2N0YWxcclxuICogIHRydW5jYXRlICAgICAgICAgICAgICAgICBpbnRQb3dcclxuICpcclxuICogIFRocm93czogICAgICAgICAgICAgICAgICBQLmxvZ2FyaXRobSwgUC5wcmVjaXNpb24sIFAudG9GcmFjdGlvbiwgY2hlY2tJbnQzMiwgZ2V0TG4xMCwgZ2V0UGksXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0dXJhbExvZ2FyaXRobSwgY29uZmlnLCBwYXJzZU90aGVyLCByYW5kb20sIERlY2ltYWxcclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gZGlnaXRzVG9TdHJpbmcoZCkge1xyXG4gIHZhciBpLCBrLCB3cyxcclxuICAgIGluZGV4T2ZMYXN0V29yZCA9IGQubGVuZ3RoIC0gMSxcclxuICAgIHN0ciA9ICcnLFxyXG4gICAgdyA9IGRbMF07XHJcblxyXG4gIGlmIChpbmRleE9mTGFzdFdvcmQgPiAwKSB7XHJcbiAgICBzdHIgKz0gdztcclxuICAgIGZvciAoaSA9IDE7IGkgPCBpbmRleE9mTGFzdFdvcmQ7IGkrKykge1xyXG4gICAgICB3cyA9IGRbaV0gKyAnJztcclxuICAgICAgayA9IExPR19CQVNFIC0gd3MubGVuZ3RoO1xyXG4gICAgICBpZiAoaykgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XHJcbiAgICAgIHN0ciArPSB3cztcclxuICAgIH1cclxuXHJcbiAgICB3ID0gZFtpXTtcclxuICAgIHdzID0gdyArICcnO1xyXG4gICAgayA9IExPR19CQVNFIC0gd3MubGVuZ3RoO1xyXG4gICAgaWYgKGspIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xyXG4gIH0gZWxzZSBpZiAodyA9PT0gMCkge1xyXG4gICAgcmV0dXJuICcwJztcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcyBvZiBsYXN0IHcuXHJcbiAgZm9yICg7IHcgJSAxMCA9PT0gMDspIHcgLz0gMTA7XHJcblxyXG4gIHJldHVybiBzdHIgKyB3O1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gY2hlY2tJbnQzMihpLCBtaW4sIG1heCkge1xyXG4gIGlmIChpICE9PSB+fmkgfHwgaSA8IG1pbiB8fCBpID4gbWF4KSB7XHJcbiAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBpKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBDaGVjayA1IHJvdW5kaW5nIGRpZ2l0cyBpZiBgcmVwZWF0aW5nYCBpcyBudWxsLCA0IG90aGVyd2lzZS5cclxuICogYHJlcGVhdGluZyA9PSBudWxsYCBpZiBjYWxsZXIgaXMgYGxvZ2Agb3IgYHBvd2AsXHJcbiAqIGByZXBlYXRpbmcgIT0gbnVsbGAgaWYgY2FsbGVyIGlzIGBuYXR1cmFsTG9nYXJpdGhtYCBvciBgbmF0dXJhbEV4cG9uZW50aWFsYC5cclxuICovXHJcbmZ1bmN0aW9uIGNoZWNrUm91bmRpbmdEaWdpdHMoZCwgaSwgcm0sIHJlcGVhdGluZykge1xyXG4gIHZhciBkaSwgaywgciwgcmQ7XHJcblxyXG4gIC8vIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBhcnJheSBkLlxyXG4gIGZvciAoayA9IGRbMF07IGsgPj0gMTA7IGsgLz0gMTApIC0taTtcclxuXHJcbiAgLy8gSXMgdGhlIHJvdW5kaW5nIGRpZ2l0IGluIHRoZSBmaXJzdCB3b3JkIG9mIGQ/XHJcbiAgaWYgKC0taSA8IDApIHtcclxuICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICBkaSA9IDA7XHJcbiAgfSBlbHNlIHtcclxuICAgIGRpID0gTWF0aC5jZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XHJcbiAgICBpICU9IExPR19CQVNFO1xyXG4gIH1cclxuXHJcbiAgLy8gaSBpcyB0aGUgaW5kZXggKDAgLSA2KSBvZiB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgLy8gRS5nLiBpZiB3aXRoaW4gdGhlIHdvcmQgMzQ4NzU2MyB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQgaXMgNSxcclxuICAvLyB0aGVuIGkgPSA0LCBrID0gMTAwMCwgcmQgPSAzNDg3NTYzICUgMTAwMCA9IDU2M1xyXG4gIGsgPSBtYXRocG93KDEwLCBMT0dfQkFTRSAtIGkpO1xyXG4gIHJkID0gZFtkaV0gJSBrIHwgMDtcclxuXHJcbiAgaWYgKHJlcGVhdGluZyA9PSBudWxsKSB7XHJcbiAgICBpZiAoaSA8IDMpIHtcclxuICAgICAgaWYgKGkgPT0gMCkgcmQgPSByZCAvIDEwMCB8IDA7XHJcbiAgICAgIGVsc2UgaWYgKGkgPT0gMSkgcmQgPSByZCAvIDEwIHwgMDtcclxuICAgICAgciA9IHJtIDwgNCAmJiByZCA9PSA5OTk5OSB8fCBybSA+IDMgJiYgcmQgPT0gNDk5OTkgfHwgcmQgPT0gNTAwMDAgfHwgcmQgPT0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHIgPSAocm0gPCA0ICYmIHJkICsgMSA9PSBrIHx8IHJtID4gMyAmJiByZCArIDEgPT0gayAvIDIpICYmXHJcbiAgICAgICAgKGRbZGkgKyAxXSAvIGsgLyAxMDAgfCAwKSA9PSBtYXRocG93KDEwLCBpIC0gMikgLSAxIHx8XHJcbiAgICAgICAgICAocmQgPT0gayAvIDIgfHwgcmQgPT0gMCkgJiYgKGRbZGkgKyAxXSAvIGsgLyAxMDAgfCAwKSA9PSAwO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoaSA8IDQpIHtcclxuICAgICAgaWYgKGkgPT0gMCkgcmQgPSByZCAvIDEwMDAgfCAwO1xyXG4gICAgICBlbHNlIGlmIChpID09IDEpIHJkID0gcmQgLyAxMDAgfCAwO1xyXG4gICAgICBlbHNlIGlmIChpID09IDIpIHJkID0gcmQgLyAxMCB8IDA7XHJcbiAgICAgIHIgPSAocmVwZWF0aW5nIHx8IHJtIDwgNCkgJiYgcmQgPT0gOTk5OSB8fCAhcmVwZWF0aW5nICYmIHJtID4gMyAmJiByZCA9PSA0OTk5O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgciA9ICgocmVwZWF0aW5nIHx8IHJtIDwgNCkgJiYgcmQgKyAxID09IGsgfHxcclxuICAgICAgKCFyZXBlYXRpbmcgJiYgcm0gPiAzKSAmJiByZCArIDEgPT0gayAvIDIpICYmXHJcbiAgICAgICAgKGRbZGkgKyAxXSAvIGsgLyAxMDAwIHwgMCkgPT0gbWF0aHBvdygxMCwgaSAtIDMpIC0gMTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiByO1xyXG59XHJcblxyXG5cclxuLy8gQ29udmVydCBzdHJpbmcgb2YgYGJhc2VJbmAgdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBgYmFzZU91dGAuXHJcbi8vIEVnLiBjb252ZXJ0QmFzZSgnMjU1JywgMTAsIDE2KSByZXR1cm5zIFsxNSwgMTVdLlxyXG4vLyBFZy4gY29udmVydEJhc2UoJ2ZmJywgMTYsIDEwKSByZXR1cm5zIFsyLCA1LCA1XS5cclxuZnVuY3Rpb24gY29udmVydEJhc2Uoc3RyLCBiYXNlSW4sIGJhc2VPdXQpIHtcclxuICB2YXIgaixcclxuICAgIGFyciA9IFswXSxcclxuICAgIGFyckwsXHJcbiAgICBpID0gMCxcclxuICAgIHN0ckwgPSBzdHIubGVuZ3RoO1xyXG5cclxuICBmb3IgKDsgaSA8IHN0ckw7KSB7XHJcbiAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07KSBhcnJbYXJyTF0gKj0gYmFzZUluO1xyXG4gICAgYXJyWzBdICs9IE5VTUVSQUxTLmluZGV4T2Yoc3RyLmNoYXJBdChpKyspKTtcclxuICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcclxuICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XHJcbiAgICAgICAgaWYgKGFycltqICsgMV0gPT09IHZvaWQgMCkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcclxuICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBjb3MoeCkgPSAxIC0geF4yLzIhICsgeF40LzQhIC0gLi4uXHJcbiAqIHx4fCA8IHBpLzJcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGNvc2luZShDdG9yLCB4KSB7XHJcbiAgdmFyIGssIGxlbiwgeTtcclxuXHJcbiAgaWYgKHguaXNaZXJvKCkpIHJldHVybiB4O1xyXG5cclxuICAvLyBBcmd1bWVudCByZWR1Y3Rpb246IGNvcyg0eCkgPSA4Kihjb3NeNCh4KSAtIGNvc14yKHgpKSArIDFcclxuICAvLyBpLmUuIGNvcyh4KSA9IDgqKGNvc140KHgvNCkgLSBjb3NeMih4LzQpKSArIDFcclxuXHJcbiAgLy8gRXN0aW1hdGUgdGhlIG9wdGltdW0gbnVtYmVyIG9mIHRpbWVzIHRvIHVzZSB0aGUgYXJndW1lbnQgcmVkdWN0aW9uLlxyXG4gIGxlbiA9IHguZC5sZW5ndGg7XHJcbiAgaWYgKGxlbiA8IDMyKSB7XHJcbiAgICBrID0gTWF0aC5jZWlsKGxlbiAvIDMpO1xyXG4gICAgeSA9ICgxIC8gdGlueVBvdyg0LCBrKSkudG9TdHJpbmcoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgayA9IDE2O1xyXG4gICAgeSA9ICcyLjMyODMwNjQzNjUzODY5NjI4OTA2MjVlLTEwJztcclxuICB9XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uICs9IGs7XHJcblxyXG4gIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMSwgeC50aW1lcyh5KSwgbmV3IEN0b3IoMSkpO1xyXG5cclxuICAvLyBSZXZlcnNlIGFyZ3VtZW50IHJlZHVjdGlvblxyXG4gIGZvciAodmFyIGkgPSBrOyBpLS07KSB7XHJcbiAgICB2YXIgY29zMnggPSB4LnRpbWVzKHgpO1xyXG4gICAgeCA9IGNvczJ4LnRpbWVzKGNvczJ4KS5taW51cyhjb3MyeCkudGltZXMoOCkucGx1cygxKTtcclxuICB9XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uIC09IGs7XHJcblxyXG4gIHJldHVybiB4O1xyXG59XHJcblxyXG5cclxuLypcclxuICogUGVyZm9ybSBkaXZpc2lvbiBpbiB0aGUgc3BlY2lmaWVkIGJhc2UuXHJcbiAqL1xyXG52YXIgZGl2aWRlID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgLy8gQXNzdW1lcyBub24temVybyB4IGFuZCBrLCBhbmQgaGVuY2Ugbm9uLXplcm8gcmVzdWx0LlxyXG4gIGZ1bmN0aW9uIG11bHRpcGx5SW50ZWdlcih4LCBrLCBiYXNlKSB7XHJcbiAgICB2YXIgdGVtcCxcclxuICAgICAgY2FycnkgPSAwLFxyXG4gICAgICBpID0geC5sZW5ndGg7XHJcblxyXG4gICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07KSB7XHJcbiAgICAgIHRlbXAgPSB4W2ldICogayArIGNhcnJ5O1xyXG4gICAgICB4W2ldID0gdGVtcCAlIGJhc2UgfCAwO1xyXG4gICAgICBjYXJyeSA9IHRlbXAgLyBiYXNlIHwgMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2FycnkpIHgudW5zaGlmdChjYXJyeSk7XHJcblxyXG4gICAgcmV0dXJuIHg7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xyXG4gICAgdmFyIGksIHI7XHJcblxyXG4gICAgaWYgKGFMICE9IGJMKSB7XHJcbiAgICAgIHIgPSBhTCA+IGJMID8gMSA6IC0xO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yIChpID0gciA9IDA7IGkgPCBhTDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xyXG4gICAgICAgICAgciA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHI7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBhTCwgYmFzZSkge1xyXG4gICAgdmFyIGkgPSAwO1xyXG5cclxuICAgIC8vIFN1YnRyYWN0IGIgZnJvbSBhLlxyXG4gICAgZm9yICg7IGFMLS07KSB7XHJcbiAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgIGkgPSBhW2FMXSA8IGJbYUxdID8gMSA6IDA7XHJcbiAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTspIGEuc2hpZnQoKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiAoeCwgeSwgcHIsIHJtLCBkcCwgYmFzZSkge1xyXG4gICAgdmFyIGNtcCwgZSwgaSwgaywgbG9nQmFzZSwgbW9yZSwgcHJvZCwgcHJvZEwsIHEsIHFkLCByZW0sIHJlbUwsIHJlbTAsIHNkLCB0LCB4aSwgeEwsIHlkMCxcclxuICAgICAgeUwsIHl6LFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgc2lnbiA9IHgucyA9PSB5LnMgPyAxIDogLTEsXHJcbiAgICAgIHhkID0geC5kLFxyXG4gICAgICB5ZCA9IHkuZDtcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgaWYgKCF4ZCB8fCAheGRbMF0gfHwgIXlkIHx8ICF5ZFswXSkge1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBDdG9yKC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGQgPyB5ZCAmJiB4ZFswXSA9PSB5ZFswXSA6ICF5ZCkgPyBOYU4gOlxyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIHggaXMgMCBvciB5IGlzIMKxSW5maW5pdHksIG9yIHJldHVybiDCsUluZmluaXR5IGFzIHkgaXMgMC5cclxuICAgICAgICB4ZCAmJiB4ZFswXSA9PSAwIHx8ICF5ZCA/IHNpZ24gKiAwIDogc2lnbiAvIDApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChiYXNlKSB7XHJcbiAgICAgIGxvZ0Jhc2UgPSAxO1xyXG4gICAgICBlID0geC5lIC0geS5lO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgIGxvZ0Jhc2UgPSBMT0dfQkFTRTtcclxuICAgICAgZSA9IG1hdGhmbG9vcih4LmUgLyBsb2dCYXNlKSAtIG1hdGhmbG9vcih5LmUgLyBsb2dCYXNlKTtcclxuICAgIH1cclxuXHJcbiAgICB5TCA9IHlkLmxlbmd0aDtcclxuICAgIHhMID0geGQubGVuZ3RoO1xyXG4gICAgcSA9IG5ldyBDdG9yKHNpZ24pO1xyXG4gICAgcWQgPSBxLmQgPSBbXTtcclxuXHJcbiAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoYW4gZS5cclxuICAgIC8vIFRoZSBkaWdpdCBhcnJheSBvZiBhIERlY2ltYWwgZnJvbSB0b1N0cmluZ0JpbmFyeSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoaSA9IDA7IHlkW2ldID09ICh4ZFtpXSB8fCAwKTsgaSsrKTtcclxuXHJcbiAgICBpZiAoeWRbaV0gPiAoeGRbaV0gfHwgMCkpIGUtLTtcclxuXHJcbiAgICBpZiAocHIgPT0gbnVsbCkge1xyXG4gICAgICBzZCA9IHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIH0gZWxzZSBpZiAoZHApIHtcclxuICAgICAgc2QgPSBwciArICh4LmUgLSB5LmUpICsgMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNkID0gcHI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNkIDwgMCkge1xyXG4gICAgICBxZC5wdXNoKDEpO1xyXG4gICAgICBtb3JlID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IHByZWNpc2lvbiBpbiBudW1iZXIgb2YgYmFzZSAxMCBkaWdpdHMgdG8gYmFzZSAxZTcgZGlnaXRzLlxyXG4gICAgICBzZCA9IHNkIC8gbG9nQmFzZSArIDIgfCAwO1xyXG4gICAgICBpID0gMDtcclxuXHJcbiAgICAgIC8vIGRpdmlzb3IgPCAxZTdcclxuICAgICAgaWYgKHlMID09IDEpIHtcclxuICAgICAgICBrID0gMDtcclxuICAgICAgICB5ZCA9IHlkWzBdO1xyXG4gICAgICAgIHNkKys7XHJcblxyXG4gICAgICAgIC8vIGsgaXMgdGhlIGNhcnJ5LlxyXG4gICAgICAgIGZvciAoOyAoaSA8IHhMIHx8IGspICYmIHNkLS07IGkrKykge1xyXG4gICAgICAgICAgdCA9IGsgKiBiYXNlICsgKHhkW2ldIHx8IDApO1xyXG4gICAgICAgICAgcWRbaV0gPSB0IC8geWQgfCAwO1xyXG4gICAgICAgICAgayA9IHQgJSB5ZCB8IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtb3JlID0gayB8fCBpIDwgeEw7XHJcblxyXG4gICAgICAvLyBkaXZpc29yID49IDFlN1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBOb3JtYWxpc2UgeGQgYW5kIHlkIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWQgaXMgPj0gYmFzZS8yXHJcbiAgICAgICAgayA9IGJhc2UgLyAoeWRbMF0gKyAxKSB8IDA7XHJcblxyXG4gICAgICAgIGlmIChrID4gMSkge1xyXG4gICAgICAgICAgeWQgPSBtdWx0aXBseUludGVnZXIoeWQsIGssIGJhc2UpO1xyXG4gICAgICAgICAgeGQgPSBtdWx0aXBseUludGVnZXIoeGQsIGssIGJhc2UpO1xyXG4gICAgICAgICAgeUwgPSB5ZC5sZW5ndGg7XHJcbiAgICAgICAgICB4TCA9IHhkLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHhpID0geUw7XHJcbiAgICAgICAgcmVtID0geGQuc2xpY2UoMCwgeUwpO1xyXG4gICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gICAgICAgIGZvciAoOyByZW1MIDwgeUw7KSByZW1bcmVtTCsrXSA9IDA7XHJcblxyXG4gICAgICAgIHl6ID0geWQuc2xpY2UoKTtcclxuICAgICAgICB5ei51bnNoaWZ0KDApO1xyXG4gICAgICAgIHlkMCA9IHlkWzBdO1xyXG5cclxuICAgICAgICBpZiAoeWRbMV0gPj0gYmFzZSAvIDIpICsreWQwO1xyXG5cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICBrID0gMDtcclxuXHJcbiAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgIGNtcCA9IGNvbXBhcmUoeWQsIHJlbSwgeUwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBrLlxyXG4gICAgICAgICAgICByZW0wID0gcmVtWzBdO1xyXG4gICAgICAgICAgICBpZiAoeUwgIT0gcmVtTCkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGsgd2lsbCBiZSBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBrID0gcmVtMCAvIHlkMCB8IDA7XHJcblxyXG4gICAgICAgICAgICAvLyAgQWxnb3JpdGhtOlxyXG4gICAgICAgICAgICAvLyAgMS4gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdCAoaylcclxuICAgICAgICAgICAgLy8gIDIuIGlmIHByb2R1Y3QgPiByZW1haW5kZXI6IHByb2R1Y3QgLT0gZGl2aXNvciwgay0tXHJcbiAgICAgICAgICAgIC8vICAzLiByZW1haW5kZXIgLT0gcHJvZHVjdFxyXG4gICAgICAgICAgICAvLyAgNC4gaWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIgYXQgMjpcclxuICAgICAgICAgICAgLy8gICAgNS4gY29tcGFyZSBuZXcgcmVtYWluZGVyIGFuZCBkaXZpc29yXHJcbiAgICAgICAgICAgIC8vICAgIDYuIElmIHJlbWFpbmRlciA+IGRpdmlzb3I6IHJlbWFpbmRlciAtPSBkaXZpc29yLCBrKytcclxuXHJcbiAgICAgICAgICAgIGlmIChrID4gMSkge1xyXG4gICAgICAgICAgICAgIGlmIChrID49IGJhc2UpIGsgPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHlJbnRlZ2VyKHlkLCBrLCBiYXNlKTtcclxuICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAvLyBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBjbXAgPSBjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBwcm9kdWN0ID4gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIGlmIChjbXAgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgay0tO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWQsIHByb2RMLCBiYXNlKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAvLyBJZiBrIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5ZCBhbmQgcmVtIGFnYWluIGJlbG93LCBzbyBjaGFuZ2UgY21wIHRvIDFcclxuICAgICAgICAgICAgICAvLyB0byBhdm9pZCBpdC4gSWYgayBpcyAxIHRoZXJlIGlzIGEgbmVlZCB0byBjb21wYXJlIHlkIGFuZCByZW0gYWdhaW4gYmVsb3cuXHJcbiAgICAgICAgICAgICAgaWYgKGsgPT0gMCkgY21wID0gayA9IDE7XHJcbiAgICAgICAgICAgICAgcHJvZCA9IHlkLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpIHByb2QudW5zaGlmdCgwKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgcHJvZCwgcmVtTCwgYmFzZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBwcm9kdWN0IHdhcyA8IHByZXZpb3VzIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xyXG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIG5ldyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgY21wID0gY29tcGFyZSh5ZCwgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIGlmIChjbXAgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICBrKys7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5ZCwgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIGsrKztcclxuICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgfSAgICAvLyBpZiBjbXAgPT09IDEsIGsgd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgLy8gQWRkIHRoZSBuZXh0IGRpZ2l0LCBrLCB0byB0aGUgcmVzdWx0IGFycmF5LlxyXG4gICAgICAgICAgcWRbaSsrXSA9IGs7XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICBpZiAoY21wICYmIHJlbVswXSkge1xyXG4gICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhkW3hpXSB8fCAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVtID0gW3hkW3hpXV07XHJcbiAgICAgICAgICAgIHJlbUwgPSAxO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPT0gdm9pZCAwKSAmJiBzZC0tKTtcclxuXHJcbiAgICAgICAgbW9yZSA9IHJlbVswXSAhPT0gdm9pZCAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBMZWFkaW5nIHplcm8/XHJcbiAgICAgIGlmICghcWRbMF0pIHFkLnNoaWZ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbG9nQmFzZSBpcyAxIHdoZW4gZGl2aWRlIGlzIGJlaW5nIHVzZWQgZm9yIGJhc2UgY29udmVyc2lvbi5cclxuICAgIGlmIChsb2dCYXNlID09IDEpIHtcclxuICAgICAgcS5lID0gZTtcclxuICAgICAgaW5leGFjdCA9IG1vcmU7XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFkWzBdLlxyXG4gICAgICBmb3IgKGkgPSAxLCBrID0gcWRbMF07IGsgPj0gMTA7IGsgLz0gMTApIGkrKztcclxuICAgICAgcS5lID0gaSArIGUgKiBsb2dCYXNlIC0gMTtcclxuXHJcbiAgICAgIGZpbmFsaXNlKHEsIGRwID8gcHIgKyBxLmUgKyAxIDogcHIsIHJtLCBtb3JlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcTtcclxuICB9O1xyXG59KSgpO1xyXG5cclxuXHJcbi8qXHJcbiAqIFJvdW5kIGB4YCB0byBgc2RgIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGBybWAuXHJcbiAqIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAqL1xyXG4gZnVuY3Rpb24gZmluYWxpc2UoeCwgc2QsIHJtLCBpc1RydW5jYXRlZCkge1xyXG4gIHZhciBkaWdpdHMsIGksIGosIGssIHJkLCByb3VuZFVwLCB3LCB4ZCwgeGRpLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIC8vIERvbid0IHJvdW5kIGlmIHNkIGlzIG51bGwgb3IgdW5kZWZpbmVkLlxyXG4gIG91dDogaWYgKHNkICE9IG51bGwpIHtcclxuICAgIHhkID0geC5kO1xyXG5cclxuICAgIC8vIEluZmluaXR5L05hTi5cclxuICAgIGlmICgheGQpIHJldHVybiB4O1xyXG5cclxuICAgIC8vIHJkOiB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgLy8gdzogdGhlIHdvcmQgb2YgeGQgY29udGFpbmluZyByZCwgYSBiYXNlIDFlNyBudW1iZXIuXHJcbiAgICAvLyB4ZGk6IHRoZSBpbmRleCBvZiB3IHdpdGhpbiB4ZC5cclxuICAgIC8vIGRpZ2l0czogdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygdy5cclxuICAgIC8vIGk6IHdoYXQgd291bGQgYmUgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiB3IGlmIGFsbCB0aGUgbnVtYmVycyB3ZXJlIDcgZGlnaXRzIGxvbmcgKGkuZS4gaWZcclxuICAgIC8vIHRoZXkgaGFkIGxlYWRpbmcgemVyb3MpXHJcbiAgICAvLyBqOiBpZiA+IDAsIHRoZSBhY3R1YWwgaW5kZXggb2YgcmQgd2l0aGluIHcgKGlmIDwgMCwgcmQgaXMgYSBsZWFkaW5nIHplcm8pLlxyXG5cclxuICAgIC8vIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBkaWdpdHMgYXJyYXkgeGQuXHJcbiAgICBmb3IgKGRpZ2l0cyA9IDEsIGsgPSB4ZFswXTsgayA+PSAxMDsgayAvPSAxMCkgZGlnaXRzKys7XHJcbiAgICBpID0gc2QgLSBkaWdpdHM7XHJcblxyXG4gICAgLy8gSXMgdGhlIHJvdW5kaW5nIGRpZ2l0IGluIHRoZSBmaXJzdCB3b3JkIG9mIHhkP1xyXG4gICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgIGogPSBzZDtcclxuICAgICAgdyA9IHhkW3hkaSA9IDBdO1xyXG5cclxuICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIHcuXHJcbiAgICAgIHJkID0gdyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKSAlIDEwIHwgMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHhkaSA9IE1hdGguY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xyXG4gICAgICBrID0geGQubGVuZ3RoO1xyXG4gICAgICBpZiAoeGRpID49IGspIHtcclxuICAgICAgICBpZiAoaXNUcnVuY2F0ZWQpIHtcclxuXHJcbiAgICAgICAgICAvLyBOZWVkZWQgYnkgYG5hdHVyYWxFeHBvbmVudGlhbGAsIGBuYXR1cmFsTG9nYXJpdGhtYCBhbmQgYHNxdWFyZVJvb3RgLlxyXG4gICAgICAgICAgZm9yICg7IGsrKyA8PSB4ZGk7KSB4ZC5wdXNoKDApO1xyXG4gICAgICAgICAgdyA9IHJkID0gMDtcclxuICAgICAgICAgIGRpZ2l0cyA9IDE7XHJcbiAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG4gICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdyA9IGsgPSB4ZFt4ZGldO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygdy5cclxuICAgICAgICBmb3IgKGRpZ2l0cyA9IDE7IGsgPj0gMTA7IGsgLz0gMTApIGRpZ2l0cysrO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiB3LlxyXG4gICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIHcsIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiB3IGlzIGdpdmVuIGJ5IExPR19CQVNFIC0gZGlnaXRzLlxyXG4gICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkaWdpdHM7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiB3LlxyXG4gICAgICAgIHJkID0gaiA8IDAgPyAwIDogdyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKSAlIDEwIHwgMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFyZSB0aGVyZSBhbnkgbm9uLXplcm8gZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdD9cclxuICAgIGlzVHJ1bmNhdGVkID0gaXNUcnVuY2F0ZWQgfHwgc2QgPCAwIHx8XHJcbiAgICAgIHhkW3hkaSArIDFdICE9PSB2b2lkIDAgfHwgKGogPCAwID8gdyA6IHcgJSBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSkpO1xyXG5cclxuICAgIC8vIFRoZSBleHByZXNzaW9uIGB3ICUgbWF0aHBvdygxMCwgZGlnaXRzIC0gaiAtIDEpYCByZXR1cm5zIGFsbCB0aGUgZGlnaXRzIG9mIHcgdG8gdGhlIHJpZ2h0XHJcbiAgICAvLyBvZiB0aGUgZGlnaXQgYXQgKGxlZnQtdG8tcmlnaHQpIGluZGV4IGosIGUuZy4gaWYgdyBpcyA5MDg3MTQgYW5kIGogaXMgMiwgdGhlIGV4cHJlc3Npb25cclxuICAgIC8vIHdpbGwgZ2l2ZSA3MTQuXHJcblxyXG4gICAgcm91bmRVcCA9IHJtIDwgNFxyXG4gICAgICA/IChyZCB8fCBpc1RydW5jYXRlZCkgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKHJtID09IDQgfHwgaXNUcnVuY2F0ZWQgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkaWdpdCB0byB0aGUgbGVmdCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgb2RkLlxyXG4gICAgICAgICgoaSA+IDAgPyBqID4gMCA/IHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqKSA6IDAgOiB4ZFt4ZGkgLSAxXSkgJSAxMCkgJiAxIHx8XHJcbiAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgaWYgKHNkIDwgMSB8fCAheGRbMF0pIHtcclxuICAgICAgeGQubGVuZ3RoID0gMDtcclxuICAgICAgaWYgKHJvdW5kVXApIHtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCBzZCB0byBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICBzZCAtPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgIHhkWzBdID0gbWF0aHBvdygxMCwgKExPR19CQVNFIC0gc2QgJSBMT0dfQkFTRSkgJSBMT0dfQkFTRSk7XHJcbiAgICAgICAgeC5lID0gLXNkIHx8IDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgeGRbMF0gPSB4LmUgPSAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cclxuICAgIGlmIChpID09IDApIHtcclxuICAgICAgeGQubGVuZ3RoID0geGRpO1xyXG4gICAgICBrID0gMTtcclxuICAgICAgeGRpLS07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB4ZC5sZW5ndGggPSB4ZGkgKyAxO1xyXG4gICAgICBrID0gbWF0aHBvdygxMCwgTE9HX0JBU0UgLSBpKTtcclxuXHJcbiAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIHcuXHJcbiAgICAgIHhkW3hkaV0gPSBqID4gMCA/ICh3IC8gbWF0aHBvdygxMCwgZGlnaXRzIC0gaikgJSBtYXRocG93KDEwLCBqKSB8IDApICogayA6IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJvdW5kVXApIHtcclxuICAgICAgZm9yICg7Oykge1xyXG5cclxuICAgICAgICAvLyBJcyB0aGUgZGlnaXQgdG8gYmUgcm91bmRlZCB1cCBpbiB0aGUgZmlyc3Qgd29yZCBvZiB4ZD9cclxuICAgICAgICBpZiAoeGRpID09IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4ZFswXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4ZFswXTsgaiA+PSAxMDsgaiAvPSAxMCkgaSsrO1xyXG4gICAgICAgICAgaiA9IHhkWzBdICs9IGs7XHJcbiAgICAgICAgICBmb3IgKGsgPSAxOyBqID49IDEwOyBqIC89IDEwKSBrKys7XHJcblxyXG4gICAgICAgICAgLy8gaWYgaSAhPSBrIHRoZSBsZW5ndGggaGFzIGluY3JlYXNlZC5cclxuICAgICAgICAgIGlmIChpICE9IGspIHtcclxuICAgICAgICAgICAgeC5lKys7XHJcbiAgICAgICAgICAgIGlmICh4ZFswXSA9PSBCQVNFKSB4ZFswXSA9IDE7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHhkW3hkaV0gKz0gaztcclxuICAgICAgICAgIGlmICh4ZFt4ZGldICE9IEJBU0UpIGJyZWFrO1xyXG4gICAgICAgICAgeGRbeGRpLS1dID0gMDtcclxuICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoaSA9IHhkLmxlbmd0aDsgeGRbLS1pXSA9PT0gMDspIHhkLnBvcCgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGV4dGVybmFsKSB7XHJcblxyXG4gICAgLy8gT3ZlcmZsb3c/XHJcbiAgICBpZiAoeC5lID4gQ3Rvci5tYXhFKSB7XHJcblxyXG4gICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgeC5kID0gbnVsbDtcclxuICAgICAgeC5lID0gTmFOO1xyXG5cclxuICAgIC8vIFVuZGVyZmxvdz9cclxuICAgIH0gZWxzZSBpZiAoeC5lIDwgQ3Rvci5taW5FKSB7XHJcblxyXG4gICAgICAvLyBaZXJvLlxyXG4gICAgICB4LmUgPSAwO1xyXG4gICAgICB4LmQgPSBbMF07XHJcbiAgICAgIC8vIEN0b3IudW5kZXJmbG93ID0gdHJ1ZTtcclxuICAgIH0gLy8gZWxzZSBDdG9yLnVuZGVyZmxvdyA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHg7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBmaW5pdGVUb1N0cmluZyh4LCBpc0V4cCwgc2QpIHtcclxuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5vbkZpbml0ZVRvU3RyaW5nKHgpO1xyXG4gIHZhciBrLFxyXG4gICAgZSA9IHguZSxcclxuICAgIHN0ciA9IGRpZ2l0c1RvU3RyaW5nKHguZCksXHJcbiAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICBpZiAoaXNFeHApIHtcclxuICAgIGlmIChzZCAmJiAoayA9IHNkIC0gbGVuKSA+IDApIHtcclxuICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSArIGdldFplcm9TdHJpbmcoayk7XHJcbiAgICB9IGVsc2UgaWYgKGxlbiA+IDEpIHtcclxuICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKTtcclxuICAgIH1cclxuXHJcbiAgICBzdHIgPSBzdHIgKyAoeC5lIDwgMCA/ICdlJyA6ICdlKycpICsgeC5lO1xyXG4gIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuICAgIHN0ciA9ICcwLicgKyBnZXRaZXJvU3RyaW5nKC1lIC0gMSkgKyBzdHI7XHJcbiAgICBpZiAoc2QgJiYgKGsgPSBzZCAtIGxlbikgPiAwKSBzdHIgKz0gZ2V0WmVyb1N0cmluZyhrKTtcclxuICB9IGVsc2UgaWYgKGUgPj0gbGVuKSB7XHJcbiAgICBzdHIgKz0gZ2V0WmVyb1N0cmluZyhlICsgMSAtIGxlbik7XHJcbiAgICBpZiAoc2QgJiYgKGsgPSBzZCAtIGUgLSAxKSA+IDApIHN0ciA9IHN0ciArICcuJyArIGdldFplcm9TdHJpbmcoayk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICgoayA9IGUgKyAxKSA8IGxlbikgc3RyID0gc3RyLnNsaWNlKDAsIGspICsgJy4nICsgc3RyLnNsaWNlKGspO1xyXG4gICAgaWYgKHNkICYmIChrID0gc2QgLSBsZW4pID4gMCkge1xyXG4gICAgICBpZiAoZSArIDEgPT09IGxlbikgc3RyICs9ICcuJztcclxuICAgICAgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyO1xyXG59XHJcblxyXG5cclxuLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50IGZyb20gdGhlIGJhc2UgMWU3IGV4cG9uZW50LlxyXG5mdW5jdGlvbiBnZXRCYXNlMTBFeHBvbmVudChkaWdpdHMsIGUpIHtcclxuICB2YXIgdyA9IGRpZ2l0c1swXTtcclxuXHJcbiAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBkaWdpdHMgYXJyYXkuXHJcbiAgZm9yICggZSAqPSBMT0dfQkFTRTsgdyA+PSAxMDsgdyAvPSAxMCkgZSsrO1xyXG4gIHJldHVybiBlO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0TG4xMChDdG9yLCBzZCwgcHIpIHtcclxuICBpZiAoc2QgPiBMTjEwX1BSRUNJU0lPTikge1xyXG5cclxuICAgIC8vIFJlc2V0IGdsb2JhbCBzdGF0ZSBpbiBjYXNlIHRoZSBleGNlcHRpb24gaXMgY2F1Z2h0LlxyXG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gICAgaWYgKHByKSBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gICAgdGhyb3cgRXJyb3IocHJlY2lzaW9uTGltaXRFeGNlZWRlZCk7XHJcbiAgfVxyXG4gIHJldHVybiBmaW5hbGlzZShuZXcgQ3RvcihMTjEwKSwgc2QsIDEsIHRydWUpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0UGkoQ3Rvciwgc2QsIHJtKSB7XHJcbiAgaWYgKHNkID4gUElfUFJFQ0lTSU9OKSB0aHJvdyBFcnJvcihwcmVjaXNpb25MaW1pdEV4Y2VlZGVkKTtcclxuICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoUEkpLCBzZCwgcm0sIHRydWUpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0UHJlY2lzaW9uKGRpZ2l0cykge1xyXG4gIHZhciB3ID0gZGlnaXRzLmxlbmd0aCAtIDEsXHJcbiAgICBsZW4gPSB3ICogTE9HX0JBU0UgKyAxO1xyXG5cclxuICB3ID0gZGlnaXRzW3ddO1xyXG5cclxuICAvLyBJZiBub24temVyby4uLlxyXG4gIGlmICh3KSB7XHJcblxyXG4gICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCB3b3JkLlxyXG4gICAgZm9yICg7IHcgJSAxMCA9PSAwOyB3IC89IDEwKSBsZW4tLTtcclxuXHJcbiAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IHdvcmQuXHJcbiAgICBmb3IgKHcgPSBkaWdpdHNbMF07IHcgPj0gMTA7IHcgLz0gMTApIGxlbisrO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGxlbjtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldFplcm9TdHJpbmcoaykge1xyXG4gIHZhciB6cyA9ICcnO1xyXG4gIGZvciAoOyBrLS07KSB6cyArPSAnMCc7XHJcbiAgcmV0dXJuIHpzO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIERlY2ltYWwgYHhgIHRvIHRoZSBwb3dlciBgbmAsIHdoZXJlIGBuYCBpcyBhblxyXG4gKiBpbnRlZ2VyIG9mIHR5cGUgbnVtYmVyLlxyXG4gKlxyXG4gKiBJbXBsZW1lbnRzICdleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZycuIENhbGxlZCBieSBgcG93YCBhbmQgYHBhcnNlT3RoZXJgLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gaW50UG93KEN0b3IsIHgsIG4sIHByKSB7XHJcbiAgdmFyIGlzVHJ1bmNhdGVkLFxyXG4gICAgciA9IG5ldyBDdG9yKDEpLFxyXG5cclxuICAgIC8vIE1heCBuIG9mIDkwMDcxOTkyNTQ3NDA5OTEgdGFrZXMgNTMgbG9vcCBpdGVyYXRpb25zLlxyXG4gICAgLy8gTWF4aW11bSBkaWdpdHMgYXJyYXkgbGVuZ3RoOyBsZWF2ZXMgWzI4LCAzNF0gZ3VhcmQgZGlnaXRzLlxyXG4gICAgayA9IE1hdGguY2VpbChwciAvIExPR19CQVNFICsgNCk7XHJcblxyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gIGZvciAoOzspIHtcclxuICAgIGlmIChuICUgMikge1xyXG4gICAgICByID0gci50aW1lcyh4KTtcclxuICAgICAgaWYgKHRydW5jYXRlKHIuZCwgaykpIGlzVHJ1bmNhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBuID0gbWF0aGZsb29yKG4gLyAyKTtcclxuICAgIGlmIChuID09PSAwKSB7XHJcblxyXG4gICAgICAvLyBUbyBlbnN1cmUgY29ycmVjdCByb3VuZGluZyB3aGVuIHIuZCBpcyB0cnVuY2F0ZWQsIGluY3JlbWVudCB0aGUgbGFzdCB3b3JkIGlmIGl0IGlzIHplcm8uXHJcbiAgICAgIG4gPSByLmQubGVuZ3RoIC0gMTtcclxuICAgICAgaWYgKGlzVHJ1bmNhdGVkICYmIHIuZFtuXSA9PT0gMCkgKytyLmRbbl07XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHggPSB4LnRpbWVzKHgpO1xyXG4gICAgdHJ1bmNhdGUoeC5kLCBrKTtcclxuICB9XHJcblxyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgcmV0dXJuIHI7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgcmV0dXJuIG4uZFtuLmQubGVuZ3RoIC0gMV0gJiAxO1xyXG59XHJcblxyXG5cclxuLypcclxuICogSGFuZGxlIGBtYXhgIGFuZCBgbWluYC4gYGx0Z3RgIGlzICdsdCcgb3IgJ2d0Jy5cclxuICovXHJcbmZ1bmN0aW9uIG1heE9yTWluKEN0b3IsIGFyZ3MsIGx0Z3QpIHtcclxuICB2YXIgeSxcclxuICAgIHggPSBuZXcgQ3RvcihhcmdzWzBdKSxcclxuICAgIGkgPSAwO1xyXG5cclxuICBmb3IgKDsgKytpIDwgYXJncy5sZW5ndGg7KSB7XHJcbiAgICB5ID0gbmV3IEN0b3IoYXJnc1tpXSk7XHJcbiAgICBpZiAoIXkucykge1xyXG4gICAgICB4ID0geTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9IGVsc2UgaWYgKHhbbHRndF0oeSkpIHtcclxuICAgICAgeCA9IHk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4geDtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGV4cG9uZW50aWFsIG9mIGB4YCByb3VuZGVkIHRvIGBzZGAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzLlxyXG4gKlxyXG4gKiBUYXlsb3IvTWFjbGF1cmluIHNlcmllcy5cclxuICpcclxuICogZXhwKHgpID0geF4wLzAhICsgeF4xLzEhICsgeF4yLzIhICsgeF4zLzMhICsgLi4uXHJcbiAqXHJcbiAqIEFyZ3VtZW50IHJlZHVjdGlvbjpcclxuICogICBSZXBlYXQgeCA9IHggLyAzMiwgayArPSA1LCB1bnRpbCB8eHwgPCAwLjFcclxuICogICBleHAoeCkgPSBleHAoeCAvIDJeayleKDJeaylcclxuICpcclxuICogUHJldmlvdXNseSwgdGhlIGFyZ3VtZW50IHdhcyBpbml0aWFsbHkgcmVkdWNlZCBieVxyXG4gKiBleHAoeCkgPSBleHAocikgKiAxMF5rICB3aGVyZSByID0geCAtIGsgKiBsbjEwLCBrID0gZmxvb3IoeCAvIGxuMTApXHJcbiAqIHRvIGZpcnN0IHB1dCByIGluIHRoZSByYW5nZSBbMCwgbG4xMF0sIGJlZm9yZSBkaXZpZGluZyBieSAzMiB1bnRpbCB8eHwgPCAwLjEsIGJ1dCB0aGlzIHdhc1xyXG4gKiBmb3VuZCB0byBiZSBzbG93ZXIgdGhhbiBqdXN0IGRpdmlkaW5nIHJlcGVhdGVkbHkgYnkgMzIgYXMgYWJvdmUuXHJcbiAqXHJcbiAqIE1heCBpbnRlZ2VyIGFyZ3VtZW50OiBleHAoJzIwNzIzMjY1ODM2OTQ2NDEzJykgPSA2LjNlKzkwMDAwMDAwMDAwMDAwMDBcclxuICogTWluIGludGVnZXIgYXJndW1lbnQ6IGV4cCgnLTIwNzIzMjY1ODM2OTQ2NDExJykgPSAxLjJlLTkwMDAwMDAwMDAwMDAwMDBcclxuICogKE1hdGggb2JqZWN0IGludGVnZXIgbWluL21heDogTWF0aC5leHAoNzA5KSA9IDguMmUrMzA3LCBNYXRoLmV4cCgtNzQ1KSA9IDVlLTMyNClcclxuICpcclxuICogIGV4cChJbmZpbml0eSkgID0gSW5maW5pdHlcclxuICogIGV4cCgtSW5maW5pdHkpID0gMFxyXG4gKiAgZXhwKE5hTikgICAgICAgPSBOYU5cclxuICogIGV4cCjCsTApICAgICAgICA9IDFcclxuICpcclxuICogIGV4cCh4KSBpcyBub24tdGVybWluYXRpbmcgZm9yIGFueSBmaW5pdGUsIG5vbi16ZXJvIHguXHJcbiAqXHJcbiAqICBUaGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGNvcnJlY3RseSByb3VuZGVkLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gbmF0dXJhbEV4cG9uZW50aWFsKHgsIHNkKSB7XHJcbiAgdmFyIGRlbm9taW5hdG9yLCBndWFyZCwgaiwgcG93LCBzdW0sIHQsIHdwcixcclxuICAgIHJlcCA9IDAsXHJcbiAgICBpID0gMCxcclxuICAgIGsgPSAwLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmcsXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG5cclxuICAvLyAwL05hTi9JbmZpbml0eT9cclxuICBpZiAoIXguZCB8fCAheC5kWzBdIHx8IHguZSA+IDE3KSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBDdG9yKHguZFxyXG4gICAgICA/ICF4LmRbMF0gPyAxIDogeC5zIDwgMCA/IDAgOiAxIC8gMFxyXG4gICAgICA6IHgucyA/IHgucyA8IDAgPyAwIDogeCA6IDAgLyAwKTtcclxuICB9XHJcblxyXG4gIGlmIChzZCA9PSBudWxsKSB7XHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gICAgd3ByID0gcHI7XHJcbiAgfSBlbHNlIHtcclxuICAgIHdwciA9IHNkO1xyXG4gIH1cclxuXHJcbiAgdCA9IG5ldyBDdG9yKDAuMDMxMjUpO1xyXG5cclxuICAvLyB3aGlsZSBhYnMoeCkgPj0gMC4xXHJcbiAgd2hpbGUgKHguZSA+IC0yKSB7XHJcblxyXG4gICAgLy8geCA9IHggLyAyXjVcclxuICAgIHggPSB4LnRpbWVzKHQpO1xyXG4gICAgayArPSA1O1xyXG4gIH1cclxuXHJcbiAgLy8gVXNlIDIgKiBsb2cxMCgyXmspICsgNSAoZW1waXJpY2FsbHkgZGVyaXZlZCkgdG8gZXN0aW1hdGUgdGhlIGluY3JlYXNlIGluIHByZWNpc2lvblxyXG4gIC8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhlIGZpcnN0IDQgcm91bmRpbmcgZGlnaXRzIGFyZSBjb3JyZWN0LlxyXG4gIGd1YXJkID0gTWF0aC5sb2cobWF0aHBvdygyLCBrKSkgLyBNYXRoLkxOMTAgKiAyICsgNSB8IDA7XHJcbiAgd3ByICs9IGd1YXJkO1xyXG4gIGRlbm9taW5hdG9yID0gcG93ID0gc3VtID0gbmV3IEN0b3IoMSk7XHJcbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHI7XHJcblxyXG4gIGZvciAoOzspIHtcclxuICAgIHBvdyA9IGZpbmFsaXNlKHBvdy50aW1lcyh4KSwgd3ByLCAxKTtcclxuICAgIGRlbm9taW5hdG9yID0gZGVub21pbmF0b3IudGltZXMoKytpKTtcclxuICAgIHQgPSBzdW0ucGx1cyhkaXZpZGUocG93LCBkZW5vbWluYXRvciwgd3ByLCAxKSk7XHJcblxyXG4gICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgd3ByKSA9PT0gZGlnaXRzVG9TdHJpbmcoc3VtLmQpLnNsaWNlKDAsIHdwcikpIHtcclxuICAgICAgaiA9IGs7XHJcbiAgICAgIHdoaWxlIChqLS0pIHN1bSA9IGZpbmFsaXNlKHN1bS50aW1lcyhzdW0pLCB3cHIsIDEpO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBmaXJzdCA0IHJvdW5kaW5nIGRpZ2l0cyBhcmUgWzQ5XTk5OS5cclxuICAgICAgLy8gSWYgc28sIHJlcGVhdCB0aGUgc3VtbWF0aW9uIHdpdGggYSBoaWdoZXIgcHJlY2lzaW9uLCBvdGhlcndpc2VcclxuICAgICAgLy8gZS5nLiB3aXRoIHByZWNpc2lvbjogMTgsIHJvdW5kaW5nOiAxXHJcbiAgICAgIC8vIGV4cCgxOC40MDQyNzI0NjI1OTUwMzQwODM1Njc3OTM5MTk4NDM3NjEpID0gOTgzNzI1NjAuMTIyOTk5OTk5OSAoc2hvdWxkIGJlIDk4MzcyNTYwLjEyMylcclxuICAgICAgLy8gYHdwciAtIGd1YXJkYCBpcyB0aGUgaW5kZXggb2YgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgIGlmIChzZCA9PSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmIChyZXAgPCAzICYmIGNoZWNrUm91bmRpbmdEaWdpdHMoc3VtLmQsIHdwciAtIGd1YXJkLCBybSwgcmVwKSkge1xyXG4gICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgKz0gMTA7XHJcbiAgICAgICAgICBkZW5vbWluYXRvciA9IHBvdyA9IHQgPSBuZXcgQ3RvcigxKTtcclxuICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgcmVwKys7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBmaW5hbGlzZShzdW0sIEN0b3IucHJlY2lzaW9uID0gcHIsIHJtLCBleHRlcm5hbCA9IHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdW0gPSB0O1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiBgeGAgcm91bmRlZCB0byBgc2RgIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cy5cclxuICpcclxuICogIGxuKC1uKSAgICAgICAgPSBOYU5cclxuICogIGxuKDApICAgICAgICAgPSAtSW5maW5pdHlcclxuICogIGxuKC0wKSAgICAgICAgPSAtSW5maW5pdHlcclxuICogIGxuKDEpICAgICAgICAgPSAwXHJcbiAqICBsbihJbmZpbml0eSkgID0gSW5maW5pdHlcclxuICogIGxuKC1JbmZpbml0eSkgPSBOYU5cclxuICogIGxuKE5hTikgICAgICAgPSBOYU5cclxuICpcclxuICogIGxuKG4pIChuICE9IDEpIGlzIG5vbi10ZXJtaW5hdGluZy5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIG5hdHVyYWxMb2dhcml0aG0oeSwgc2QpIHtcclxuICB2YXIgYywgYzAsIGRlbm9taW5hdG9yLCBlLCBudW1lcmF0b3IsIHJlcCwgc3VtLCB0LCB3cHIsIHgxLCB4MixcclxuICAgIG4gPSAxLFxyXG4gICAgZ3VhcmQgPSAxMCxcclxuICAgIHggPSB5LFxyXG4gICAgeGQgPSB4LmQsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZyxcclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb247XHJcblxyXG4gIC8vIElzIHggbmVnYXRpdmUgb3IgSW5maW5pdHksIE5hTiwgMCBvciAxP1xyXG4gIGlmICh4LnMgPCAwIHx8ICF4ZCB8fCAheGRbMF0gfHwgIXguZSAmJiB4ZFswXSA9PSAxICYmIHhkLmxlbmd0aCA9PSAxKSB7XHJcbiAgICByZXR1cm4gbmV3IEN0b3IoeGQgJiYgIXhkWzBdID8gLTEgLyAwIDogeC5zICE9IDEgPyBOYU4gOiB4ZCA/IDAgOiB4KTtcclxuICB9XHJcblxyXG4gIGlmIChzZCA9PSBudWxsKSB7XHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gICAgd3ByID0gcHI7XHJcbiAgfSBlbHNlIHtcclxuICAgIHdwciA9IHNkO1xyXG4gIH1cclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgKz0gZ3VhcmQ7XHJcbiAgYyA9IGRpZ2l0c1RvU3RyaW5nKHhkKTtcclxuICBjMCA9IGMuY2hhckF0KDApO1xyXG5cclxuICBpZiAoTWF0aC5hYnMoZSA9IHguZSkgPCAxLjVlMTUpIHtcclxuXHJcbiAgICAvLyBBcmd1bWVudCByZWR1Y3Rpb24uXHJcbiAgICAvLyBUaGUgc2VyaWVzIGNvbnZlcmdlcyBmYXN0ZXIgdGhlIGNsb3NlciB0aGUgYXJndW1lbnQgaXMgdG8gMSwgc28gdXNpbmdcclxuICAgIC8vIGxuKGFeYikgPSBiICogbG4oYSksICAgbG4oYSkgPSBsbihhXmIpIC8gYlxyXG4gICAgLy8gbXVsdGlwbHkgdGhlIGFyZ3VtZW50IGJ5IGl0c2VsZiB1bnRpbCB0aGUgbGVhZGluZyBkaWdpdHMgb2YgdGhlIHNpZ25pZmljYW5kIGFyZSA3LCA4LCA5LFxyXG4gICAgLy8gMTAsIDExLCAxMiBvciAxMywgcmVjb3JkaW5nIHRoZSBudW1iZXIgb2YgbXVsdGlwbGljYXRpb25zIHNvIHRoZSBzdW0gb2YgdGhlIHNlcmllcyBjYW5cclxuICAgIC8vIGxhdGVyIGJlIGRpdmlkZWQgYnkgdGhpcyBudW1iZXIsIHRoZW4gc2VwYXJhdGUgb3V0IHRoZSBwb3dlciBvZiAxMCB1c2luZ1xyXG4gICAgLy8gbG4oYSoxMF5iKSA9IGxuKGEpICsgYipsbigxMCkuXHJcblxyXG4gICAgLy8gbWF4IG4gaXMgMjEgKGdpdmVzIDAuOSwgMS4wIG9yIDEuMSkgKDllMTUgLyAyMSA9IDQuMmUxNCkuXHJcbiAgICAvL3doaWxlIChjMCA8IDkgJiYgYzAgIT0gMSB8fCBjMCA9PSAxICYmIGMuY2hhckF0KDEpID4gMSkge1xyXG4gICAgLy8gbWF4IG4gaXMgNiAoZ2l2ZXMgMC43IC0gMS4zKVxyXG4gICAgd2hpbGUgKGMwIDwgNyAmJiBjMCAhPSAxIHx8IGMwID09IDEgJiYgYy5jaGFyQXQoMSkgPiAzKSB7XHJcbiAgICAgIHggPSB4LnRpbWVzKHkpO1xyXG4gICAgICBjID0gZGlnaXRzVG9TdHJpbmcoeC5kKTtcclxuICAgICAgYzAgPSBjLmNoYXJBdCgwKTtcclxuICAgICAgbisrO1xyXG4gICAgfVxyXG5cclxuICAgIGUgPSB4LmU7XHJcblxyXG4gICAgaWYgKGMwID4gMSkge1xyXG4gICAgICB4ID0gbmV3IEN0b3IoJzAuJyArIGMpO1xyXG4gICAgICBlKys7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB4ID0gbmV3IEN0b3IoYzAgKyAnLicgKyBjLnNsaWNlKDEpKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG5cclxuICAgIC8vIFRoZSBhcmd1bWVudCByZWR1Y3Rpb24gbWV0aG9kIGFib3ZlIG1heSByZXN1bHQgaW4gb3ZlcmZsb3cgaWYgdGhlIGFyZ3VtZW50IHkgaXMgYSBtYXNzaXZlXHJcbiAgICAvLyBudW1iZXIgd2l0aCBleHBvbmVudCA+PSAxNTAwMDAwMDAwMDAwMDAwICg5ZTE1IC8gNiA9IDEuNWUxNSksIHNvIGluc3RlYWQgcmVjYWxsIHRoaXNcclxuICAgIC8vIGZ1bmN0aW9uIHVzaW5nIGxuKHgqMTBeZSkgPSBsbih4KSArIGUqbG4oMTApLlxyXG4gICAgdCA9IGdldExuMTAoQ3Rvciwgd3ByICsgMiwgcHIpLnRpbWVzKGUgKyAnJyk7XHJcbiAgICB4ID0gbmF0dXJhbExvZ2FyaXRobShuZXcgQ3RvcihjMCArICcuJyArIGMuc2xpY2UoMSkpLCB3cHIgLSBndWFyZCkucGx1cyh0KTtcclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcblxyXG4gICAgcmV0dXJuIHNkID09IG51bGwgPyBmaW5hbGlzZSh4LCBwciwgcm0sIGV4dGVybmFsID0gdHJ1ZSkgOiB4O1xyXG4gIH1cclxuXHJcbiAgLy8geDEgaXMgeCByZWR1Y2VkIHRvIGEgdmFsdWUgbmVhciAxLlxyXG4gIHgxID0geDtcclxuXHJcbiAgLy8gVGF5bG9yIHNlcmllcy5cclxuICAvLyBsbih5KSA9IGxuKCgxICsgeCkvKDEgLSB4KSkgPSAyKHggKyB4XjMvMyArIHheNS81ICsgeF43LzcgKyAuLi4pXHJcbiAgLy8gd2hlcmUgeCA9ICh5IC0gMSkvKHkgKyAxKSAgICAofHh8IDwgMSlcclxuICBzdW0gPSBudW1lcmF0b3IgPSB4ID0gZGl2aWRlKHgubWludXMoMSksIHgucGx1cygxKSwgd3ByLCAxKTtcclxuICB4MiA9IGZpbmFsaXNlKHgudGltZXMoeCksIHdwciwgMSk7XHJcbiAgZGVub21pbmF0b3IgPSAzO1xyXG5cclxuICBmb3IgKDs7KSB7XHJcbiAgICBudW1lcmF0b3IgPSBmaW5hbGlzZShudW1lcmF0b3IudGltZXMoeDIpLCB3cHIsIDEpO1xyXG4gICAgdCA9IHN1bS5wbHVzKGRpdmlkZShudW1lcmF0b3IsIG5ldyBDdG9yKGRlbm9taW5hdG9yKSwgd3ByLCAxKSk7XHJcblxyXG4gICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgd3ByKSA9PT0gZGlnaXRzVG9TdHJpbmcoc3VtLmQpLnNsaWNlKDAsIHdwcikpIHtcclxuICAgICAgc3VtID0gc3VtLnRpbWVzKDIpO1xyXG5cclxuICAgICAgLy8gUmV2ZXJzZSB0aGUgYXJndW1lbnQgcmVkdWN0aW9uLiBDaGVjayB0aGF0IGUgaXMgbm90IDAgYmVjYXVzZSwgYmVzaWRlcyBwcmV2ZW50aW5nIGFuXHJcbiAgICAgIC8vIHVubmVjZXNzYXJ5IGNhbGN1bGF0aW9uLCAtMCArIDAgPSArMCBhbmQgdG8gZW5zdXJlIGNvcnJlY3Qgcm91bmRpbmcgLTAgbmVlZHMgdG8gc3RheSAtMC5cclxuICAgICAgaWYgKGUgIT09IDApIHN1bSA9IHN1bS5wbHVzKGdldExuMTAoQ3Rvciwgd3ByICsgMiwgcHIpLnRpbWVzKGUgKyAnJykpO1xyXG4gICAgICBzdW0gPSBkaXZpZGUoc3VtLCBuZXcgQ3RvcihuKSwgd3ByLCAxKTtcclxuXHJcbiAgICAgIC8vIElzIHJtID4gMyBhbmQgdGhlIGZpcnN0IDQgcm91bmRpbmcgZGlnaXRzIDQ5OTksIG9yIHJtIDwgNCAob3IgdGhlIHN1bW1hdGlvbiBoYXNcclxuICAgICAgLy8gYmVlbiByZXBlYXRlZCBwcmV2aW91c2x5KSBhbmQgdGhlIGZpcnN0IDQgcm91bmRpbmcgZGlnaXRzIDk5OTk/XHJcbiAgICAgIC8vIElmIHNvLCByZXN0YXJ0IHRoZSBzdW1tYXRpb24gd2l0aCBhIGhpZ2hlciBwcmVjaXNpb24sIG90aGVyd2lzZVxyXG4gICAgICAvLyBlLmcuIHdpdGggcHJlY2lzaW9uOiAxMiwgcm91bmRpbmc6IDFcclxuICAgICAgLy8gbG4oMTM1NTIwMDI4LjYxMjYwOTE3MTQyNjUzODE1MzMpID0gMTguNzI0NjI5OTk5OSB3aGVuIGl0IHNob3VsZCBiZSAxOC43MjQ2My5cclxuICAgICAgLy8gYHdwciAtIGd1YXJkYCBpcyB0aGUgaW5kZXggb2YgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgIGlmIChzZCA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGNoZWNrUm91bmRpbmdEaWdpdHMoc3VtLmQsIHdwciAtIGd1YXJkLCBybSwgcmVwKSkge1xyXG4gICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgKz0gZ3VhcmQ7XHJcbiAgICAgICAgICB0ID0gbnVtZXJhdG9yID0geCA9IGRpdmlkZSh4MS5taW51cygxKSwgeDEucGx1cygxKSwgd3ByLCAxKTtcclxuICAgICAgICAgIHgyID0gZmluYWxpc2UoeC50aW1lcyh4KSwgd3ByLCAxKTtcclxuICAgICAgICAgIGRlbm9taW5hdG9yID0gcmVwID0gMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIGZpbmFsaXNlKHN1bSwgQ3Rvci5wcmVjaXNpb24gPSBwciwgcm0sIGV4dGVybmFsID0gdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN1bSA9IHQ7XHJcbiAgICBkZW5vbWluYXRvciArPSAyO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8vIMKxSW5maW5pdHksIE5hTi5cclxuZnVuY3Rpb24gbm9uRmluaXRlVG9TdHJpbmcoeCkge1xyXG4gIC8vIFVuc2lnbmVkLlxyXG4gIHJldHVybiBTdHJpbmcoeC5zICogeC5zIC8gMCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBQYXJzZSB0aGUgdmFsdWUgb2YgYSBuZXcgRGVjaW1hbCBgeGAgZnJvbSBzdHJpbmcgYHN0cmAuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZURlY2ltYWwoeCwgc3RyKSB7XHJcbiAgdmFyIGUsIGksIGxlbjtcclxuXHJcbiAgLy8gRGVjaW1hbCBwb2ludD9cclxuICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuXHJcbiAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICBpZiAoKGkgPSBzdHIuc2VhcmNoKC9lL2kpKSA+IDApIHtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXHJcbiAgICBpZiAoZSA8IDApIGUgPSBpO1xyXG4gICAgZSArPSArc3RyLnNsaWNlKGkgKyAxKTtcclxuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSk7XHJcbiAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgIC8vIEludGVnZXIuXHJcbiAgICBlID0gc3RyLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gIGZvciAoaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrKTtcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQobGVuIC0gMSkgPT09IDQ4OyAtLWxlbik7XHJcbiAgc3RyID0gc3RyLnNsaWNlKGksIGxlbik7XHJcblxyXG4gIGlmIChzdHIpIHtcclxuICAgIGxlbiAtPSBpO1xyXG4gICAgeC5lID0gZSA9IGUgLSBpIC0gMTtcclxuICAgIHguZCA9IFtdO1xyXG5cclxuICAgIC8vIFRyYW5zZm9ybSBiYXNlXHJcblxyXG4gICAgLy8gZSBpcyB0aGUgYmFzZSAxMCBleHBvbmVudC5cclxuICAgIC8vIGkgaXMgd2hlcmUgdG8gc2xpY2Ugc3RyIHRvIGdldCB0aGUgZmlyc3Qgd29yZCBvZiB0aGUgZGlnaXRzIGFycmF5LlxyXG4gICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgIGlmIChlIDwgMCkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICBpZiAoaSA8IGxlbikge1xyXG4gICAgICBpZiAoaSkgeC5kLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XHJcbiAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOykgeC5kLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XHJcbiAgICAgIHN0ciA9IHN0ci5zbGljZShpKTtcclxuICAgICAgaSA9IExPR19CQVNFIC0gc3RyLmxlbmd0aDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGkgLT0gbGVuO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoOyBpLS07KSBzdHIgKz0gJzAnO1xyXG4gICAgeC5kLnB1c2goK3N0cik7XHJcblxyXG4gICAgaWYgKGV4dGVybmFsKSB7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgaWYgKHguZSA+IHguY29uc3RydWN0b3IubWF4RSkge1xyXG5cclxuICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICB4LmQgPSBudWxsO1xyXG4gICAgICAgIHguZSA9IE5hTjtcclxuXHJcbiAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgfSBlbHNlIGlmICh4LmUgPCB4LmNvbnN0cnVjdG9yLm1pbkUpIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4LmUgPSAwO1xyXG4gICAgICAgIHguZCA9IFswXTtcclxuICAgICAgICAvLyB4LmNvbnN0cnVjdG9yLnVuZGVyZmxvdyA9IHRydWU7XHJcbiAgICAgIH0gLy8gZWxzZSB4LmNvbnN0cnVjdG9yLnVuZGVyZmxvdyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcblxyXG4gICAgLy8gWmVyby5cclxuICAgIHguZSA9IDA7XHJcbiAgICB4LmQgPSBbMF07XHJcbiAgfVxyXG5cclxuICByZXR1cm4geDtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFBhcnNlIHRoZSB2YWx1ZSBvZiBhIG5ldyBEZWNpbWFsIGB4YCBmcm9tIGEgc3RyaW5nIGBzdHJgLCB3aGljaCBpcyBub3QgYSBkZWNpbWFsIHZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VPdGhlcih4LCBzdHIpIHtcclxuICB2YXIgYmFzZSwgQ3RvciwgZGl2aXNvciwgaSwgaXNGbG9hdCwgbGVuLCBwLCB4ZCwgeGU7XHJcblxyXG4gIGlmIChzdHIuaW5kZXhPZignXycpID4gLTEpIHtcclxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csICckMScpO1xyXG4gICAgaWYgKGlzRGVjaW1hbC50ZXN0KHN0cikpIHJldHVybiBwYXJzZURlY2ltYWwoeCwgc3RyKTtcclxuICB9IGVsc2UgaWYgKHN0ciA9PT0gJ0luZmluaXR5JyB8fCBzdHIgPT09ICdOYU4nKSB7XHJcbiAgICBpZiAoIStzdHIpIHgucyA9IE5hTjtcclxuICAgIHguZSA9IE5hTjtcclxuICAgIHguZCA9IG51bGw7XHJcbiAgICByZXR1cm4geDtcclxuICB9XHJcblxyXG4gIGlmIChpc0hleC50ZXN0KHN0cikpICB7XHJcbiAgICBiYXNlID0gMTY7XHJcbiAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcclxuICB9IGVsc2UgaWYgKGlzQmluYXJ5LnRlc3Qoc3RyKSkgIHtcclxuICAgIGJhc2UgPSAyO1xyXG4gIH0gZWxzZSBpZiAoaXNPY3RhbC50ZXN0KHN0cikpICB7XHJcbiAgICBiYXNlID0gODtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgc3RyKTtcclxuICB9XHJcblxyXG4gIC8vIElzIHRoZXJlIGEgYmluYXJ5IGV4cG9uZW50IHBhcnQ/XHJcbiAgaSA9IHN0ci5zZWFyY2goL3AvaSk7XHJcblxyXG4gIGlmIChpID4gMCkge1xyXG4gICAgcCA9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygyLCBpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgc3RyID0gc3RyLnNsaWNlKDIpO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29udmVydCBgc3RyYCBhcyBhbiBpbnRlZ2VyIHRoZW4gZGl2aWRlIHRoZSByZXN1bHQgYnkgYGJhc2VgIHJhaXNlZCB0byBhIHBvd2VyIHN1Y2ggdGhhdCB0aGVcclxuICAvLyBmcmFjdGlvbiBwYXJ0IHdpbGwgYmUgcmVzdG9yZWQuXHJcbiAgaSA9IHN0ci5pbmRleE9mKCcuJyk7XHJcbiAgaXNGbG9hdCA9IGkgPj0gMDtcclxuICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKGlzRmxvYXQpIHtcclxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgbGVuID0gc3RyLmxlbmd0aDtcclxuICAgIGkgPSBsZW4gLSBpO1xyXG5cclxuICAgIC8vIGxvZ1sxMF0oMTYpID0gMS4yMDQxLi4uICwgbG9nWzEwXSg4OCkgPSAxLjk0NDQuLi4uXHJcbiAgICBkaXZpc29yID0gaW50UG93KEN0b3IsIG5ldyBDdG9yKGJhc2UpLCBpLCBpICogMik7XHJcbiAgfVxyXG5cclxuICB4ZCA9IGNvbnZlcnRCYXNlKHN0ciwgYmFzZSwgQkFTRSk7XHJcbiAgeGUgPSB4ZC5sZW5ndGggLSAxO1xyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgZm9yIChpID0geGU7IHhkW2ldID09PSAwOyAtLWkpIHhkLnBvcCgpO1xyXG4gIGlmIChpIDwgMCkgcmV0dXJuIG5ldyBDdG9yKHgucyAqIDApO1xyXG4gIHguZSA9IGdldEJhc2UxMEV4cG9uZW50KHhkLCB4ZSk7XHJcbiAgeC5kID0geGQ7XHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgLy8gQXQgd2hhdCBwcmVjaXNpb24gdG8gcGVyZm9ybSB0aGUgZGl2aXNpb24gdG8gZW5zdXJlIGV4YWN0IGNvbnZlcnNpb24/XHJcbiAgLy8gbWF4RGVjaW1hbEludGVnZXJQYXJ0RGlnaXRDb3VudCA9IGNlaWwobG9nWzEwXShiKSAqIG90aGVyQmFzZUludGVnZXJQYXJ0RGlnaXRDb3VudClcclxuICAvLyBsb2dbMTBdKDIpID0gMC4zMDEwMywgbG9nWzEwXSg4KSA9IDAuOTAzMDksIGxvZ1sxMF0oMTYpID0gMS4yMDQxMlxyXG4gIC8vIEUuZy4gY2VpbCgxLjIgKiAzKSA9IDQsIHNvIHVwIHRvIDQgZGVjaW1hbCBkaWdpdHMgYXJlIG5lZWRlZCB0byByZXByZXNlbnQgMyBoZXggaW50IGRpZ2l0cy5cclxuICAvLyBtYXhEZWNpbWFsRnJhY3Rpb25QYXJ0RGlnaXRDb3VudCA9IHtIZXg6NHxPY3Q6M3xCaW46MX0gKiBvdGhlckJhc2VGcmFjdGlvblBhcnREaWdpdENvdW50XHJcbiAgLy8gVGhlcmVmb3JlIHVzaW5nIDQgKiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBzdHIgd2lsbCBhbHdheXMgYmUgZW5vdWdoLlxyXG4gIGlmIChpc0Zsb2F0KSB4ID0gZGl2aWRlKHgsIGRpdmlzb3IsIGxlbiAqIDQpO1xyXG5cclxuICAvLyBNdWx0aXBseSBieSB0aGUgYmluYXJ5IGV4cG9uZW50IHBhcnQgaWYgcHJlc2VudC5cclxuICBpZiAocCkgeCA9IHgudGltZXMoTWF0aC5hYnMocCkgPCA1NCA/IG1hdGhwb3coMiwgcCkgOiBEZWNpbWFsLnBvdygyLCBwKSk7XHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICByZXR1cm4geDtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIHNpbih4KSA9IHggLSB4XjMvMyEgKyB4XjUvNSEgLSAuLi5cclxuICogfHh8IDwgcGkvMlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gc2luZShDdG9yLCB4KSB7XHJcbiAgdmFyIGssXHJcbiAgICBsZW4gPSB4LmQubGVuZ3RoO1xyXG5cclxuICBpZiAobGVuIDwgMykge1xyXG4gICAgcmV0dXJuIHguaXNaZXJvKCkgPyB4IDogdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgpO1xyXG4gIH1cclxuXHJcbiAgLy8gQXJndW1lbnQgcmVkdWN0aW9uOiBzaW4oNXgpID0gMTYqc2luXjUoeCkgLSAyMCpzaW5eMyh4KSArIDUqc2luKHgpXHJcbiAgLy8gaS5lLiBzaW4oeCkgPSAxNipzaW5eNSh4LzUpIC0gMjAqc2luXjMoeC81KSArIDUqc2luKHgvNSlcclxuICAvLyBhbmQgIHNpbih4KSA9IHNpbih4LzUpKDUgKyBzaW5eMih4LzUpKDE2c2luXjIoeC81KSAtIDIwKSlcclxuXHJcbiAgLy8gRXN0aW1hdGUgdGhlIG9wdGltdW0gbnVtYmVyIG9mIHRpbWVzIHRvIHVzZSB0aGUgYXJndW1lbnQgcmVkdWN0aW9uLlxyXG4gIGsgPSAxLjQgKiBNYXRoLnNxcnQobGVuKTtcclxuICBrID0gayA+IDE2ID8gMTYgOiBrIHwgMDtcclxuXHJcbiAgeCA9IHgudGltZXMoMSAvIHRpbnlQb3coNSwgaykpO1xyXG4gIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCk7XHJcblxyXG4gIC8vIFJldmVyc2UgYXJndW1lbnQgcmVkdWN0aW9uXHJcbiAgdmFyIHNpbjJfeCxcclxuICAgIGQ1ID0gbmV3IEN0b3IoNSksXHJcbiAgICBkMTYgPSBuZXcgQ3RvcigxNiksXHJcbiAgICBkMjAgPSBuZXcgQ3RvcigyMCk7XHJcbiAgZm9yICg7IGstLTspIHtcclxuICAgIHNpbjJfeCA9IHgudGltZXMoeCk7XHJcbiAgICB4ID0geC50aW1lcyhkNS5wbHVzKHNpbjJfeC50aW1lcyhkMTYudGltZXMoc2luMl94KS5taW51cyhkMjApKSkpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHg7XHJcbn1cclxuXHJcblxyXG4vLyBDYWxjdWxhdGUgVGF5bG9yIHNlcmllcyBmb3IgYGNvc2AsIGBjb3NoYCwgYHNpbmAgYW5kIGBzaW5oYC5cclxuZnVuY3Rpb24gdGF5bG9yU2VyaWVzKEN0b3IsIG4sIHgsIHksIGlzSHlwZXJib2xpYykge1xyXG4gIHZhciBqLCB0LCB1LCB4MixcclxuICAgIGkgPSAxLFxyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbixcclxuICAgIGsgPSBNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSk7XHJcblxyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcbiAgeDIgPSB4LnRpbWVzKHgpO1xyXG4gIHUgPSBuZXcgQ3Rvcih5KTtcclxuXHJcbiAgZm9yICg7Oykge1xyXG4gICAgdCA9IGRpdmlkZSh1LnRpbWVzKHgyKSwgbmV3IEN0b3IobisrICogbisrKSwgcHIsIDEpO1xyXG4gICAgdSA9IGlzSHlwZXJib2xpYyA/IHkucGx1cyh0KSA6IHkubWludXModCk7XHJcbiAgICB5ID0gZGl2aWRlKHQudGltZXMoeDIpLCBuZXcgQ3RvcihuKysgKiBuKyspLCBwciwgMSk7XHJcbiAgICB0ID0gdS5wbHVzKHkpO1xyXG5cclxuICAgIGlmICh0LmRba10gIT09IHZvaWQgMCkge1xyXG4gICAgICBmb3IgKGogPSBrOyB0LmRbal0gPT09IHUuZFtqXSAmJiBqLS07KTtcclxuICAgICAgaWYgKGogPT0gLTEpIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIGogPSB1O1xyXG4gICAgdSA9IHk7XHJcbiAgICB5ID0gdDtcclxuICAgIHQgPSBqO1xyXG4gICAgaSsrO1xyXG4gIH1cclxuXHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gIHQuZC5sZW5ndGggPSBrICsgMTtcclxuXHJcbiAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcblxyXG4vLyBFeHBvbmVudCBlIG11c3QgYmUgcG9zaXRpdmUgYW5kIG5vbi16ZXJvLlxyXG5mdW5jdGlvbiB0aW55UG93KGIsIGUpIHtcclxuICB2YXIgbiA9IGI7XHJcbiAgd2hpbGUgKC0tZSkgbiAqPSBiO1xyXG4gIHJldHVybiBuO1xyXG59XHJcblxyXG5cclxuLy8gUmV0dXJuIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBgeGAgcmVkdWNlZCB0byBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gaGFsZiBwaS5cclxuZnVuY3Rpb24gdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSB7XHJcbiAgdmFyIHQsXHJcbiAgICBpc05lZyA9IHgucyA8IDAsXHJcbiAgICBwaSA9IGdldFBpKEN0b3IsIEN0b3IucHJlY2lzaW9uLCAxKSxcclxuICAgIGhhbGZQaSA9IHBpLnRpbWVzKDAuNSk7XHJcblxyXG4gIHggPSB4LmFicygpO1xyXG5cclxuICBpZiAoeC5sdGUoaGFsZlBpKSkge1xyXG4gICAgcXVhZHJhbnQgPSBpc05lZyA/IDQgOiAxO1xyXG4gICAgcmV0dXJuIHg7XHJcbiAgfVxyXG5cclxuICB0ID0geC5kaXZUb0ludChwaSk7XHJcblxyXG4gIGlmICh0LmlzWmVybygpKSB7XHJcbiAgICBxdWFkcmFudCA9IGlzTmVnID8gMyA6IDI7XHJcbiAgfSBlbHNlIHtcclxuICAgIHggPSB4Lm1pbnVzKHQudGltZXMocGkpKTtcclxuXHJcbiAgICAvLyAwIDw9IHggPCBwaVxyXG4gICAgaWYgKHgubHRlKGhhbGZQaSkpIHtcclxuICAgICAgcXVhZHJhbnQgPSBpc09kZCh0KSA/IChpc05lZyA/IDIgOiAzKSA6IChpc05lZyA/IDQgOiAxKTtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgcXVhZHJhbnQgPSBpc09kZCh0KSA/IChpc05lZyA/IDEgOiA0KSA6IChpc05lZyA/IDMgOiAyKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB4Lm1pbnVzKHBpKS5hYnMoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgRGVjaW1hbCBgeGAgYXMgYSBzdHJpbmcgaW4gYmFzZSBgYmFzZU91dGAuXHJcbiAqXHJcbiAqIElmIHRoZSBvcHRpb25hbCBgc2RgIGFyZ3VtZW50IGlzIHByZXNlbnQgaW5jbHVkZSBhIGJpbmFyeSBleHBvbmVudCBzdWZmaXguXHJcbiAqL1xyXG5mdW5jdGlvbiB0b1N0cmluZ0JpbmFyeSh4LCBiYXNlT3V0LCBzZCwgcm0pIHtcclxuICB2YXIgYmFzZSwgZSwgaSwgaywgbGVuLCByb3VuZFVwLCBzdHIsIHhkLCB5LFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICBpc0V4cCA9IHNkICE9PSB2b2lkIDA7XHJcblxyXG4gIGlmIChpc0V4cCkge1xyXG4gICAgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XHJcbiAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcclxuICB9IGVsc2Uge1xyXG4gICAgc2QgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICB9XHJcblxyXG4gIGlmICgheC5pc0Zpbml0ZSgpKSB7XHJcbiAgICBzdHIgPSBub25GaW5pdGVUb1N0cmluZyh4KTtcclxuICB9IGVsc2Uge1xyXG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCk7XHJcbiAgICBpID0gc3RyLmluZGV4T2YoJy4nKTtcclxuXHJcbiAgICAvLyBVc2UgZXhwb25lbnRpYWwgbm90YXRpb24gYWNjb3JkaW5nIHRvIGB0b0V4cFBvc2AgYW5kIGB0b0V4cE5lZ2A/IE5vLCBidXQgaWYgcmVxdWlyZWQ6XHJcbiAgICAvLyBtYXhCaW5hcnlFeHBvbmVudCA9IGZsb29yKChkZWNpbWFsRXhwb25lbnQgKyAxKSAqIGxvZ1syXSgxMCkpXHJcbiAgICAvLyBtaW5CaW5hcnlFeHBvbmVudCA9IGZsb29yKGRlY2ltYWxFeHBvbmVudCAqIGxvZ1syXSgxMCkpXHJcbiAgICAvLyBsb2dbMl0oMTApID0gMy4zMjE5MjgwOTQ4ODczNjIzNDc4NzAzMTk0Mjk0ODkzOTAxNzU4NjRcclxuXHJcbiAgICBpZiAoaXNFeHApIHtcclxuICAgICAgYmFzZSA9IDI7XHJcbiAgICAgIGlmIChiYXNlT3V0ID09IDE2KSB7XHJcbiAgICAgICAgc2QgPSBzZCAqIDQgLSAzO1xyXG4gICAgICB9IGVsc2UgaWYgKGJhc2VPdXQgPT0gOCkge1xyXG4gICAgICAgIHNkID0gc2QgKiAzIC0gMjtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYmFzZSA9IGJhc2VPdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGFuIGludGVnZXIgdGhlbiBkaXZpZGUgdGhlIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlciBzdWNoXHJcbiAgICAvLyB0aGF0IHRoZSBmcmFjdGlvbiBwYXJ0IHdpbGwgYmUgcmVzdG9yZWQuXHJcblxyXG4gICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICB5ID0gbmV3IEN0b3IoMSk7XHJcbiAgICAgIHkuZSA9IHN0ci5sZW5ndGggLSBpO1xyXG4gICAgICB5LmQgPSBjb252ZXJ0QmFzZShmaW5pdGVUb1N0cmluZyh5KSwgMTAsIGJhc2UpO1xyXG4gICAgICB5LmUgPSB5LmQubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIHhkID0gY29udmVydEJhc2Uoc3RyLCAxMCwgYmFzZSk7XHJcbiAgICBlID0gbGVuID0geGQubGVuZ3RoO1xyXG5cclxuICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoOyB4ZFstLWxlbl0gPT0gMDspIHhkLnBvcCgpO1xyXG5cclxuICAgIGlmICgheGRbMF0pIHtcclxuICAgICAgc3RyID0gaXNFeHAgPyAnMHArMCcgOiAnMCc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICBlLS07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeCA9IG5ldyBDdG9yKHgpO1xyXG4gICAgICAgIHguZCA9IHhkO1xyXG4gICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgeCA9IGRpdmlkZSh4LCB5LCBzZCwgcm0sIDAsIGJhc2UpO1xyXG4gICAgICAgIHhkID0geC5kO1xyXG4gICAgICAgIGUgPSB4LmU7XHJcbiAgICAgICAgcm91bmRVcCA9IGluZXhhY3Q7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoZSByb3VuZGluZyBkaWdpdCwgaS5lLiB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgIGkgPSB4ZFtzZF07XHJcbiAgICAgIGsgPSBiYXNlIC8gMjtcclxuICAgICAgcm91bmRVcCA9IHJvdW5kVXAgfHwgeGRbc2QgKyAxXSAhPT0gdm9pZCAwO1xyXG5cclxuICAgICAgcm91bmRVcCA9IHJtIDwgNFxyXG4gICAgICAgID8gKGkgIT09IHZvaWQgMCB8fCByb3VuZFVwKSAmJiAocm0gPT09IDAgfHwgcm0gPT09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgIDogaSA+IGsgfHwgaSA9PT0gayAmJiAocm0gPT09IDQgfHwgcm91bmRVcCB8fCBybSA9PT0gNiAmJiB4ZFtzZCAtIDFdICYgMSB8fFxyXG4gICAgICAgICAgcm0gPT09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgIHhkLmxlbmd0aCA9IHNkO1xyXG5cclxuICAgICAgaWYgKHJvdW5kVXApIHtcclxuXHJcbiAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICBmb3IgKDsgKyt4ZFstLXNkXSA+IGJhc2UgLSAxOykge1xyXG4gICAgICAgICAgeGRbc2RdID0gMDtcclxuICAgICAgICAgIGlmICghc2QpIHtcclxuICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICB4ZC51bnNoaWZ0KDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGxlbiA9IHhkLmxlbmd0aDsgIXhkW2xlbiAtIDFdOyAtLWxlbik7XHJcblxyXG4gICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICBmb3IgKGkgPSAwLCBzdHIgPSAnJzsgaSA8IGxlbjsgaSsrKSBzdHIgKz0gTlVNRVJBTFMuY2hhckF0KHhkW2ldKTtcclxuXHJcbiAgICAgIC8vIEFkZCBiaW5hcnkgZXhwb25lbnQgc3VmZml4P1xyXG4gICAgICBpZiAoaXNFeHApIHtcclxuICAgICAgICBpZiAobGVuID4gMSkge1xyXG4gICAgICAgICAgaWYgKGJhc2VPdXQgPT0gMTYgfHwgYmFzZU91dCA9PSA4KSB7XHJcbiAgICAgICAgICAgIGkgPSBiYXNlT3V0ID09IDE2ID8gNCA6IDM7XHJcbiAgICAgICAgICAgIGZvciAoLS1sZW47IGxlbiAlIGk7IGxlbisrKSBzdHIgKz0gJzAnO1xyXG4gICAgICAgICAgICB4ZCA9IGNvbnZlcnRCYXNlKHN0ciwgYmFzZSwgYmFzZU91dCk7XHJcbiAgICAgICAgICAgIGZvciAobGVuID0geGQubGVuZ3RoOyAheGRbbGVuIC0gMV07IC0tbGVuKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHhkWzBdIHdpbGwgYWx3YXlzIGJlIGJlIDFcclxuICAgICAgICAgICAgZm9yIChpID0gMSwgc3RyID0gJzEuJzsgaSA8IGxlbjsgaSsrKSBzdHIgKz0gTlVNRVJBTFMuY2hhckF0KHhkW2ldKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSAgc3RyICsgKGUgPCAwID8gJ3AnIDogJ3ArJykgKyBlO1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcbiAgICAgICAgZm9yICg7ICsrZTspIHN0ciA9ICcwJyArIHN0cjtcclxuICAgICAgICBzdHIgPSAnMC4nICsgc3RyO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICgrK2UgPiBsZW4pIGZvciAoZSAtPSBsZW47IGUtLSA7KSBzdHIgKz0gJzAnO1xyXG4gICAgICAgIGVsc2UgaWYgKGUgPCBsZW4pIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0ciA9IChiYXNlT3V0ID09IDE2ID8gJzB4JyA6IGJhc2VPdXQgPT0gMiA/ICcwYicgOiBiYXNlT3V0ID09IDggPyAnMG8nIDogJycpICsgc3RyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHgucyA8IDAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbn1cclxuXHJcblxyXG4vLyBEb2VzIG5vdCBzdHJpcCB0cmFpbGluZyB6ZXJvcy5cclxuZnVuY3Rpb24gdHJ1bmNhdGUoYXJyLCBsZW4pIHtcclxuICBpZiAoYXJyLmxlbmd0aCA+IGxlbikge1xyXG4gICAgYXJyLmxlbmd0aCA9IGxlbjtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8vIERlY2ltYWwgbWV0aG9kc1xyXG5cclxuXHJcbi8qXHJcbiAqICBhYnNcclxuICogIGFjb3NcclxuICogIGFjb3NoXHJcbiAqICBhZGRcclxuICogIGFzaW5cclxuICogIGFzaW5oXHJcbiAqICBhdGFuXHJcbiAqICBhdGFuaFxyXG4gKiAgYXRhbjJcclxuICogIGNicnRcclxuICogIGNlaWxcclxuICogIGNsYW1wXHJcbiAqICBjbG9uZVxyXG4gKiAgY29uZmlnXHJcbiAqICBjb3NcclxuICogIGNvc2hcclxuICogIGRpdlxyXG4gKiAgZXhwXHJcbiAqICBmbG9vclxyXG4gKiAgaHlwb3RcclxuICogIGxuXHJcbiAqICBsb2dcclxuICogIGxvZzJcclxuICogIGxvZzEwXHJcbiAqICBtYXhcclxuICogIG1pblxyXG4gKiAgbW9kXHJcbiAqICBtdWxcclxuICogIHBvd1xyXG4gKiAgcmFuZG9tXHJcbiAqICByb3VuZFxyXG4gKiAgc2V0XHJcbiAqICBzaWduXHJcbiAqICBzaW5cclxuICogIHNpbmhcclxuICogIHNxcnRcclxuICogIHN1YlxyXG4gKiAgc3VtXHJcbiAqICB0YW5cclxuICogIHRhbmhcclxuICogIHRydW5jXHJcbiAqL1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBgeGAuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGFicyh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFicygpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGFyY2Nvc2luZSBpbiByYWRpYW5zIG9mIGB4YC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gYWNvcyh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFjb3MoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBpbnZlcnNlIG9mIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiBgeGAsIHJvdW5kZWQgdG9cclxuICogYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBhY29zaCh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFjb3NoKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIGB4YCBhbmQgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICogeSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gYWRkKHgsIHkpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkucGx1cyh5KTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmNzaW5lIGluIHJhZGlhbnMgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGFzaW4oeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5hc2luKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaHlwZXJib2xpYyBzaW5lIG9mIGB4YCwgcm91bmRlZCB0b1xyXG4gKiBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGFzaW5oKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuYXNpbmgoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmN0YW5nZW50IGluIHJhZGlhbnMgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGF0YW4oeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5hdGFuKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaHlwZXJib2xpYyB0YW5nZW50IG9mIGB4YCwgcm91bmRlZCB0b1xyXG4gKiBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGF0YW5oKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuYXRhbmgoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmN0YW5nZW50IGluIHJhZGlhbnMgb2YgYHkveGAgaW4gdGhlIHJhbmdlIC1waSB0byBwaVxyXG4gKiAoaW5jbHVzaXZlKSwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gKiBSYW5nZTogWy1waSwgcGldXHJcbiAqXHJcbiAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIHktY29vcmRpbmF0ZS5cclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgeC1jb29yZGluYXRlLlxyXG4gKlxyXG4gKiBhdGFuMijCsTAsIC0wKSAgICAgICAgICAgICAgID0gwrFwaVxyXG4gKiBhdGFuMijCsTAsICswKSAgICAgICAgICAgICAgID0gwrEwXHJcbiAqIGF0YW4yKMKxMCwgLXgpICAgICAgICAgICAgICAgPSDCsXBpIGZvciB4ID4gMFxyXG4gKiBhdGFuMijCsTAsIHgpICAgICAgICAgICAgICAgID0gwrEwIGZvciB4ID4gMFxyXG4gKiBhdGFuMigteSwgwrEwKSAgICAgICAgICAgICAgID0gLXBpLzIgZm9yIHkgPiAwXHJcbiAqIGF0YW4yKHksIMKxMCkgICAgICAgICAgICAgICAgPSBwaS8yIGZvciB5ID4gMFxyXG4gKiBhdGFuMijCsXksIC1JbmZpbml0eSkgICAgICAgID0gwrFwaSBmb3IgZmluaXRlIHkgPiAwXHJcbiAqIGF0YW4yKMKxeSwgK0luZmluaXR5KSAgICAgICAgPSDCsTAgZm9yIGZpbml0ZSB5ID4gMFxyXG4gKiBhdGFuMijCsUluZmluaXR5LCB4KSAgICAgICAgID0gwrFwaS8yIGZvciBmaW5pdGUgeFxyXG4gKiBhdGFuMijCsUluZmluaXR5LCAtSW5maW5pdHkpID0gwrEzKnBpLzRcclxuICogYXRhbjIowrFJbmZpbml0eSwgK0luZmluaXR5KSA9IMKxcGkvNFxyXG4gKiBhdGFuMihOYU4sIHgpID0gTmFOXHJcbiAqIGF0YW4yKHksIE5hTikgPSBOYU5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGF0YW4yKHksIHgpIHtcclxuICB5ID0gbmV3IHRoaXMoeSk7XHJcbiAgeCA9IG5ldyB0aGlzKHgpO1xyXG4gIHZhciByLFxyXG4gICAgcHIgPSB0aGlzLnByZWNpc2lvbixcclxuICAgIHJtID0gdGhpcy5yb3VuZGluZyxcclxuICAgIHdwciA9IHByICsgNDtcclxuXHJcbiAgLy8gRWl0aGVyIE5hTlxyXG4gIGlmICgheS5zIHx8ICF4LnMpIHtcclxuICAgIHIgPSBuZXcgdGhpcyhOYU4pO1xyXG5cclxuICAvLyBCb3RoIMKxSW5maW5pdHlcclxuICB9IGVsc2UgaWYgKCF5LmQgJiYgIXguZCkge1xyXG4gICAgciA9IGdldFBpKHRoaXMsIHdwciwgMSkudGltZXMoeC5zID4gMCA/IDAuMjUgOiAwLjc1KTtcclxuICAgIHIucyA9IHkucztcclxuXHJcbiAgLy8geCBpcyDCsUluZmluaXR5IG9yIHkgaXMgwrEwXHJcbiAgfSBlbHNlIGlmICgheC5kIHx8IHkuaXNaZXJvKCkpIHtcclxuICAgIHIgPSB4LnMgPCAwID8gZ2V0UGkodGhpcywgcHIsIHJtKSA6IG5ldyB0aGlzKDApO1xyXG4gICAgci5zID0geS5zO1xyXG5cclxuICAvLyB5IGlzIMKxSW5maW5pdHkgb3IgeCBpcyDCsTBcclxuICB9IGVsc2UgaWYgKCF5LmQgfHwgeC5pc1plcm8oKSkge1xyXG4gICAgciA9IGdldFBpKHRoaXMsIHdwciwgMSkudGltZXMoMC41KTtcclxuICAgIHIucyA9IHkucztcclxuXHJcbiAgLy8gQm90aCBub24temVybyBhbmQgZmluaXRlXHJcbiAgfSBlbHNlIGlmICh4LnMgPCAwKSB7XHJcbiAgICB0aGlzLnByZWNpc2lvbiA9IHdwcjtcclxuICAgIHRoaXMucm91bmRpbmcgPSAxO1xyXG4gICAgciA9IHRoaXMuYXRhbihkaXZpZGUoeSwgeCwgd3ByLCAxKSk7XHJcbiAgICB4ID0gZ2V0UGkodGhpcywgd3ByLCAxKTtcclxuICAgIHRoaXMucHJlY2lzaW9uID0gcHI7XHJcbiAgICB0aGlzLnJvdW5kaW5nID0gcm07XHJcbiAgICByID0geS5zIDwgMCA/IHIubWludXMoeCkgOiByLnBsdXMoeCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHIgPSB0aGlzLmF0YW4oZGl2aWRlKHksIHgsIHdwciwgMSkpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHI7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgY3ViZSByb290IG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gKiBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjYnJ0KHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuY2JydCgpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIHJvdW5kZWQgdG8gYW4gaW50ZWdlciB1c2luZyBgUk9VTkRfQ0VJTGAuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGNlaWwoeCkge1xyXG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIDIpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIGNsYW1wZWQgdG8gdGhlIHJhbmdlIGRlbGluZWF0ZWQgYnkgYG1pbmAgYW5kIGBtYXhgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqIG1pbiB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKiBtYXgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGNsYW1wKHgsIG1pbiwgbWF4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmNsYW1wKG1pbiwgbWF4KTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIENvbmZpZ3VyZSBnbG9iYWwgc2V0dGluZ3MgZm9yIGEgRGVjaW1hbCBjb25zdHJ1Y3Rvci5cclxuICpcclxuICogYG9iamAgaXMgYW4gb2JqZWN0IHdpdGggb25lIG9yIG1vcmUgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzLFxyXG4gKlxyXG4gKiAgIHByZWNpc2lvbiAge251bWJlcn1cclxuICogICByb3VuZGluZyAgIHtudW1iZXJ9XHJcbiAqICAgdG9FeHBOZWcgICB7bnVtYmVyfVxyXG4gKiAgIHRvRXhwUG9zICAge251bWJlcn1cclxuICogICBtYXhFICAgICAgIHtudW1iZXJ9XHJcbiAqICAgbWluRSAgICAgICB7bnVtYmVyfVxyXG4gKiAgIG1vZHVsbyAgICAge251bWJlcn1cclxuICogICBjcnlwdG8gICAgIHtib29sZWFufG51bWJlcn1cclxuICogICBkZWZhdWx0cyAgIHt0cnVlfVxyXG4gKlxyXG4gKiBFLmcuIERlY2ltYWwuY29uZmlnKHsgcHJlY2lzaW9uOiAyMCwgcm91bmRpbmc6IDQgfSlcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGNvbmZpZyhvYmopIHtcclxuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgdGhyb3cgRXJyb3IoZGVjaW1hbEVycm9yICsgJ09iamVjdCBleHBlY3RlZCcpO1xyXG4gIHZhciBpLCBwLCB2LFxyXG4gICAgdXNlRGVmYXVsdHMgPSBvYmouZGVmYXVsdHMgPT09IHRydWUsXHJcbiAgICBwcyA9IFtcclxuICAgICAgJ3ByZWNpc2lvbicsIDEsIE1BWF9ESUdJVFMsXHJcbiAgICAgICdyb3VuZGluZycsIDAsIDgsXHJcbiAgICAgICd0b0V4cE5lZycsIC1FWFBfTElNSVQsIDAsXHJcbiAgICAgICd0b0V4cFBvcycsIDAsIEVYUF9MSU1JVCxcclxuICAgICAgJ21heEUnLCAwLCBFWFBfTElNSVQsXHJcbiAgICAgICdtaW5FJywgLUVYUF9MSU1JVCwgMCxcclxuICAgICAgJ21vZHVsbycsIDAsIDlcclxuICAgIF07XHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgaWYgKHAgPSBwc1tpXSwgdXNlRGVmYXVsdHMpIHRoaXNbcF0gPSBERUZBVUxUU1twXTtcclxuICAgIGlmICgodiA9IG9ialtwXSkgIT09IHZvaWQgMCkge1xyXG4gICAgICBpZiAobWF0aGZsb29yKHYpID09PSB2ICYmIHYgPj0gcHNbaSArIDFdICYmIHYgPD0gcHNbaSArIDJdKSB0aGlzW3BdID0gdjtcclxuICAgICAgZWxzZSB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBwICsgJzogJyArIHYpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHAgPSAnY3J5cHRvJywgdXNlRGVmYXVsdHMpIHRoaXNbcF0gPSBERUZBVUxUU1twXTtcclxuICBpZiAoKHYgPSBvYmpbcF0pICE9PSB2b2lkIDApIHtcclxuICAgIGlmICh2ID09PSB0cnVlIHx8IHYgPT09IGZhbHNlIHx8IHYgPT09IDAgfHwgdiA9PT0gMSkge1xyXG4gICAgICBpZiAodikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0byAmJlxyXG4gICAgICAgICAgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xyXG4gICAgICAgICAgdGhpc1twXSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRocm93IEVycm9yKGNyeXB0b1VuYXZhaWxhYmxlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpc1twXSA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBwICsgJzogJyArIHYpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgY29zaW5lIG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gKiBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGNvcyh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmNvcygpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGh5cGVyYm9saWMgY29zaW5lIG9mIGB4YCwgcm91bmRlZCB0byBwcmVjaXNpb25cclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjb3NoKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuY29zaCgpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBEZWNpbWFsIGNvbnN0cnVjdG9yIHdpdGggdGhlIHNhbWUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIGFzIHRoaXMgRGVjaW1hbFxyXG4gKiBjb25zdHJ1Y3Rvci5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGNsb25lKG9iaikge1xyXG4gIHZhciBpLCBwLCBwcztcclxuXHJcbiAgLypcclxuICAgKiBUaGUgRGVjaW1hbCBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiB2IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIERlY2ltYWwodikge1xyXG4gICAgdmFyIGUsIGksIHQsXHJcbiAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgIC8vIERlY2ltYWwgY2FsbGVkIHdpdGhvdXQgbmV3LlxyXG4gICAgaWYgKCEoeCBpbnN0YW5jZW9mIERlY2ltYWwpKSByZXR1cm4gbmV3IERlY2ltYWwodik7XHJcblxyXG4gICAgLy8gUmV0YWluIGEgcmVmZXJlbmNlIHRvIHRoaXMgRGVjaW1hbCBjb25zdHJ1Y3RvciwgYW5kIHNoYWRvdyBEZWNpbWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvclxyXG4gICAgLy8gd2hpY2ggcG9pbnRzIHRvIE9iamVjdC5cclxuICAgIHguY29uc3RydWN0b3IgPSBEZWNpbWFsO1xyXG5cclxuICAgIC8vIER1cGxpY2F0ZS5cclxuICAgIGlmIChpc0RlY2ltYWxJbnN0YW5jZSh2KSkge1xyXG4gICAgICB4LnMgPSB2LnM7XHJcblxyXG4gICAgICBpZiAoZXh0ZXJuYWwpIHtcclxuICAgICAgICBpZiAoIXYuZCB8fCB2LmUgPiBEZWNpbWFsLm1heEUpIHtcclxuXHJcbiAgICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICAgIHguZSA9IE5hTjtcclxuICAgICAgICAgIHguZCA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmICh2LmUgPCBEZWNpbWFsLm1pbkUpIHtcclxuXHJcbiAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgeC5lID0gMDtcclxuICAgICAgICAgIHguZCA9IFswXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5lID0gdi5lO1xyXG4gICAgICAgICAgeC5kID0gdi5kLnNsaWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHguZSA9IHYuZTtcclxuICAgICAgICB4LmQgPSB2LmQgPyB2LmQuc2xpY2UoKSA6IHYuZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHQgPSB0eXBlb2YgdjtcclxuXHJcbiAgICBpZiAodCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgaWYgKHYgPT09IDApIHtcclxuICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgeC5lID0gMDtcclxuICAgICAgICB4LmQgPSBbMF07XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodiA8IDApIHtcclxuICAgICAgICB2ID0gLXY7XHJcbiAgICAgICAgeC5zID0gLTE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeC5zID0gMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRmFzdCBwYXRoIGZvciBzbWFsbCBpbnRlZ2Vycy5cclxuICAgICAgaWYgKHYgPT09IH5+diAmJiB2IDwgMWU3KSB7XHJcbiAgICAgICAgZm9yIChlID0gMCwgaSA9IHY7IGkgPj0gMTA7IGkgLz0gMTApIGUrKztcclxuXHJcbiAgICAgICAgaWYgKGV4dGVybmFsKSB7XHJcbiAgICAgICAgICBpZiAoZSA+IERlY2ltYWwubWF4RSkge1xyXG4gICAgICAgICAgICB4LmUgPSBOYU47XHJcbiAgICAgICAgICAgIHguZCA9IG51bGw7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGUgPCBEZWNpbWFsLm1pbkUpIHtcclxuICAgICAgICAgICAgeC5lID0gMDtcclxuICAgICAgICAgICAgeC5kID0gWzBdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgICAgeC5kID0gW3ZdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgeC5kID0gW3ZdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgLy8gSW5maW5pdHksIE5hTi5cclxuICAgICAgfSBlbHNlIGlmICh2ICogMCAhPT0gMCkge1xyXG4gICAgICAgIGlmICghdikgeC5zID0gTmFOO1xyXG4gICAgICAgIHguZSA9IE5hTjtcclxuICAgICAgICB4LmQgPSBudWxsO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHBhcnNlRGVjaW1hbCh4LCB2LnRvU3RyaW5nKCkpO1xyXG5cclxuICAgIH0gZWxzZSBpZiAodCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgdik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWludXMgc2lnbj9cclxuICAgIGlmICgoaSA9IHYuY2hhckNvZGVBdCgwKSkgPT09IDQ1KSB7XHJcbiAgICAgIHYgPSB2LnNsaWNlKDEpO1xyXG4gICAgICB4LnMgPSAtMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFBsdXMgc2lnbj9cclxuICAgICAgaWYgKGkgPT09IDQzKSB2ID0gdi5zbGljZSgxKTtcclxuICAgICAgeC5zID0gMTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXNEZWNpbWFsLnRlc3QodikgPyBwYXJzZURlY2ltYWwoeCwgdikgOiBwYXJzZU90aGVyKHgsIHYpO1xyXG4gIH1cclxuXHJcbiAgRGVjaW1hbC5wcm90b3R5cGUgPSBQO1xyXG5cclxuICBEZWNpbWFsLlJPVU5EX1VQID0gMDtcclxuICBEZWNpbWFsLlJPVU5EX0RPV04gPSAxO1xyXG4gIERlY2ltYWwuUk9VTkRfQ0VJTCA9IDI7XHJcbiAgRGVjaW1hbC5ST1VORF9GTE9PUiA9IDM7XHJcbiAgRGVjaW1hbC5ST1VORF9IQUxGX1VQID0gNDtcclxuICBEZWNpbWFsLlJPVU5EX0hBTEZfRE9XTiA9IDU7XHJcbiAgRGVjaW1hbC5ST1VORF9IQUxGX0VWRU4gPSA2O1xyXG4gIERlY2ltYWwuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICBEZWNpbWFsLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xyXG4gIERlY2ltYWwuRVVDTElEID0gOTtcclxuXHJcbiAgRGVjaW1hbC5jb25maWcgPSBEZWNpbWFsLnNldCA9IGNvbmZpZztcclxuICBEZWNpbWFsLmNsb25lID0gY2xvbmU7XHJcbiAgRGVjaW1hbC5pc0RlY2ltYWwgPSBpc0RlY2ltYWxJbnN0YW5jZTtcclxuXHJcbiAgRGVjaW1hbC5hYnMgPSBhYnM7XHJcbiAgRGVjaW1hbC5hY29zID0gYWNvcztcclxuICBEZWNpbWFsLmFjb3NoID0gYWNvc2g7ICAgICAgICAvLyBFUzZcclxuICBEZWNpbWFsLmFkZCA9IGFkZDtcclxuICBEZWNpbWFsLmFzaW4gPSBhc2luO1xyXG4gIERlY2ltYWwuYXNpbmggPSBhc2luaDsgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwuYXRhbiA9IGF0YW47XHJcbiAgRGVjaW1hbC5hdGFuaCA9IGF0YW5oOyAgICAgICAgLy8gRVM2XHJcbiAgRGVjaW1hbC5hdGFuMiA9IGF0YW4yO1xyXG4gIERlY2ltYWwuY2JydCA9IGNicnQ7ICAgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwuY2VpbCA9IGNlaWw7XHJcbiAgRGVjaW1hbC5jbGFtcCA9IGNsYW1wO1xyXG4gIERlY2ltYWwuY29zID0gY29zO1xyXG4gIERlY2ltYWwuY29zaCA9IGNvc2g7ICAgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwuZGl2ID0gZGl2O1xyXG4gIERlY2ltYWwuZXhwID0gZXhwO1xyXG4gIERlY2ltYWwuZmxvb3IgPSBmbG9vcjtcclxuICBEZWNpbWFsLmh5cG90ID0gaHlwb3Q7ICAgICAgICAvLyBFUzZcclxuICBEZWNpbWFsLmxuID0gbG47XHJcbiAgRGVjaW1hbC5sb2cgPSBsb2c7XHJcbiAgRGVjaW1hbC5sb2cxMCA9IGxvZzEwOyAgICAgICAgLy8gRVM2XHJcbiAgRGVjaW1hbC5sb2cyID0gbG9nMjsgICAgICAgICAgLy8gRVM2XHJcbiAgRGVjaW1hbC5tYXggPSBtYXg7XHJcbiAgRGVjaW1hbC5taW4gPSBtaW47XHJcbiAgRGVjaW1hbC5tb2QgPSBtb2Q7XHJcbiAgRGVjaW1hbC5tdWwgPSBtdWw7XHJcbiAgRGVjaW1hbC5wb3cgPSBwb3c7XHJcbiAgRGVjaW1hbC5yYW5kb20gPSByYW5kb207XHJcbiAgRGVjaW1hbC5yb3VuZCA9IHJvdW5kO1xyXG4gIERlY2ltYWwuc2lnbiA9IHNpZ247ICAgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwuc2luID0gc2luO1xyXG4gIERlY2ltYWwuc2luaCA9IHNpbmg7ICAgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwuc3FydCA9IHNxcnQ7XHJcbiAgRGVjaW1hbC5zdWIgPSBzdWI7XHJcbiAgRGVjaW1hbC5zdW0gPSBzdW07XHJcbiAgRGVjaW1hbC50YW4gPSB0YW47XHJcbiAgRGVjaW1hbC50YW5oID0gdGFuaDsgICAgICAgICAgLy8gRVM2XHJcbiAgRGVjaW1hbC50cnVuYyA9IHRydW5jOyAgICAgICAgLy8gRVM2XHJcblxyXG4gIGlmIChvYmogPT09IHZvaWQgMCkgb2JqID0ge307XHJcbiAgaWYgKG9iaikge1xyXG4gICAgaWYgKG9iai5kZWZhdWx0cyAhPT0gdHJ1ZSkge1xyXG4gICAgICBwcyA9IFsncHJlY2lzaW9uJywgJ3JvdW5kaW5nJywgJ3RvRXhwTmVnJywgJ3RvRXhwUG9zJywgJ21heEUnLCAnbWluRScsICdtb2R1bG8nLCAnY3J5cHRvJ107XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBwcy5sZW5ndGg7KSBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShwID0gcHNbaSsrXSkpIG9ialtwXSA9IHRoaXNbcF07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBEZWNpbWFsLmNvbmZpZyhvYmopO1xyXG5cclxuICByZXR1cm4gRGVjaW1hbDtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCBkaXZpZGVkIGJ5IGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gKiBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGRpdih4LCB5KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmRpdih5KTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGV4cG9uZW50aWFsIG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBwb3dlciB0byB3aGljaCB0byByYWlzZSB0aGUgYmFzZSBvZiB0aGUgbmF0dXJhbCBsb2cuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBleHAoeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5leHAoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCByb3VuZCB0byBhbiBpbnRlZ2VyIHVzaW5nIGBST1VORF9GTE9PUmAuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGZsb29yKHgpIHtcclxuICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCAzKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgc3VtIG9mIHRoZSBzcXVhcmVzIG9mIHRoZSBhcmd1bWVudHMsXHJcbiAqIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogaHlwb3QoYSwgYiwgLi4uKSA9IHNxcnQoYV4yICsgYl4yICsgLi4uKVxyXG4gKlxyXG4gKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGh5cG90KCkge1xyXG4gIHZhciBpLCBuLFxyXG4gICAgdCA9IG5ldyB0aGlzKDApO1xyXG5cclxuICBleHRlcm5hbCA9IGZhbHNlO1xyXG5cclxuICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDspIHtcclxuICAgIG4gPSBuZXcgdGhpcyhhcmd1bWVudHNbaSsrXSk7XHJcbiAgICBpZiAoIW4uZCkge1xyXG4gICAgICBpZiAobi5zKSB7XHJcbiAgICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcygxIC8gMCk7XHJcbiAgICAgIH1cclxuICAgICAgdCA9IG47XHJcbiAgICB9IGVsc2UgaWYgKHQuZCkge1xyXG4gICAgICB0ID0gdC5wbHVzKG4udGltZXMobikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICByZXR1cm4gdC5zcXJ0KCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiBvYmplY3QgaXMgYSBEZWNpbWFsIGluc3RhbmNlICh3aGVyZSBEZWNpbWFsIGlzIGFueSBEZWNpbWFsIGNvbnN0cnVjdG9yKSxcclxuICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGlzRGVjaW1hbEluc3RhbmNlKG9iaikge1xyXG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBEZWNpbWFsIHx8IG9iaiAmJiBvYmoudG9TdHJpbmdUYWcgPT09IHRhZyB8fCBmYWxzZTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gbG4oeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5sbigpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGxvZyBvZiBgeGAgdG8gdGhlIGJhc2UgYHlgLCBvciB0byBiYXNlIDEwIGlmIG5vIGJhc2VcclxuICogaXMgc3BlY2lmaWVkLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIGxvZ1t5XSh4KVxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBhcmd1bWVudCBvZiB0aGUgbG9nYXJpdGhtLlxyXG4gKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBiYXNlIG9mIHRoZSBsb2dhcml0aG0uXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2coeCwgeSkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5sb2coeSk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYmFzZSAyIGxvZ2FyaXRobSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gbG9nMih4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmxvZygyKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBiYXNlIDEwIGxvZ2FyaXRobSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gbG9nMTAoeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5sb2coMTApO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICpcclxuICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXgoKSB7XHJcbiAgcmV0dXJuIG1heE9yTWluKHRoaXMsIGFyZ3VtZW50cywgJ2x0Jyk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gKlxyXG4gKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIG1pbigpIHtcclxuICByZXR1cm4gbWF4T3JNaW4odGhpcywgYXJndW1lbnRzLCAnZ3QnKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCBtb2R1bG8gYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gKiB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICogeSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gbW9kKHgsIHkpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkubW9kKHkpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIG11bHRpcGxpZWQgYnkgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICogeSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gbXVsKHgsIHkpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkubXVsKHkpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIHJhaXNlZCB0byB0aGUgcG93ZXIgYHlgLCByb3VuZGVkIHRvIHByZWNpc2lvblxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBiYXNlLlxyXG4gKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBleHBvbmVudC5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHBvdyh4LCB5KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnBvdyh5KTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybnMgYSBuZXcgRGVjaW1hbCB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSwgYW5kIHdpdGhcclxuICogYHNkYCwgb3IgYERlY2ltYWwucHJlY2lzaW9uYCBpZiBgc2RgIGlzIG9taXR0ZWQsIHNpZ25pZmljYW50IGRpZ2l0cyAob3IgbGVzcyBpZiB0cmFpbGluZyB6ZXJvc1xyXG4gKiBhcmUgcHJvZHVjZWQpLlxyXG4gKlxyXG4gKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMCB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHJhbmRvbShzZCkge1xyXG4gIHZhciBkLCBlLCBrLCBuLFxyXG4gICAgaSA9IDAsXHJcbiAgICByID0gbmV3IHRoaXMoMSksXHJcbiAgICByZCA9IFtdO1xyXG5cclxuICBpZiAoc2QgPT09IHZvaWQgMCkgc2QgPSB0aGlzLnByZWNpc2lvbjtcclxuICBlbHNlIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xyXG5cclxuICBrID0gTWF0aC5jZWlsKHNkIC8gTE9HX0JBU0UpO1xyXG5cclxuICBpZiAoIXRoaXMuY3J5cHRvKSB7XHJcbiAgICBmb3IgKDsgaSA8IGs7KSByZFtpKytdID0gTWF0aC5yYW5kb20oKSAqIDFlNyB8IDA7XHJcblxyXG4gIC8vIEJyb3dzZXJzIHN1cHBvcnRpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5cclxuICB9IGVsc2UgaWYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcclxuICAgIGQgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrKSk7XHJcblxyXG4gICAgZm9yICg7IGkgPCBrOykge1xyXG4gICAgICBuID0gZFtpXTtcclxuXHJcbiAgICAgIC8vIDAgPD0gbiA8IDQyOTQ5NjcyOTZcclxuICAgICAgLy8gUHJvYmFiaWxpdHkgbiA+PSA0LjI5ZTksIGlzIDQ5NjcyOTYgLyA0Mjk0OTY3Mjk2ID0gMC4wMDExNiAoMSBpbiA4NjUpLlxyXG4gICAgICBpZiAobiA+PSA0LjI5ZTkpIHtcclxuICAgICAgICBkW2ldID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyAwIDw9IG4gPD0gNDI4OTk5OTk5OVxyXG4gICAgICAgIC8vIDAgPD0gKG4gJSAxZTcpIDw9IDk5OTk5OTlcclxuICAgICAgICByZFtpKytdID0gbiAlIDFlNztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XHJcblxyXG4gICAgLy8gYnVmZmVyXHJcbiAgICBkID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNCk7XHJcblxyXG4gICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgLy8gMCA8PSBuIDwgMjE0NzQ4MzY0OFxyXG4gICAgICBuID0gZFtpXSArIChkW2kgKyAxXSA8PCA4KSArIChkW2kgKyAyXSA8PCAxNikgKyAoKGRbaSArIDNdICYgMHg3ZikgPDwgMjQpO1xyXG5cclxuICAgICAgLy8gUHJvYmFiaWxpdHkgbiA+PSAyLjE0ZTksIGlzIDc0ODM2NDggLyAyMTQ3NDgzNjQ4ID0gMC4wMDM1ICgxIGluIDI4NikuXHJcbiAgICAgIGlmIChuID49IDIuMTRlOSkge1xyXG4gICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg0KS5jb3B5KGQsIGkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyAwIDw9IG4gPD0gMjEzOTk5OTk5OVxyXG4gICAgICAgIC8vIDAgPD0gKG4gJSAxZTcpIDw9IDk5OTk5OTlcclxuICAgICAgICByZC5wdXNoKG4gJSAxZTcpO1xyXG4gICAgICAgIGkgKz0gNDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGkgPSBrIC8gNDtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgRXJyb3IoY3J5cHRvVW5hdmFpbGFibGUpO1xyXG4gIH1cclxuXHJcbiAgayA9IHJkWy0taV07XHJcbiAgc2QgJT0gTE9HX0JBU0U7XHJcblxyXG4gIC8vIENvbnZlcnQgdHJhaWxpbmcgZGlnaXRzIHRvIHplcm9zIGFjY29yZGluZyB0byBzZC5cclxuICBpZiAoayAmJiBzZCkge1xyXG4gICAgbiA9IG1hdGhwb3coMTAsIExPR19CQVNFIC0gc2QpO1xyXG4gICAgcmRbaV0gPSAoayAvIG4gfCAwKSAqIG47XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgd29yZHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgZm9yICg7IHJkW2ldID09PSAwOyBpLS0pIHJkLnBvcCgpO1xyXG5cclxuICAvLyBaZXJvP1xyXG4gIGlmIChpIDwgMCkge1xyXG4gICAgZSA9IDA7XHJcbiAgICByZCA9IFswXTtcclxuICB9IGVsc2Uge1xyXG4gICAgZSA9IC0xO1xyXG5cclxuICAgIC8vIFJlbW92ZSBsZWFkaW5nIHdvcmRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICBmb3IgKDsgcmRbMF0gPT09IDA7IGUgLT0gTE9HX0JBU0UpIHJkLnNoaWZ0KCk7XHJcblxyXG4gICAgLy8gQ291bnQgdGhlIGRpZ2l0cyBvZiB0aGUgZmlyc3Qgd29yZCBvZiByZCB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgIGZvciAoayA9IDEsIG4gPSByZFswXTsgbiA+PSAxMDsgbiAvPSAxMCkgaysrO1xyXG5cclxuICAgIC8vIEFkanVzdCB0aGUgZXhwb25lbnQgZm9yIGxlYWRpbmcgemVyb3Mgb2YgdGhlIGZpcnN0IHdvcmQgb2YgcmQuXHJcbiAgICBpZiAoayA8IExPR19CQVNFKSBlIC09IExPR19CQVNFIC0gaztcclxuICB9XHJcblxyXG4gIHIuZSA9IGU7XHJcbiAgci5kID0gcmQ7XHJcblxyXG4gIHJldHVybiByO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIHJvdW5kZWQgdG8gYW4gaW50ZWdlciB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIFRvIGVtdWxhdGUgYE1hdGgucm91bmRgLCBzZXQgcm91bmRpbmcgdG8gNyAoUk9VTkRfSEFMRl9DRUlMKS5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gcm91bmQoeCkge1xyXG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIHRoaXMucm91bmRpbmcpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuXHJcbiAqICAgMSAgICBpZiB4ID4gMCxcclxuICogIC0xICAgIGlmIHggPCAwLFxyXG4gKiAgIDAgICAgaWYgeCBpcyAwLFxyXG4gKiAgLTAgICAgaWYgeCBpcyAtMCxcclxuICogICBOYU4gIG90aGVyd2lzZVxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBzaWduKHgpIHtcclxuICB4ID0gbmV3IHRoaXMoeCk7XHJcbiAgcmV0dXJuIHguZCA/ICh4LmRbMF0gPyB4LnMgOiAwICogeC5zKSA6IHgucyB8fCBOYU47XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc2luZSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBzaW4oeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5zaW4oKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBoeXBlcmJvbGljIHNpbmUgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gc2luaCh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnNpbmgoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gc3FydCh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnNxcnQoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCBtaW51cyBgeWAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBzdWIoeCwgeSkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5zdWIoeSk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBhcmd1bWVudHMsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogT25seSB0aGUgcmVzdWx0IGlzIHJvdW5kZWQsIG5vdCB0aGUgaW50ZXJtZWRpYXRlIGNhbGN1bGF0aW9ucy5cclxuICpcclxuICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBzdW0oKSB7XHJcbiAgdmFyIGkgPSAwLFxyXG4gICAgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgIHggPSBuZXcgdGhpcyhhcmdzW2ldKTtcclxuXHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICBmb3IgKDsgeC5zICYmICsraSA8IGFyZ3MubGVuZ3RoOykgeCA9IHgucGx1cyhhcmdzW2ldKTtcclxuICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZSh4LCB0aGlzLnByZWNpc2lvbiwgdGhpcy5yb3VuZGluZyk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdGFuZ2VudCBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiB0YW4oeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS50YW4oKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gdGFuaCh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnRhbmgoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCB0cnVuY2F0ZWQgdG8gYW4gaW50ZWdlci5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gdHJ1bmMoeCkge1xyXG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIDEpO1xyXG59XHJcblxyXG5cclxuUFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSA9IFAudG9TdHJpbmc7XHJcblBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICdEZWNpbWFsJztcclxuXHJcbi8vIENyZWF0ZSBhbmQgY29uZmlndXJlIGluaXRpYWwgRGVjaW1hbCBjb25zdHJ1Y3Rvci5cclxuZXhwb3J0IHZhciBEZWNpbWFsID0gUC5jb25zdHJ1Y3RvciA9IGNsb25lKERFRkFVTFRTKTtcclxuXHJcbi8vIENyZWF0ZSB0aGUgaW50ZXJuYWwgY29uc3RhbnRzIGZyb20gdGhlaXIgc3RyaW5nIHZhbHVlcy5cclxuTE4xMCA9IG5ldyBEZWNpbWFsKExOMTApO1xyXG5QSSA9IG5ldyBEZWNpbWFsKFBJKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERlY2ltYWw7XHJcbiJdLCJuYW1lcyI6WyJFWFBfTElNSVQiLCJNQVhfRElHSVRTIiwiTlVNRVJBTFMiLCJMTjEwIiwiUEkiLCJERUZBVUxUUyIsInByZWNpc2lvbiIsInJvdW5kaW5nIiwibW9kdWxvIiwidG9FeHBOZWciLCJ0b0V4cFBvcyIsIm1pbkUiLCJtYXhFIiwiY3J5cHRvIiwiaW5leGFjdCIsInF1YWRyYW50IiwiZXh0ZXJuYWwiLCJkZWNpbWFsRXJyb3IiLCJpbnZhbGlkQXJndW1lbnQiLCJwcmVjaXNpb25MaW1pdEV4Y2VlZGVkIiwiY3J5cHRvVW5hdmFpbGFibGUiLCJ0YWciLCJtYXRoZmxvb3IiLCJNYXRoIiwiZmxvb3IiLCJtYXRocG93IiwicG93IiwiaXNCaW5hcnkiLCJpc0hleCIsImlzT2N0YWwiLCJpc0RlY2ltYWwiLCJCQVNFIiwiTE9HX0JBU0UiLCJNQVhfU0FGRV9JTlRFR0VSIiwiTE4xMF9QUkVDSVNJT04iLCJsZW5ndGgiLCJQSV9QUkVDSVNJT04iLCJQIiwidG9TdHJpbmdUYWciLCJhYnNvbHV0ZVZhbHVlIiwiYWJzIiwieCIsImNvbnN0cnVjdG9yIiwicyIsImZpbmFsaXNlIiwiY2VpbCIsImUiLCJjbGFtcGVkVG8iLCJjbGFtcCIsIm1pbiIsIm1heCIsImsiLCJDdG9yIiwiTmFOIiwiZ3QiLCJFcnJvciIsImNtcCIsImNvbXBhcmVkVG8iLCJ5IiwiaSIsImoiLCJ4ZEwiLCJ5ZEwiLCJ4ZCIsImQiLCJ5ZCIsInhzIiwieXMiLCJjb3NpbmUiLCJjb3MiLCJwciIsInJtIiwic2QiLCJ0b0xlc3NUaGFuSGFsZlBpIiwibmVnIiwiY3ViZVJvb3QiLCJjYnJ0IiwibSIsIm4iLCJyIiwicmVwIiwidCIsInQzIiwidDNwbHVzeCIsImlzRmluaXRlIiwiaXNaZXJvIiwiZGlnaXRzVG9TdHJpbmciLCJ0b0V4cG9uZW50aWFsIiwic2xpY2UiLCJpbmRleE9mIiwidG9TdHJpbmciLCJ0aW1lcyIsInBsdXMiLCJkaXZpZGUiLCJlcSIsImNoYXJBdCIsImRlY2ltYWxQbGFjZXMiLCJkcCIsInciLCJkaXZpZGVkQnkiLCJkaXYiLCJkaXZpZGVkVG9JbnRlZ2VyQnkiLCJkaXZUb0ludCIsImVxdWFscyIsImdyZWF0ZXJUaGFuIiwiZ3JlYXRlclRoYW5PckVxdWFsVG8iLCJndGUiLCJoeXBlcmJvbGljQ29zaW5lIiwiY29zaCIsImxlbiIsIm9uZSIsInRpbnlQb3ciLCJ0YXlsb3JTZXJpZXMiLCJjb3NoMl94IiwiZDgiLCJtaW51cyIsImh5cGVyYm9saWNTaW5lIiwic2luaCIsInNxcnQiLCJzaW5oMl94IiwiZDUiLCJkMTYiLCJkMjAiLCJoeXBlcmJvbGljVGFuZ2VudCIsInRhbmgiLCJpbnZlcnNlQ29zaW5lIiwiYWNvcyIsImhhbGZQaSIsImlzTmVnIiwiZ2V0UGkiLCJhc2luIiwiaW52ZXJzZUh5cGVyYm9saWNDb3NpbmUiLCJhY29zaCIsImx0ZSIsImxuIiwiaW52ZXJzZUh5cGVyYm9saWNTaW5lIiwiYXNpbmgiLCJpbnZlcnNlSHlwZXJib2xpY1RhbmdlbnQiLCJhdGFuaCIsIndwciIsInhzZCIsImludmVyc2VTaW5lIiwiYXRhbiIsImludmVyc2VUYW5nZW50IiwicHgiLCJ4MiIsImlzSW50ZWdlciIsImlzSW50IiwiaXNOYU4iLCJpc05lZ2F0aXZlIiwiaXNQb3NpdGl2ZSIsImlzUG9zIiwibGVzc1RoYW4iLCJsdCIsImxlc3NUaGFuT3JFcXVhbFRvIiwibG9nYXJpdGhtIiwibG9nIiwiYmFzZSIsImlzQmFzZTEwIiwiZGVub21pbmF0b3IiLCJpbmYiLCJudW0iLCJhcmciLCJndWFyZCIsIm5hdHVyYWxMb2dhcml0aG0iLCJnZXRMbjEwIiwiY2hlY2tSb3VuZGluZ0RpZ2l0cyIsInN1YiIsInhlIiwieExUeSIsInJldmVyc2UiLCJwdXNoIiwicG9wIiwic2hpZnQiLCJnZXRCYXNlMTBFeHBvbmVudCIsIm1vZCIsInEiLCJuYXR1cmFsRXhwb25lbnRpYWwiLCJleHAiLCJuZWdhdGVkIiwiYWRkIiwiY2FycnkiLCJ1bnNoaWZ0IiwieiIsImdldFByZWNpc2lvbiIsInJvdW5kIiwic2luZSIsInNpbiIsInNxdWFyZVJvb3QiLCJ0YW5nZW50IiwidGFuIiwibXVsIiwickwiLCJ0b0JpbmFyeSIsInRvU3RyaW5nQmluYXJ5IiwidG9EZWNpbWFsUGxhY2VzIiwidG9EUCIsImNoZWNrSW50MzIiLCJzdHIiLCJmaW5pdGVUb1N0cmluZyIsInRvRml4ZWQiLCJ0b0ZyYWN0aW9uIiwibWF4RCIsImQwIiwiZDEiLCJkMiIsIm4wIiwibjEiLCJ0b0hleGFkZWNpbWFsIiwidG9IZXgiLCJ0b05lYXJlc3QiLCJ0b051bWJlciIsInRvT2N0YWwiLCJ0b1Bvd2VyIiwieW4iLCJpbnRQb3ciLCJ0b1ByZWNpc2lvbiIsInRvU2lnbmlmaWNhbnREaWdpdHMiLCJ0b1NEIiwidHJ1bmNhdGVkIiwidHJ1bmMiLCJ2YWx1ZU9mIiwidG9KU09OIiwid3MiLCJpbmRleE9mTGFzdFdvcmQiLCJnZXRaZXJvU3RyaW5nIiwicmVwZWF0aW5nIiwiZGkiLCJyZCIsImNvbnZlcnRCYXNlIiwiYmFzZUluIiwiYmFzZU91dCIsImFyciIsImFyckwiLCJzdHJMIiwiY29zMngiLCJtdWx0aXBseUludGVnZXIiLCJ0ZW1wIiwiY29tcGFyZSIsImEiLCJiIiwiYUwiLCJiTCIsInN1YnRyYWN0IiwibG9nQmFzZSIsIm1vcmUiLCJwcm9kIiwicHJvZEwiLCJxZCIsInJlbSIsInJlbUwiLCJyZW0wIiwieGkiLCJ4TCIsInlkMCIsInlMIiwieXoiLCJzaWduIiwiaXNUcnVuY2F0ZWQiLCJkaWdpdHMiLCJyb3VuZFVwIiwieGRpIiwib3V0IiwiaXNFeHAiLCJub25GaW5pdGVUb1N0cmluZyIsInpzIiwidHJ1bmNhdGUiLCJpc09kZCIsIm1heE9yTWluIiwiYXJncyIsImx0Z3QiLCJzdW0iLCJjIiwiYzAiLCJudW1lcmF0b3IiLCJ4MSIsIlN0cmluZyIsInBhcnNlRGVjaW1hbCIsInJlcGxhY2UiLCJzZWFyY2giLCJzdWJzdHJpbmciLCJjaGFyQ29kZUF0IiwicGFyc2VPdGhlciIsImRpdmlzb3IiLCJpc0Zsb2F0IiwicCIsInRlc3QiLCJ0b0xvd2VyQ2FzZSIsIkRlY2ltYWwiLCJzaW4yX3giLCJpc0h5cGVyYm9saWMiLCJ1IiwicGkiLCJhdGFuMiIsImNvbmZpZyIsIm9iaiIsInYiLCJ1c2VEZWZhdWx0cyIsImRlZmF1bHRzIiwicHMiLCJnZXRSYW5kb21WYWx1ZXMiLCJyYW5kb21CeXRlcyIsImNsb25lIiwiaXNEZWNpbWFsSW5zdGFuY2UiLCJwcm90b3R5cGUiLCJST1VORF9VUCIsIlJPVU5EX0RPV04iLCJST1VORF9DRUlMIiwiUk9VTkRfRkxPT1IiLCJST1VORF9IQUxGX1VQIiwiUk9VTkRfSEFMRl9ET1dOIiwiUk9VTkRfSEFMRl9FVkVOIiwiUk9VTkRfSEFMRl9DRUlMIiwiUk9VTkRfSEFMRl9GTE9PUiIsIkVVQ0xJRCIsInNldCIsImh5cG90IiwibG9nMTAiLCJsb2cyIiwicmFuZG9tIiwiaGFzT3duUHJvcGVydHkiLCJhcmd1bWVudHMiLCJVaW50MzJBcnJheSIsImNvcHkiLCJTeW1ib2wiLCJmb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/decimal.js/decimal.mjs\n");

/***/ })

};
;