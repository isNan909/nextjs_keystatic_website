"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ignore";
exports.ids = ["vendor-chunks/ignore"];
exports.modules = {

/***/ "(rsc)/./node_modules/ignore/index.js":
/*!**************************************!*\
  !*** ./node_modules/ignore/index.js ***!
  \**************************************/
/***/ ((module) => {

eval("// A simple implementation of make-array\n\nfunction makeArray(subject) {\n    return Array.isArray(subject) ? subject : [\n        subject\n    ];\n}\nconst EMPTY = \"\";\nconst SPACE = \" \";\nconst ESCAPE = \"\\\\\";\nconst REGEX_TEST_BLANK_LINE = /^\\s+$/;\nconst REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\\\]|^)\\\\$/;\nconst REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/;\nconst REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/;\nconst REGEX_SPLITALL_CRLF = /\\r?\\n/g;\n// /foo,\n// ./foo,\n// ../foo,\n// .\n// ..\nconst REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/;\nconst SLASH = \"/\";\n// Do not use ternary expression here, since \"istanbul ignore next\" is buggy\nlet TMP_KEY_IGNORE = \"node-ignore\";\n/* istanbul ignore else */ if (typeof Symbol !== \"undefined\") {\n    TMP_KEY_IGNORE = Symbol.for(\"node-ignore\");\n}\nconst KEY_IGNORE = TMP_KEY_IGNORE;\nconst define = (object, key, value)=>Object.defineProperty(object, key, {\n        value\n    });\nconst REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;\nconst RETURN_FALSE = ()=>false;\n// Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\nconst sanitizeRange = (range)=>range.replace(REGEX_REGEXP_RANGE, (match, from, to)=>from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY);\n// See fixtures #59\nconst cleanRangeBackSlash = (slashes)=>{\n    const { length } = slashes;\n    return slashes.slice(0, length - length % 2);\n};\n// > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n// '`foo/`' should not continue with the '`..`'\nconst REPLACERS = [\n    [\n        // remove BOM\n        // TODO:\n        // Other similar zero-width characters?\n        /^\\uFEFF/,\n        ()=>EMPTY\n    ],\n    // > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n    [\n        // (a\\ ) -> (a )\n        // (a  ) -> (a)\n        // (a \\ ) -> (a  )\n        /\\\\?\\s+$/,\n        (match)=>match.indexOf(\"\\\\\") === 0 ? SPACE : EMPTY\n    ],\n    // replace (\\ ) with ' '\n    [\n        /\\\\\\s/g,\n        ()=>SPACE\n    ],\n    // Escape metacharacters\n    // which is written down by users but means special for regular expressions.\n    // > There are 12 characters with special meanings:\n    // > - the backslash \\,\n    // > - the caret ^,\n    // > - the dollar sign $,\n    // > - the period or dot .,\n    // > - the vertical bar or pipe symbol |,\n    // > - the question mark ?,\n    // > - the asterisk or star *,\n    // > - the plus sign +,\n    // > - the opening parenthesis (,\n    // > - the closing parenthesis ),\n    // > - and the opening square bracket [,\n    // > - the opening curly brace {,\n    // > These special characters are often called \"metacharacters\".\n    [\n        /[\\\\$.|*+(){^]/g,\n        (match)=>`\\\\${match}`\n    ],\n    [\n        // > a question mark (?) matches a single character\n        /(?!\\\\)\\?/g,\n        ()=>\"[^/]\"\n    ],\n    // leading slash\n    [\n        // > A leading slash matches the beginning of the pathname.\n        // > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n        // A leading slash matches the beginning of the pathname\n        /^\\//,\n        ()=>\"^\"\n    ],\n    // replace special metacharacter slash after the leading slash\n    [\n        /\\//g,\n        ()=>\"\\\\/\"\n    ],\n    [\n        // > A leading \"**\" followed by a slash means match in all directories.\n        // > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n        // > the same as pattern \"foo\".\n        // > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n        // >   under directory \"foo\".\n        // Notice that the '*'s have been replaced as '\\\\*'\n        /^\\^*\\\\\\*\\\\\\*\\\\\\//,\n        // '**/foo' <-> 'foo'\n        ()=>\"^(?:.*\\\\/)?\"\n    ],\n    // starting\n    [\n        // there will be no leading '/'\n        //   (which has been replaced by section \"leading slash\")\n        // If starts with '**', adding a '^' to the regular expression also works\n        /^(?=[^^])/,\n        function startingReplacer() {\n            // If has a slash `/` at the beginning or middle\n            return !/\\/(?!$)/.test(this) ? \"(?:^|\\\\/)\" : \"^\";\n        }\n    ],\n    // two globstars\n    [\n        // Use lookahead assertions so that we could match more than one `'/**'`\n        /\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\n        // Zero, one or several directories\n        // should not use '*', or it will be replaced by the next replacer\n        // Check if it is not the last `'/**'`\n        (_, index, str)=>index + 6 < str.length ? \"(?:\\\\/[^\\\\/]+)*\" : \"\\\\/.+\"\n    ],\n    // normal intermediate wildcards\n    [\n        // Never replace escaped '*'\n        // ignore rule '\\*' will match the path '*'\n        // 'abc.*/' -> go\n        // 'abc.*'  -> skip this rule,\n        //    coz trailing single wildcard will be handed by [trailing wildcard]\n        /(^|[^\\\\]+)(\\\\\\*)+(?=.+)/g,\n        // '*.js' matches '.js'\n        // '*.js' doesn't match 'abc'\n        (_, p1, p2)=>{\n            // 1.\n            // > An asterisk \"*\" matches anything except a slash.\n            // 2.\n            // > Other consecutive asterisks are considered regular asterisks\n            // > and will match according to the previous rules.\n            const unescaped = p2.replace(/\\\\\\*/g, \"[^\\\\/]*\");\n            return p1 + unescaped;\n        }\n    ],\n    [\n        // unescape, revert step 3 except for back slash\n        // For example, if a user escape a '\\\\*',\n        // after step 3, the result will be '\\\\\\\\\\\\*'\n        /\\\\\\\\\\\\(?=[$.|*+(){^])/g,\n        ()=>ESCAPE\n    ],\n    [\n        // '\\\\\\\\' -> '\\\\'\n        /\\\\\\\\/g,\n        ()=>ESCAPE\n    ],\n    [\n        // > The range notation, e.g. [a-zA-Z],\n        // > can be used to match one of the characters in a range.\n        // `\\` is escaped by step 3\n        /(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g,\n        (match, leadEscape, range, endEscape, close)=>leadEscape === ESCAPE ? `\\\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === \"]\" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : \"[]\" : \"[]\"\n    ],\n    // ending\n    [\n        // 'js' will not match 'js.'\n        // 'ab' will not match 'abc'\n        /(?:[^*])$/,\n        // WTF!\n        // https://git-scm.com/docs/gitignore\n        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\n        // which re-fixes #24, #38\n        // > If there is a separator at the end of the pattern then the pattern\n        // > will only match directories, otherwise the pattern can match both\n        // > files and directories.\n        // 'js*' will not match 'a.js'\n        // 'js/' will not match 'a.js'\n        // 'js' will match 'a.js' and 'a.js/'\n        (match)=>/\\/$/.test(match) ? `${match}$` : `${match}(?=$|\\\\/$)`\n    ],\n    // trailing wildcard\n    [\n        /(\\^|\\\\\\/)?\\\\\\*$/,\n        (_, p1)=>{\n            const prefix = p1 ? `${p1}[^/]+` : \"[^/]*\";\n            return `${prefix}(?=$|\\\\/$)`;\n        }\n    ]\n];\n// A simple cache, because an ignore rule only has only one certain meaning\nconst regexCache = Object.create(null);\n// @param {pattern}\nconst makeRegex = (pattern, ignoreCase)=>{\n    let source = regexCache[pattern];\n    if (!source) {\n        source = REPLACERS.reduce((prev, current)=>prev.replace(current[0], current[1].bind(pattern)), pattern);\n        regexCache[pattern] = source;\n    }\n    return ignoreCase ? new RegExp(source, \"i\") : new RegExp(source);\n};\nconst isString = (subject)=>typeof subject === \"string\";\n// > A blank line matches no files, so it can serve as a separator for readability.\nconst checkPattern = (pattern)=>pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf(\"#\") !== 0;\nconst splitPattern = (pattern)=>pattern.split(REGEX_SPLITALL_CRLF);\nclass IgnoreRule {\n    constructor(origin, pattern, negative, regex){\n        this.origin = origin;\n        this.pattern = pattern;\n        this.negative = negative;\n        this.regex = regex;\n    }\n}\nconst createRule = (pattern, ignoreCase)=>{\n    const origin = pattern;\n    let negative = false;\n    // > An optional prefix \"!\" which negates the pattern;\n    if (pattern.indexOf(\"!\") === 0) {\n        negative = true;\n        pattern = pattern.substr(1);\n    }\n    pattern = pattern// > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n    // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n    .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, \"!\")// > Put a backslash (\"\\\") in front of the first hash for patterns that\n    // >   begin with a hash.\n    .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, \"#\");\n    const regex = makeRegex(pattern, ignoreCase);\n    return new IgnoreRule(origin, pattern, negative, regex);\n};\nconst throwError = (message, Ctor)=>{\n    throw new Ctor(message);\n};\nconst checkPath = (path, originalPath, doThrow)=>{\n    if (!isString(path)) {\n        return doThrow(`path must be a string, but got \\`${originalPath}\\``, TypeError);\n    }\n    // We don't know if we should ignore EMPTY, so throw\n    if (!path) {\n        return doThrow(`path must not be empty`, TypeError);\n    }\n    // Check if it is a relative path\n    if (checkPath.isNotRelative(path)) {\n        const r = \"`path.relative()`d\";\n        return doThrow(`path should be a ${r} string, but got \"${originalPath}\"`, RangeError);\n    }\n    return true;\n};\nconst isNotRelative = (path)=>REGEX_TEST_INVALID_PATH.test(path);\ncheckPath.isNotRelative = isNotRelative;\ncheckPath.convert = (p)=>p;\nclass Ignore {\n    constructor({ ignorecase = true, ignoreCase = ignorecase, allowRelativePaths = false } = {}){\n        define(this, KEY_IGNORE, true);\n        this._rules = [];\n        this._ignoreCase = ignoreCase;\n        this._allowRelativePaths = allowRelativePaths;\n        this._initCache();\n    }\n    _initCache() {\n        this._ignoreCache = Object.create(null);\n        this._testCache = Object.create(null);\n    }\n    _addPattern(pattern) {\n        // #32\n        if (pattern && pattern[KEY_IGNORE]) {\n            this._rules = this._rules.concat(pattern._rules);\n            this._added = true;\n            return;\n        }\n        if (checkPattern(pattern)) {\n            const rule = createRule(pattern, this._ignoreCase);\n            this._added = true;\n            this._rules.push(rule);\n        }\n    }\n    // @param {Array<string> | string | Ignore} pattern\n    add(pattern) {\n        this._added = false;\n        makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);\n        // Some rules have just added to the ignore,\n        // making the behavior changed.\n        if (this._added) {\n            this._initCache();\n        }\n        return this;\n    }\n    // legacy\n    addPattern(pattern) {\n        return this.add(pattern);\n    }\n    //          |           ignored : unignored\n    // negative |   0:0   |   0:1   |   1:0   |   1:1\n    // -------- | ------- | ------- | ------- | --------\n    //     0    |  TEST   |  TEST   |  SKIP   |    X\n    //     1    |  TESTIF |  SKIP   |  TEST   |    X\n    // - SKIP: always skip\n    // - TEST: always test\n    // - TESTIF: only test if checkUnignored\n    // - X: that never happen\n    // @param {boolean} whether should check if the path is unignored,\n    //   setting `checkUnignored` to `false` could reduce additional\n    //   path matching.\n    // @returns {TestResult} true if a file is ignored\n    _testOne(path, checkUnignored) {\n        let ignored = false;\n        let unignored = false;\n        this._rules.forEach((rule)=>{\n            const { negative } = rule;\n            if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {\n                return;\n            }\n            const matched = rule.regex.test(path);\n            if (matched) {\n                ignored = !negative;\n                unignored = negative;\n            }\n        });\n        return {\n            ignored,\n            unignored\n        };\n    }\n    // @returns {TestResult}\n    _test(originalPath, cache, checkUnignored, slices) {\n        const path = originalPath && checkPath.convert(originalPath);\n        checkPath(path, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);\n        return this._t(path, cache, checkUnignored, slices);\n    }\n    _t(path, cache, checkUnignored, slices) {\n        if (path in cache) {\n            return cache[path];\n        }\n        if (!slices) {\n            // path/to/a.js\n            // ['path', 'to', 'a.js']\n            slices = path.split(SLASH);\n        }\n        slices.pop();\n        // If the path has no parent directory, just test it\n        if (!slices.length) {\n            return cache[path] = this._testOne(path, checkUnignored);\n        }\n        const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);\n        // If the path contains a parent directory, check the parent first\n        return cache[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);\n    }\n    ignores(path) {\n        return this._test(path, this._ignoreCache, false).ignored;\n    }\n    createFilter() {\n        return (path)=>!this.ignores(path);\n    }\n    filter(paths) {\n        return makeArray(paths).filter(this.createFilter());\n    }\n    // @returns {TestResult}\n    test(path) {\n        return this._test(path, this._testCache, true);\n    }\n}\nconst factory = (options)=>new Ignore(options);\nconst isPathValid = (path)=>checkPath(path && checkPath.convert(path), path, RETURN_FALSE);\nfactory.isPathValid = isPathValid;\n// Fixes typescript\nfactory.default = factory;\nmodule.exports = factory;\n// Windows\n// --------------------------------------------------------------\n/* istanbul ignore if */ if (// Detect `process` so that it can run in browsers.\ntypeof process !== \"undefined\" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === \"win32\")) {\n    /* eslint no-control-regex: \"off\" */ const makePosix = (str)=>/^\\\\\\\\\\?\\\\/.test(str) || /[\"<>|\\u0000-\\u001F]+/u.test(str) ? str : str.replace(/\\\\/g, \"/\");\n    checkPath.convert = makePosix;\n    // 'C:\\\\foo'     <- 'C:\\\\foo' has been converted to 'C:/'\n    // 'd:\\\\foo'\n    const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i;\n    checkPath.isNotRelative = (path)=>REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaWdub3JlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLHdDQUF3Qzs7QUFDeEMsU0FBU0EsVUFBV0MsT0FBTztJQUN6QixPQUFPQyxNQUFNQyxPQUFPLENBQUNGLFdBQ2pCQSxVQUNBO1FBQUNBO0tBQVE7QUFDZjtBQUVBLE1BQU1HLFFBQVE7QUFDZCxNQUFNQyxRQUFRO0FBQ2QsTUFBTUMsU0FBUztBQUNmLE1BQU1DLHdCQUF3QjtBQUM5QixNQUFNQyxtQ0FBbUM7QUFDekMsTUFBTUMsNENBQTRDO0FBQ2xELE1BQU1DLHFDQUFxQztBQUMzQyxNQUFNQyxzQkFBc0I7QUFDNUIsUUFBUTtBQUNSLFNBQVM7QUFDVCxVQUFVO0FBQ1YsSUFBSTtBQUNKLEtBQUs7QUFDTCxNQUFNQywwQkFBMEI7QUFFaEMsTUFBTUMsUUFBUTtBQUVkLDRFQUE0RTtBQUM1RSxJQUFJQyxpQkFBaUI7QUFDckIsd0JBQXdCLEdBQ3hCLElBQUksT0FBT0MsV0FBVyxhQUFhO0lBQ2pDRCxpQkFBaUJDLE9BQU9DLEdBQUcsQ0FBQztBQUM5QjtBQUNBLE1BQU1DLGFBQWFIO0FBRW5CLE1BQU1JLFNBQVMsQ0FBQ0MsUUFBUUMsS0FBS0MsUUFDM0JDLE9BQU9DLGNBQWMsQ0FBQ0osUUFBUUMsS0FBSztRQUFDQztJQUFLO0FBRTNDLE1BQU1HLHFCQUFxQjtBQUUzQixNQUFNQyxlQUFlLElBQU07QUFFM0IsNkNBQTZDO0FBQzdDLHdEQUF3RDtBQUN4RCxNQUFNQyxnQkFBZ0JDLENBQUFBLFFBQVNBLE1BQU1DLE9BQU8sQ0FDMUNKLG9CQUNBLENBQUNLLE9BQU9DLE1BQU1DLEtBQU9ELEtBQUtFLFVBQVUsQ0FBQyxNQUFNRCxHQUFHQyxVQUFVLENBQUMsS0FDckRILFFBR0F6QjtBQUdOLG1CQUFtQjtBQUNuQixNQUFNNkIsc0JBQXNCQyxDQUFBQTtJQUMxQixNQUFNLEVBQUNDLE1BQU0sRUFBQyxHQUFHRDtJQUNqQixPQUFPQSxRQUFRRSxLQUFLLENBQUMsR0FBR0QsU0FBU0EsU0FBUztBQUM1QztBQUVBLHNDQUFzQztBQUN0QyxnRUFBZ0U7QUFDaEUscURBQXFEO0FBQ3JELDZFQUE2RTtBQUM3RSw2REFBNkQ7QUFDN0QsNkVBQTZFO0FBQzdFLHdFQUF3RTtBQUN4RSwrRUFBK0U7QUFDL0UscURBQXFEO0FBRXJELCtDQUErQztBQUMvQyxNQUFNRSxZQUFZO0lBRWhCO1FBQ0UsYUFBYTtRQUNiLFFBQVE7UUFDUix1Q0FBdUM7UUFDdkM7UUFDQSxJQUFNakM7S0FDUDtJQUVELDRFQUE0RTtJQUM1RTtRQUNFLGdCQUFnQjtRQUNoQixlQUFlO1FBQ2Ysa0JBQWtCO1FBQ2xCO1FBQ0F5QixDQUFBQSxRQUFTQSxNQUFNUyxPQUFPLENBQUMsVUFBVSxJQUM3QmpDLFFBQ0FEO0tBQ0w7SUFFRCx3QkFBd0I7SUFDeEI7UUFDRTtRQUNBLElBQU1DO0tBQ1A7SUFFRCx3QkFBd0I7SUFDeEIsNEVBQTRFO0lBRTVFLG1EQUFtRDtJQUNuRCx1QkFBdUI7SUFDdkIsbUJBQW1CO0lBQ25CLHlCQUF5QjtJQUN6QiwyQkFBMkI7SUFDM0IseUNBQXlDO0lBQ3pDLDJCQUEyQjtJQUMzQiw4QkFBOEI7SUFDOUIsdUJBQXVCO0lBQ3ZCLGlDQUFpQztJQUNqQyxpQ0FBaUM7SUFDakMsd0NBQXdDO0lBQ3hDLGlDQUFpQztJQUNqQyxnRUFBZ0U7SUFDaEU7UUFDRTtRQUNBd0IsQ0FBQUEsUUFBUyxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDO0tBQ3RCO0lBRUQ7UUFDRSxtREFBbUQ7UUFDbkQ7UUFDQSxJQUFNO0tBQ1A7SUFFRCxnQkFBZ0I7SUFDaEI7UUFFRSwyREFBMkQ7UUFDM0QsNEVBQTRFO1FBQzVFLHdEQUF3RDtRQUN4RDtRQUNBLElBQU07S0FDUDtJQUVELDhEQUE4RDtJQUM5RDtRQUNFO1FBQ0EsSUFBTTtLQUNQO0lBRUQ7UUFDRSx1RUFBdUU7UUFDdkUsb0VBQW9FO1FBQ3BFLCtCQUErQjtRQUMvQiwyRUFBMkU7UUFDM0UsNkJBQTZCO1FBQzdCLG1EQUFtRDtRQUNuRDtRQUVBLHFCQUFxQjtRQUNyQixJQUFNO0tBQ1A7SUFFRCxXQUFXO0lBQ1g7UUFDRSwrQkFBK0I7UUFDL0IseURBQXlEO1FBQ3pELHlFQUF5RTtRQUN6RTtRQUNBLFNBQVNVO1lBQ1AsZ0RBQWdEO1lBQ2hELE9BQU8sQ0FBQyxVQUFVQyxJQUFJLENBQUMsSUFBSSxJQWF2QixjQUlBO1FBQ047S0FDRDtJQUVELGdCQUFnQjtJQUNoQjtRQUNFLHdFQUF3RTtRQUN4RTtRQUVBLG1DQUFtQztRQUNuQyxrRUFBa0U7UUFFbEUsc0NBQXNDO1FBQ3RDLENBQUNDLEdBQUdDLE9BQU9DLE1BQVFELFFBQVEsSUFBSUMsSUFBSVIsTUFBTSxHQU9yQyxvQkFNQTtLQUNMO0lBRUQsZ0NBQWdDO0lBQ2hDO1FBQ0UsNEJBQTRCO1FBQzVCLDJDQUEyQztRQUUzQyxpQkFBaUI7UUFDakIsOEJBQThCO1FBQzlCLHdFQUF3RTtRQUN4RTtRQUVBLHVCQUF1QjtRQUN2Qiw2QkFBNkI7UUFDN0IsQ0FBQ00sR0FBR0csSUFBSUM7WUFDTixLQUFLO1lBQ0wscURBQXFEO1lBQ3JELEtBQUs7WUFDTCxpRUFBaUU7WUFDakUsb0RBQW9EO1lBQ3BELE1BQU1DLFlBQVlELEdBQUdqQixPQUFPLENBQUMsU0FBUztZQUN0QyxPQUFPZ0IsS0FBS0U7UUFDZDtLQUNEO0lBRUQ7UUFDRSxnREFBZ0Q7UUFDaEQseUNBQXlDO1FBQ3pDLDZDQUE2QztRQUM3QztRQUNBLElBQU14QztLQUNQO0lBRUQ7UUFDRSxpQkFBaUI7UUFDakI7UUFDQSxJQUFNQTtLQUNQO0lBRUQ7UUFDRSx1Q0FBdUM7UUFDdkMsMkRBQTJEO1FBRTNELDJCQUEyQjtRQUMzQjtRQUNBLENBQUN1QixPQUFPa0IsWUFBWXBCLE9BQU9xQixXQUFXQyxRQUFVRixlQUFlekMsU0FFM0QsQ0FBQyxHQUFHLEVBQUVxQixNQUFNLEVBQUVNLG9CQUFvQmUsV0FBVyxFQUFFQyxNQUFNLENBQUMsR0FDdERBLFVBQVUsTUFDUkQsVUFBVWIsTUFBTSxHQUFHLE1BQU0sSUFJdkIsQ0FBQyxDQUFDLEVBQUVULGNBQWNDLE9BQU8sRUFBRXFCLFVBQVUsQ0FBQyxDQUFDLEdBR3ZDLE9BQ0Y7S0FDUDtJQUVELFNBQVM7SUFDVDtRQUNFLDRCQUE0QjtRQUM1Qiw0QkFBNEI7UUFDNUI7UUFFQSxPQUFPO1FBQ1AscUNBQXFDO1FBQ3JDLGlFQUFpRTtRQUNqRSwwQkFBMEI7UUFFMUIsdUVBQXVFO1FBQ3ZFLHNFQUFzRTtRQUN0RSwyQkFBMkI7UUFFM0IsOEJBQThCO1FBQzlCLDhCQUE4QjtRQUM5QixxQ0FBcUM7UUFDckNuQixDQUFBQSxRQUFTLE1BQU1XLElBQUksQ0FBQ1gsU0FFaEIsQ0FBQyxFQUFFQSxNQUFNLENBQUMsQ0FBQyxHQUVYLENBQUMsRUFBRUEsTUFBTSxVQUFVLENBQUM7S0FDekI7SUFFRCxvQkFBb0I7SUFDcEI7UUFDRTtRQUNBLENBQUNZLEdBQUdHO1lBQ0YsTUFBTU0sU0FBU04sS0FPWCxDQUFDLEVBQUVBLEdBQUcsS0FBSyxDQUFDLEdBSVo7WUFFSixPQUFPLENBQUMsRUFBRU0sT0FBTyxVQUFVLENBQUM7UUFDOUI7S0FDRDtDQUNGO0FBRUQsMkVBQTJFO0FBQzNFLE1BQU1DLGFBQWE3QixPQUFPOEIsTUFBTSxDQUFDO0FBRWpDLG1CQUFtQjtBQUNuQixNQUFNQyxZQUFZLENBQUNDLFNBQVNDO0lBQzFCLElBQUlDLFNBQVNMLFVBQVUsQ0FBQ0csUUFBUTtJQUVoQyxJQUFJLENBQUNFLFFBQVE7UUFDWEEsU0FBU25CLFVBQVVvQixNQUFNLENBQ3ZCLENBQUNDLE1BQU1DLFVBQVlELEtBQUs5QixPQUFPLENBQUMrQixPQUFPLENBQUMsRUFBRSxFQUFFQSxPQUFPLENBQUMsRUFBRSxDQUFDQyxJQUFJLENBQUNOLFdBQzVEQTtRQUVGSCxVQUFVLENBQUNHLFFBQVEsR0FBR0U7SUFDeEI7SUFFQSxPQUFPRCxhQUNILElBQUlNLE9BQU9MLFFBQVEsT0FDbkIsSUFBSUssT0FBT0w7QUFDakI7QUFFQSxNQUFNTSxXQUFXN0QsQ0FBQUEsVUFBVyxPQUFPQSxZQUFZO0FBRS9DLG1GQUFtRjtBQUNuRixNQUFNOEQsZUFBZVQsQ0FBQUEsVUFBV0EsV0FDM0JRLFNBQVNSLFlBQ1QsQ0FBQy9DLHNCQUFzQmlDLElBQUksQ0FBQ2MsWUFDNUIsQ0FBQzlDLGlDQUFpQ2dDLElBQUksQ0FBQ2MsWUFHdkNBLFFBQVFoQixPQUFPLENBQUMsU0FBUztBQUU5QixNQUFNMEIsZUFBZVYsQ0FBQUEsVUFBV0EsUUFBUVcsS0FBSyxDQUFDdEQ7QUFFOUMsTUFBTXVEO0lBQ0pDLFlBQ0VDLE1BQU0sRUFDTmQsT0FBTyxFQUNQZSxRQUFRLEVBQ1JDLEtBQUssQ0FDTDtRQUNBLElBQUksQ0FBQ0YsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ2QsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ2UsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLEtBQUssR0FBR0E7SUFDZjtBQUNGO0FBRUEsTUFBTUMsYUFBYSxDQUFDakIsU0FBU0M7SUFDM0IsTUFBTWEsU0FBU2Q7SUFDZixJQUFJZSxXQUFXO0lBRWYsc0RBQXNEO0lBQ3RELElBQUlmLFFBQVFoQixPQUFPLENBQUMsU0FBUyxHQUFHO1FBQzlCK0IsV0FBVztRQUNYZixVQUFVQSxRQUFRa0IsTUFBTSxDQUFDO0lBQzNCO0lBRUFsQixVQUFVQSxPQUNWLHNFQUFzRTtJQUN0RSxtRUFBbUU7S0FDbEUxQixPQUFPLENBQUNuQiwyQ0FBMkMsSUFDcEQsdUVBQXVFO0lBQ3ZFLHlCQUF5QjtLQUN4Qm1CLE9BQU8sQ0FBQ2xCLG9DQUFvQztJQUU3QyxNQUFNNEQsUUFBUWpCLFVBQVVDLFNBQVNDO0lBRWpDLE9BQU8sSUFBSVcsV0FDVEUsUUFDQWQsU0FDQWUsVUFDQUM7QUFFSjtBQUVBLE1BQU1HLGFBQWEsQ0FBQ0MsU0FBU0M7SUFDM0IsTUFBTSxJQUFJQSxLQUFLRDtBQUNqQjtBQUVBLE1BQU1FLFlBQVksQ0FBQ0MsTUFBTUMsY0FBY0M7SUFDckMsSUFBSSxDQUFDakIsU0FBU2UsT0FBTztRQUNuQixPQUFPRSxRQUNMLENBQUMsaUNBQWlDLEVBQUVELGFBQWEsRUFBRSxDQUFDLEVBQ3BERTtJQUVKO0lBRUEsb0RBQW9EO0lBQ3BELElBQUksQ0FBQ0gsTUFBTTtRQUNULE9BQU9FLFFBQVEsQ0FBQyxzQkFBc0IsQ0FBQyxFQUFFQztJQUMzQztJQUVBLGlDQUFpQztJQUNqQyxJQUFJSixVQUFVSyxhQUFhLENBQUNKLE9BQU87UUFDakMsTUFBTUssSUFBSTtRQUNWLE9BQU9ILFFBQ0wsQ0FBQyxpQkFBaUIsRUFBRUcsRUFBRSxrQkFBa0IsRUFBRUosYUFBYSxDQUFDLENBQUMsRUFDekRLO0lBRUo7SUFFQSxPQUFPO0FBQ1Q7QUFFQSxNQUFNRixnQkFBZ0JKLENBQUFBLE9BQVFqRSx3QkFBd0I0QixJQUFJLENBQUNxQztBQUUzREQsVUFBVUssYUFBYSxHQUFHQTtBQUMxQkwsVUFBVVEsT0FBTyxHQUFHQyxDQUFBQSxJQUFLQTtBQUV6QixNQUFNQztJQUNKbkIsWUFBYSxFQUNYb0IsYUFBYSxJQUFJLEVBQ2pCaEMsYUFBYWdDLFVBQVUsRUFDdkJDLHFCQUFxQixLQUFLLEVBQzNCLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDTnRFLE9BQU8sSUFBSSxFQUFFRCxZQUFZO1FBRXpCLElBQUksQ0FBQ3dFLE1BQU0sR0FBRyxFQUFFO1FBQ2hCLElBQUksQ0FBQ0MsV0FBVyxHQUFHbkM7UUFDbkIsSUFBSSxDQUFDb0MsbUJBQW1CLEdBQUdIO1FBQzNCLElBQUksQ0FBQ0ksVUFBVTtJQUNqQjtJQUVBQSxhQUFjO1FBQ1osSUFBSSxDQUFDQyxZQUFZLEdBQUd2RSxPQUFPOEIsTUFBTSxDQUFDO1FBQ2xDLElBQUksQ0FBQzBDLFVBQVUsR0FBR3hFLE9BQU84QixNQUFNLENBQUM7SUFDbEM7SUFFQTJDLFlBQWF6QyxPQUFPLEVBQUU7UUFDcEIsTUFBTTtRQUNOLElBQUlBLFdBQVdBLE9BQU8sQ0FBQ3JDLFdBQVcsRUFBRTtZQUNsQyxJQUFJLENBQUN3RSxNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNLENBQUNPLE1BQU0sQ0FBQzFDLFFBQVFtQyxNQUFNO1lBQy9DLElBQUksQ0FBQ1EsTUFBTSxHQUFHO1lBQ2Q7UUFDRjtRQUVBLElBQUlsQyxhQUFhVCxVQUFVO1lBQ3pCLE1BQU00QyxPQUFPM0IsV0FBV2pCLFNBQVMsSUFBSSxDQUFDb0MsV0FBVztZQUNqRCxJQUFJLENBQUNPLE1BQU0sR0FBRztZQUNkLElBQUksQ0FBQ1IsTUFBTSxDQUFDVSxJQUFJLENBQUNEO1FBQ25CO0lBQ0Y7SUFFQSxtREFBbUQ7SUFDbkRFLElBQUs5QyxPQUFPLEVBQUU7UUFDWixJQUFJLENBQUMyQyxNQUFNLEdBQUc7UUFFZGpHLFVBQ0U4RCxTQUFTUixXQUNMVSxhQUFhVixXQUNiQSxTQUNKK0MsT0FBTyxDQUFDLElBQUksQ0FBQ04sV0FBVyxFQUFFLElBQUk7UUFFaEMsNENBQTRDO1FBQzVDLCtCQUErQjtRQUMvQixJQUFJLElBQUksQ0FBQ0UsTUFBTSxFQUFFO1lBQ2YsSUFBSSxDQUFDTCxVQUFVO1FBQ2pCO1FBRUEsT0FBTyxJQUFJO0lBQ2I7SUFFQSxTQUFTO0lBQ1RVLFdBQVloRCxPQUFPLEVBQUU7UUFDbkIsT0FBTyxJQUFJLENBQUM4QyxHQUFHLENBQUM5QztJQUNsQjtJQUVBLDJDQUEyQztJQUMzQyxpREFBaUQ7SUFDakQsb0RBQW9EO0lBQ3BELGdEQUFnRDtJQUNoRCxnREFBZ0Q7SUFFaEQsc0JBQXNCO0lBQ3RCLHNCQUFzQjtJQUN0Qix3Q0FBd0M7SUFDeEMseUJBQXlCO0lBRXpCLGtFQUFrRTtJQUNsRSxnRUFBZ0U7SUFDaEUsbUJBQW1CO0lBRW5CLGtEQUFrRDtJQUNsRGlELFNBQVUxQixJQUFJLEVBQUUyQixjQUFjLEVBQUU7UUFDOUIsSUFBSUMsVUFBVTtRQUNkLElBQUlDLFlBQVk7UUFFaEIsSUFBSSxDQUFDakIsTUFBTSxDQUFDWSxPQUFPLENBQUNILENBQUFBO1lBQ2xCLE1BQU0sRUFBQzdCLFFBQVEsRUFBQyxHQUFHNkI7WUFDbkIsSUFDRVEsY0FBY3JDLFlBQVlvQyxZQUFZQyxhQUNuQ3JDLFlBQVksQ0FBQ29DLFdBQVcsQ0FBQ0MsYUFBYSxDQUFDRixnQkFDMUM7Z0JBQ0E7WUFDRjtZQUVBLE1BQU1HLFVBQVVULEtBQUs1QixLQUFLLENBQUM5QixJQUFJLENBQUNxQztZQUVoQyxJQUFJOEIsU0FBUztnQkFDWEYsVUFBVSxDQUFDcEM7Z0JBQ1hxQyxZQUFZckM7WUFDZDtRQUNGO1FBRUEsT0FBTztZQUNMb0M7WUFDQUM7UUFDRjtJQUNGO0lBRUEsd0JBQXdCO0lBQ3hCRSxNQUFPOUIsWUFBWSxFQUFFK0IsS0FBSyxFQUFFTCxjQUFjLEVBQUVNLE1BQU0sRUFBRTtRQUNsRCxNQUFNakMsT0FBT0MsZ0JBRVJGLFVBQVVRLE9BQU8sQ0FBQ047UUFFdkJGLFVBQ0VDLE1BQ0FDLGNBQ0EsSUFBSSxDQUFDYSxtQkFBbUIsR0FDcEJsRSxlQUNBZ0Q7UUFHTixPQUFPLElBQUksQ0FBQ3NDLEVBQUUsQ0FBQ2xDLE1BQU1nQyxPQUFPTCxnQkFBZ0JNO0lBQzlDO0lBRUFDLEdBQUlsQyxJQUFJLEVBQUVnQyxLQUFLLEVBQUVMLGNBQWMsRUFBRU0sTUFBTSxFQUFFO1FBQ3ZDLElBQUlqQyxRQUFRZ0MsT0FBTztZQUNqQixPQUFPQSxLQUFLLENBQUNoQyxLQUFLO1FBQ3BCO1FBRUEsSUFBSSxDQUFDaUMsUUFBUTtZQUNYLGVBQWU7WUFDZix5QkFBeUI7WUFDekJBLFNBQVNqQyxLQUFLWixLQUFLLENBQUNwRDtRQUN0QjtRQUVBaUcsT0FBT0UsR0FBRztRQUVWLG9EQUFvRDtRQUNwRCxJQUFJLENBQUNGLE9BQU8zRSxNQUFNLEVBQUU7WUFDbEIsT0FBTzBFLEtBQUssQ0FBQ2hDLEtBQUssR0FBRyxJQUFJLENBQUMwQixRQUFRLENBQUMxQixNQUFNMkI7UUFDM0M7UUFFQSxNQUFNUyxTQUFTLElBQUksQ0FBQ0YsRUFBRSxDQUNwQkQsT0FBT0ksSUFBSSxDQUFDckcsU0FBU0EsT0FDckJnRyxPQUNBTCxnQkFDQU07UUFHRixrRUFBa0U7UUFDbEUsT0FBT0QsS0FBSyxDQUFDaEMsS0FBSyxHQUFHb0MsT0FBT1IsT0FBTyxHQUcvQlEsU0FDQSxJQUFJLENBQUNWLFFBQVEsQ0FBQzFCLE1BQU0yQjtJQUMxQjtJQUVBVyxRQUFTdEMsSUFBSSxFQUFFO1FBQ2IsT0FBTyxJQUFJLENBQUMrQixLQUFLLENBQUMvQixNQUFNLElBQUksQ0FBQ2dCLFlBQVksRUFBRSxPQUFPWSxPQUFPO0lBQzNEO0lBRUFXLGVBQWdCO1FBQ2QsT0FBT3ZDLENBQUFBLE9BQVEsQ0FBQyxJQUFJLENBQUNzQyxPQUFPLENBQUN0QztJQUMvQjtJQUVBd0MsT0FBUUMsS0FBSyxFQUFFO1FBQ2IsT0FBT3RILFVBQVVzSCxPQUFPRCxNQUFNLENBQUMsSUFBSSxDQUFDRCxZQUFZO0lBQ2xEO0lBRUEsd0JBQXdCO0lBQ3hCNUUsS0FBTXFDLElBQUksRUFBRTtRQUNWLE9BQU8sSUFBSSxDQUFDK0IsS0FBSyxDQUFDL0IsTUFBTSxJQUFJLENBQUNpQixVQUFVLEVBQUU7SUFDM0M7QUFDRjtBQUVBLE1BQU15QixVQUFVQyxDQUFBQSxVQUFXLElBQUlsQyxPQUFPa0M7QUFFdEMsTUFBTUMsY0FBYzVDLENBQUFBLE9BQ2xCRCxVQUFVQyxRQUFRRCxVQUFVUSxPQUFPLENBQUNQLE9BQU9BLE1BQU1wRDtBQUVuRDhGLFFBQVFFLFdBQVcsR0FBR0E7QUFFdEIsbUJBQW1CO0FBQ25CRixRQUFRRyxPQUFPLEdBQUdIO0FBRWxCSSxPQUFPQyxPQUFPLEdBQUdMO0FBRWpCLFVBQVU7QUFDVixpRUFBaUU7QUFDakUsc0JBQXNCLEdBQ3RCLElBQ0UsbURBQW1EO0FBQ25ELE9BQU9NLFlBQVksZUFFakJBLENBQUFBLFFBQVFDLEdBQUcsSUFBSUQsUUFBUUMsR0FBRyxDQUFDQyxpQkFBaUIsSUFDekNGLFFBQVFHLFFBQVEsS0FBSyxPQUFNLEdBRWhDO0lBQ0Esa0NBQWtDLEdBQ2xDLE1BQU1DLFlBQVl0RixDQUFBQSxNQUFPLFlBQVlILElBQUksQ0FBQ0csUUFDdkMsd0JBQXdCSCxJQUFJLENBQUNHLE9BQzVCQSxNQUNBQSxJQUFJZixPQUFPLENBQUMsT0FBTztJQUV2QmdELFVBQVVRLE9BQU8sR0FBRzZDO0lBRXBCLHlEQUF5RDtJQUN6RCxZQUFZO0lBQ1osTUFBTUMsaUNBQWlDO0lBQ3ZDdEQsVUFBVUssYUFBYSxHQUFHSixDQUFBQSxPQUN4QnFELCtCQUErQjFGLElBQUksQ0FBQ3FDLFNBQ2pDSSxjQUFjSjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BrZXlzdGF0aWMvdGVtcGxhdGVzLW5leHRqcy8uL25vZGVfbW9kdWxlcy9pZ25vcmUvaW5kZXguanM/NzZmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBIHNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBtYWtlLWFycmF5XG5mdW5jdGlvbiBtYWtlQXJyYXkgKHN1YmplY3QpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3ViamVjdClcbiAgICA/IHN1YmplY3RcbiAgICA6IFtzdWJqZWN0XVxufVxuXG5jb25zdCBFTVBUWSA9ICcnXG5jb25zdCBTUEFDRSA9ICcgJ1xuY29uc3QgRVNDQVBFID0gJ1xcXFwnXG5jb25zdCBSRUdFWF9URVNUX0JMQU5LX0xJTkUgPSAvXlxccyskL1xuY29uc3QgUkVHRVhfSU5WQUxJRF9UUkFJTElOR19CQUNLU0xBU0ggPSAvKD86W15cXFxcXXxeKVxcXFwkL1xuY29uc3QgUkVHRVhfUkVQTEFDRV9MRUFESU5HX0VYQ0FQRURfRVhDTEFNQVRJT04gPSAvXlxcXFwhL1xuY29uc3QgUkVHRVhfUkVQTEFDRV9MRUFESU5HX0VYQ0FQRURfSEFTSCA9IC9eXFxcXCMvXG5jb25zdCBSRUdFWF9TUExJVEFMTF9DUkxGID0gL1xccj9cXG4vZ1xuLy8gL2Zvbyxcbi8vIC4vZm9vLFxuLy8gLi4vZm9vLFxuLy8gLlxuLy8gLi5cbmNvbnN0IFJFR0VYX1RFU1RfSU5WQUxJRF9QQVRIID0gL15cXC4qXFwvfF5cXC4rJC9cblxuY29uc3QgU0xBU0ggPSAnLydcblxuLy8gRG8gbm90IHVzZSB0ZXJuYXJ5IGV4cHJlc3Npb24gaGVyZSwgc2luY2UgXCJpc3RhbmJ1bCBpZ25vcmUgbmV4dFwiIGlzIGJ1Z2d5XG5sZXQgVE1QX0tFWV9JR05PUkUgPSAnbm9kZS1pZ25vcmUnXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnKSB7XG4gIFRNUF9LRVlfSUdOT1JFID0gU3ltYm9sLmZvcignbm9kZS1pZ25vcmUnKVxufVxuY29uc3QgS0VZX0lHTk9SRSA9IFRNUF9LRVlfSUdOT1JFXG5cbmNvbnN0IGRlZmluZSA9IChvYmplY3QsIGtleSwgdmFsdWUpID0+XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge3ZhbHVlfSlcblxuY29uc3QgUkVHRVhfUkVHRVhQX1JBTkdFID0gLyhbMC16XSktKFswLXpdKS9nXG5cbmNvbnN0IFJFVFVSTl9GQUxTRSA9ICgpID0+IGZhbHNlXG5cbi8vIFNhbml0aXplIHRoZSByYW5nZSBvZiBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuLy8gVGhlIGNhc2VzIGFyZSBjb21wbGljYXRlZCwgc2VlIHRlc3QgY2FzZXMgZm9yIGRldGFpbHNcbmNvbnN0IHNhbml0aXplUmFuZ2UgPSByYW5nZSA9PiByYW5nZS5yZXBsYWNlKFxuICBSRUdFWF9SRUdFWFBfUkFOR0UsXG4gIChtYXRjaCwgZnJvbSwgdG8pID0+IGZyb20uY2hhckNvZGVBdCgwKSA8PSB0by5jaGFyQ29kZUF0KDApXG4gICAgPyBtYXRjaFxuICAgIC8vIEludmFsaWQgcmFuZ2UgKG91dCBvZiBvcmRlcikgd2hpY2ggaXMgb2sgZm9yIGdpdGlnbm9yZSBydWxlcyBidXRcbiAgICAvLyAgIGZhdGFsIGZvciBKYXZhU2NyaXB0IHJlZ3VsYXIgZXhwcmVzc2lvbiwgc28gZWxpbWluYXRlIGl0LlxuICAgIDogRU1QVFlcbilcblxuLy8gU2VlIGZpeHR1cmVzICM1OVxuY29uc3QgY2xlYW5SYW5nZUJhY2tTbGFzaCA9IHNsYXNoZXMgPT4ge1xuICBjb25zdCB7bGVuZ3RofSA9IHNsYXNoZXNcbiAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMCwgbGVuZ3RoIC0gbGVuZ3RoICUgMilcbn1cblxuLy8gPiBJZiB0aGUgcGF0dGVybiBlbmRzIHdpdGggYSBzbGFzaCxcbi8vID4gaXQgaXMgcmVtb3ZlZCBmb3IgdGhlIHB1cnBvc2Ugb2YgdGhlIGZvbGxvd2luZyBkZXNjcmlwdGlvbixcbi8vID4gYnV0IGl0IHdvdWxkIG9ubHkgZmluZCBhIG1hdGNoIHdpdGggYSBkaXJlY3RvcnkuXG4vLyA+IEluIG90aGVyIHdvcmRzLCBmb28vIHdpbGwgbWF0Y2ggYSBkaXJlY3RvcnkgZm9vIGFuZCBwYXRocyB1bmRlcm5lYXRoIGl0LFxuLy8gPiBidXQgd2lsbCBub3QgbWF0Y2ggYSByZWd1bGFyIGZpbGUgb3IgYSBzeW1ib2xpYyBsaW5rIGZvb1xuLy8gPiAgKHRoaXMgaXMgY29uc2lzdGVudCB3aXRoIHRoZSB3YXkgaG93IHBhdGhzcGVjIHdvcmtzIGluIGdlbmVyYWwgaW4gR2l0KS5cbi8vICdgZm9vL2AnIHdpbGwgbm90IG1hdGNoIHJlZ3VsYXIgZmlsZSAnYGZvb2AnIG9yIHN5bWJvbGljIGxpbmsgJ2Bmb29gJ1xuLy8gLT4gaWdub3JlLXJ1bGVzIHdpbGwgbm90IGRlYWwgd2l0aCBpdCwgYmVjYXVzZSBpdCBjb3N0cyBleHRyYSBgZnMuc3RhdGAgY2FsbFxuLy8gICAgICB5b3UgY291bGQgdXNlIG9wdGlvbiBgbWFyazogdHJ1ZWAgd2l0aCBgZ2xvYmBcblxuLy8gJ2Bmb28vYCcgc2hvdWxkIG5vdCBjb250aW51ZSB3aXRoIHRoZSAnYC4uYCdcbmNvbnN0IFJFUExBQ0VSUyA9IFtcblxuICBbXG4gICAgLy8gcmVtb3ZlIEJPTVxuICAgIC8vIFRPRE86XG4gICAgLy8gT3RoZXIgc2ltaWxhciB6ZXJvLXdpZHRoIGNoYXJhY3RlcnM/XG4gICAgL15cXHVGRUZGLyxcbiAgICAoKSA9PiBFTVBUWVxuICBdLFxuXG4gIC8vID4gVHJhaWxpbmcgc3BhY2VzIGFyZSBpZ25vcmVkIHVubGVzcyB0aGV5IGFyZSBxdW90ZWQgd2l0aCBiYWNrc2xhc2ggKFwiXFxcIilcbiAgW1xuICAgIC8vIChhXFwgKSAtPiAoYSApXG4gICAgLy8gKGEgICkgLT4gKGEpXG4gICAgLy8gKGEgXFwgKSAtPiAoYSAgKVxuICAgIC9cXFxcP1xccyskLyxcbiAgICBtYXRjaCA9PiBtYXRjaC5pbmRleE9mKCdcXFxcJykgPT09IDBcbiAgICAgID8gU1BBQ0VcbiAgICAgIDogRU1QVFlcbiAgXSxcblxuICAvLyByZXBsYWNlIChcXCApIHdpdGggJyAnXG4gIFtcbiAgICAvXFxcXFxccy9nLFxuICAgICgpID0+IFNQQUNFXG4gIF0sXG5cbiAgLy8gRXNjYXBlIG1ldGFjaGFyYWN0ZXJzXG4gIC8vIHdoaWNoIGlzIHdyaXR0ZW4gZG93biBieSB1c2VycyBidXQgbWVhbnMgc3BlY2lhbCBmb3IgcmVndWxhciBleHByZXNzaW9ucy5cblxuICAvLyA+IFRoZXJlIGFyZSAxMiBjaGFyYWN0ZXJzIHdpdGggc3BlY2lhbCBtZWFuaW5nczpcbiAgLy8gPiAtIHRoZSBiYWNrc2xhc2ggXFwsXG4gIC8vID4gLSB0aGUgY2FyZXQgXixcbiAgLy8gPiAtIHRoZSBkb2xsYXIgc2lnbiAkLFxuICAvLyA+IC0gdGhlIHBlcmlvZCBvciBkb3QgLixcbiAgLy8gPiAtIHRoZSB2ZXJ0aWNhbCBiYXIgb3IgcGlwZSBzeW1ib2wgfCxcbiAgLy8gPiAtIHRoZSBxdWVzdGlvbiBtYXJrID8sXG4gIC8vID4gLSB0aGUgYXN0ZXJpc2sgb3Igc3RhciAqLFxuICAvLyA+IC0gdGhlIHBsdXMgc2lnbiArLFxuICAvLyA+IC0gdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMgKCxcbiAgLy8gPiAtIHRoZSBjbG9zaW5nIHBhcmVudGhlc2lzICksXG4gIC8vID4gLSBhbmQgdGhlIG9wZW5pbmcgc3F1YXJlIGJyYWNrZXQgWyxcbiAgLy8gPiAtIHRoZSBvcGVuaW5nIGN1cmx5IGJyYWNlIHssXG4gIC8vID4gVGhlc2Ugc3BlY2lhbCBjaGFyYWN0ZXJzIGFyZSBvZnRlbiBjYWxsZWQgXCJtZXRhY2hhcmFjdGVyc1wiLlxuICBbXG4gICAgL1tcXFxcJC58KisoKXteXS9nLFxuICAgIG1hdGNoID0+IGBcXFxcJHttYXRjaH1gXG4gIF0sXG5cbiAgW1xuICAgIC8vID4gYSBxdWVzdGlvbiBtYXJrICg/KSBtYXRjaGVzIGEgc2luZ2xlIGNoYXJhY3RlclxuICAgIC8oPyFcXFxcKVxcPy9nLFxuICAgICgpID0+ICdbXi9dJ1xuICBdLFxuXG4gIC8vIGxlYWRpbmcgc2xhc2hcbiAgW1xuXG4gICAgLy8gPiBBIGxlYWRpbmcgc2xhc2ggbWF0Y2hlcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwYXRobmFtZS5cbiAgICAvLyA+IEZvciBleGFtcGxlLCBcIi8qLmNcIiBtYXRjaGVzIFwiY2F0LWZpbGUuY1wiIGJ1dCBub3QgXCJtb3ppbGxhLXNoYTEvc2hhMS5jXCIuXG4gICAgLy8gQSBsZWFkaW5nIHNsYXNoIG1hdGNoZXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgcGF0aG5hbWVcbiAgICAvXlxcLy8sXG4gICAgKCkgPT4gJ14nXG4gIF0sXG5cbiAgLy8gcmVwbGFjZSBzcGVjaWFsIG1ldGFjaGFyYWN0ZXIgc2xhc2ggYWZ0ZXIgdGhlIGxlYWRpbmcgc2xhc2hcbiAgW1xuICAgIC9cXC8vZyxcbiAgICAoKSA9PiAnXFxcXC8nXG4gIF0sXG5cbiAgW1xuICAgIC8vID4gQSBsZWFkaW5nIFwiKipcIiBmb2xsb3dlZCBieSBhIHNsYXNoIG1lYW5zIG1hdGNoIGluIGFsbCBkaXJlY3Rvcmllcy5cbiAgICAvLyA+IEZvciBleGFtcGxlLCBcIioqL2Zvb1wiIG1hdGNoZXMgZmlsZSBvciBkaXJlY3RvcnkgXCJmb29cIiBhbnl3aGVyZSxcbiAgICAvLyA+IHRoZSBzYW1lIGFzIHBhdHRlcm4gXCJmb29cIi5cbiAgICAvLyA+IFwiKiovZm9vL2JhclwiIG1hdGNoZXMgZmlsZSBvciBkaXJlY3RvcnkgXCJiYXJcIiBhbnl3aGVyZSB0aGF0IGlzIGRpcmVjdGx5XG4gICAgLy8gPiAgIHVuZGVyIGRpcmVjdG9yeSBcImZvb1wiLlxuICAgIC8vIE5vdGljZSB0aGF0IHRoZSAnKidzIGhhdmUgYmVlbiByZXBsYWNlZCBhcyAnXFxcXConXG4gICAgL15cXF4qXFxcXFxcKlxcXFxcXCpcXFxcXFwvLyxcblxuICAgIC8vICcqKi9mb28nIDwtPiAnZm9vJ1xuICAgICgpID0+ICdeKD86LipcXFxcLyk/J1xuICBdLFxuXG4gIC8vIHN0YXJ0aW5nXG4gIFtcbiAgICAvLyB0aGVyZSB3aWxsIGJlIG5vIGxlYWRpbmcgJy8nXG4gICAgLy8gICAod2hpY2ggaGFzIGJlZW4gcmVwbGFjZWQgYnkgc2VjdGlvbiBcImxlYWRpbmcgc2xhc2hcIilcbiAgICAvLyBJZiBzdGFydHMgd2l0aCAnKionLCBhZGRpbmcgYSAnXicgdG8gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbHNvIHdvcmtzXG4gICAgL14oPz1bXl5dKS8sXG4gICAgZnVuY3Rpb24gc3RhcnRpbmdSZXBsYWNlciAoKSB7XG4gICAgICAvLyBJZiBoYXMgYSBzbGFzaCBgL2AgYXQgdGhlIGJlZ2lubmluZyBvciBtaWRkbGVcbiAgICAgIHJldHVybiAhL1xcLyg/ISQpLy50ZXN0KHRoaXMpXG4gICAgICAgIC8vID4gUHJpb3IgdG8gMi4yMi4xXG4gICAgICAgIC8vID4gSWYgdGhlIHBhdHRlcm4gZG9lcyBub3QgY29udGFpbiBhIHNsYXNoIC8sXG4gICAgICAgIC8vID4gICBHaXQgdHJlYXRzIGl0IGFzIGEgc2hlbGwgZ2xvYiBwYXR0ZXJuXG4gICAgICAgIC8vIEFjdHVhbGx5LCBpZiB0aGVyZSBpcyBvbmx5IGEgdHJhaWxpbmcgc2xhc2gsXG4gICAgICAgIC8vICAgZ2l0IGFsc28gdHJlYXRzIGl0IGFzIGEgc2hlbGwgZ2xvYiBwYXR0ZXJuXG5cbiAgICAgICAgLy8gQWZ0ZXIgMi4yMi4xIChjb21wYXRpYmxlIGJ1dCBjbGVhcmVyKVxuICAgICAgICAvLyA+IElmIHRoZXJlIGlzIGEgc2VwYXJhdG9yIGF0IHRoZSBiZWdpbm5pbmcgb3IgbWlkZGxlIChvciBib3RoKVxuICAgICAgICAvLyA+IG9mIHRoZSBwYXR0ZXJuLCB0aGVuIHRoZSBwYXR0ZXJuIGlzIHJlbGF0aXZlIHRvIHRoZSBkaXJlY3RvcnlcbiAgICAgICAgLy8gPiBsZXZlbCBvZiB0aGUgcGFydGljdWxhciAuZ2l0aWdub3JlIGZpbGUgaXRzZWxmLlxuICAgICAgICAvLyA+IE90aGVyd2lzZSB0aGUgcGF0dGVybiBtYXkgYWxzbyBtYXRjaCBhdCBhbnkgbGV2ZWwgYmVsb3dcbiAgICAgICAgLy8gPiB0aGUgLmdpdGlnbm9yZSBsZXZlbC5cbiAgICAgICAgPyAnKD86XnxcXFxcLyknXG5cbiAgICAgICAgLy8gPiBPdGhlcndpc2UsIEdpdCB0cmVhdHMgdGhlIHBhdHRlcm4gYXMgYSBzaGVsbCBnbG9iIHN1aXRhYmxlIGZvclxuICAgICAgICAvLyA+ICAgY29uc3VtcHRpb24gYnkgZm5tYXRjaCgzKVxuICAgICAgICA6ICdeJ1xuICAgIH1cbiAgXSxcblxuICAvLyB0d28gZ2xvYnN0YXJzXG4gIFtcbiAgICAvLyBVc2UgbG9va2FoZWFkIGFzc2VydGlvbnMgc28gdGhhdCB3ZSBjb3VsZCBtYXRjaCBtb3JlIHRoYW4gb25lIGAnLyoqJ2BcbiAgICAvXFxcXFxcL1xcXFxcXCpcXFxcXFwqKD89XFxcXFxcL3wkKS9nLFxuXG4gICAgLy8gWmVybywgb25lIG9yIHNldmVyYWwgZGlyZWN0b3JpZXNcbiAgICAvLyBzaG91bGQgbm90IHVzZSAnKicsIG9yIGl0IHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIG5leHQgcmVwbGFjZXJcblxuICAgIC8vIENoZWNrIGlmIGl0IGlzIG5vdCB0aGUgbGFzdCBgJy8qKidgXG4gICAgKF8sIGluZGV4LCBzdHIpID0+IGluZGV4ICsgNiA8IHN0ci5sZW5ndGhcblxuICAgICAgLy8gY2FzZTogLyoqL1xuICAgICAgLy8gPiBBIHNsYXNoIGZvbGxvd2VkIGJ5IHR3byBjb25zZWN1dGl2ZSBhc3Rlcmlza3MgdGhlbiBhIHNsYXNoIG1hdGNoZXNcbiAgICAgIC8vID4gICB6ZXJvIG9yIG1vcmUgZGlyZWN0b3JpZXMuXG4gICAgICAvLyA+IEZvciBleGFtcGxlLCBcImEvKiovYlwiIG1hdGNoZXMgXCJhL2JcIiwgXCJhL3gvYlwiLCBcImEveC95L2JcIiBhbmQgc28gb24uXG4gICAgICAvLyAnLyoqLydcbiAgICAgID8gJyg/OlxcXFwvW15cXFxcL10rKSonXG5cbiAgICAgIC8vIGNhc2U6IC8qKlxuICAgICAgLy8gPiBBIHRyYWlsaW5nIGBcIi8qKlwiYCBtYXRjaGVzIGV2ZXJ5dGhpbmcgaW5zaWRlLlxuXG4gICAgICAvLyAjMjE6IGV2ZXJ5dGhpbmcgaW5zaWRlIGJ1dCBpdCBzaG91bGQgbm90IGluY2x1ZGUgdGhlIGN1cnJlbnQgZm9sZGVyXG4gICAgICA6ICdcXFxcLy4rJ1xuICBdLFxuXG4gIC8vIG5vcm1hbCBpbnRlcm1lZGlhdGUgd2lsZGNhcmRzXG4gIFtcbiAgICAvLyBOZXZlciByZXBsYWNlIGVzY2FwZWQgJyonXG4gICAgLy8gaWdub3JlIHJ1bGUgJ1xcKicgd2lsbCBtYXRjaCB0aGUgcGF0aCAnKidcblxuICAgIC8vICdhYmMuKi8nIC0+IGdvXG4gICAgLy8gJ2FiYy4qJyAgLT4gc2tpcCB0aGlzIHJ1bGUsXG4gICAgLy8gICAgY296IHRyYWlsaW5nIHNpbmdsZSB3aWxkY2FyZCB3aWxsIGJlIGhhbmRlZCBieSBbdHJhaWxpbmcgd2lsZGNhcmRdXG4gICAgLyhefFteXFxcXF0rKShcXFxcXFwqKSsoPz0uKykvZyxcblxuICAgIC8vICcqLmpzJyBtYXRjaGVzICcuanMnXG4gICAgLy8gJyouanMnIGRvZXNuJ3QgbWF0Y2ggJ2FiYydcbiAgICAoXywgcDEsIHAyKSA9PiB7XG4gICAgICAvLyAxLlxuICAgICAgLy8gPiBBbiBhc3RlcmlzayBcIipcIiBtYXRjaGVzIGFueXRoaW5nIGV4Y2VwdCBhIHNsYXNoLlxuICAgICAgLy8gMi5cbiAgICAgIC8vID4gT3RoZXIgY29uc2VjdXRpdmUgYXN0ZXJpc2tzIGFyZSBjb25zaWRlcmVkIHJlZ3VsYXIgYXN0ZXJpc2tzXG4gICAgICAvLyA+IGFuZCB3aWxsIG1hdGNoIGFjY29yZGluZyB0byB0aGUgcHJldmlvdXMgcnVsZXMuXG4gICAgICBjb25zdCB1bmVzY2FwZWQgPSBwMi5yZXBsYWNlKC9cXFxcXFwqL2csICdbXlxcXFwvXSonKVxuICAgICAgcmV0dXJuIHAxICsgdW5lc2NhcGVkXG4gICAgfVxuICBdLFxuXG4gIFtcbiAgICAvLyB1bmVzY2FwZSwgcmV2ZXJ0IHN0ZXAgMyBleGNlcHQgZm9yIGJhY2sgc2xhc2hcbiAgICAvLyBGb3IgZXhhbXBsZSwgaWYgYSB1c2VyIGVzY2FwZSBhICdcXFxcKicsXG4gICAgLy8gYWZ0ZXIgc3RlcCAzLCB0aGUgcmVzdWx0IHdpbGwgYmUgJ1xcXFxcXFxcXFxcXConXG4gICAgL1xcXFxcXFxcXFxcXCg/PVskLnwqKygpe15dKS9nLFxuICAgICgpID0+IEVTQ0FQRVxuICBdLFxuXG4gIFtcbiAgICAvLyAnXFxcXFxcXFwnIC0+ICdcXFxcJ1xuICAgIC9cXFxcXFxcXC9nLFxuICAgICgpID0+IEVTQ0FQRVxuICBdLFxuXG4gIFtcbiAgICAvLyA+IFRoZSByYW5nZSBub3RhdGlvbiwgZS5nLiBbYS16QS1aXSxcbiAgICAvLyA+IGNhbiBiZSB1c2VkIHRvIG1hdGNoIG9uZSBvZiB0aGUgY2hhcmFjdGVycyBpbiBhIHJhbmdlLlxuXG4gICAgLy8gYFxcYCBpcyBlc2NhcGVkIGJ5IHN0ZXAgM1xuICAgIC8oXFxcXCk/XFxbKFteXFxdL10qPykoXFxcXCopKCR8XFxdKS9nLFxuICAgIChtYXRjaCwgbGVhZEVzY2FwZSwgcmFuZ2UsIGVuZEVzY2FwZSwgY2xvc2UpID0+IGxlYWRFc2NhcGUgPT09IEVTQ0FQRVxuICAgICAgLy8gJ1xcXFxbYmFyXScgLT4gJ1xcXFxcXFxcW2JhclxcXFxdJ1xuICAgICAgPyBgXFxcXFske3JhbmdlfSR7Y2xlYW5SYW5nZUJhY2tTbGFzaChlbmRFc2NhcGUpfSR7Y2xvc2V9YFxuICAgICAgOiBjbG9zZSA9PT0gJ10nXG4gICAgICAgID8gZW5kRXNjYXBlLmxlbmd0aCAlIDIgPT09IDBcbiAgICAgICAgICAvLyBBIG5vcm1hbCBjYXNlLCBhbmQgaXQgaXMgYSByYW5nZSBub3RhdGlvblxuICAgICAgICAgIC8vICdbYmFyXSdcbiAgICAgICAgICAvLyAnW2JhclxcXFxcXFxcXSdcbiAgICAgICAgICA/IGBbJHtzYW5pdGl6ZVJhbmdlKHJhbmdlKX0ke2VuZEVzY2FwZX1dYFxuICAgICAgICAgIC8vIEludmFsaWQgcmFuZ2Ugbm90YXRvblxuICAgICAgICAgIC8vICdbYmFyXFxcXF0nIC0+ICdbYmFyXFxcXFxcXFxdJ1xuICAgICAgICAgIDogJ1tdJ1xuICAgICAgICA6ICdbXSdcbiAgXSxcblxuICAvLyBlbmRpbmdcbiAgW1xuICAgIC8vICdqcycgd2lsbCBub3QgbWF0Y2ggJ2pzLidcbiAgICAvLyAnYWInIHdpbGwgbm90IG1hdGNoICdhYmMnXG4gICAgLyg/OlteKl0pJC8sXG5cbiAgICAvLyBXVEYhXG4gICAgLy8gaHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdGlnbm9yZVxuICAgIC8vIGNoYW5nZXMgaW4gWzIuMjIuMV0oaHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdGlnbm9yZS8yLjIyLjEpXG4gICAgLy8gd2hpY2ggcmUtZml4ZXMgIzI0LCAjMzhcblxuICAgIC8vID4gSWYgdGhlcmUgaXMgYSBzZXBhcmF0b3IgYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiB0aGVuIHRoZSBwYXR0ZXJuXG4gICAgLy8gPiB3aWxsIG9ubHkgbWF0Y2ggZGlyZWN0b3JpZXMsIG90aGVyd2lzZSB0aGUgcGF0dGVybiBjYW4gbWF0Y2ggYm90aFxuICAgIC8vID4gZmlsZXMgYW5kIGRpcmVjdG9yaWVzLlxuXG4gICAgLy8gJ2pzKicgd2lsbCBub3QgbWF0Y2ggJ2EuanMnXG4gICAgLy8gJ2pzLycgd2lsbCBub3QgbWF0Y2ggJ2EuanMnXG4gICAgLy8gJ2pzJyB3aWxsIG1hdGNoICdhLmpzJyBhbmQgJ2EuanMvJ1xuICAgIG1hdGNoID0+IC9cXC8kLy50ZXN0KG1hdGNoKVxuICAgICAgLy8gZm9vLyB3aWxsIG5vdCBtYXRjaCAnZm9vJ1xuICAgICAgPyBgJHttYXRjaH0kYFxuICAgICAgLy8gZm9vIG1hdGNoZXMgJ2ZvbycgYW5kICdmb28vJ1xuICAgICAgOiBgJHttYXRjaH0oPz0kfFxcXFwvJClgXG4gIF0sXG5cbiAgLy8gdHJhaWxpbmcgd2lsZGNhcmRcbiAgW1xuICAgIC8oXFxefFxcXFxcXC8pP1xcXFxcXCokLyxcbiAgICAoXywgcDEpID0+IHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IHAxXG4gICAgICAgIC8vICdcXF4nOlxuICAgICAgICAvLyAnLyonIGRvZXMgbm90IG1hdGNoIEVNUFRZXG4gICAgICAgIC8vICcvKicgZG9lcyBub3QgbWF0Y2ggZXZlcnl0aGluZ1xuXG4gICAgICAgIC8vICdcXFxcXFwvJzpcbiAgICAgICAgLy8gJ2FiYy8qJyBkb2VzIG5vdCBtYXRjaCAnYWJjLydcbiAgICAgICAgPyBgJHtwMX1bXi9dK2BcblxuICAgICAgICAvLyAnYSonIG1hdGNoZXMgJ2EnXG4gICAgICAgIC8vICdhKicgbWF0Y2hlcyAnYWEnXG4gICAgICAgIDogJ1teL10qJ1xuXG4gICAgICByZXR1cm4gYCR7cHJlZml4fSg/PSR8XFxcXC8kKWBcbiAgICB9XG4gIF0sXG5dXG5cbi8vIEEgc2ltcGxlIGNhY2hlLCBiZWNhdXNlIGFuIGlnbm9yZSBydWxlIG9ubHkgaGFzIG9ubHkgb25lIGNlcnRhaW4gbWVhbmluZ1xuY29uc3QgcmVnZXhDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuLy8gQHBhcmFtIHtwYXR0ZXJufVxuY29uc3QgbWFrZVJlZ2V4ID0gKHBhdHRlcm4sIGlnbm9yZUNhc2UpID0+IHtcbiAgbGV0IHNvdXJjZSA9IHJlZ2V4Q2FjaGVbcGF0dGVybl1cblxuICBpZiAoIXNvdXJjZSkge1xuICAgIHNvdXJjZSA9IFJFUExBQ0VSUy5yZWR1Y2UoXG4gICAgICAocHJldiwgY3VycmVudCkgPT4gcHJldi5yZXBsYWNlKGN1cnJlbnRbMF0sIGN1cnJlbnRbMV0uYmluZChwYXR0ZXJuKSksXG4gICAgICBwYXR0ZXJuXG4gICAgKVxuICAgIHJlZ2V4Q2FjaGVbcGF0dGVybl0gPSBzb3VyY2VcbiAgfVxuXG4gIHJldHVybiBpZ25vcmVDYXNlXG4gICAgPyBuZXcgUmVnRXhwKHNvdXJjZSwgJ2knKVxuICAgIDogbmV3IFJlZ0V4cChzb3VyY2UpXG59XG5cbmNvbnN0IGlzU3RyaW5nID0gc3ViamVjdCA9PiB0eXBlb2Ygc3ViamVjdCA9PT0gJ3N0cmluZydcblxuLy8gPiBBIGJsYW5rIGxpbmUgbWF0Y2hlcyBubyBmaWxlcywgc28gaXQgY2FuIHNlcnZlIGFzIGEgc2VwYXJhdG9yIGZvciByZWFkYWJpbGl0eS5cbmNvbnN0IGNoZWNrUGF0dGVybiA9IHBhdHRlcm4gPT4gcGF0dGVyblxuICAmJiBpc1N0cmluZyhwYXR0ZXJuKVxuICAmJiAhUkVHRVhfVEVTVF9CTEFOS19MSU5FLnRlc3QocGF0dGVybilcbiAgJiYgIVJFR0VYX0lOVkFMSURfVFJBSUxJTkdfQkFDS1NMQVNILnRlc3QocGF0dGVybilcblxuICAvLyA+IEEgbGluZSBzdGFydGluZyB3aXRoICMgc2VydmVzIGFzIGEgY29tbWVudC5cbiAgJiYgcGF0dGVybi5pbmRleE9mKCcjJykgIT09IDBcblxuY29uc3Qgc3BsaXRQYXR0ZXJuID0gcGF0dGVybiA9PiBwYXR0ZXJuLnNwbGl0KFJFR0VYX1NQTElUQUxMX0NSTEYpXG5cbmNsYXNzIElnbm9yZVJ1bGUge1xuICBjb25zdHJ1Y3RvciAoXG4gICAgb3JpZ2luLFxuICAgIHBhdHRlcm4sXG4gICAgbmVnYXRpdmUsXG4gICAgcmVnZXhcbiAgKSB7XG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW5cbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuXG4gICAgdGhpcy5uZWdhdGl2ZSA9IG5lZ2F0aXZlXG4gICAgdGhpcy5yZWdleCA9IHJlZ2V4XG4gIH1cbn1cblxuY29uc3QgY3JlYXRlUnVsZSA9IChwYXR0ZXJuLCBpZ25vcmVDYXNlKSA9PiB7XG4gIGNvbnN0IG9yaWdpbiA9IHBhdHRlcm5cbiAgbGV0IG5lZ2F0aXZlID0gZmFsc2VcblxuICAvLyA+IEFuIG9wdGlvbmFsIHByZWZpeCBcIiFcIiB3aGljaCBuZWdhdGVzIHRoZSBwYXR0ZXJuO1xuICBpZiAocGF0dGVybi5pbmRleE9mKCchJykgPT09IDApIHtcbiAgICBuZWdhdGl2ZSA9IHRydWVcbiAgICBwYXR0ZXJuID0gcGF0dGVybi5zdWJzdHIoMSlcbiAgfVxuXG4gIHBhdHRlcm4gPSBwYXR0ZXJuXG4gIC8vID4gUHV0IGEgYmFja3NsYXNoIChcIlxcXCIpIGluIGZyb250IG9mIHRoZSBmaXJzdCBcIiFcIiBmb3IgcGF0dGVybnMgdGhhdFxuICAvLyA+ICAgYmVnaW4gd2l0aCBhIGxpdGVyYWwgXCIhXCIsIGZvciBleGFtcGxlLCBgXCJcXCFpbXBvcnRhbnQhLnR4dFwiYC5cbiAgLnJlcGxhY2UoUkVHRVhfUkVQTEFDRV9MRUFESU5HX0VYQ0FQRURfRVhDTEFNQVRJT04sICchJylcbiAgLy8gPiBQdXQgYSBiYWNrc2xhc2ggKFwiXFxcIikgaW4gZnJvbnQgb2YgdGhlIGZpcnN0IGhhc2ggZm9yIHBhdHRlcm5zIHRoYXRcbiAgLy8gPiAgIGJlZ2luIHdpdGggYSBoYXNoLlxuICAucmVwbGFjZShSRUdFWF9SRVBMQUNFX0xFQURJTkdfRVhDQVBFRF9IQVNILCAnIycpXG5cbiAgY29uc3QgcmVnZXggPSBtYWtlUmVnZXgocGF0dGVybiwgaWdub3JlQ2FzZSlcblxuICByZXR1cm4gbmV3IElnbm9yZVJ1bGUoXG4gICAgb3JpZ2luLFxuICAgIHBhdHRlcm4sXG4gICAgbmVnYXRpdmUsXG4gICAgcmVnZXhcbiAgKVxufVxuXG5jb25zdCB0aHJvd0Vycm9yID0gKG1lc3NhZ2UsIEN0b3IpID0+IHtcbiAgdGhyb3cgbmV3IEN0b3IobWVzc2FnZSlcbn1cblxuY29uc3QgY2hlY2tQYXRoID0gKHBhdGgsIG9yaWdpbmFsUGF0aCwgZG9UaHJvdykgPT4ge1xuICBpZiAoIWlzU3RyaW5nKHBhdGgpKSB7XG4gICAgcmV0dXJuIGRvVGhyb3coXG4gICAgICBgcGF0aCBtdXN0IGJlIGEgc3RyaW5nLCBidXQgZ290IFxcYCR7b3JpZ2luYWxQYXRofVxcYGAsXG4gICAgICBUeXBlRXJyb3JcbiAgICApXG4gIH1cblxuICAvLyBXZSBkb24ndCBrbm93IGlmIHdlIHNob3VsZCBpZ25vcmUgRU1QVFksIHNvIHRocm93XG4gIGlmICghcGF0aCkge1xuICAgIHJldHVybiBkb1Rocm93KGBwYXRoIG11c3Qgbm90IGJlIGVtcHR5YCwgVHlwZUVycm9yKVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgaXQgaXMgYSByZWxhdGl2ZSBwYXRoXG4gIGlmIChjaGVja1BhdGguaXNOb3RSZWxhdGl2ZShwYXRoKSkge1xuICAgIGNvbnN0IHIgPSAnYHBhdGgucmVsYXRpdmUoKWBkJ1xuICAgIHJldHVybiBkb1Rocm93KFxuICAgICAgYHBhdGggc2hvdWxkIGJlIGEgJHtyfSBzdHJpbmcsIGJ1dCBnb3QgXCIke29yaWdpbmFsUGF0aH1cImAsXG4gICAgICBSYW5nZUVycm9yXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuY29uc3QgaXNOb3RSZWxhdGl2ZSA9IHBhdGggPT4gUkVHRVhfVEVTVF9JTlZBTElEX1BBVEgudGVzdChwYXRoKVxuXG5jaGVja1BhdGguaXNOb3RSZWxhdGl2ZSA9IGlzTm90UmVsYXRpdmVcbmNoZWNrUGF0aC5jb252ZXJ0ID0gcCA9PiBwXG5cbmNsYXNzIElnbm9yZSB7XG4gIGNvbnN0cnVjdG9yICh7XG4gICAgaWdub3JlY2FzZSA9IHRydWUsXG4gICAgaWdub3JlQ2FzZSA9IGlnbm9yZWNhc2UsXG4gICAgYWxsb3dSZWxhdGl2ZVBhdGhzID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgZGVmaW5lKHRoaXMsIEtFWV9JR05PUkUsIHRydWUpXG5cbiAgICB0aGlzLl9ydWxlcyA9IFtdXG4gICAgdGhpcy5faWdub3JlQ2FzZSA9IGlnbm9yZUNhc2VcbiAgICB0aGlzLl9hbGxvd1JlbGF0aXZlUGF0aHMgPSBhbGxvd1JlbGF0aXZlUGF0aHNcbiAgICB0aGlzLl9pbml0Q2FjaGUoKVxuICB9XG5cbiAgX2luaXRDYWNoZSAoKSB7XG4gICAgdGhpcy5faWdub3JlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgdGhpcy5fdGVzdENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICB9XG5cbiAgX2FkZFBhdHRlcm4gKHBhdHRlcm4pIHtcbiAgICAvLyAjMzJcbiAgICBpZiAocGF0dGVybiAmJiBwYXR0ZXJuW0tFWV9JR05PUkVdKSB7XG4gICAgICB0aGlzLl9ydWxlcyA9IHRoaXMuX3J1bGVzLmNvbmNhdChwYXR0ZXJuLl9ydWxlcylcbiAgICAgIHRoaXMuX2FkZGVkID0gdHJ1ZVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNoZWNrUGF0dGVybihwYXR0ZXJuKSkge1xuICAgICAgY29uc3QgcnVsZSA9IGNyZWF0ZVJ1bGUocGF0dGVybiwgdGhpcy5faWdub3JlQ2FzZSlcbiAgICAgIHRoaXMuX2FkZGVkID0gdHJ1ZVxuICAgICAgdGhpcy5fcnVsZXMucHVzaChydWxlKVxuICAgIH1cbiAgfVxuXG4gIC8vIEBwYXJhbSB7QXJyYXk8c3RyaW5nPiB8IHN0cmluZyB8IElnbm9yZX0gcGF0dGVyblxuICBhZGQgKHBhdHRlcm4pIHtcbiAgICB0aGlzLl9hZGRlZCA9IGZhbHNlXG5cbiAgICBtYWtlQXJyYXkoXG4gICAgICBpc1N0cmluZyhwYXR0ZXJuKVxuICAgICAgICA/IHNwbGl0UGF0dGVybihwYXR0ZXJuKVxuICAgICAgICA6IHBhdHRlcm5cbiAgICApLmZvckVhY2godGhpcy5fYWRkUGF0dGVybiwgdGhpcylcblxuICAgIC8vIFNvbWUgcnVsZXMgaGF2ZSBqdXN0IGFkZGVkIHRvIHRoZSBpZ25vcmUsXG4gICAgLy8gbWFraW5nIHRoZSBiZWhhdmlvciBjaGFuZ2VkLlxuICAgIGlmICh0aGlzLl9hZGRlZCkge1xuICAgICAgdGhpcy5faW5pdENhY2hlKClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gbGVnYWN5XG4gIGFkZFBhdHRlcm4gKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gdGhpcy5hZGQocGF0dGVybilcbiAgfVxuXG4gIC8vICAgICAgICAgIHwgICAgICAgICAgIGlnbm9yZWQgOiB1bmlnbm9yZWRcbiAgLy8gbmVnYXRpdmUgfCAgIDA6MCAgIHwgICAwOjEgICB8ICAgMTowICAgfCAgIDE6MVxuICAvLyAtLS0tLS0tLSB8IC0tLS0tLS0gfCAtLS0tLS0tIHwgLS0tLS0tLSB8IC0tLS0tLS0tXG4gIC8vICAgICAwICAgIHwgIFRFU1QgICB8ICBURVNUICAgfCAgU0tJUCAgIHwgICAgWFxuICAvLyAgICAgMSAgICB8ICBURVNUSUYgfCAgU0tJUCAgIHwgIFRFU1QgICB8ICAgIFhcblxuICAvLyAtIFNLSVA6IGFsd2F5cyBza2lwXG4gIC8vIC0gVEVTVDogYWx3YXlzIHRlc3RcbiAgLy8gLSBURVNUSUY6IG9ubHkgdGVzdCBpZiBjaGVja1VuaWdub3JlZFxuICAvLyAtIFg6IHRoYXQgbmV2ZXIgaGFwcGVuXG5cbiAgLy8gQHBhcmFtIHtib29sZWFufSB3aGV0aGVyIHNob3VsZCBjaGVjayBpZiB0aGUgcGF0aCBpcyB1bmlnbm9yZWQsXG4gIC8vICAgc2V0dGluZyBgY2hlY2tVbmlnbm9yZWRgIHRvIGBmYWxzZWAgY291bGQgcmVkdWNlIGFkZGl0aW9uYWxcbiAgLy8gICBwYXRoIG1hdGNoaW5nLlxuXG4gIC8vIEByZXR1cm5zIHtUZXN0UmVzdWx0fSB0cnVlIGlmIGEgZmlsZSBpcyBpZ25vcmVkXG4gIF90ZXN0T25lIChwYXRoLCBjaGVja1VuaWdub3JlZCkge1xuICAgIGxldCBpZ25vcmVkID0gZmFsc2VcbiAgICBsZXQgdW5pZ25vcmVkID0gZmFsc2VcblxuICAgIHRoaXMuX3J1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICBjb25zdCB7bmVnYXRpdmV9ID0gcnVsZVxuICAgICAgaWYgKFxuICAgICAgICB1bmlnbm9yZWQgPT09IG5lZ2F0aXZlICYmIGlnbm9yZWQgIT09IHVuaWdub3JlZFxuICAgICAgICB8fCBuZWdhdGl2ZSAmJiAhaWdub3JlZCAmJiAhdW5pZ25vcmVkICYmICFjaGVja1VuaWdub3JlZFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXRjaGVkID0gcnVsZS5yZWdleC50ZXN0KHBhdGgpXG5cbiAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIGlnbm9yZWQgPSAhbmVnYXRpdmVcbiAgICAgICAgdW5pZ25vcmVkID0gbmVnYXRpdmVcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlnbm9yZWQsXG4gICAgICB1bmlnbm9yZWRcbiAgICB9XG4gIH1cblxuICAvLyBAcmV0dXJucyB7VGVzdFJlc3VsdH1cbiAgX3Rlc3QgKG9yaWdpbmFsUGF0aCwgY2FjaGUsIGNoZWNrVW5pZ25vcmVkLCBzbGljZXMpIHtcbiAgICBjb25zdCBwYXRoID0gb3JpZ2luYWxQYXRoXG4gICAgICAvLyBTdXBwb3J0cyBudWxsYWJsZSBwYXRoXG4gICAgICAmJiBjaGVja1BhdGguY29udmVydChvcmlnaW5hbFBhdGgpXG5cbiAgICBjaGVja1BhdGgoXG4gICAgICBwYXRoLFxuICAgICAgb3JpZ2luYWxQYXRoLFxuICAgICAgdGhpcy5fYWxsb3dSZWxhdGl2ZVBhdGhzXG4gICAgICAgID8gUkVUVVJOX0ZBTFNFXG4gICAgICAgIDogdGhyb3dFcnJvclxuICAgIClcblxuICAgIHJldHVybiB0aGlzLl90KHBhdGgsIGNhY2hlLCBjaGVja1VuaWdub3JlZCwgc2xpY2VzKVxuICB9XG5cbiAgX3QgKHBhdGgsIGNhY2hlLCBjaGVja1VuaWdub3JlZCwgc2xpY2VzKSB7XG4gICAgaWYgKHBhdGggaW4gY2FjaGUpIHtcbiAgICAgIHJldHVybiBjYWNoZVtwYXRoXVxuICAgIH1cblxuICAgIGlmICghc2xpY2VzKSB7XG4gICAgICAvLyBwYXRoL3RvL2EuanNcbiAgICAgIC8vIFsncGF0aCcsICd0bycsICdhLmpzJ11cbiAgICAgIHNsaWNlcyA9IHBhdGguc3BsaXQoU0xBU0gpXG4gICAgfVxuXG4gICAgc2xpY2VzLnBvcCgpXG5cbiAgICAvLyBJZiB0aGUgcGF0aCBoYXMgbm8gcGFyZW50IGRpcmVjdG9yeSwganVzdCB0ZXN0IGl0XG4gICAgaWYgKCFzbGljZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gY2FjaGVbcGF0aF0gPSB0aGlzLl90ZXN0T25lKHBhdGgsIGNoZWNrVW5pZ25vcmVkKVxuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3QoXG4gICAgICBzbGljZXMuam9pbihTTEFTSCkgKyBTTEFTSCxcbiAgICAgIGNhY2hlLFxuICAgICAgY2hlY2tVbmlnbm9yZWQsXG4gICAgICBzbGljZXNcbiAgICApXG5cbiAgICAvLyBJZiB0aGUgcGF0aCBjb250YWlucyBhIHBhcmVudCBkaXJlY3RvcnksIGNoZWNrIHRoZSBwYXJlbnQgZmlyc3RcbiAgICByZXR1cm4gY2FjaGVbcGF0aF0gPSBwYXJlbnQuaWdub3JlZFxuICAgICAgLy8gPiBJdCBpcyBub3QgcG9zc2libGUgdG8gcmUtaW5jbHVkZSBhIGZpbGUgaWYgYSBwYXJlbnQgZGlyZWN0b3J5IG9mXG4gICAgICAvLyA+ICAgdGhhdCBmaWxlIGlzIGV4Y2x1ZGVkLlxuICAgICAgPyBwYXJlbnRcbiAgICAgIDogdGhpcy5fdGVzdE9uZShwYXRoLCBjaGVja1VuaWdub3JlZClcbiAgfVxuXG4gIGlnbm9yZXMgKHBhdGgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGVzdChwYXRoLCB0aGlzLl9pZ25vcmVDYWNoZSwgZmFsc2UpLmlnbm9yZWRcbiAgfVxuXG4gIGNyZWF0ZUZpbHRlciAoKSB7XG4gICAgcmV0dXJuIHBhdGggPT4gIXRoaXMuaWdub3JlcyhwYXRoKVxuICB9XG5cbiAgZmlsdGVyIChwYXRocykge1xuICAgIHJldHVybiBtYWtlQXJyYXkocGF0aHMpLmZpbHRlcih0aGlzLmNyZWF0ZUZpbHRlcigpKVxuICB9XG5cbiAgLy8gQHJldHVybnMge1Rlc3RSZXN1bHR9XG4gIHRlc3QgKHBhdGgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGVzdChwYXRoLCB0aGlzLl90ZXN0Q2FjaGUsIHRydWUpXG4gIH1cbn1cblxuY29uc3QgZmFjdG9yeSA9IG9wdGlvbnMgPT4gbmV3IElnbm9yZShvcHRpb25zKVxuXG5jb25zdCBpc1BhdGhWYWxpZCA9IHBhdGggPT5cbiAgY2hlY2tQYXRoKHBhdGggJiYgY2hlY2tQYXRoLmNvbnZlcnQocGF0aCksIHBhdGgsIFJFVFVSTl9GQUxTRSlcblxuZmFjdG9yeS5pc1BhdGhWYWxpZCA9IGlzUGF0aFZhbGlkXG5cbi8vIEZpeGVzIHR5cGVzY3JpcHRcbmZhY3RvcnkuZGVmYXVsdCA9IGZhY3RvcnlcblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5XG5cbi8vIFdpbmRvd3Ncbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChcbiAgLy8gRGV0ZWN0IGBwcm9jZXNzYCBzbyB0aGF0IGl0IGNhbiBydW4gaW4gYnJvd3NlcnMuXG4gIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJ1xuICAmJiAoXG4gICAgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuSUdOT1JFX1RFU1RfV0lOMzJcbiAgICB8fCBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXG4gIClcbikge1xuICAvKiBlc2xpbnQgbm8tY29udHJvbC1yZWdleDogXCJvZmZcIiAqL1xuICBjb25zdCBtYWtlUG9zaXggPSBzdHIgPT4gL15cXFxcXFxcXFxcP1xcXFwvLnRlc3Qoc3RyKVxuICB8fCAvW1wiPD58XFx1MDAwMC1cXHUwMDFGXSsvdS50ZXN0KHN0cilcbiAgICA/IHN0clxuICAgIDogc3RyLnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuXG4gIGNoZWNrUGF0aC5jb252ZXJ0ID0gbWFrZVBvc2l4XG5cbiAgLy8gJ0M6XFxcXGZvbycgICAgIDwtICdDOlxcXFxmb28nIGhhcyBiZWVuIGNvbnZlcnRlZCB0byAnQzovJ1xuICAvLyAnZDpcXFxcZm9vJ1xuICBjb25zdCBSRUdJWF9JU19XSU5ET1dTX1BBVEhfQUJTT0xVVEUgPSAvXlthLXpdOlxcLy9pXG4gIGNoZWNrUGF0aC5pc05vdFJlbGF0aXZlID0gcGF0aCA9PlxuICAgIFJFR0lYX0lTX1dJTkRPV1NfUEFUSF9BQlNPTFVURS50ZXN0KHBhdGgpXG4gICAgfHwgaXNOb3RSZWxhdGl2ZShwYXRoKVxufVxuIl0sIm5hbWVzIjpbIm1ha2VBcnJheSIsInN1YmplY3QiLCJBcnJheSIsImlzQXJyYXkiLCJFTVBUWSIsIlNQQUNFIiwiRVNDQVBFIiwiUkVHRVhfVEVTVF9CTEFOS19MSU5FIiwiUkVHRVhfSU5WQUxJRF9UUkFJTElOR19CQUNLU0xBU0giLCJSRUdFWF9SRVBMQUNFX0xFQURJTkdfRVhDQVBFRF9FWENMQU1BVElPTiIsIlJFR0VYX1JFUExBQ0VfTEVBRElOR19FWENBUEVEX0hBU0giLCJSRUdFWF9TUExJVEFMTF9DUkxGIiwiUkVHRVhfVEVTVF9JTlZBTElEX1BBVEgiLCJTTEFTSCIsIlRNUF9LRVlfSUdOT1JFIiwiU3ltYm9sIiwiZm9yIiwiS0VZX0lHTk9SRSIsImRlZmluZSIsIm9iamVjdCIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJSRUdFWF9SRUdFWFBfUkFOR0UiLCJSRVRVUk5fRkFMU0UiLCJzYW5pdGl6ZVJhbmdlIiwicmFuZ2UiLCJyZXBsYWNlIiwibWF0Y2giLCJmcm9tIiwidG8iLCJjaGFyQ29kZUF0IiwiY2xlYW5SYW5nZUJhY2tTbGFzaCIsInNsYXNoZXMiLCJsZW5ndGgiLCJzbGljZSIsIlJFUExBQ0VSUyIsImluZGV4T2YiLCJzdGFydGluZ1JlcGxhY2VyIiwidGVzdCIsIl8iLCJpbmRleCIsInN0ciIsInAxIiwicDIiLCJ1bmVzY2FwZWQiLCJsZWFkRXNjYXBlIiwiZW5kRXNjYXBlIiwiY2xvc2UiLCJwcmVmaXgiLCJyZWdleENhY2hlIiwiY3JlYXRlIiwibWFrZVJlZ2V4IiwicGF0dGVybiIsImlnbm9yZUNhc2UiLCJzb3VyY2UiLCJyZWR1Y2UiLCJwcmV2IiwiY3VycmVudCIsImJpbmQiLCJSZWdFeHAiLCJpc1N0cmluZyIsImNoZWNrUGF0dGVybiIsInNwbGl0UGF0dGVybiIsInNwbGl0IiwiSWdub3JlUnVsZSIsImNvbnN0cnVjdG9yIiwib3JpZ2luIiwibmVnYXRpdmUiLCJyZWdleCIsImNyZWF0ZVJ1bGUiLCJzdWJzdHIiLCJ0aHJvd0Vycm9yIiwibWVzc2FnZSIsIkN0b3IiLCJjaGVja1BhdGgiLCJwYXRoIiwib3JpZ2luYWxQYXRoIiwiZG9UaHJvdyIsIlR5cGVFcnJvciIsImlzTm90UmVsYXRpdmUiLCJyIiwiUmFuZ2VFcnJvciIsImNvbnZlcnQiLCJwIiwiSWdub3JlIiwiaWdub3JlY2FzZSIsImFsbG93UmVsYXRpdmVQYXRocyIsIl9ydWxlcyIsIl9pZ25vcmVDYXNlIiwiX2FsbG93UmVsYXRpdmVQYXRocyIsIl9pbml0Q2FjaGUiLCJfaWdub3JlQ2FjaGUiLCJfdGVzdENhY2hlIiwiX2FkZFBhdHRlcm4iLCJjb25jYXQiLCJfYWRkZWQiLCJydWxlIiwicHVzaCIsImFkZCIsImZvckVhY2giLCJhZGRQYXR0ZXJuIiwiX3Rlc3RPbmUiLCJjaGVja1VuaWdub3JlZCIsImlnbm9yZWQiLCJ1bmlnbm9yZWQiLCJtYXRjaGVkIiwiX3Rlc3QiLCJjYWNoZSIsInNsaWNlcyIsIl90IiwicG9wIiwicGFyZW50Iiwiam9pbiIsImlnbm9yZXMiLCJjcmVhdGVGaWx0ZXIiLCJmaWx0ZXIiLCJwYXRocyIsImZhY3RvcnkiLCJvcHRpb25zIiwiaXNQYXRoVmFsaWQiLCJkZWZhdWx0IiwibW9kdWxlIiwiZXhwb3J0cyIsInByb2Nlc3MiLCJlbnYiLCJJR05PUkVfVEVTVF9XSU4zMiIsInBsYXRmb3JtIiwibWFrZVBvc2l4IiwiUkVHSVhfSVNfV0lORE9XU19QQVRIX0FCU09MVVRFIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ignore/index.js\n");

/***/ })

};
;